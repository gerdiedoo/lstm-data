filename,code,Quicksort,Mergesort,Selectionsort,Insertionsort,Bubblesort,Linear search,Binary Search,Linked List,Hashmap
0,"package Mini_algorithms;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public abstract class AbstractMap<K,V> implements Map<K,V>{
	public boolean isEmpty(){
		return size() == 0;
	}
	protected static class MapEntry<K,V> implements Entry<K,V>{
		private K k;
		private V v;
		public MapEntry(K key, V value){
			k = key;
			v = value;
		}
		public K getKey() {
			return k;
		}
		public V getValue() {
			return v;
		}
		protected void setKey(K key){
			k = key;
		}
		public V setValue(V value) {
			V old = v;
			v = value;
			return old;
		}
	}
	private class KeyIterator implements Iterator<K>{
		private Iterator<Entry<K,V>> entries = entrySet().iterator();
		public boolean hasNext() {
			return entries.hasNext();
		}
		public K next() {
			return entries.next().getKey();
		}
		public void remove(){
			throw new UnsupportedOperationException();
		}
	}
	private class KeyIterable implements Iterable<K>{
		public Iterator<K> iterator() {
			return new KeyIterator();
		}
	}
	public Set<K> keySet() {
		return (Set<K>) new KeyIterable();
	}
	private class ValueIterator implements Iterator<V>{
		private Iterator<Entry<K,V>> entries = entrySet().iterator();
		public boolean hasNext() {
			return entries.hasNext();
		}
		public V next() {
			return entries.next().getValue();
		}
		public void remove(){
			throw new UnsupportedOperationException();
		}
	}
	private class ValueIterable implements Iterable<V>{
		public Iterator<V> iterator() {
			return new ValueIterator();
		}
	}
	public Set<V> values() {
		return (Set<V>) new ValueIterable();
	}
}",0,0,0,0,0,0,0,0,0
1,"public abstract class AbstractMap implements Map<String, String> {
    public boolean isEmpty() {
        return size() == 0;
    }
    protected static class MapEntry {
        private String k;
        private String v;
        public String getKey() {
            return k;
        }
        public String getValue() {
            return v;
        }
        protected void setKey(String key) {
            k = key;
        }
        protected String setValue(String value) {
            String old = v;
            v = value;
            return old;
        }
    }
}",0,0,0,0,0,0,0,0,0
2,"package com.ks.hashmap.basic;
import com.ks.hashmap.HashFunction;
import com.ks.hashmap.HashMap;
import com.ks.hashmap.KeyValuePair;
import java.lang.reflect.Array;
public class BasicHashMap<K, V> implements HashMap<K, V> {
    private int size = 0;
    private static final float DEFAULT_LOAD_FACTOR = 0.75f;
    private HashFunction hashFunction;
    private static final KeyValuePair<?, ?>[] EMPTY_TABLE = {};
    private KeyValuePair<K, V>[] table;
    public BasicHashMap(HashFunction hashFunction) {
        this.hashFunction = hashFunction;
        this.table = (KeyValuePair<K, V>[]) EMPTY_TABLE;
    }
    public BasicHashMap(HashFunction hashFunction, int tableLength) {
        this.hashFunction = hashFunction;
        this.table = (KeyValuePair<K, V>[]) EMPTY_TABLE;
        this.table = (KeyValuePair<K, V>[]) Array.newInstance(table.getClass().getComponentType(), tableLength);
    }
    @Override
    public HashFunction hashFunction() {
        return hashFunction;
    }
    @Override
    public int size() {
        return size;
    }
    @Override
    public float loadFactor() {
        return (table.length == 0 ? 0 : (float) size/table.length);
    }
    @Override
    public boolean empty() {
        return size == 0;
    }
    @Override
    public KeyValuePair<K, V>[] table() {
        return table;
    }
    @Override
    public void put(final K key, final V value) {
        BasicKeyValuePair<K, V> basicKeyValuePair = new BasicKeyValuePair<>(key, value, null);
        int keyIndex;
        if (!hasKey(key)) {
            size++;
            resize();
            keyIndex = keyIndexFromKey(key);
            putInBucket(keyIndex, basicKeyValuePair, table);
        } else {
            keyIndex = keyIndexFromKey(key);
            replaceInBucket(keyIndex, basicKeyValuePair);
        }
    }
    private void removeFromBucket(K key) {
        int keyIndex = keyIndexFromKey(key);
        if (table[keyIndex].getKey().equals(key)) {
            table[keyIndex] = table[keyIndex].getNext();
            return;
        }
        KeyValuePair<K, V> previous = table[keyIndex];
        KeyValuePair<K, V> next = previous.getNext();
        while (next != null) {
            if (next.getKey().equals(key)) {
                previous.setNext(next.getNext());
                return;
            }
            previous = next;
            next = next.getNext();
        }
    }
    private void replaceInBucket(int keyIndex, KeyValuePair<K, V> newKeyValuePair) {
        KeyValuePair<K, V> startingKeyValuePair = table[keyIndex];
        if (startingKeyValuePair.getKey().equals(newKeyValuePair.getKey())) {
            if (startingKeyValuePair.getNext() != null) {
                newKeyValuePair.setNext(startingKeyValuePair.getNext());
            }
            table[keyIndex] = newKeyValuePair;
        } else {
            KeyValuePair<K, V> previousKeyValuePair = startingKeyValuePair;
            KeyValuePair<K, V> nextKeyValuePair = previousKeyValuePair.getNext();
            while (nextKeyValuePair != null) {
                if (nextKeyValuePair.getKey().equals(newKeyValuePair.getKey())) {
                    if (nextKeyValuePair.getNext() != null) {
                        newKeyValuePair.setNext(nextKeyValuePair.getNext());
                    }
                    previousKeyValuePair.setNext(newKeyValuePair);
                    break;
                } else {
                    KeyValuePair<K, V> temporaryKeyValuePair = nextKeyValuePair;
                    previousKeyValuePair = nextKeyValuePair;
                    nextKeyValuePair = temporaryKeyValuePair.getNext();
                }
            }
        }
    }
    @Override
    public V get(final K key) {
        if (!hasKey(key)) {
            return null;
        }
        KeyValuePair<K, V> currentKeyValuePair = table[keyIndexFromKey(key)];
        while (!currentKeyValuePair.getKey().equals(key)) {
            currentKeyValuePair = currentKeyValuePair.getNext();
        }
        return currentKeyValuePair.getValue();
    }
    @Override
    public boolean hasKey(final K key) {
        if (empty()) {
            return false;
        }
        for (KeyValuePair keyValuePair : table) {
            if (keyValuePair != null) {
                if (keyValuePair.getKey().equals(key)) {
                    return true;
                } else {
                    while (keyValuePair.getNext() != null) {
                        if (keyValuePair.getNext().getKey().equals(key)) {
                            return true;
                        }
                        keyValuePair = keyValuePair.getNext();
                    }
                }
            }
        }
        return false;
    }
    @Override
    public boolean hasValue(final V value) {
        if (empty()) {
            return false;
        }
        for (KeyValuePair keyValuePair : table) {
            do {
                if (keyValuePair != null && keyValuePair.getValue().equals(value)) {
                    return true;
                }
                if (keyValuePair != null && keyValuePair.getNext() != null) {
                    keyValuePair = keyValuePair.getNext();
                }
            } while (keyValuePair != null && keyValuePair.getNext() != null);
        }
        return false;
    }
    @Override
    public void remove(final K key) {
        if (hasKey(key)) {
            size--;
            removeFromBucket(key);
        }
    }
    private int keyIndexFromKey(final K key, KeyValuePair<K, V>[] referenceTable) {
        int keyHash = hashFunction.hash(key);
        return Math.abs(keyHash) % referenceTable.length;
    }
    private int keyIndexFromKey(final K key) {
        return keyIndexFromKey(key, table);
    }
    private void resize() {
        float currentLoadFactor = loadFactor();
        if (currentLoadFactor > DEFAULT_LOAD_FACTOR || currentLoadFactor == 0) {
            int newSize = (int) Math.ceil((double)size/(double)DEFAULT_LOAD_FACTOR);
            KeyValuePair<K, V>[] tempTable = (KeyValuePair<K, V>[]) Array.newInstance(table.getClass().getComponentType(), newSize);
            int keyIndex;
            for (KeyValuePair<K, V> keyValuePair : table) {
                if (keyValuePair != null) {
                    KeyValuePair<K, V> insertKeyValuePair = keyValuePair.clone(keyValuePair);
                    keyIndex = keyIndexFromKey(insertKeyValuePair.getKey(), tempTable);
                    putInBucket(keyIndex, insertKeyValuePair, tempTable);
                    while (keyValuePair.getNext() != null) {
                        KeyValuePair<K, V> nextKeyValuePair = keyValuePair.getNext();
                        insertKeyValuePair = nextKeyValuePair.clone(nextKeyValuePair);
                        keyIndex = keyIndexFromKey(insertKeyValuePair.getKey(), tempTable);
                        putInBucket(keyIndex, insertKeyValuePair, tempTable);
                        keyValuePair = keyValuePair.getNext();
                    }
                }
            }
            table = tempTable;
        }
    }
    private void putInBucket(int keyIndex, KeyValuePair<K, V> newKeyValuePair, KeyValuePair<K, V>[] referenceTable) {
        KeyValuePair<K, V> currentKeyValuePair = referenceTable[keyIndex];
        if (currentKeyValuePair == null) {
            referenceTable[keyIndex] = newKeyValuePair;
        } else {
            while (currentKeyValuePair.getNext() != null) {
                currentKeyValuePair = currentKeyValuePair.getNext();
            }
            currentKeyValuePair.setNext(newKeyValuePair);
        }
    }
}",0,0,0,0,0,1,0,0,1
3,"package com.ks.hashmap.basic;
import com.ks.hashmap.KeyValuePair;
public class BasicKeyValuePair<K, V> implements KeyValuePair<K, V> {
    private K key;
    private V value;
    private KeyValuePair<K, V> next;
    public BasicKeyValuePair(K key, V value, KeyValuePair<K, V> next) {
        this.key = key;
        this.value = value;
        this.next = next;
    }
    @Override
    public K getKey() {
        return key;
    }
    @Override
    public V getValue() {
        return value;
    }
    @Override
    public KeyValuePair<K, V> getNext() {
        return next;
    }
    @Override
    public void setNext(KeyValuePair<K, V> keyValuePair) {
        this.next = keyValuePair;
    }
    @Override
    public KeyValuePair<K, V> clone(KeyValuePair<K, V> keyValuePair) {
        return new BasicKeyValuePair<K, V>(keyValuePair.getKey(), keyValuePair.getValue(), null);
    }
}",0,0,0,0,0,0,0,0,0
4,"package com.cfelde.bohmap;
import java.util.Arrays;
public final class Binary {
    private final byte[] value;
    public Binary(byte[] value) {
        if (value == null)
            throw new NullPointerException(""value is null"");
        this.value = value;
    }
    public byte[] getValue() {
        return value;
    }
    @Override
    public int hashCode() {
        int hash = 5;
        hash = 19 * hash + Arrays.hashCode(this.value);
        return hash;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final Binary other = (Binary) obj;
        return Arrays.equals(this.value, other.value);
    }
    @Override
    public String toString() {
        return ""Binary{"" + ""value=size("" + value.length + "")}"";
    }
}",0,0,0,0,0,0,0,0,0
5,"import java.util.ArrayList;
public class  BrentHashMap<K,V> extends AbstractHashMap<K,V> {
	private MapEntry<K,V>[] buckets;
	public BrentHashMap() { super(); }
	public BrentHashMap(int capacity, float loadFactor) {	super(capacity, loadFactor);}
	@SuppressWarnings(""unchecked"")
	@Override
	protected void createTable() {
		buckets = (MapEntry<K,V>[]) new MapEntry[this.capacity];
	}
	private int findEmptySlot(int index, int increment) {
		int step = 0;
		while(buckets[index] != null) {
			index = (index + increment) % buckets.length;
			step += 1;
		}
		return step; 
	}
	@Override
	protected V bucketGet(K key) {
		MapEntry<K,V> element = contains(key);
		if(element == null) return null;
		return element.getValue();
	}
	@Override
	public int getIndex(K key) {
		int index = compression(key);
		if(contains(key) != null) {
			while(buckets[index] != null ) {
				if(buckets[index].getKey().hashCode() == key.hashCode())
					return index;
				index = (index + increment(key)) % buckets.length;
			} 
		}
		return -1;
	}
	public int getCount(K key) {
		MapEntry<K,V> element = contains(key);
		if(element != null) return element.getCount();
		return -1;
	}
	@Override
	protected V bucketPut(K key, V value) {
		MapEntry<K,V> newEntry = new MapEntry<K,V>(key, value);
		MapEntry<K,V> tempEntry = newEntry;
		int index = compression(newEntry.getKey());
		int tempIndex = index;
		MapEntry<K,V> oldEntry = buckets[index];
		MapEntry<K,V> ifFound = null;
		int closestLength = 0;
		int bestI = 0; 
		int bestJ = 0;
		if(value == null) throw new IllegalArgumentException(""Given value can not be null"");
		else if(oldEntry == null) {
			buckets[index] = newEntry;
			this.size += 1;
		}
		else if((ifFound = contains(key)) != null) {  
			V temp = ifFound.getValue();
			ifFound.increaseCount();
			return temp; 
		}
		else { 
			bestI = findEmptySlot(index, increment(oldEntry.getKey()));
			bestJ = 0;
			closestLength = bestI + bestJ;
			if(findEmptySlot(index, increment(newEntry.getKey())) <= closestLength) {
				bestJ = findEmptySlot(index, increment(newEntry.getKey()));
				bestI = 0;
				closestLength = bestI + bestJ;
			}
			for(int j = 1 ; buckets[tempIndex] != null ; j++) {
				tempIndex = (index + j*increment(newEntry.getKey())) % buckets.length;
				if(buckets[tempIndex] != null) {
					if(j + findEmptySlot(tempIndex, increment(buckets[tempIndex].getKey())) < closestLength) {
						bestI = findEmptySlot(tempIndex, increment(buckets[tempIndex].getKey()));
						bestJ = j;
						closestLength = bestI + bestJ;
					}
				}
			}
			if(bestI == 0) {
				buckets[index] = oldEntry;
				buckets[(index + increment(newEntry.getKey()) * bestJ) % buckets.length] = newEntry;
			}
			else if(bestJ == 0) {
				buckets[index] = newEntry;
				buckets[(index + increment(oldEntry.getKey()) * bestI) % buckets.length] = oldEntry;
			}
			else{
				tempEntry = buckets[(index + bestJ * increment(newEntry.getKey())) % buckets.length];
				buckets[(index + bestJ * increment(newEntry.getKey()) + bestI * increment(tempEntry.getKey())) % buckets.length] = tempEntry;
		   	    buckets[(index + bestJ * increment(newEntry.getKey())) % buckets.length] = newEntry;
			}
			this.size += 1;
		}
		if(size == threshold) 
			resize();
		return null;
	}
	public MapEntry<K,V> contains(K key) {
		int index = compression(key);
		int increment = increment(key);
		int counter = 0;
		if(buckets[index] != null) {
			if(key.equals(buckets[index].getKey())) {
				return buckets[index];
			}
			else {
				while(buckets[index] != null) {
					if(buckets[index].getKey().hashCode() != key.hashCode()) {
						index = (index + increment) % buckets.length;
						counter += 1;
						if(counter >= buckets.length) {
						return null;
						}
					}
					else {
						return buckets[index];	
					}
				}	
			}	
		}
		return null;	
	}
	@Override
	protected int compression(K key) {
		int index = (key.hashCode() % buckets.length) ;
		if(index < 0)
			index += buckets.length;
		return index;
	}
	private int increment(K key) {
		int increment = (key.hashCode() / buckets.length) % buckets.length;
		if(increment == 0)
			increment = 1; 
		else if(increment < 0)
			increment += buckets.length;
		return increment;
	}
	private void resize() {
		int newCap = newPrimeCapacity();
		MapEntry<K,V>[] temp = buckets;
		this.size = 0;
		buckets = new MapEntry[newCap];
		for(MapEntry<K,V> e : temp) {
			if(e != null) {
				bucketPut(e.getKey(),e.getValue());
			}
		}
	}
	private int newPrimeCapacity() {
		int newCapacity = buckets.length * 2;
		boolean isPrime = false; 
		int counter = 0;
		do{
			for(int j = 2 ; j < newCapacity ; j++) 
				if(newCapacity % j == 0) 
					counter++;
			if(counter == 0) 
				isPrime = true;
			else {
				newCapacity += 1;
				counter = 0;
			}
		}while(!isPrime);
		threshold =(int)(loadFactor * newCapacity);
		return newCapacity;
	}
	@Override
	public Iterable<Entry<K,V>> entrySet() {
		ArrayList<Entry<K,V>> buffer = new ArrayList<>(this.capacity);
		for(Entry<K,V> element : buckets)
			buffer.add(element);
		return buffer;
	}
	@Override
	public V bucketSet(K key, V value) {
		MapEntry<K,V> element = contains(key);
		V temp = null;
		if(element != null) {
			temp = element.getValue();
			element.setValue(value);
		}
		return temp;
	}
}",0,0,0,0,0,1,0,0,1
6,"package net.intelie.tinymap;
public interface CacheableBuilder<B, T> {
    T build();
    CacheAdapter<B, T> adapter();
}",0,0,0,0,0,0,0,0,0
7,"package net.intelie.tinymap;
public interface CacheAdapter<B, T> {
    int contentHashCode(B builder);
    T contentEquals(B builder, Object cached);
    T build(B builder, ObjectCache cache);
}",0,0,0,0,0,0,0,0,0
8,"package com.jamierf.persistenthashmap;
import java.io.File;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import com.jamierf.persistenthashmap.serializers.OOSSerializer;
import com.jamierf.persistenthashmap.serializers.ObjectSerializer;
public class CachedPersistentHashMap<K extends Serializable, V extends Serializable> extends PersistentHashMap<K, V> {
	protected HashMap<K, V> cache;
	public CachedPersistentHashMap(File root) {
		this (root, new OOSSerializer());
	}
	public CachedPersistentHashMap(File root, ObjectSerializer serializer) {
		super(root, serializer, false);
		cache = new HashMap<K, V>();
		Iterator<Map.Entry<K, V>> iterator = new EntryIterator<K, V>(this);
		while (iterator.hasNext()) {
			Map.Entry<K, V> e = iterator.next();
			cache.put(e.getKey(), e.getValue());
		}
	}
	@Override
	public synchronized boolean containsKey(Object key) {
		return cache.containsKey(key);
	}
	@Override
	public synchronized boolean containsValue(Object v) {
		return cache.containsValue(v);
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public synchronized V get(Object key) {
		if (cache.containsKey(key))
			return cache.get(key);
		V value = super.get(key);
		if (value != null)
			cache.put((K) key, value);
		return value;
	}
	@Override
	public synchronized V put(K key, V value) {
		cache.put(key, value);
		return super.put(key, value);
	}
	@Override
	public synchronized V remove(Object key) {
		cache.remove(key);
		return super.remove(key);
	}
	@Override
	public boolean isEmpty() {
		return cache.isEmpty();
	}
	@Override
	public int size() {
		return cache.size();
	}
	@Override
	public synchronized void clear() {
		cache.clear();
		super.clear();
	}
}",0,0,0,0,0,0,0,0,1
9,"package Hashtables.Chaining;
import Hashtables.Employee;
import java.util.LinkedList;
import java.util.ListIterator;
import Hashtables.LinearProbing.StoredEmployee;
public class ChainedHashtable {
    private LinkedList<StoredEmployee>[] hashtable;
    public ChainedHashtable() {
        hashtable = new LinkedList[10];
        for (int i = 0; i < hashtable.length; i++) {
            hashtable[i] = new LinkedList<StoredEmployee>();
        }
    }
    public void put(String key, Employee employee) {
        int hashedKey = hashKey(key);
        hashtable[hashedKey].add(new StoredEmployee(key, employee));
    }
    public Employee get(String key) {
        int hashedKey = hashKey(key);
        ListIterator<StoredEmployee> iterator = hashtable[hashedKey].listIterator();
        StoredEmployee employee = null;
        while (iterator.hasNext()) {
            employee = iterator.next();
            if (employee.key.equals(key)) {
                return employee.employee;
            }
        }
        return null;
    }
    public Employee remove(String key) {
        int hashedKey = hashKey(key);
        ListIterator<StoredEmployee> iterator = hashtable[hashedKey].listIterator();
        StoredEmployee employee = null;
        int index = -1;
        while (iterator.hasNext()) {
            employee = iterator.next();
            index++;
            if (employee.key.equals(key)) {
                break;
            }
        }
        if (employee == null) {
            return null;
        }
        else {
            hashtable[hashedKey].remove(index);
            return employee.employee;
        }
    }
    private int hashKey(String key) {
        return Math.abs(key.hashCode() % hashtable.length);
    }
    public void printHashtable() {
        for (int i = 0; i < hashtable.length; i++) {
            if (hashtable[i].isEmpty()) {
                System.out.println(""Position "" + i + "": empty"");
            }
            else {
                System.out.print(""Position "" + i + "": "");
                ListIterator<StoredEmployee> iterator = hashtable[i].listIterator();
                while (iterator.hasNext()) {
                    System.out.print(iterator.next().employee);
                    System.out.print(""->"");
                }
                System.out.println(""null"");
            }
        }
    }
}",0,0,0,0,0,1,0,0,1
10,"package Mini_algorithms;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
public class ChainHashMap<K,V> extends AbstractHashMap<K,V> {
	private UnsortedTableMap<K,V>[] table;
	public ChainHashMap() { 
		super();
	}
	public ChainHashMap(int cap) {
		super(cap);
	}
	public ChainHashMap(int cap, int p){
		super(cap, p);
	}
	protected void createTable(){
		table = (UnsortedTableMap<K,V>[]) new UnsortedTableMap[capacity];
	}
	public Set<java.util.Map.Entry<K, V>> entrySet() {
		ArrayList<Entry<K,V>> buffer = new ArrayList<>();
		for(int h = 0; h < capacity; h++)
			if(table[h] != null)
				for(Entry<K,V> entry: table[h].entrySet())
					buffer.add(entry);
		Set<Entry<K,V>> set = new HashSet<Entry<K,V>>(buffer);
		return set;
	}
	protected V bucketGet(int h, K k) {
		UnsortedTableMap<K,V> bucket = table[h];
		if(bucket == null) return null;
		return bucket.get(k);
	}
	protected V bucketPut(int h, K k, V v) {
		UnsortedTableMap<K,V> bucket = table[h];
		if(bucket == null){
			bucket = table[h] = new UnsortedTableMap<>();
		}
		int oldSize = bucket.size();
		V answer = bucket.put(k, v);
		n += (bucket.size() - oldSize);
		return answer;
	}
	protected V bucketRemove(int h, K k) {
		UnsortedTableMap<K,V> bucket = table[h];
		if(bucket == null){
			bucket = table[h] = new UnsortedTableMap<>();
		}
		int oldSize = bucket.size();
		V answer = bucket.remove(k);
		n -= (oldSize - bucket.size());
		return answer;
	}
	public void clear() {}
	public boolean containsKey(Object key) {return false;}
	public boolean containsValue(Object value) {return false;}
	public void putAll(Map<? extends K, ? extends V> m) {}
}",0,0,0,0,0,0,0,0,1
11,"import java.util.ArrayList;
import java.util.Map.Entry;
class Node {
    String key, value;
    Node next;
    public Node(String key, String value) {
        this.key = key;
        this.value = value;
    }
}
public class ChainHashMap extends AbstractMap {
    private ArrayList<Node> buckets;
    private int capacity;
    private int size;
    public ChainHashMap() {
        this.capacity = 10;
        initializeBuckets();
    }
    public ChainHashMap(int capacity) {
        this.capacity = capacity;
        initializeBuckets();
    }
    private void initializeBuckets() {
        buckets = new ArrayList<Node>(capacity);
        size = 0;
        for (int i = 0; i < capacity; i++) {
            buckets.add(null);
        }
    }
    public Double getLoadFactor() {
        return (double) this.size / (double) this.capacity;
    }
    private Node getHead(String key) {
        int index = getIndex(key);
        return buckets.get(index);
    }
    private int getIndex(String key) {
        int hash = key.hashCode();
        int index = compress(hash);
        return index < 0 ? index * -1 : index;
    }
    private int compress(long hash) {
        return (int) (hash % this.capacity);
    }
    private void doubleCapacity() {
        ArrayList<Node> tempList = buckets;
        capacity *= 2;
        initializeBuckets();
        for (Node item : tempList) {
            while (item != null) {
                put(item.key, item.value);
                item = item.next;
            }
        }
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public String get(String key) {
        Node head = getHead(key);
        while (head != null) {
            if (head.key.equals(key)) {
                return head.value;
            }
            head = head.next;
        }
        return null;
    }
    @Override
    public String put(String key, String value) {
        Node head = getHead(key);
        while (head != null) {
            if (head.key.equals(key)) {
                String lastValue = head.value;
                head.value = value;
                return lastValue;
            }
            head = head.next;
        }
        head = getHead(key);
        int indexInList = getIndex(key);
        Node newValue = new Node(key, value);
        newValue.next = head;
        buckets.set(indexInList, newValue);
        size++;
        if (getLoadFactor() >= 0.75) {
            doubleCapacity();
        }
        return null;
    }
    @Override
    public String remove(String key) {
        int index = getIndex(key);
        Node head = getHead(key);
        Node prev = null;
        while (head != null) {
            if (head.key.equals(key)) {
                size--;
                if (prev != null) {
                    prev.next = head.next;
                } else {
                    buckets.set(index, head.next);
                }
                return head.value;
            }
            prev = head;
            head = head.next;
        }
        return null;
    }
    @Override
    public Iterable<String> keySet() {
        ArrayList<String> keys = new ArrayList<String>();
        for (Node item : buckets) {
            while (item != null) {
                keys.add(item.key);
                item = item.next;
            }
        }
        return keys;
    }
    @Override
    public Iterable<String> values() {
        ArrayList<String> keys = new ArrayList<String>();
        for (Node item : buckets) {
            while (item != null) {
                keys.add(item.value);
                item = item.next;
            }
        }
        return keys;
    }
    @Override
    public Iterable<Entry<String, String>> entrySet() {
        ArrayList<Entry<String, String>> keys = null;
        return keys;
    }
}",0,0,0,0,0,1,0,0,1
12,"package vlsi.utils;
import java.io.IOException;
import java.io.Serializable;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
public class CompactHashMap<K, V> implements Map<K, V>, Serializable {
    private static final long serialVersionUID = -7720507706954394566L;
    CompactHashMapClass<K, V> klass = CompactHashMapClass.EMPTY;
    Object v1, v2, v3;
    public int size() {
        return klass.size(this);
    }
    public boolean isEmpty() {
        return size() == 0;
    }
    public boolean containsKey(Object key) {
        return klass.containsKey(this, key);
    }
    public boolean containsValue(Object value) {
        return values().contains(value);
    }
    public V get(Object key) {
        return klass.get(this, (K) key);
    }
    public V put(K key, V value) {
        return klass.put(this, key, value);
    }
    public V putOrRemove(K key, Object value) {
        return klass.put(this, key, value);
    }
    public V remove(Object key) {
        return klass.put(this, (K) key, CompactHashMapClass.REMOVED_OBJECT);
    }
    public void putAll(Map<? extends K, ? extends V> m) {
        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {
            put(entry.getKey(), entry.getValue());
        }
    }
    public void clear() {
        klass = CompactHashMapClass.EMPTY;
        v1 = v2 = v3 = null;
    }
    public Set<K> keySet() {
        return klass.keySet(this);
    }
    public Collection<V> values() {
        return klass.values(this);
    }
    public Set<Entry<K, V>> entrySet() {
        return klass.entrySet(this);
    }
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof Map)) {
            return false;
        }
        Map<?,?> m = (Map<?,?>) o;
        if (m.size() != size())
            return false;
        for (Entry<K, V> e : entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            if (value == null) {
                if (m.get(key) != null || !m.containsKey(key)) {
                    return false;
                }
            } else {
                if (!value.equals(m.get(key))) {
                    return false;
                }
            }
        }
        return true;
    }
    @Override
    public String toString() {
        Iterator<Entry<K, V>> it = entrySet().iterator();
        if (!it.hasNext())
            return ""{}"";
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        while (it.hasNext()) {
            Entry<K, V> e = it.next();
            K key = e.getKey();
            V value = e.getValue();
            sb.append(key).append('=').append(value);
            sb.append(',').append(' ');
        }
        sb.setLength(sb.length() - 2);
        return sb.append('}').toString();
    }
    public int hashCode() {
        int h = 0;
        for (Entry<K, V> entry : entrySet()) {
            h += entry.hashCode();
        }
        return h;
    }
    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
        klass.serialize(this, s);
    }
    private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
        CompactHashMapClass.deserialize(this, s);
    }
}",0,0,0,0,0,0,0,0,0
13,"package vlsi.utils;
import com.github.andrewoma.dexx.collection.Pair;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.*;
abstract class CompactHashMapClass<K, V> {
    public static final CompactHashMapClass EMPTY = new CompactHashMapClassEmptyDefaults(
            new com.github.andrewoma.dexx.collection.HashMap());
    final com.github.andrewoma.dexx.collection.Map<K, Integer> key2slot;  
    public static final String REMOVED_OBJECT = new String(""Non existing mapping value"");
    private static final Object NULL = new Object();
    public CompactHashMapClass(com.github.andrewoma.dexx.collection.Map<K, Integer> key2slot) {
        this.key2slot = key2slot;
    }
    private K maskNull(K key) {
        return key == null ? (K) NULL : key;
    }
    private K unmaskNull(K key) {
        return key == NULL ? null : key;
    }
    protected Map<K, V> getDefaultValues() {
        return Collections.emptyMap();
    }
    protected abstract CompactHashMapClassEmptyDefaults<K, V> getMapWithEmptyDefaults();
    public V get(CompactHashMap<K, V> map, K key) {
        Object result = getInternal(map, key);
        return result != REMOVED_OBJECT ? (V) result : null;
    }
    private Object getInternal(CompactHashMap<K, V> map, Object key) {
        K nonNullKey = maskNull((K) key);
        final Integer slot = key2slot.get(nonNullKey);
        if (slot == null)
            return getDefaultValues().get(nonNullKey);
        return getValueFromSlot(map, slot);
    }
    protected static Object getValueFromSlot(CompactHashMap map, int slot) {
        switch (slot) {
            case -1:
                return map.v1;
            case -2:
                return map.v2;
            case -3:
                return map.v3;
        }
        return ((Object[]) map.v1)[slot];
    }
    public V put(CompactHashMap<K, V> map, K key, Object value) {
        K nonNullKey = maskNull(key);
        Integer slot = key2slot.get(nonNullKey);
        Object prevValue = REMOVED_OBJECT;
        if (slot == null) {
            prevValue = getDefaultValues().get(nonNullKey);
            Map<K, V> newDef = CompactHashMapDefaultValues.getNewDefaultValues(getDefaultValues(), nonNullKey, value);
            if (newDef != null) {
                map.klass = getMapWithEmptyDefaults().getNewDefaultClass(newDef);
                return (V) prevValue;
            }
            if (value == REMOVED_OBJECT)
                return (V) prevValue;
            slot = createNewSlot(map, nonNullKey);
        }
        switch (slot) {
            case -1:
                if (prevValue == REMOVED_OBJECT)
                    prevValue = map.v1;
                map.v1 = value;
                break;
            case -2:
                if (prevValue == REMOVED_OBJECT)
                    prevValue = map.v2;
                map.v2 = value;
                break;
            case -3:
                if (prevValue == REMOVED_OBJECT)
                    prevValue = map.v3;
                map.v3 = value;
                break;
            default:
                Object[] array = (Object[]) map.v1;
                if (prevValue == REMOVED_OBJECT)
                    prevValue = array[slot];
                array[slot] = value;
                break;
        }
        return (V) prevValue;
    }
    private Integer createNewSlot(CompactHashMap<K, V> map, K key) {
        final CompactHashMapClass<K, V> nextKlass = getMapWithEmptyDefaults().getNextKlass(key, getDefaultValues());
        map.klass = nextKlass;
        int prevSize = key2slot.size();
        if (prevSize == 3) {
            Object[] array = new Object[4];
            array[0] = map.v1;
            map.v1 = array;
        } else if (prevSize > 3) {
            Object[] array = (Object[]) map.v1;
            if (array.length < prevSize - 1) {
                int newSize = array.length * 3 / 2;
                newSize += newSize & 1;  
                Object[] newArray = new Object[newSize];
                System.arraycopy(array, 0, newArray, 0, array.length);
                map.v1 = newArray;
            }
        }
        return nextKlass.key2slot.get(key);
    }
    public int size(CompactHashMap<K, V> map) {
        return key2slot.size() + getDefaultValues().size() - removedSlotsCount(map);
    }
    private int removedSlotsCount(CompactHashMap<K, V> map) {
        int emptySlots = 0;
        switch (key2slot.size()) {
            default:  
                for (Object o : (Object[]) map.v1) {
                    if (o == REMOVED_OBJECT) emptySlots++;
                }
            case 3:  
                if (map.v1 == REMOVED_OBJECT) emptySlots++;
            case 2:  
                if (map.v2 == REMOVED_OBJECT) emptySlots++;
            case 1:  
                if (map.v3 == REMOVED_OBJECT) emptySlots++;
            case 0:
        }
        return emptySlots;
    }
    public boolean containsKey(CompactHashMap<K, V> map, Object key) {
        K nonNullKey = maskNull((K) key);
        final Integer slot = key2slot.get(nonNullKey);
        if (slot == null)
            return getDefaultValues().containsKey(nonNullKey);
        return getValueFromSlot(map, slot) != REMOVED_OBJECT;
    }
    public Set<K> keySet(CompactHashMap<K, V> map) {
        return new CompactHashMapClass.KeySet<K, V>(map);
    }
    public Set<V> values(CompactHashMap<K, V> map) {
        return new CompactHashMapClass.Values<K, V>(map);
    }
    public Set<Map.Entry<K, V>> entrySet(CompactHashMap<K, V> map) {
        return new CompactHashMapClass.EntrySet<K, V>(map);
    }
    public void serialize(final CompactHashMap<K, V> map, final ObjectOutputStream s) throws IOException {
        int size = key2slot.size() - removedSlotsCount(map);
        s.writeInt(size);
        if (size > 0)
            for (Pair<K, Integer> entry : key2slot) {
                Object value = getValueFromSlot(map, entry.component2());
                if (value == REMOVED_OBJECT) continue;
                s.writeObject(unmaskNull(entry.component1()));
                s.writeObject(value);
            }
        s.writeObject(getDefaultValues());
    }
    public static <K, V> void deserialize(CompactHashMap<K, V> map, ObjectInputStream s) throws IOException, ClassNotFoundException {
        int size = s.readInt();
        map.klass = CompactHashMapClass.EMPTY;
        for (int i = 0; i < size; i++) {
            K key = (K) s.readObject();
            V value = (V) s.readObject();
            map.put(key, value);
        }
        Map<K, V> defaults = (Map<K, V>) s.readObject();
        for (Map.Entry<K, V> entry : defaults.entrySet()) {
            map.put(entry.getKey(), entry.getValue());
        }
    }
    static class KeySet<K, V> extends AbstractSet<K> {
        private final CompactHashMap<K, V> map;
        public KeySet(CompactHashMap<K, V> map) {
            this.map = map;
        }
        @Override
        public int size() {
            return map.size();
        }
        @Override
        public boolean contains(Object o) {
            return map.containsKey(o);
        }
        @Override
        public boolean remove(Object o) {
            return map.remove(o) != null;  
        }
        @Override
        public Iterator<K> iterator() {
            return new KeyIterator<K, V>(map);
        }
        @Override
        public void clear() {
            map.clear();
        }
    }
    static class Values<K, V> extends AbstractSet<V> {
        private final CompactHashMap<K, V> map;
        public Values(CompactHashMap<K, V> map) {
            this.map = map;
        }
        @Override
        public int size() {
            return map.size();
        }
        @Override
        public Iterator<V> iterator() {
            return new ValueIterator<K, V>(map);
        }
        @Override
        public void clear() {
            map.clear();
        }
    }
    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {
        private final CompactHashMap<K, V> map;
        public EntrySet(CompactHashMap<K, V> map) {
            this.map = map;
        }
        @Override
        public Iterator<Map.Entry<K, V>> iterator() {
            return new EntryIterator<K, V>(map);
        }
        @Override
        public boolean contains(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry<K, V> e = (Map.Entry<K, V>) o;
            K key = e.getKey();
            V value = e.getValue();
            V ourValue = map.get(key);
            if (value == null) {
                return ourValue == null && map.containsKey(key);
            }
            return value.equals(ourValue);
        }
        @Override
        public boolean remove(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry<K, V> e = (Map.Entry<K, V>) o;
            return map.remove(e.getKey()) != null;  
        }
        @Override
        public int size() {
            return map.size();
        }
        @Override
        public void clear() {
            map.clear();
        }
    }
    static abstract class HashIterator<K, V, E> implements Iterator<E> {
        boolean defValues = true;
        private final CompactHashMap<K, V> map;
        Iterator it;
        Map.Entry<K, V> current, next;
        public HashIterator(CompactHashMap<K, V> map) {
            this.map = map;
            if (map.isEmpty()) return;
            this.it = map.klass.getDefaultValues().entrySet().iterator();
            advance();
        }
        private void advance() {
            if (!it.hasNext() && defValues) {
                defValues = false;
                it = map.klass.key2slot.asMap().entrySet().iterator();
            }
            if (!it.hasNext()) {
                next = null;
                return;
            }
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                V value;
                if (defValues)
                    value = (V) entry.getValue();
                else {
                    value = (V) getValueFromSlot(map, (Integer) entry.getValue());
                    if (value == REMOVED_OBJECT) continue;
                }
                next = new SimpleEntry<K, V>(map, (K) entry.getKey(), value);
                return;
            }
            next = null;
        }
        public boolean hasNext() {
            return next != null;
        }
        public Map.Entry<K, V> nextEntry() {
            if (next == null)
                throw new NoSuchElementException();
            current = next;
            advance();
            return current;
        }
        public void remove() {
            if (current == null) {
                throw new IllegalStateException();
            }
            map.remove(current.getKey());
            current = null;
        }
    }
    static class KeyIterator<K, V> extends HashIterator<K, V, K> {
        public KeyIterator(CompactHashMap<K, V> kvCompactMap) {
            super(kvCompactMap);
        }
        public K next() {
            return nextEntry().getKey();
        }
    }
    static class ValueIterator<K, V> extends HashIterator<K, V, V> {
        public ValueIterator(CompactHashMap<K, V> kvCompactMap) {
            super(kvCompactMap);
        }
        public V next() {
            return nextEntry().getValue();
        }
    }
    static class EntryIterator<K, V> extends HashIterator<K, V, Map.Entry<K, V>> {
        public EntryIterator(CompactHashMap<K, V> kvCompactMap) {
            super(kvCompactMap);
        }
        public Map.Entry<K, V> next() {
            return nextEntry();
        }
    }
    static class SimpleEntry<K, V> implements Map.Entry<K, V> {
        final K key;
        V value;
        private final CompactHashMap<K, V> map;
        public SimpleEntry(CompactHashMap<K, V> map, K key, V value) {
            this.map = map;
            this.key = key;
            this.value = value;
        }
        public K getKey() {
            return map.klass.unmaskNull(key);
        }
        public V getValue() {
            return value;
        }
        public V setValue(V value) {
            this.value = value;
            return map.put(key, value);
        }
        private static boolean eq(Object o1, Object o2) {
            return o1 == null ? o2 == null : o1.equals(o2);
        }
        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry)) {
                return false;
            }
            Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
            return eq(getKey(), e.getKey()) && eq(value, e.getValue());
        }
        public int hashCode() {
            return (key == NULL ? 0 : key.hashCode()) ^
                    (value == null ? 0 : value.hashCode());
        }
        @Override
        public String toString() {
            return map.klass.unmaskNull(key) + ""="" + value;
        }
    }
}",0,0,0,0,0,0,0,0,1
14,"package vlsi.utils;
import com.github.andrewoma.dexx.collection.Pair;
import java.util.Collections;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;
class CompactHashMapClassEmptyDefaults<K, V> extends CompactHashMapClass<K, V> {
    private Map<K, CompactHashMapClassEmptyDefaults<K, V>> key2newKlass;
    private Map<Map<K, V>, CompactHashMapClass<K, V>> defValues2Klass;
    public CompactHashMapClassEmptyDefaults(com.github.andrewoma.dexx.collection.Map<K, Integer> key2Slot) {
        super(key2Slot);
    }
    @Override
    protected CompactHashMapClassEmptyDefaults<K, V> getMapWithEmptyDefaults() {
        return this;
    }
    protected CompactHashMapClass<K, V> getNewDefaultClass(Map<K, V> newDef) {
        CompactHashMapClass<K, V> newClass;
        if (newDef == null || newDef.isEmpty())
            return this;
        synchronized (this) {
            Map<Map<K, V>, CompactHashMapClass<K, V>> defValues2Klass = this.defValues2Klass;
            if (defValues2Klass == null)
                this.defValues2Klass = defValues2Klass =
                        new IdentityHashMap<Map<K, V>, CompactHashMapClass<K, V>>();
            newClass = defValues2Klass.get(newDef);
            if (newClass == null) {
                newClass = new CompactHashMapClassWithDefaults<K, V>(key2slot, newDef, this);
                defValues2Klass.put(newDef, newClass);
            }
        }
        return newClass;
    }
    protected CompactHashMapClass<K, V> getNextKlass(K key, Map<K, V> defaultValues) {
        CompactHashMapClassEmptyDefaults<K, V> newKlass = null;
        synchronized (this) {
            Map<K, CompactHashMapClassEmptyDefaults<K, V>> key2newKlass = this.key2newKlass;
            if (key2newKlass != null)
                newKlass = key2newKlass.get(key);
        }
        if (defaultValues.containsKey(key))
            defaultValues = CompactHashMapDefaultValues.getNewDefaultValues(defaultValues, key, REMOVED_OBJECT);
        if (newKlass != null)
            return newKlass.getNewDefaultClass(defaultValues);
        int size = key2slot.size();
        com.github.andrewoma.dexx.collection.Map<K, Integer> newKey2slot = key2slot;
        if (size < 3) size -= 3;
        else if (size == 3) {
            size = 1;
            for (Pair<K, Integer> entry : key2slot)
                if (entry.component2() == -1) {
                    newKey2slot = newKey2slot.put(entry.component1(), 0);
                    break;
                }
        } else size -= 2;
        newKey2slot = newKey2slot.put(key, size);
        newKlass = new CompactHashMapClassEmptyDefaults<K, V>(newKey2slot);
        synchronized (this) {
            if (key2newKlass == null) {
                key2newKlass = Collections.singletonMap(key, newKlass);
            } else {
                final CompactHashMapClassEmptyDefaults<K, V> anotherNewKlass = key2newKlass.get(key);
                if (anotherNewKlass != null)
                    newKlass = anotherNewKlass;
                else {
                    if (key2newKlass.size() == 1) {
                        key2newKlass = new HashMap<K, CompactHashMapClassEmptyDefaults<K, V>>(key2newKlass);
                    }
                    key2newKlass.put(key, newKlass);
                }
            }
        }
        return newKlass.getNewDefaultClass(defaultValues);
    }
}",0,0,0,0,0,0,0,0,0
15,"package vlsi.utils;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class CompactHashMapDefaultValues {
    private static Map<Object, Map<Object, Map<Map, Map>>> defaultValues
            = new HashMap<Object, Map<Object, Map<Map, Map>>>();
    private static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private static Lock readLock = readWriteLock.readLock();
    private static Lock writeLock = readWriteLock.writeLock();
    public static final String ALL_VALUES_MATCH = new String(""All values match"");
    public static void clear() {
        writeLock.lock();
        try {
            defaultValues.clear();
        } finally {
            writeLock.unlock();
        }
    }
    public static boolean add(Object key) {
        return add(key, ALL_VALUES_MATCH);
    }
    public static boolean add(Object key, Object value) {
        writeLock.lock();
        try {
            Map<Object, Map<Map, Map>> m = defaultValues.get(key);
            if (m == null)
                defaultValues.put(key, m = new HashMap<Object, Map<Map, Map>>());
            if (m.get(value) != null)
                return false;  
            m.put(value, new IdentityHashMap<Map, Map>());
            return true;
        } finally {
            writeLock.unlock();
        }
    }
    public static <K, V> Map<K, V> getNewDefaultValues(Map<K, V> prevDefaultValues, K key, Object value) {
        final Map<Object, Map<Map, Map>> m;
        Map<Map, Map> identityOld2New;
        readLock.lock();
        try {
            m = defaultValues.get(key);
            if (m == null) return null;  
            identityOld2New = m.get(value);
            if (identityOld2New == null) {
                if (value != CompactHashMapClass.REMOVED_OBJECT && m.get(ALL_VALUES_MATCH) == null)
                    return null;  
            } else {
                Map newMap = identityOld2New.get(prevDefaultValues);
                if (newMap != null) return newMap;
            }
        } finally {
            readLock.unlock();
        }
        Map<K, V> newMap = new HashMap<K, V>((int) ((prevDefaultValues.size() + 1) / 0.75f));
        newMap.putAll(prevDefaultValues);
        if (value == CompactHashMapClass.REMOVED_OBJECT)
            newMap.remove(key);
        else
            newMap.put(key, (V) value);
        writeLock.lock();
        try {
            if (identityOld2New == null) {
                identityOld2New = m.get(value);
                if (identityOld2New == null)
                    m.put(value, identityOld2New = new IdentityHashMap<Map, Map>());
            }
            final Map anotherNewMap = identityOld2New.get(prevDefaultValues);
            if (anotherNewMap != null) return anotherNewMap;  
            identityOld2New.put(prevDefaultValues, newMap);
            return newMap;
        } finally {
            writeLock.unlock();
        }
    }
}",0,0,0,0,0,0,0,0,0
16,"package org.joyfulmonster.util.concurrent;
import org.joyfulmonster.util.concurrent.internal.ConcurrentElasticHashMapImpl;
import org.joyfulmonster.util.concurrent.internal.MetricsSupport;
public class ConcurrentElasticHashMap<K, V> {
    private static final String ILLEGAL_ARGUMENT_EXPECTION_MSG = ""The key or value can not be null."";
    private ConcurrentElasticHashMapImpl<K, V> service;
    public ConcurrentElasticHashMap() {
        service = new ConcurrentElasticHashMapImpl<K, V>();
    }
    public ConcurrentElasticHashMap(int bucketSize, int initBucketCount, float loadFactor) {
        service = new ConcurrentElasticHashMapImpl<K, V>(bucketSize, initBucketCount, loadFactor);
    }
    public V put(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.put(key, value);
    }
    public V putIfAbsent(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.putIfAbsent(key, value);
    }
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.get(key);
    }
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.remove(key);
    }
    public boolean remove(K key, V val) {
        if (key == null || val == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.remove(key, val);
    }
    public V replace(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.replace(key, value);
    }
    public boolean replace(K key, V oldValue, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.replace(key, oldValue, value);
    }
    public int size() {
        return service.size();
    }
    MetricsSupport getMetrics() {
        return service;
    }
}",0,0,0,0,0,0,0,0,0
17,"package org.joyfulmonster.util.concurrent.internal;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
public class ConcurrentElasticHashMapImpl<K, V> implements MetricsSupport {
    private static final String ILLEGAL_ARGUMENT_EXPECTION_MSG = ""The key or value can not be null."";
    public static final int DEFAULT_BUCKET_SIZE = 8092;  
    public static final int DEFAULT_BUCKET_COUNT = 8;
    public static final float DEFAULT_BUKCET_LOAD_FACTOR = 0.75f;
    public static final int MAX_CAPACITY = 1 << 30;
    public static final int MIN_BUCKET_COUNT = 2;
    public static final int MAX_BUCKET_COUNT = MAX_CAPACITY / MIN_BUCKET_COUNT;
    public static final float MAX_BUCKET_LOADFACTOR = 0.95f;
    private final Directory directory;
    private final AtomicInteger totalSplitCount;
    private final AtomicInteger totalEntryCount;
    public ConcurrentElasticHashMapImpl() {
        this(DEFAULT_BUCKET_SIZE, DEFAULT_BUCKET_COUNT, DEFAULT_BUKCET_LOAD_FACTOR);
    }
    public ConcurrentElasticHashMapImpl(int bucketSize, int initBucketCount, float bucketLoadFactor) {
        totalSplitCount = new AtomicInteger(0);
        totalEntryCount = new AtomicInteger(0);
        initBucketCount = lowestUpperBound(initBucketCount);
        bucketLoadFactor = (bucketLoadFactor < MAX_BUCKET_LOADFACTOR) ? bucketLoadFactor : MAX_BUCKET_LOADFACTOR;
        directory = DirectoryFactory.create(initBucketCount, bucketSize, bucketLoadFactor, totalEntryCount, totalSplitCount);
    }
    public V put(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return put(key, value, true);
    }
    public V putIfAbsent(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return put(key, value, false);
    }
    private V put(K key, V value, boolean replaceIfPresent) {
        int hashCode = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket<K, V> bucket = directory.getBucket(hashCode);
            bucket.lock();
            if (bucket.isInvalid()) {
                bucket.unlock();
                continue;
            }
            else {
                try {
                    V result = null;
                    boolean putSuccess;
                    if (bucket.hasMoreSpace()) {
                        try {
                            result = (V) bucket.put(key, value, hashCode, replaceIfPresent);
                            putSuccess = true;
                        } catch (BucketOverflowError soe) {
                            putSuccess = false;
                        }
                    } else {
                        putSuccess = false;
                    }
                    if (!putSuccess) {
                        result = bucket.splitAndPut(key, value, hashCode, replaceIfPresent);
                    }
                    return result;
                } finally {
                    bucket.unlock();
                }
            }
        }
    }
    public boolean remove(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return bucket.remove(key, hashValue, value) != null;
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public V replace(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return (V) bucket.replace(key, hashValue, null, value);
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return bucket.replace(key, hashValue, oldValue, newValue) != null;
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashCode = HashStrategy.getInstance().hash(key.hashCode());
        Bucket<K, V> bucket = directory.getBucket(hashCode);
        return bucket.get(key, hashCode);
    }
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        int hashValue = HashStrategy.getInstance().hash(key.hashCode());
        while (true) {
            Bucket<K, V> bucket = directory.getBucket(hashValue);
            bucket.lock();
            try {
                if (!bucket.isInvalid()) {
                    return (V) bucket.remove(key, hashValue, null);
                }
            } finally {
                bucket.unlock();
            }
        }
    }
    public int size() {
        return totalEntryCount.get();
    }
    public int totalSplits() {
        return totalSplitCount.get();
    }
    public int getBucketCount() {
        return directory.getBucketCount();
    }
    @Override
    public int getMaxBucketCountDifference() {
        AtomicReferenceArray<Bucket> buckets = directory.get();
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        for (int i=0; i<buckets.length(); i++) {
            Bucket bucket = buckets.get(i);
            if (bucket instanceof BucketMetricsSupport) {
                int entries = ((BucketMetricsSupport)bucket).getBucketEntries();
                if (entries < min) {
                    min = entries;
                }
                if (entries > max) {
                    max = entries;
                }
            }
        }
        return max-min;
    }
    private int lowestUpperBound (int i) {
        int seed = 1;
        while (seed < i) {
            seed = seed << 1;
        }
        return seed;
    }
}",0,0,0,0,0,0,0,0,1
18,"package com.deepak.data.structures.Hashing;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
public class ConcurrentHashMapImplementation {
	static Map<String, AtomicLong> ordersMap = new ConcurrentHashMap<>();
	static void processOrders() {
		for (String city : ordersMap.keySet()) {
			for (int i = 0; i < 50; i++) {
				ordersMap.get(city).getAndIncrement();
			}
		}
	}
	public static void main(String[] args) throws InterruptedException {
		ordersMap.put(""Delhi"", new AtomicLong());
		ordersMap.put(""London"", new AtomicLong());
		ordersMap.put(""New York"", new AtomicLong());
		ordersMap.put(""Sydney"", new AtomicLong());
		ExecutorService service = Executors.newFixedThreadPool(2);
		service.submit(new Runnable() {
			@Override
			public void run() {
				processOrders();
			}
		});
		service.submit(new Runnable() {
			@Override
			public void run() {
				processOrders();
			}
		});
		service.awaitTermination(1, TimeUnit.SECONDS);
		service.shutdown();
		System.out.println(ordersMap);
	}
}",0,0,0,0,0,0,0,0,0
19,"package com.deepak.data.structures.Hashing;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
public class ConcurrentModificationException {
	public static void main(String[] args) {
		Map<String, Integer> scores = new HashMap<>();
		scores.put(""Team A"", 10);
		scores.put(""Team B"", 10);
		scores.put(""Team C"", 12);
		scores.put(""Team D"", 10);
		scores.put(""Team E"", 14);
		scores.put(""Team F"", 10);
		Iterator<String> scoresItr = scores.keySet().iterator();
		while (scoresItr.hasNext()) {
			System.out.println(scores.get(scoresItr.next()));
			scores.put(""Team G"", 10);
		}
	}
}",0,0,0,0,0,0,0,0,0
20,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;
public class Controller{
	private BrentHashMap<Key, Integer> hashTable;
	private Scanner scan;
	private BufferedReader read;
	private FileReader fileRead;
	private View view; 
	private Key key;
	private static final String DEFAULTFILE = ""story.txt"";
	public static void main(String[] args) {
		new Controller();
	}
	public Controller() {
		this(DEFAULTFILE);
	}
	public Controller(String fileName) {
		try {
			 hashTable = new BrentHashMap<Key,Integer>();
			 view = new View();
			 fileRead = new FileReader(fileName);
			 read = new BufferedReader(fileRead);
			 scan = new Scanner(System.in);
			 readFile();
			 run();
		}catch(IOException e) { view.printTxtReadError();}
	}
	private void readFile() throws IOException {
		String line = null;
		String[] words = null;
		while((line = read.readLine()) != null) {
			words = line.split("" "");
			for(String s : words) {
				if(!s.equals("""")) {
					s = s.toLowerCase();
					if(s.contains("""")) {
						s = s.replace("""", ""i"");
					}
					key = new Key(s);
					hashTable.put(key, 1);
				}		
			}
		}
	}
	private void run() {
		Key key = null;
		String input = null;
		do {
			view.printNewSearch();
			input = scan.nextLine().toLowerCase();
			if(input.contains(""""))
				input = input.replace("""", ""i"");
			if(!""-exit"".equals(input) && !""-show"".equals(input)) {
				key = new Key(input);
				if(hashTable.get(key) != null) {
					view.printResults(key.hashCode(), 
										hashTable.getCount(key), 
											hashTable.getIndex(key));
				}
				else 
					view.printNotFound(key.toString());
			}
		}while(!""-exit"".equals(input) && !""-show"".equals(input));
		if(""-show"".equals(input)) {
			show();
		}
		view.printClosedMessage();
	}
	private void show(){
		int totalWords = 0;
		int i = 0;
		for(Entry<Key,Integer> entry : hashTable.entrySet()) {
			if(entry != null) {
				view.printTableLine(i, entry.getKey(), entry.getKey().hashCode(), entry.getCount());
				totalWords += entry.getCount();
			}
			i++;
		}
		view.printTotalValues(totalWords, hashTable.size());
	}
}",0,0,0,0,0,0,0,0,0
21,"package cuckoo;  
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.atomic.AtomicLong;
public class Cuckoo<K, V> {
    int size, maxReach;
    LinkedList<KVStruct<K, V>>[] values;
    private final AtomicLong txnCtr = new AtomicLong(0);
    private final AtomicLong lsTxn = new AtomicLong(0);
    private final Lock lock = new ReentrantLock();
    protected long getLsTxn() {
        return lsTxn.get();
    }
    protected long getTxnCtr() {
        return txnCtr.get();
    }
    protected LinkedList<KVStruct<K,V>>[] getValues() {
        return values;
    }
    private Cuckoo(int size, int maxReach, long txnCtr, long lsTxn){
        this(size, maxReach);
        this.txnCtr.set(txnCtr);
        this.lsTxn.set(lsTxn);
    }
    public Cuckoo(int size, int maxReach){
        this.size = size;
        this.maxReach = maxReach;
        values = new LinkedList[size];
        for (int i = 0; i < size; i++) {
            values[i] =  new LinkedList<KVStruct<K, V>>();
            values[i].insert(0, new KVStruct<K, V>());
        }
        txnCtr.set(1);
        lsTxn.set(1);
    }
    public int hash1(K key){
        if (key == null)
            return 0;
        int h = key.hashCode();
        h += (h <<  15) ^ 0xffffcd7d;
        h ^= (h >>> 10);
        h += (h <<   3);
        h ^= (h >>>  6);
        h += (h <<   2) + (h << 14);
        return Math.abs((h ^ (h >>> 16)) % size);
    }
    public int hash2(K key){
        if (key == null)
            return 0;
        int h = key.hashCode();
        h += (h <<  15) ^ 0xffffcd4d;
        h ^= (h >>> 10);
        h += (h <<   3);
        h ^= (h >>>  6);
        h += (h <<   2) + (h << 14);
        h ^= (h >>> 16);
        return Math.abs((h / 11) % size);
    }
    private void insert(long txn, KVStruct kv, int idx){
        values[idx].insert(txn, kv);
    }
    public void put(K key, V value) throws NeedExpansionException {
        if(key == null || value == null) throw new NullPointerException();
        try{
            lock.lock();
            long txn = txnCtr.getAndIncrement();
            KVStruct<K, V> current = new KVStruct<K, V>(key, value);
            int[] idxMod = new int[maxReach];
            for(int i = 0; i < maxReach; i++) {
                int idx = hash1(current.key);
                KVStruct temp = values[idx].getHeadObj();
                if(temp.equals(new KVStruct())){
                    insert(txn, current, idx);
                    lsTxn.set(txn);
                    return;
                }
                idx = hash2(current.key);
                temp = values[idx].getHeadObj();
                if(temp.equals(new KVStruct())){
                    insert(txn, current, idx);
                    lsTxn.set(txn);
                    return;
                }
                insert(txn, current, idx);
                idxMod[i] = idx;
                current = temp;
            }
            for(int i=0; i < maxReach; i++){
                values[idxMod[i]].delete(txn);
            }
            throw new NeedExpansionException(""Key "" + key + "" Could not be inserted due to tight table"");
        }finally{
            lock.unlock();
        }
    }
    public V get(K key) {
        long version = lsTxn.get();
        int idx = hash1(key);
        KVStruct<K, V> kv = values[idx].latestVer(version);
        if(kv.key != null && kv.key.equals(key)) {
            return kv.value;
        }
        idx = hash2(key);
        kv = values[idx].latestVer(version);
        if(kv.key != null && kv.key.equals(key)){
            return kv.value;
        }
        return null;
    }
    public boolean delete(K key){
        try{
            lock.lock();
            long txn = txnCtr.getAndIncrement();
            int idx = hash1(key);
            KVStruct kv = values[idx].latestVer(lsTxn.get());
            if(kv.key != null && kv.key.equals(key)){
                insert(txn, new KVStruct(), idx);
                lsTxn.set(txn);
                return true;
            }
            idx = hash2(key);
            kv = values[idx].latestVer(lsTxn.get());
            if(kv.key != null && kv.key.equals(key)){
                insert(txn, new KVStruct(), idx);
                lsTxn.set(txn);
                return true;
            }
            return false;
        }finally{
            lock.unlock();
        }
    }
    private class KVStruct<K, V> {
        public K key;
        public V value;
        public KVStruct() {
        }
        public K getKey() {
            return key;
        }
        public V getValue() {
            return value;
        }
        public KVStruct(K key, V value) {
            this.key = key;
            this.value = value;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            KVStruct<?, ?> kvStruct = (KVStruct<?, ?>) o;
            if (key != null ? !key.equals(kvStruct.key) : kvStruct.key != null) return false;
            return value != null ? value.equals(kvStruct.value) : kvStruct.value == null;
        }
        @Override
        public int hashCode() {
            int result = key != null ? key.hashCode() : 0;
            result = 31 * result + (value != null ? value.hashCode() : 0);
            return result;
        }
    }
}",0,0,0,0,0,0,0,0,1
22,"package com.fullstory;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import static com.fullstory.CustomHashMapIterator.DEFAULT_INDEX;
@SuppressWarnings({""WeakerAccess"", ""unused""})
public class CustomHashMap<K, V> implements Iterable<KeyValuePojo<K, V>> {
    private static int BUCKET_CAPACITY = 64;
    private DoublyLinkedList<K, V>[] buckets;
    private final Object editLock = new Object();
    CustomHashMap(DoublyLinkedList<K, V>[] buckets, int capacity) {
        this.buckets = buckets;
        BUCKET_CAPACITY = capacity;
    }
    public CustomHashMap() {
        init();
    }
    @SuppressWarnings(""unchecked"")
    private void init() {
        this.buckets = new DoublyLinkedList[BUCKET_CAPACITY];
        for (int i = 0; i < BUCKET_CAPACITY; i++) {
            this.buckets[i] = new DoublyLinkedList<>();
        }
    }
    private int hash(K key) {
        return Math.abs(key.hashCode()) % BUCKET_CAPACITY;
    }
    private DoublyLinkedList<K, V> fetchListHoldingKey(K key) {
        int index = hash(key);
        return this.buckets[index];
    }
    private Stream<DoublyLinkedList<K, V>> nonEmptyBucketsStream() {
        return Arrays.stream(this.buckets).filter(bucket -> !bucket.isEmpty());
    }
    int getNextNonEmptyBucketFromIndex(int index) {
        if (index >= BUCKET_CAPACITY)
            return DEFAULT_INDEX;
        int i = index;
        while (i < BUCKET_CAPACITY && this.buckets[i].isEmpty())
            i++;
        return i == BUCKET_CAPACITY ? DEFAULT_INDEX : i;
    }
    DoublyLinkedList<K, V> getListInBucket(int index) {
        return this.buckets[index];
    }
    public void put(K key, V value) {
        synchronized (editLock) {
            DoublyLinkedList<K, V> list = fetchListHoldingKey(key);
            list.add(key, value);
        }
    }
    public V get(K key) throws KeyNotFoundException {
        return fetchListHoldingKey(key).fetchValueInNodeWithKey(key);
    }
    public V get(K key, V defaultValue) {
        return fetchListHoldingKey(key).fetchValueInNodeWithKey(key, defaultValue);
    }
    public V getThreadSafe(K key, V defaultValue) {
        synchronized (editLock) {
            return fetchListHoldingKey(key).fetchValueInNodeWithKey(key, defaultValue);
        }
    }
    public void remove(K key) throws KeyNotFoundException {
        synchronized (editLock) {
            DoublyLinkedList<K, V> listContainingNodeToRemove = this.fetchListHoldingKey(key);
            if (!listContainingNodeToRemove.removeNodeWithKeyIfExists(key))
                throw new KeyNotFoundException(key.toString());
        }
    }
    public void clear() {
        synchronized (editLock) {
            init();
            System.gc();
        }
    }
    public Set<K> keys() {
        return nonEmptyBucketsStream().flatMap(DoublyLinkedList::getAllKeys).collect(Collectors.toSet());
    }
    public List<V> values() {
        return nonEmptyBucketsStream().flatMap(DoublyLinkedList::getAllValues).collect(Collectors.toList());
    }
    public List<KeyValuePojo<K, V>> keyValuePojo() {
        return nonEmptyBucketsStream().flatMap(DoublyLinkedList::getAllPojo).collect(Collectors.toList());
    }
    public boolean isPresent(K key) {
        return !fetchListHoldingKey(key).isEmpty();
    }
    @Override
    public Iterator<KeyValuePojo<K, V>> iterator() {
        return new CustomHashMapIterator<>(this, editLock);
    }
}",0,0,0,0,0,0,0,0,1
23,"package maps.customhashmap;
public class CustomHashMapImpl<K, V> implements CustomHashMap<K, V> {
    private int DEFAULT_BUCKET_COUNT = 10;
    Entry[] entryBuckets;
    public CustomHashMapImpl() {
        this.entryBuckets = new Entry[DEFAULT_BUCKET_COUNT];
    }
    public CustomHashMapImpl(int size) {
        this.entryBuckets = new Entry[size];
    }
    @Override
    public void put(K key, V value) {
        Entry<K, V> newEntry = new Entry<K, V>(key, value);
        if (key == null) {
            throw new IllegalArgumentException(""Key "" + key + "" cannot be null."");
        }
        int bucketIndex = findBucketUsingHashFunction(key.hashCode());
        if (entryBuckets[bucketIndex] == null) {
            entryBuckets[bucketIndex] = newEntry;
        } else {
            Entry<K, V> entry = entryBuckets[bucketIndex];
            if (entry.getKey().equals(key)) {
                entry.setValue(value);
            } else {
                while (entry.getNext() != null) {
                    entry = entry.getNext();
                }
                entry.setNext(newEntry);
            }
        }
    }
    @Override
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Key "" + key + "" cannot be null."");
        }
        int bucketIndex = findBucketUsingHashFunction(key.hashCode());
        Entry<K, V> entry = entryBuckets[bucketIndex];
        while (entry != null && !key.equals(entry.getKey())) {
            entry = entry.getNext();
        }
        return entry != null ? entry.getValue() : null;
    }
    private int findBucketUsingHashFunction(int hashCode) {
        return hashCode % entryBuckets.length;
    }
    @Override
    public boolean remove(K key) {
        return false;
    }
    private static class Entry<K, V> {
        private Entry<K, V> next;
        private final K key;
        private V value;
        public Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
        private V getValue() {
            return value;
        }
        private void setValue(V value) {
            this.value = value;
        }
        private K getKey() {
            return key;
        }
        private Entry<K, V> getNext() {
            return next;
        }
        private void setNext(Entry<K, V> next) {
            this.next = next;
        }
    }
}",0,0,0,0,0,1,0,0,1
24,"package com.fullstory;
import java.util.Iterator;
public class CustomHashMapIterator<K, V> implements Iterator<KeyValuePojo<K, V>> {
    final static int DEFAULT_INDEX = -1;
    private final CustomHashMap<K, V> hashMap;
    private final Object hashMapEditLock;
    private int currentNodeIndexInList;
    private int currentBucketIndex;
    CustomHashMapIterator(CustomHashMap<K, V> hashMap, Object hashMapEditLock) {
        this.hashMap = hashMap;
        this.hashMapEditLock = hashMapEditLock;
        this.currentBucketIndex = 0;
        this.currentNodeIndexInList = DEFAULT_INDEX;
    }
    private void updateNonEmptyBucketIndex() {
        int updatedBucketIndex = this.hashMap.getNextNonEmptyBucketFromIndex(this.currentBucketIndex);
        if (updatedBucketIndex != this.currentBucketIndex) {
            this.currentBucketIndex = updatedBucketIndex;
            this.currentNodeIndexInList = DEFAULT_INDEX;
        } else if (this.currentNodeIndexInList + 1 >= lengthOfListInCurrentBucket()) {
            this.currentBucketIndex = this.hashMap.getNextNonEmptyBucketFromIndex(this.currentBucketIndex + 1);
            this.currentNodeIndexInList = DEFAULT_INDEX;
        }
    }
    private DoublyLinkedList<K, V> getCurrentList() {
        return this.hashMap.getListInBucket(this.currentBucketIndex);
    }
    private int lengthOfListInCurrentBucket() {
        return getCurrentList().length();
    }
    private KeyValuePojo<K, V> getNextPojo() {
        this.currentNodeIndexInList++;
        return getCurrentList().getPojoOfNodeAtIndex(this.currentNodeIndexInList);
    }
    private boolean hasNextUnsafe() {
        updateNonEmptyBucketIndex();
        return this.currentBucketIndex != DEFAULT_INDEX;
    }
    @Override
    public boolean hasNext() {
        synchronized (this.hashMapEditLock) {
            return hasNextUnsafe();
        }
    }
    @Override
    public KeyValuePojo<K, V> next() {
        synchronized (this.hashMapEditLock) {
            if (hasNextUnsafe())
                return getNextPojo();
            return null;
        }
    }
}",0,0,0,0,0,0,0,0,0
25,"package com.deepak.data.structures.Hashing;
import java.util.Map;
import java.util.Objects;
public class CustomHashTable<K, V> {
	static class Entry<K, V> {
		final int hash;
		final K key;
		V value;
		Entry<K, V> next;
		public Entry(int hash, K key, V value, Entry<K, V> next) {
			this.hash = hash;
			this.key = key;
			this.value = value;
			this.next = next;
		}
		public final int hashCode() {
			return Objects.hashCode(key) ^ Objects.hashCode(value);
		}
		public final boolean equals(Object o) {
			if (o == this) {
				return true;
			}
			if (o instanceof Map.Entry) {
				Map.Entry<?,?> e = (Map.Entry<?,?>)o;
				if (Objects.equals(key, e.getKey()) &&
						Objects.equals(value, e.getValue())) {
					return true;
				}
			}
			return false;
		}
	}
}",0,0,0,0,0,0,0,0,0
26,"package com.blogspot.mydailyjava.weaklockfree;
public class DetachedThreadLocal<T> implements Runnable {
    final WeakConcurrentMap<Thread, T> map;
    public DetachedThreadLocal(Cleaner cleaner) {
        switch (cleaner) {
            case THREAD:
            case MANUAL:
                map = new WeakConcurrentMap<Thread, T>(cleaner == Cleaner.THREAD) {
                    @Override
                    protected T defaultValue(Thread key) {
                        return DetachedThreadLocal.this.initialValue(key);
                    }
                };
                break;
            case INLINE:
                map = new WeakConcurrentMap.WithInlinedExpunction<Thread, T>() {
                    @Override
                    protected T defaultValue(Thread key) {
                        return DetachedThreadLocal.this.initialValue(key);
                    }
                };
                break;
            default:
                throw new AssertionError();
        }
    }
    public T get() {
        return map.get(Thread.currentThread());
    }
    public T getIfPresent() {
      return map.getIfPresent(Thread.currentThread());
    }
    public void set(T value) {
        map.put(Thread.currentThread(), value);
    }
    public void clear() {
        map.remove(Thread.currentThread());
    }
    public void clearAll() {
        map.clear();
    }
    public T pushTo(Thread thread) {
        T value = get();
        if (value != null) {
            map.put(thread, inheritValue(value));
        }
        return value;
    }
    public T fetchFrom(Thread thread) {
        T value = map.get(thread);
        if (value != null) {
            set(inheritValue(value));
        }
        return value;
    }
    public T get(Thread thread) {
        return map.get(thread);
    }
    public void define(Thread thread, T value) {
        map.put(thread, value);
    }
    protected T initialValue(Thread thread) {
        return null;
    }
    protected T inheritValue(T value) {
        return value;
    }
    public WeakConcurrentMap<Thread, T> getBackingMap() {
        return map;
    }
    @Override
    public void run() {
        map.run();
    }
    public enum Cleaner {
        THREAD, INLINE, MANUAL
    }
}",0,0,0,0,0,0,0,0,0
27,"DEFAULT_DICTIONARY_SIZE = 64
class Dictionary(object):
    def __init__(self):
        self._size = 0
        self._values = [None] * DEFAULT_DICTIONARY_SIZE
    def _expand(self):
        values = list(self._values)
        self._values = [None] * len(self._values) * 2
        self._size = 0
        for entry in values:
            if entry != None:
                key = entry[0]
                value = entry[1]
                self[key] = value
    def _indexof(self, key):
        i = hash(key) % len(self._values)
        if self._values[i] == None:
            return -1
        if self._values[i][0] == key:
            return i
        else:
            j = i + 1
            while self._values[j] != None and self._values[j][0] != key and j != i:
                if j == len(self._values) - 1:
                    j = 0
                else:
                    j += 1
            if self._values[j] != None and self._values[j][0] == key:
                return j
            else:
                return -1
    def __getitem__(self, key):
        i = self._indexof(key)
        if i == -1:
            return None
        else:
            return self._values[i][1]
    def __setitem__(self, key, value):
        i = hash(key) % len(self._values)
        if self._values[i] == None:
            self._values[i] = (key, value)
            self._size += 1
        elif self._values[i][0] == key:
            self._values[i] = (key, value)
        else:
            j = i + 1 if i < len(self._values) - 1 else 0
            while self._values[j] != None and j != i:
                if j == len(self._values) - 1:
                    j = 0
                else:
                    j += 1
            if j == i:
                self._expand()
                self.__setitem__(key, value)
            else:
                self._values[j] = (key, value)
                self._size += 1
    def remove(self, key):
        i = self._indexof(key)
        if i != -1:
            self._values[i] = None
            self._size -= 1
    def contains_key(self, key):
        return self[key] != None
    def __len__(self):
        return self._size",0,0,0,0,0,0,0,0,1
28,"package org.joyfulmonster.util.concurrent.internal;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
class DirectoryFactory {
    public static Directory create(int bucketCount, int bucketSize, float loadFactor, AtomicInteger totalEntryCount, AtomicInteger splitCount) {
        int dirSize = bucketCount;
        int dirMask = dirSize - 1;
        int globalDepth = Integer.bitCount(dirMask);
        AtomicReferenceArray<Bucket> bucketsArray = new AtomicReferenceArray<Bucket>(bucketCount);
        for (int bucketIdex = 0; bucketIdex < bucketCount; bucketIdex++) {
            bucketsArray.set(bucketIdex, new LinearProbingBucketImpl(globalDepth, bucketIdex, bucketSize, loadFactor, totalEntryCount, splitCount));
        }
        DirectoryImpl result = new DirectoryImpl(bucketsArray);
        for (int i = 0; i < bucketCount; i++) {
            ((LinearProbingBucketImpl)bucketsArray.get(i)).directory(result);
        }
        BucketFactory bucketFactory = new BucketFactory(result, bucketSize, loadFactor, totalEntryCount, splitCount);
        result.bucketFactory(bucketFactory);
        return result;
    }
}",0,0,0,0,0,0,0,0,0
29,"package org.joyfulmonster.util.concurrent.internal;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.concurrent.locks.ReentrantLock;
class DirectoryImpl extends AtomicReference<AtomicReferenceArray<Bucket>> implements Directory {
    private final ReentrantLock lock;
    private volatile int bucketCount;
    private BucketFactory bucketFactory;
    DirectoryImpl(AtomicReferenceArray<Bucket> buckets) {
        super(buckets);
        lock = new ReentrantLock(true);
        bucketCount = buckets.length();
    }
    public void lock() {
        lock.lock();
    }
    public void unlock() {
        lock.unlock();
    }
    public int getBucketCount() {
        return bucketCount;
    }
    public Bucket getBucket(int hashCode) {
        AtomicReferenceArray<Bucket> dir = get();
        int dirSize = dir.length();
        int dirMask = dirSize - 1;
        int bucketIndex = hashCode & dirMask;
        Bucket bucket = dir.get(bucketIndex);
        return bucket;
    }
    Directory bucketFactory(BucketFactory factory) {
        bucketFactory = factory;
        return this;
    }
    public BucketFactory getBucketFactory() {
        return bucketFactory;
    }
    public int onSplit(Bucket oldBucket, Bucket[] newBuckets) {
        lock();
        try {
            this.bucketCount++;  
            AtomicReferenceArray<Bucket> bucketArray = get();
            int bucketsNumber = bucketArray.length();
            int dirMask = bucketsNumber - 1;
            int globalDepth = Integer.bitCount(dirMask);
            if (globalDepth < newBuckets[0].getLocalDepth()) {
                int newDirSize = bucketsNumber * 2;
                if (newDirSize > ConcurrentElasticHashMapImpl.MAX_BUCKET_COUNT) {
                    throw new IllegalStateException(""directory size limit exceeded"");
                }
                AtomicReferenceArray<Bucket> newDirectory = new AtomicReferenceArray<Bucket>(newDirSize);
                for (int i = 0; i < bucketsNumber; i++) {
                    newDirectory.set(i, bucketArray.get(i));
                    newDirectory.set(i + bucketsNumber, bucketArray.get(i));
                }
                bucketArray = newDirectory;
                bucketsNumber = newDirSize;
                set(newDirectory);
            } else {
            }
            final int step = 1 << newBuckets[0].getLocalDepth();
            for (int i = newBuckets[1].getBucketIdx(); i < bucketsNumber; i += step) {
                bucketArray.set(i, newBuckets[1]);
            }
            for (int i = newBuckets[0].getBucketIdx(); i < bucketsNumber; i += step) {
                bucketArray.set(i, newBuckets[0]);
            }
        } finally {
            unlock();
        }
        return bucketCount;
    }
    @Override
    public int onMerge(Bucket oldBucket) {
        return 0;
    }
}",0,0,0,0,0,0,0,0,0
30,"from .hash_table import HashTable
from number_theory.prime_numbers import next_prime, check_prime
class DoubleHash(HashTable):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    def __hash_function_2(self, value, data):
        next_prime_gt = next_prime(value % self.size_table)            if not check_prime(value % self.size_table) else value % self.size_table  
        return next_prime_gt - (data % next_prime_gt)
    def __hash_double_function(self, key, data, increment):
        return (increment * self.__hash_function_2(key, data)) % self.size_table
    def _colision_resolution(self, key, data=None):
        i = 1
        new_key = self.hash_function(data)
        while self.values[new_key] is not None and self.values[new_key] != key:
            new_key = self.__hash_double_function(key, data, i) if                self.balanced_factor() >= self.lim_charge else None
            if new_key is None: break 
            else: i += 1
        return new_key",0,0,0,0,0,0,0,0,0
31,"class HashTable(object):
    def __init__(self, size):
        self.size = size
        self.length = 0
        self.keys = [None for _ in range(self.size)]
    def add(self, key, value):
        for i in range(self.size):
            hash_value = hash_function(key, i, self.size)
            node = self.keys[hash_value]
            if node is None:
                self.keys[hash_value] = Node(key, value)
                self.length += 1
                return self.keys[hash_value]
            elif node.key == key:
                self.keys[hash_value].value = value
                if self.keys[hash_value].deleted:
                    self.length += 1
                self.keys[hash_value].deleted = False
                return self.keys[hash_value]
        raise Exception('The hash table is full')
    def get(self, key, default=None):
        for i in range(self.size):
            hash_value = hash_function(key, i, self.size)
            node = self.keys[hash_value]
            if node is None:
                return default
            elif not node.deleted and node.key == key:
                return node.value
        return default
    def remove(self, key):
        for i in range(self.size):
            hash_value = hash_function(key, i, self.size)
            node = self.keys[hash_value]
            if node is None:
                return None
            elif node.key == key and not node.deleted:
                node.deleted = True
                self.length -= 1
                return node.value
        return None
    def __len__(self):
        return self.length
    def __str__(self):
        string = ''
        for item in self.keys:
            if item is None:
                continue
            if item.deleted:
                continue
            string += str(item) + ', '
        return '{' + string[:-2] + '}'
class Node(object):
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.deleted = False
    def __str__(self):
        key = self.key
        if isinstance(self.key, str):
            key = ""'{}'"".format(self.key)
        value = self.value
        if isinstance(self.value, str):
            value = ""'{}'"".format(self.value)
        return str(key) + ': ' + str(value)
def hash_function(key, item, size):
    hash_value = hash_1(key, size)
    if item == 0:
        return hash_value
    return (hash_value + item * hash_2(key, size - 1)) % size
def hash_1(key, size):
    return sum([i * 256 + ord(v_) for i, v_ in enumerate(str(key))]) % size
def hash_2(key, size):
    return sum([i * 256 + ord(v_) + i for i, v_ in enumerate(str(key))]) % size
if __name__ in '__main__':
    ht = HashTable(size=100)
    DATA = {'hello 0123': 0, '1': '1', 1: 1, 0: -1, 4: 4}
    for k, v in DATA.items():
        ht.add(k, v)
        print('add key', k, 'value', v, 'length', len(ht))
    print('\nhashtable:', ht, '\n')
    print('add key \'hello 0123\'', 'value', -10, 'length', len(ht))
    ht.add('hello 0123', -10)
    print('\nhashtable:', ht, '\n')
    for k in [4, '1', 100, 4]:
        ht.remove(k)
        print('remove key', k, 'length', len(ht))
    print('\nhashtable:', ht, '\n')
    for k in [4]:
        ht.add(k, k)
        print('add key', k, 'value', k, 'length', len(ht))
    print('\nhashtable:', ht, '\n')
    for k in [4, 0, 'hello 0123']:
        print('get value by key', k, 'value:', ht.get(k))",0,0,0,0,0,0,0,0,1
32,"class DoubleHashing extends AbstractHashSequence {
  private final HashFunction func2;
  private Object key;
  private int j;
  public DoubleHashing(HashFunction f1, HashFunction f2) {
    super(f1);
    func2 = f2;
  }
  @Override
  public int first(Object key) {
    j = 0;
    this.key = key;
    return func.compute(key);
  }
  @Override
  public int next() {
    return (func.compute(key) + ++j * func2.compute(key)) % size();
  }
}",0,0,0,0,0,0,0,0,0
33,"package com.fullstory;
import java.util.ArrayList;
import java.util.stream.Stream;
class DoublyLinkedList<K, V> {
    private KeyValueNode<K, V> head;
    private int numberOfNodes;
    DoublyLinkedList() {
        this(null, 0);
    }
    DoublyLinkedList(KeyValueNode<K, V> head, int numberOfNodes) {
        this.head = head;
        this.numberOfNodes = numberOfNodes;
    }
    private void insertAtBeginning(KeyValueNode<K, V> newKeyValueNode) {
        if (this.head != null) {
            newKeyValueNode.next(this.head);
            this.head.previous(newKeyValueNode);
        }
        this.head = newKeyValueNode;
        numberOfNodes++;
    }
    private KeyValueNode<K, V> fetchNodeWithKey(K key) {
        KeyValueNode<K, V> tempPointer = this.head;
        while (tempPointer != null) {
            if (tempPointer.key().equals(key))
                return tempPointer;
            tempPointer = tempPointer.next();
        }
        return null;
    }
    private void deleteNode(KeyValueNode<K, V> node) {
        numberOfNodes--;
        KeyValueNode<K, V> previousPointer = node.previous();
        KeyValueNode<K, V> nextPointer = node.next();
        if (previousPointer == null) {
            this.head = node.next();
        } else if (nextPointer == null) {
            previousPointer.next(null);
        } else {
            node.next(null);
            node.previous(null);
            previousPointer.next(nextPointer);
            nextPointer.previous(previousPointer);
        }
    }
    private Stream<KeyValueNode<K, V>> allNodesStream() {
        ArrayList<KeyValueNode<K, V>> nodes = new ArrayList<>();
        KeyValueNode<K, V> tempPointer = this.head;
        while (tempPointer != null) {
            nodes.add(tempPointer);
            tempPointer = tempPointer.next();
        }
        return nodes.stream();
    }
    void add(K key, V value) {
        KeyValueNode<K, V> newKeyValueNode = new KeyValueNode<>(key, value);
        removeNodeWithKeyIfExists(key);
        insertAtBeginning(newKeyValueNode);
    }
    V fetchValueInNodeWithKey(K key, V defaultValue) {
        KeyValueNode<K, V> node = fetchNodeWithKey(key);
        if (node == null)
            return defaultValue;
        return node.value();
    }
    V fetchValueInNodeWithKey(K key) throws KeyNotFoundException {
        KeyValueNode<K, V> node = fetchNodeWithKey(key);
        if (node == null)
            throw new KeyNotFoundException(key.toString());
        return node.value();
    }
    boolean removeNodeWithKeyIfExists(K key) {
        KeyValueNode<K, V> nodeToDelete = this.fetchNodeWithKey(key);
        if (nodeToDelete == null)
            return false;
        deleteNode(nodeToDelete);
        return true;
    }
    KeyValuePojo<K, V> getPojoOfNodeAtIndex(int index) {
        if (index >= this.length())
            return null;
        KeyValueNode<K, V> tempPointer = this.head;
        for (int i = 0; i < index; i++) {
            tempPointer = tempPointer.next();
        }
        return tempPointer.pojo();
    }
    int length() {
        return numberOfNodes;
    }
    boolean isEmpty() {
        return this.length() == 0;
    }
    Stream<K> getAllKeys() {
        return allNodesStream().map(KeyValueNode::key);
    }
    Stream<V> getAllValues() {
        return allNodesStream().map(KeyValueNode::value);
    }
    Stream<KeyValuePojo<K, V>> getAllPojo() {
        return allNodesStream().map(node -> new KeyValuePojo<>(node.key(), node.value()));
    }
}",0,0,0,0,0,1,0,1,0
34,"package com.kevinbohinski.algs;
public class Driver {
	public static void main(String[] args) {
		HashMap<String, Integer> hm = new HashMap<String, Integer>(50);
		System.out.println(""Setting a to 10    : "" + hm.set(""a"", 10));
		System.out.println(""Getting a          : "" + hm.get(""a""));
		System.out.println(""--------------------------"");
		System.out.println(""Setting b to 50    : "" + hm.set(""b"", 50));
		System.out.println(""Getting b          : "" + hm.get(""b""));
		System.out.println(""--------------------------"");
		System.out.println(""Overwriting a to 20: "" + hm.set(""a"", 20));
		System.out.println(""Getting a          : "" + hm.get(""a""));
		System.out.println(""Deleting a         : "" + hm.delete(""a""));
		System.out.println(""Getting a          : "" + hm.get(""A""));
		System.out.println(""--------------------------"");
		System.out.println(""Deleting c         : "" + hm.delete(""c""));
		System.out.println(""Setting c to 15    : "" + hm.set(""c"", 15));
		System.out.println(""Getting c          : "" + hm.get(""c""));
		System.out.println(""--------------------------"");
		System.out.println(""Setting null to 15 : "" + hm.set(null, 15));
		System.out.println(""Getting null       : "" + hm.get(null));
		System.out.println(""--------------------------"");
		System.out.println(""Getting a          : "" + hm.get(""a""));
		System.out.println(""Getting b          : "" + hm.get(""b""));
		System.out.println(""Getting c          : "" + hm.get(""c""));
		System.out.println(""--------------------------"");
		System.out.println(""Getting load factor: "" + hm.load());
	}
}",0,0,0,0,0,0,0,0,0
35,"from __future__ import print_function
import math
class HashTable(object):
    DELETED = True
    def __init__(self, capacity=1):
        self.capacity = capacity
        self.keys = [None] * self.capacity
        self.values = [None] * self.capacity
        self.length = 0
    def add(self, key, value):
        if self.length == self.capacity:
            capacity = self.capacity * 2
            self._change_capacity(capacity)
        self._add(key, value)
    def _add(self, key, value):
        for i in range(self.capacity):
            hash_value = hash_function(key, i, self.capacity)
            element = self.keys[hash_value]
            if element is None:
                self.keys[hash_value] = key
                self.values[hash_value] = value
                self.length += 1
                return self.values[hash_value]
            elif element is self.DELETED:
                pass
            elif element == key:
                self.values[hash_value] = value
                return self.values[hash_value]
        raise Exception('The hash table is full')
    def _change_capacity(self, capacity):
        newtable = HashTable(capacity)
        for i, key in enumerate(self.keys):
            if key is None or key is self.DELETED:
                continue
            newtable._add(key, self.values[i])
        self.capacity = newtable.capacity
        self.length = newtable.length
        self.keys = newtable.keys
        self.values = newtable.values
    def get(self, key, default=None):
        for i in range(self.capacity):
            hash_value = hash_function(key, i, self.capacity)
            element = self.keys[hash_value]
            if element is None:
                return default
            elif element is self.DELETED:
                pass
            elif element == key:
                return self.values[hash_value]
        return default
    def remove(self, key):
        if self.length // self.capacity <= 1 / 4:
            if self.length == 0:
                capacity = 1
            else:
                capacity = 2 ** math.ceil(math.log(self.length, 2))
            self._change_capacity(capacity)
        return self._remove(key)
    def _remove(self, key):
        for i in range(self.capacity):
            hash_value = hash_function(key, i, self.capacity)
            element = self.keys[hash_value]
            if element is None:
                return None
            elif element is self.DELETED:
                pass
            elif element == key:
                self.keys[hash_value] = self.DELETED
                self.length -= 1
                return self.values[hash_value]
        return None
    def __len__(self):
        return self.length
    def __str__(self):
        string = ''
        for i, key in enumerate(self.keys):
            if key is None:
                continue
            if key is self.DELETED:
                continue
            string += str(key) + ': ' + str(self.values[i]) + ', '
        return '{' + string[:-2] + '}'
def hash_function(key, item, size):
    hash_value = hash_1(key, size)
    if item == 0:
        return hash_value
    return (hash_value + item * hash_2(key, size - 1)) % size
def hash_1(key, size):
    return sum([i * 256 + ord(v_) for i, v_ in enumerate(str(key))]) % size
def hash_2(key, size):
    return sum([i * 256 + ord(v_) + i for i, v_ in enumerate(str(key))]) % size
if __name__ in '__main__':
    TABLE = HashTable()
    for k in range(10):
        print('add key', k, 'value', k * 10)
        TABLE.add(k, k * 10)
    print('\nhashtable:', TABLE, '\n')
    print('keys', TABLE.keys)
    print('values', TABLE.values, '\n')
    for k in range(10):
        print('remove key', k)
        TABLE.remove(k)
    print('\nhashtable:', TABLE, '\n')
    print('keys', TABLE.keys)
    print('values', TABLE.values, '\n')",0,0,0,0,0,1,0,0,1
36,"package com.jamierf.persistenthashmap;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.Iterator;
import java.util.Map;
class EntryIterator<K extends Serializable, V extends Serializable> implements Iterator<Map.Entry<K, V>> {
	private PersistentHashMap<K, V> map;
	private Iterator<K> iterator;
	private K current;
	public EntryIterator(PersistentHashMap<K, V> map) {
		this.map = map;
		iterator = new KeyIterator<K, V>(map);
		current = null;
	}
	public boolean hasNext() {
		return iterator.hasNext();
	}
	public Map.Entry<K, V> next() {
		current = iterator.next();
		return new AbstractMap.SimpleEntry<K, V>(current, map.get(current));
	}
	public void remove() {
		if (current != null)
			map.remove(current);
	}
}",0,0,0,0,0,0,0,0,0
37,"package com.jamierf.persistenthashmap;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
class EntrySet<K extends Serializable, V extends Serializable> extends AbstractSet<Map.Entry<K, V>> {
	private PersistentHashMap<K, V> map;
	public EntrySet(PersistentHashMap<K, V> map) {
		this.map = map;
	}
	@Override
	public Iterator<Map.Entry<K, V>> iterator() {
		return new EntryIterator<K, V>(map);
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public boolean contains(Object o) {
		if (!(o instanceof Map.Entry))
			return false;
		Map.Entry<K, V> e = (Map.Entry<K, V>) o;
		V value = map.get(e.getKey());
		return value != null && value.equals(e.getValue());
	}
	@Override
	public int size() {
		return map.size();
	}
	@Override
	public void clear() {
		map.clear();
	}
	@Override
	public boolean add(Map.Entry<K, V> e) {
		map.put(e.getKey(), e.getValue());
		return true;
	}
	@Override
	public boolean addAll(Collection<? extends Map.Entry<K, V>> c) {
		for (Map.Entry<K, V> e : c)
			map.put(e.getKey(), e.getValue());
		return true;
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public boolean containsAll(Collection<?> c) {
		Collection<Map.Entry<K, V>> ec = (Collection<Map.Entry<K, V>>) c;
		for (Map.Entry<K, V> e : ec)
			if (!contains(e))
				return false;
		return true;
	}
	@Override
	public boolean isEmpty() {
		return map.isEmpty();
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public boolean remove(Object o) {
		if (!(o instanceof Map.Entry))
			return false;
		Map.Entry<K, V> e = (Map.Entry<K, V>) o;
		if (!contains(e))
			return false;
		map.remove(e.getKey());
		return true;
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public boolean removeAll(Collection<?> c) {
		Collection<Map.Entry<K, V>> ec = (Collection<Map.Entry<K, V>>) c;
		for (Map.Entry<K, V> e : ec)
			remove(e);
		return true;
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public boolean retainAll(Collection<?> c) {
		Collection<Map.Entry<K, V>> ec = (Collection<Map.Entry<K, V>>) c;
		Iterator<Map.Entry<K, V>> iterator = iterator();
		Map.Entry<K, V> entry = null;
		while (iterator.hasNext()) {
			entry = iterator.next();
			if (!ec.contains(entry))
				remove(entry);
		}
		return true;
	}
}",0,0,0,0,0,0,0,0,0
38,"function firstRecurringNumber(input) {
  const map = {};
  for (let i = 0; i < input.length; i++) {
    if (map[input[i]] !== undefined) {
      return input[i];
    }
    map[input[i]] = i;
  }
  return undefined;
}
console.log(firstRecurringNumber([2, 5, 6, 7, 2, 3, 4, 5]));
console.log(firstRecurringNumber([2, 5, 5, 7, 2, 3, 4, 5]));
console.log(firstRecurringNumber([2, 5, 7, 9, 3, 4, 8]));
console.log(firstRecurringNumber([]));",0,0,0,0,0,0,0,0,0
39,"public class FixedSizedHashMap<ValueObject> {
	public static final Object DEFAULT_NOT_FOUND = null;
	public static final double DEFAULT_FILL_FRACTION = 0.4;  
	protected final int arraySize;
	protected final String[] keyArray;
	protected final ValueObject[] valueArray;
	protected Object notFoundValue = null;
	protected final int hitOffset;
	public FixedSizedHashMap(int count, double fill, Object defaultNotFound){
		if(fill <= 0.0 || fill > 0.8){
			throw new IllegalArgumentException(""Fill fraction is out of allowed range"");
		}
		int size = Math.max((int) (count/fill), 11);
		size = size + (size + 1) % 2;
		arraySize = size;
		keyArray = new String[size];
		valueArray = (ValueObject[]) new Object[size];
		for(int i =0; i<size; i++){
			valueArray[i] = null;
		}
		hitOffset = arraySize / 2;
		notFoundValue = defaultNotFound;
	}
	public FixedSizedHashMap(int count, ValueObject miss){
		this(count, DEFAULT_FILL_FRACTION, miss);
	}
	public FixedSizedHashMap(int count){
		this(count,DEFAULT_FILL_FRACTION, DEFAULT_NOT_FOUND);
	}
	private final int slotStep(int slot){
		return (slot + hitOffset) % arraySize;
	}
	private final int findFreeSlot(int slot){
		while(keyArray[slot] != null)
		{
			slot = slotStep(slot);
		}
		return slot;
	}
	private int regularFind(String key){
		int slot = regularSlot(key);
		while(keyArray[slot]!=null)
		{
			if(keyArray[slot].equals(key)){
				return slot;
			}
			else{
				slot = slotStep(slot);
			}
		}
		return -slot-1;
	}
	private final int regularSlot(String key){
		return (key.hashCode() & Integer.MAX_VALUE) % arraySize;
	}
	public boolean set(String key, ValueObject value)
	{
		if(key == null || value == null){
			return false;
		}
		else{
			int offset  = regularFind(key);
			if (offset >- 0){
				valueArray[offset] = value;
				return true;
			}
			else{  
				offset = -offset - 1;
				keyArray[offset] = key;
				valueArray[offset] = value;
				return true;
			}
		}
	}
	public final boolean containsKey(String key){
		return regularFind(key) >= 0;
	}
	public final ValueObject get(String key){
		int slot = regularFind(key);
		if(slot>=0){
			return valueArray[slot];
		}
		else{
			return (ValueObject) notFoundValue;
		}
	}
	public boolean delete(String key){
		int slot = regularFind(key);
		if(slot >= 0){
			valueArray[slot] = (ValueObject) notFoundValue;
			keyArray[slot] = null;
			return true;
		}
		else{
			return false;
		}
	}
	public float load(){
		return keyArray.length / arraySize;
	} 
	public static void main(String args[]){  
		FixedSizedHashMap<String> hm = new FixedSizedHashMap<>(5);
		hm.set(""a"", ""Armageddon"");
		hm.set(""b"", ""bail"");
		hm.set(""c"", ""Class"");
		hm.set(""d"", ""Github"");
		hm.set(""l"", ""Rules."");
		System.out.println(hm.get(""d"") + hm.get(""l""));
		hm.delete(""b"");
		System.out.println(hm.get(""b""));
	}
}",0,0,0,0,0,1,0,0,1
40,"export default function Hash(key: string, mapLength: number = 50): number {
  return hashCode(key) % mapLength;
}
function hashCode(string: string): number {
  let hash = 5381;
  let index = string.length;
  while (index) {
    hash = (hash * 33) ^ string.charCodeAt(--index);
  }
  return hash >>> 0;
}",0,0,0,0,0,0,0,0,0
41,"class HashTable(object):
    def __init__(self, size=5):
        self.size = size
        self.length = 0
        self.keys = [LinkedList() for _ in range(self.size)]
    def add(self, key, value):
        hash_value = hash_function(key, self.size)
        linkedlist = self.keys[hash_value]
        node = linkedlist.search(key)
        if node is None:
            linkedlist.add(key, value)
            self.length += 1
        else:
            node.value = value
    def get(self, key, default=None):
        hash_value = hash_function(key, self.size)
        linkedlist = self.keys[hash_value]
        node = linkedlist.search(key)
        return node.value if node is not None else default
    def remove(self, key):
        hash_value = hash_function(key, self.size)
        linkedlist = self.keys[hash_value]
        node = linkedlist.remove(key)
        if node is None:
            return None
        self.length -= 1
        return node.value
    def __len__(self):
        return self.length
    def __str__(self):
        string = ''
        for item in self.keys:
            node = item.head
            while node is not None:
                string += str(node) + ', '
                node = node.child
        return '{' + string[:-2] + '}'
class Node(object):
    def __init__(self, key, value, child=None):
        self.key = key
        self.value = value
        self.child = child
    def __str__(self):
        key = self.key
        if isinstance(self.key, str):
            key = ""'{}'"".format(self.key)
        value = self.value
        if isinstance(self.value, str):
            value = ""'{}'"".format(self.value)
        return str(key) + ': ' + str(value)
class LinkedList(object):
    def __init__(self):
        self.head = None
    def add(self, key, value):
        node = Node(key, value, child=self.head)
        self.head = node
    def search(self, key):
        current = self.head
        while current is not None:
            if current.key == key:
                return current
            current = current.child
        return None
    def remove(self, key):
        current = self.head
        previous = None
        while current is not None and current.key != key:
            previous = current
            current = current.child
        if previous is None:
            self.head = current.child
        elif current is not None:
            previous.child = current.child
        return current
    def __str__(self):
        string = ''
        current = self.head
        while current is not None and current.child is not None:
            string += str(current) + ' -> '
            current = current.child
        string += str(current) + ' -> ' + str(None)
        return string
def hash_function(key, size):
    return sum([i * 256 + ord(v_) for i, v_ in enumerate(str(key))]) % size
if __name__ in '__main__':
    ht = HashTable()
    DATA = {'hello 0123': 0, '1': '1', 1: 1, 0: -1, 4: 4}
    for k, v in DATA.items():
        ht.add(k, v)
        print('add key', k, 'value', v, 'length', len(ht))
    print('\nhashtable:', ht, '\n')
    print('add key \'hello 0123\'', 'value', -10, 'length', len(ht))
    ht.add('hello 0123', -10)
    print('\nhashtable:', ht, '\n')
    for k in [4, '1', 100]:
        ht.remove(k)
        print('remove key', k, 'length', len(ht))
    print('\nhashtable:', ht, '\n')
    for k in [4, 0, 'hello 0123']:
        print('get value by key', k, 'value:', ht.get(k))",0,0,0,0,0,0,0,0,1
42,"from number_theory.prime_numbers import next_prime
class HashTable:
    def __init__(self, size_table, charge_factor=None, lim_charge=None):
        self.size_table = size_table
        self.values = [None] * self.size_table
        self.lim_charge = 0.75 if lim_charge is None else lim_charge
        self.charge_factor = 1 if charge_factor is None else charge_factor
        self.__aux_list = []
        self._keys = {}
    def keys(self):
        return self._keys
    def balanced_factor(self):
        return sum([1 for slot in self.values
                    if slot is not None]) / (self.size_table * self.charge_factor)
    def hash_function(self, key):
        return key % self.size_table
    def _step_by_step(self, step_ord):
        print(""step {0}"".format(step_ord))
        print([i for i in range(len(self.values))])
        print(self.values)
    def bulk_insert(self, values):
        i = 1
        self.__aux_list = values
        for value in values:
            self.insert_data(value)
            self._step_by_step(i)
            i += 1
    def _set_value(self, key, data):
        self.values[key] = data
        self._keys[key] = data
    def _colision_resolution(self, key, data=None):
        new_key = self.hash_function(key + 1)
        while self.values[new_key] is not None                and self.values[new_key] != key:
            if self.values.count(None) > 0:
                new_key = self.hash_function(new_key + 1)
            else:
                new_key = None
                break
        return new_key
    def rehashing(self):
        survivor_values = [value for value in self.values if value is not None]
        self.size_table = next_prime(self.size_table, factor=2)
        self._keys.clear()
        self.values = [None] * self.size_table 
        map(self.insert_data, survivor_values)
    def insert_data(self, data):
        key = self.hash_function(data)
        if self.values[key] is None:
            self._set_value(key, data)
        elif self.values[key] == data:
            pass
        else:
            colision_resolution = self._colision_resolution(key, data)
            if colision_resolution is not None:
                self._set_value(colision_resolution, data)
            else:
                self.rehashing()
                self.insert_data(data)",0,0,0,0,0,0,0,0,1
43,"from .hash_table import HashTable
from collections import deque
class HashTableWithLinkedList(HashTable):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    def _set_value(self, key, data):
        self.values[key] = deque([]) if self.values[key] is None else self.values[key]  
        self.values[key].appendleft(data)
        self._keys[key] = self.values[key]
    def balanced_factor(self):
        return sum([self.charge_factor - len(slot) for slot in self.values])               / self.size_table * self.charge_factor
    def _colision_resolution(self, key, data=None):
        if not (len(self.values[key]) == self.charge_factor
                and self.values.count(None) == 0):
            return key
        return super()._colision_resolution(key, data)",0,0,0,0,0,0,0,0,0
44,"package com.deepak.data.structures.Hashing;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
public class HashCodeAndEquals {
	public static void main(String[] args) {
		Map<Employee, String> cache = loadEmployeeCache();
		Employee lookUpKey = new Employee(""101"", ""10111992"");
		String empName = cache.get(lookUpKey);
		System.out.println(empName);
		Set<Employee> employeeSet = new HashSet<>();
		Employee e1 = new Employee(""100"", ""10111990"");
		Employee e2 = new Employee(""101"", ""10111992"");
		Employee e3 = new Employee(""101"", ""10111992"");
		Employee e4 = new Employee(""102"", ""10111991"");
		Employee e5 = new Employee(""102"", ""10111991"");
		employeeSet.add(e1);
		employeeSet.add(e2);
		employeeSet.add(e3);
		employeeSet.add(e4);
		employeeSet.add(e5);
		System.out.println(employeeSet);
	}
	static Map<Employee, String> loadEmployeeCache() {
		Employee e1 = new Employee(""100"", ""10111991"");
		Employee e2 = new Employee(""101"", ""10111992"");
		Employee e3 = new Employee(""102"", ""10111993"");
		Map<Employee, String> cacheMap = new HashMap<>();
		cacheMap.put(e1, ""Alice"");
		cacheMap.put(e2, ""Bob"");
		cacheMap.put(e3, ""Steve"");
		return cacheMap;
	}
}
class Employee {
	String empId;
	String empDob;
	public Employee(String id, String dob) {
		empId = id;
		empDob = dob;
	}
	@Override
	public int hashCode() {
		int result = empId != null ? empId.hashCode() : 0;
		result = 31 * result + (empDob != null ? empDob.hashCode() : 0);
		return result;
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Employee employee = (Employee) o;
		if (empDob != null ? !empDob.equals(employee.empDob) : employee.empDob != null) return false;
		if (empId != null ? !empId.equals(employee.empId) : employee.empId != null) return false;
		return true;
	}
	@Override
	public String toString() {
		return ""Employee [empId="" + empId + "", empDob="" + empDob + ""]"";
	}
}",0,0,0,0,0,0,0,0,0
45,"package org.joyfulmonster.util.concurrent.internal;
import java.util.Map;
class HashEntry<K,V> implements Map.Entry<K, V> {
    private final K key;
    private final V value;
    private transient final int keyHashCode;
    HashEntry(K key, V value, int keyHashCode) {
        this.key = key;
        this.value = value;
        this.keyHashCode = keyHashCode;
    }
    private HashEntry(K key, V value) {
        this(key, value, HashStrategy.getInstance().hash(key.hashCode()));
    }
    private HashEntry(Map.Entry<? extends K, ? extends V> entry) {
        this(entry.getKey(), entry.getValue());
    }
    @Override
    public K getKey() {
        return key;
    }
    @Override
    public V getValue() {
        return value;
    }
    @SuppressWarnings(""rawtypes"")
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Map.Entry) {
            Map.Entry e = (Map.Entry) obj;
            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());
        } else {
            return false;
        }
    }
    @Override
    public int hashCode() {
        return key.hashCode() ^ value.hashCode();
    }
    int getKeyHashCode() {
        return keyHashCode;
    }
    @Override
    public V setValue(V value) {
        throw new UnsupportedOperationException();
    }
    @Override
    public String toString() {
        return key + ""="" + value;
    }
}",0,0,0,0,0,0,0,0,0
46,"@SuppressWarnings(""ALL"")
interface HashFunction {
  int size ();
  int compute (Object key);
}",0,0,0,0,0,0,0,0,0
47,"package com.contactsunny.poc.HashMapImplementation.hashMap;
import com.contactsunny.poc.HashMapImplementation.exceptions.InvalidIndexException;
public class HashMap<K, V> {
    private static final int ARRAY_SIZE = 16;
    private Node<K, V>[] nodeList = new Node[ARRAY_SIZE];
    public void put(K key, V value) throws InvalidIndexException {
        long hashCode = this.getHashCode(key);
        int index = this.getIndex(hashCode);
        if (index > ARRAY_SIZE) {
            throw new InvalidIndexException(""Invalid key, please check again!"");
        }
        if (this.nodeList[index] != null) {
            Node<K, V> exitingNode = this.nodeList[index];
            while (exitingNode.getNext() != null) {
                exitingNode = exitingNode.getNext();
            }
            Node<K, V> newNode = new Node<>();
            newNode.setKey(key);
            newNode.setValue(value);
            newNode.setHashCode(hashCode);
            exitingNode.setNext(newNode);
        } else {
            Node<K, V> newNode = new Node<>();
            newNode.setKey(key);
            newNode.setValue(value);
            newNode.setHashCode(hashCode);
            this.nodeList[index] = newNode;
        }
    }
    private long getHashCode(K key) {
        String keyString = key.toString();
        return keyString.hashCode();
    }
    private int getIndex(long hashCode) {
        return Math.toIntExact(hashCode % ARRAY_SIZE);
    }
    public void printHashMap() {
        System.out.println(""=============================================="");
        System.out.println(""Printing map:"");
        int index = 0;
        while (index < ARRAY_SIZE) {
            Node<K, V> node = this.nodeList[index];
            if (node != null) {
                int listIndex = 0;
                while (node != null) {
                    if (listIndex > 0) {
                        System.out.print("" || "");
                    }
                    System.out.print(node.getKey().toString() + "" -> "");
                    System.out.print(node.getValue().toString());
                    node = node.getNext();
                    listIndex++;
                }
                System.out.println("""");
            }
            index++;
        }
        System.out.println(""=============================================="");
    }
}",0,0,0,0,0,0,0,0,1
48,"import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
public class HashMap<K, V> implements HashMapInterface<K, V> {
    private MapEntry<K, V>[] table;
    private int size;
    public HashMap() {
        clear();
    }
    @Override
    public V add(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(""Argument cannot be null."");
        }
        if (this.getNextLoadFactor() > MAX_LOAD_FACTOR) {
            resize();
        }
        int index = this.getAddIndex(key);
        MapEntry<K, V> entry = this.table[index];
        V result = null;
        if (entry == null) {
            this.table[index] = new MapEntry<K, V>(key, value);
        } else if (entry.getKey().equals(key)) {
            if (!entry.isRemoved()) {
                result = entry.getValue();
            }
            entry.setValue(value);
            entry.setRemoved(false);
        } else {
            entry.setKey(key);
            entry.setValue(value);
            entry.setRemoved(false);
        }
        if (result == null) {
            size++;
        }
        return result;
    }
    @Override
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Argument cannot be null."");
        }
        int index = this.getAddIndex(key);
        MapEntry<K, V> entry = this.table[index];
        if (entry != null && entry.getKey().equals(key) && !entry.isRemoved()) {
            entry.setRemoved(true);
            size--;
            return entry.getValue();
        }
        return null;
    }
    @Override
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Argument cannot be null."");
        }
        int index = this.getAddIndex(key);
        MapEntry<K, V> entry = this.table[index];
        return (entry != null && !entry.isRemoved()
                && entry.getKey().equals(key) ? entry.getValue() : null);
    }
    @Override
    public boolean contains(K key) {
        return get(key) != null;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public void clear() {
        this.table = (MapEntry<K, V>[]) new MapEntry[STARTING_SIZE];
        this.size = 0;
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public Set<K> keySet() {
        HashSet<K> result = new HashSet<K>(size);
        for (int i = 0; i < this.table.length; i++) {
            MapEntry<K, V> entry = this.table[i];
            if (entry != null && !entry.isRemoved()) {
                result.add(entry.getKey());
            }
        }
        return result;
    }
    @Override
    public List<V> values() {
        ArrayList<V> result = new ArrayList<V>(size);
        for (int i = 0; i < this.table.length; i++) {
            MapEntry<K, V> entry = this.table[i];
            if (entry != null && !entry.isRemoved()) {
                result.add(entry.getValue());
            }
        }
        return result;
    }
    private double getNextLoadFactor() {
        return (double) (size + 1) / (double) this.table.length;
    }
    @SuppressWarnings(""unchecked"")
    private void resize() {
        MapEntry<K, V>[] temp = this.table;
        this.table = (MapEntry<K, V>[]) new MapEntry[temp.length * 2];
        this.size = 0;
        for (int i = 0; i < temp.length; i++) {
            MapEntry<K, V> entry = temp[i];
            if (entry != null && !entry.isRemoved()) {
                this.add(entry.getKey(), entry.getValue());
            }
        }
    }
    private int getAddIndex(K key) {
        int index = Math.abs(key.hashCode()) % this.table.length;
        MapEntry<K, V> curEntry = this.table[index];
        int firstRemoved = -1;
        int curIndex = index;
        boolean looped = false;
        while (curEntry != null && !curEntry.getKey().equals(key)
                && (!looped || curIndex != index)) {
            if (firstRemoved == -1 && curEntry.isRemoved()) {
                firstRemoved = index;
            }
            if (++curIndex >= this.table.length) {
                curIndex = 0;
                looped = true;
            }
            curEntry = this.table[curIndex];
        }
        if (curEntry != null && curEntry.getKey().equals(key)) {
            return curIndex;
        } else {
            return (firstRemoved == -1 ? curIndex : firstRemoved);
        }
    }
}",0,0,0,0,0,0,0,0,1
49,"package com.kevinbohinski.algs;
import java.util.Arrays;
public class HashMap<K, V> {
	private final static int DEFAULT_CAPACITY = 101;
	private int size;
	private int numEntries;
	private HashMapEntry<K, V> entries[];
	public HashMap(int size) {
		this.size = size;
		entries = new HashMapEntry[size];
		numEntries = 0;
	}
	public HashMap() {
		size = DEFAULT_CAPACITY;
		entries = new HashMapEntry[size];
		numEntries = 0;
	}
	private int getHash(K key) {
		return (key.hashCode() & 0x7fffffff) % size;
	}
	public boolean set(K key, V value) {
		if (key == null) {
			return false;
		}
		int hc = getHash(key);
		HashMapEntry<K, V> tmp = entries[hc];
		if (tmp != null) {
			if (tmp.getKey().equals(key)) {
				tmp.setValue(value);
				return true;
			} else {
				while (tmp.getNext() != null) {
					tmp = tmp.getNext();
				}
				HashMapEntry<K, V> newEntry = new HashMapEntry<K, V>(
						key, value);
				tmp.setNext(newEntry);
				numEntries++;
				return true;
			}
		} else {
			HashMapEntry<K, V> newEntry = new HashMapEntry<K, V>(key,
					value);
			entries[hc] = newEntry;
			numEntries++;
			return true;
		}
	}
	public V get(K key) {
		if (key == null) {
			return null;
		}
		int hc = getHash(key);
		HashMapEntry<K, V> tmp = entries[hc];
		while (tmp != null) {
			if (tmp.getKey().equals(key)) {
				return tmp.getValue();
			}
			tmp = tmp.getNext();
		}
		return null;
	}
	public V delete(K key) {
		int hc = getHash(key);
		HashMapEntry<K, V> tmp = entries[hc];
		if (tmp != null) {
			HashMapEntry<K, V> prev = null;
			while (tmp != null) {
				if (tmp.getKey().equals(key)) {
					if (prev == null) {
						V val = (V) entries[hc].getValue();
						entries[hc] = entries[hc].getNext();
						numEntries--;
						return val;
					} else {
						prev.setNext(tmp.getNext());
						numEntries--;
						return prev.getNext().getValue();
					}
				}
				prev = tmp;
				tmp = tmp.getNext();
			}
			return null;
		}
		return null;
	}
	public float load() {
		return ((float) numEntries / size);
	}
	@Override
	public String toString() {
		return ""HashMap [size="" + size + "", numEntries="" + numEntries
				+ "", entries="" + Arrays.toString(entries) + ""]"";
	}
}",0,0,0,0,0,1,0,0,1
50,"import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.LinkedList;
public class HashMap<K, V> implements HashMapInterface<K, V> {
    private LinkedList<MapEntry<K, V>>[] backingTable;
    private int size;
    public HashMap() {
        backingTable = new LinkedList[INITIAL_CAPACITY];
        size = 0;
    }
    public HashMap(int initialCapacity) {
        backingTable = new LinkedList[initialCapacity];
        size = 0;
    }
    @Override
    public V put(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(""Input data cannot be null."");
        }
        if ((double) (size + 1) / backingTable.length > MAX_LOAD_FACTOR) {
            resizeBackingTable(backingTable.length * 2 + 1);
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        if (backingTable[index] == null) {
            backingTable[index] = new LinkedList<>();
        } else {
            for (MapEntry<K, V> temp : backingTable[index]) {
                if (temp.getKey() == key) {
                    V returnValue = temp.getValue();
                    temp.setValue(value);
                    return returnValue;
                }
            }
        }
        backingTable[index].addFirst(new MapEntry<>(key, value));
        ++size;
        return null;
    }
    @Override
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Input key is null"");
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        MapEntry<K, V> curr;
        if (backingTable[index] != null) {
            Iterator<MapEntry<K, V>> it = backingTable[index].iterator();
            while (it.hasNext()) {
                curr = it.next();
                if (curr.getKey() == key) {
                    V returnValue = curr.getValue();
                    it.remove();
                    --size;
                    return returnValue;
                }
            }
        }
        throw new java.util.NoSuchElementException(""Key does not exist"");
    }
    @Override
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Input key is null"");
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        MapEntry<K, V> curr;
        if (backingTable[index] != null) {
            Iterator<MapEntry<K, V>> it = backingTable[index].iterator();
            while (it.hasNext()) {
                curr = it.next();
                if (curr.getKey() == key) {
                    return curr.getValue();
                }
            }
        }
        throw new java.util.NoSuchElementException(""Key does not exist"");
    }
    @Override
    public boolean containsKey(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Input key is null"");
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        MapEntry<K, V> curr;
        if (backingTable[index] != null) {
            Iterator<MapEntry<K, V>> it = backingTable[index].iterator();
            while (it.hasNext()) {
                curr = it.next();
                if (curr.getKey() == key) {
                    return true;
                }
            }
        }
        return false;
    }
    @Override
    public void clear() {
        backingTable = new LinkedList[INITIAL_CAPACITY];
        size = 0;
    }
    @Override
    public int size() {
        return size;
    }
    @Override
    public Set<K> keySet() {
        Set<K> returnSet = new HashSet<>();
        for (int i = 0; i < backingTable.length; ++i) {
            if (backingTable[i] != null) {
                for (MapEntry<K, V> temp : backingTable[i]) {
                    returnSet.add(temp.getKey());
                }
            }
        }
        return returnSet;
    }
    @Override
    public List<V> values() {
        List<V> returnList = new ArrayList<>();
        for (int i = 0; i < backingTable.length; ++i) {
            if (backingTable[i] != null) {
                for (MapEntry<K, V> temp : backingTable[i]) {
                    returnList.add(temp.getValue());
                }
            }
        }
        return returnList;
    }
    @Override
    public void resizeBackingTable(int length) {
        if (length <= 0) {
            throw new IllegalArgumentException(""Input length cannot be ""
                    + ""negative"");
        }
        LinkedList<MapEntry<K, V>>[] tempTable = new LinkedList[length];
        for (int i = 0; i < backingTable.length; ++i) {
            if (backingTable[i] != null) {
                for (MapEntry<K, V> temp : backingTable[i]) {
                    int index = Math.abs(temp.getKey().hashCode()) % length;
                    if (tempTable[index] == null) {
                        tempTable[index] = new LinkedList<>();
                    }
                    tempTable[index].addFirst(temp);
                }
            }
        }
        backingTable = tempTable;
    }
    @Override
    public LinkedList<MapEntry<K, V>>[] getTable() {
        return backingTable;
    }
}",0,0,0,0,0,1,0,0,1
51,"class HashMap {
	private int hsize;
	private LinkedList[] buckets;
	public HashMap(int hsize) {
		buckets = new LinkedList[hsize];
		for (int i = 0; i < hsize ; i++ ) {
			buckets[i] = new LinkedList();
		}
		this.hsize = hsize;
	}
	public int hashing(int key) {
		int hash = key % hsize;
		if(hash < 0)
			hash += hsize;
		return hash;
	}
	public void insertHash(int key) {
		int hash = hashing(key);
		buckets[hash].insert(key);
	}
	public void deleteHash(int key) {
		int hash = hashing(key);
		buckets[hash].delete(key);
	}
	public void displayHashtable() {
		for (int i = 0;i < hsize ; i++) {
			System.out.printf(""Bucket %d :"",i);
			buckets[i].display();
		}
	}
}",0,0,0,0,0,0,0,0,0
52,"<<<<<<< HEAD:Data Structures/HashMap/HashMap.java
import java.util.ArrayList;
import java.util.LinkedList;
public class HashMap<K,V> {
	public class hmnodes{  
		K key;
		V value;
	}
	private int size=0;  
	private LinkedList<hmnodes> buckets[];   
	public HashMap(){
		buckets=new LinkedList[4];  
		for(int i=0;i<4;i++)
			buckets[i]=new LinkedList<>(); 
	}
	public void put(K key,V value) throws Exception{
		int bi=bucketIndex(key);  
		int fountAt=find(bi,key);  
		if(fountAt==-1){
			hmnodes temp=new hmnodes();  
			temp.key=key;
			temp.value=value;
			buckets[bi].addLast(temp);
			this.size++;
		}else{
			buckets[bi].get(fountAt).value=value; 
		}
		double lambda = (this.size*1.0)/this.buckets.length;
		if(lambda>2.0){
			rehash();   
		}
		return;
	}
	public V get(K key) throws Exception{
		int bi=bucketIndex(key);
		int fountAt=find(bi,key);
		if(fountAt==-1){
			return null;
		}else{
			return buckets[bi].get(fountAt).value;
		}
	}
	public V remove(K key) throws Exception{
		int bi=bucketIndex(key);
		int fountAt=find(bi,key);
		if(fountAt==-1){
			return null;
		}else{
			this.size--;
			return buckets[bi].remove(fountAt).value;
		}
	}
	public boolean containskey(K key) throws Exception{
		int bi=bucketIndex(key);
		int fountAt=find(bi,key);
		if(fountAt==-1){
			return false;
		}else{
			return true;
		}
	}
	public int size(){
		return this.size;
	}
	public boolean isempty(){
		return this.size==0;
	}
	public ArrayList<K> keyset() throws Exception{
		ArrayList<K> arr=new ArrayList<>();
		for(int i=0;i<buckets.length;i++){
			for(int j=0;j<buckets[i].size();j++){
				arr.add(buckets[i].get(j).key);
			}
		}
		return arr;
	}
	public ArrayList<V> valueset() throws Exception{
		ArrayList<V> arr=new ArrayList<>();
		for(int i=0;i<buckets.length;i++){
			for(int j=0;j<buckets[i].size();j++){
				arr.add(buckets[i].get(j).value);
			}
		}
		return arr;
	}
	public void display() throws Exception{
		for(int i=0;i<buckets.length;i++){
			System.out.print(""Bucket: ""+i+"" "");
			for(int j=0;j<buckets[i].size();j++){
				hmnodes temp=buckets[i].get(j);
				System.out.print(""[""+temp.key+""->""+temp.value+""]"");
			}
			System.out.println();
		}
	}
	public int find(int bi,K key) throws Exception{
		for(int i=0;i<buckets[bi].size();i++){
			if(key.equals(buckets[bi].get(i).key))
				return i;
		}
		return -1;
	}
	public int bucketIndex(K key) throws Exception{
		int bi=key.hashCode();
		return Math.abs(bi%buckets.length);
	}
	private void rehash() throws Exception{
		LinkedList<hmnodes> ob[]= buckets;
		buckets=new LinkedList[ob.length*2];
		for(int i=0;i<ob.length*2;i++)
			buckets[i]=new LinkedList<>();
		size = 0;
		for(int i=0;i<ob.length;i++){
			for(int j=0;j<ob[i].size();j++){
				put(ob[i].get(j).key,ob[i].get(j).value);
			}
		}
	}
}
=======
import java.util.ArrayList;
import java.util.LinkedList;
public class HashMap<K,V> {
	public class hmnodes{  
		K key;
		V value;
	}
	private int size=0;  
	private LinkedList<hmnodes> buckets[];   
	public HashMap(){
		buckets=new LinkedList[4];  
		for(int i=0;i<4;i++)
			buckets[i]=new LinkedList<>(); 
	}
	public void put(K key,V value) throws Exception{
		int bi=bucketIndex(key);  
		int fountAt=find(bi,key);  
		if(fountAt==-1){
			hmnodes temp=new hmnodes();  
			temp.key=key;
			temp.value=value;
			buckets[bi].addLast(temp);
			this.size++;
		}else{
			buckets[bi].get(fountAt).value=value; 
		}
		double lambda = (this.size*1.0)/this.buckets.length;
		if(lambda>2.0){
			rehash();   
		}
		return;
	}
	public V get(K key) throws Exception{
		int bi=bucketIndex(key);
		int fountAt=find(bi,key);
		if(fountAt==-1){
			return null;
		}else{
			return buckets[bi].get(fountAt).value;
		}
	}
	public V remove(K key) throws Exception{
		int bi=bucketIndex(key);
		int fountAt=find(bi,key);
		if(fountAt==-1){
			return null;
		}else{
			this.size--;
			return buckets[bi].remove(fountAt).value;
		}
	}
	public boolean containskey(K key) throws Exception{
		int bi=bucketIndex(key);
		int fountAt=find(bi,key);
		if(fountAt==-1){
			return false;
		}else{
			return true;
		}
	}
	public int size(){
		return this.size;
	}
	public boolean isempty(){
		return this.size==0;
	}
	public ArrayList<K> keyset() throws Exception{
		ArrayList<K> arr=new ArrayList<>();
		for(int i=0;i<buckets.length;i++){
			for(int j=0;j<buckets[i].size();j++){
				arr.add(buckets[i].get(j).key);
			}
		}
		return arr;
	}
	public ArrayList<V> valueset() throws Exception{
		ArrayList<V> arr=new ArrayList<>();
		for(int i=0;i<buckets.length;i++){
			for(int j=0;j<buckets[i].size();j++){
				arr.add(buckets[i].get(j).value);
			}
		}
		return arr;
	}
	public void display() throws Exception{
		for(int i=0;i<buckets.length;i++){
			System.out.print(""Bucket: ""+i+"" "");
			for(int j=0;j<buckets[i].size();j++){
				hmnodes temp=buckets[i].get(j);
				System.out.print(""[""+temp.key+""->""+temp.value+""]"");
			}
			System.out.println();
		}
	}
	public int find(int bi,K key) throws Exception{
		for(int i=0;i<buckets[bi].size();i++){
			if(key.equals(buckets[bi].get(i).key))
				return i;
		}
		return -1;
	}
	public int bucketIndex(K key) throws Exception{
		int bi=key.hashCode();
		return Math.abs(bi%buckets.length);
	}
	private void rehash() throws Exception{
		LinkedList<hmnodes> ob[]= buckets;
		buckets=new LinkedList[ob.length*2];
		for(int i=0;i<ob.length*2;i++)
			buckets[i]=new LinkedList<>();
		size = 0;
		for(int i=0;i<ob.length;i++){
			for(int j=0;j<ob[i].size();j++){
				put(ob[i].get(j).key,ob[i].get(j).value);
			}
		}
	}
}
>>>>>>> 7e3a8c55c865471a33f6932a022a1059c5243fc3:data_structures/HashMap/HashMap.java",0,0,0,0,0,1,0,0,1
53,"import java.util.*;
public class HashMap<K,V>{
	static final int DEFAULT_CPAPCITY = 1 << 2;
	HashEntry<K,V>[] table;
	int size;
	int capacity;
	public HashMap() {
		capacity = DEFAULT_CPAPCITY;
	}
	public HashMap(int cap) {
		this.capacity = cap;
	}
	class HashEntry<K, V> {
		final int hash;
		final K key;
		V value;
		HashEntry<K,V> next;
		HashEntry(int hash, K key, V value, HashEntry<K,V> next) {
			this.hash = hash;
			this.key = key;
			this.value = value;
			this.next = next;
		}
		public K getKey() {
			return key;
		}
		public V getValue() {
			return value;
		}
		public final String toString() { return key + ""="" + value; }
		public final int hashCode() {
			return Objects.hashCode(key) ^ Objects.hashCode(value);
		}
	}
	static final int hash(Object key) {
		return (key == null) ? 0 : key.hashCode();
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0;
	}
	@SuppressWarnings(""unchecked"")
	public V put(K key, V value) {
		HashEntry<K, V> oldNode;  int hash = hash(key);
		if (table == null || table.length == 0) {
			table = (HashEntry<K, V>[]) new HashEntry[capacity];
		}
		int len = table.length;
		int index = (len - 1) & hash;
		if (table[index] == null) {
			table[index] = new HashEntry<K,V>(hash, key, value, null);
		} else {
			HashEntry<K, V> curNode;
			oldNode = table[index];
			if (oldNode.hash == hash && 
					oldNode.key == key || (key != null && oldNode.key.equals(key))){
				curNode = oldNode;
			} else {
				for (int count = 0; ; count++) {
					System.out.println(""LinkedList: Not "" + oldNode.key);
					curNode = oldNode.next;
					if (oldNode.next == null) {
						oldNode.next = new HashEntry(hash, key, value, null);
						break;
					}
					if (curNode.hash == hash &&
							(curNode.key == key || (key != null && curNode.key.equals(key)))) {
						break;
					}
					oldNode = curNode;
				}
			}
			if (curNode != null) {
				V oldValue = curNode.value;
				curNode.value = value;
				return oldValue;
			}
		}
		size++;
		return null;
	}
	public V get(Object key) {
		int hash = hash(key);
		int len = table.length;
		if (table != null && table.length > 0 && table[hash & (len - 1)] != null) {
			HashEntry<K, V> firstNode = table[hash & (len - 1)];
			if (firstNode.hash == hash && 
					firstNode.key == key || (key != null && firstNode.key.equals(key))) {
				return firstNode.value;
			}
			HashEntry<K, V> curNode = firstNode.next;
			if (firstNode.next != null) {
				do {
					if (curNode.hash == hash &&
							curNode.key == key || (curNode.key != null && curNode.key.equals(key))) {
						return curNode.value;
					} 
				}while ((curNode = curNode.next) != null);
			}
		}
		return null;
	}
	public boolean containsKey(Object key) {
		return get(key) != null;
	}
	public V remove(Object key) {
		int hash = hash(key);
		int len = table.length;
		int index = hash & (len - 1);
		if (table != null && table.length > 0 && table[index] != null) {
			HashEntry<K, V> prevNode = table[index];
			HashEntry<K, V> curNode = null; HashEntry<K, V> nodeRemoved = null;
			if (prevNode.hash == hash && 
					prevNode.key == key || (key != null && prevNode.key.equals(key))) {
				nodeRemoved = prevNode;
			}
			curNode = prevNode.next;
			if (prevNode.next != null) {
				do {
					if (curNode.hash == hash && 
							curNode.key == key || (key != null && curNode.key.equals(key))) {
						nodeRemoved = curNode;
						break;
					}
					prevNode = curNode;
				} while ((curNode = curNode.next) != null);
			}
			if (nodeRemoved != null) {
				if (nodeRemoved == prevNode) {
					table[index] = nodeRemoved.next;
				} else {
					prevNode.next = nodeRemoved.next;
				}
				size--;
				return nodeRemoved.value;
			}
		}
		return null;
	}
}",0,0,0,0,0,1,0,0,1
54,"import java.util.*;
public class HashMap
{
   private int size;
   private int initializedSize;
   private int itemsInHashMap;
   private LinkedList<Object[]>[] map;
   public HashMap(){}
   public HashMap(int size)
   {
      this.initializedSize = size;
      this.size = size*4/3;  
      itemsInHashMap = 0;
      map = new LinkedList[this.size];
   }
   public float load()
   {
      return (float) itemsInHashMap / size;
   }
   public boolean set(String key, Object value)
   {
      int bucket = Math.abs(key.hashCode() % size);
      if(map[bucket] == null)
      {
         if(itemsInHashMap >= initializedSize)  
            return false; 
         LinkedList valueList = new LinkedList();
         Object[] valuePair = {key, value};
         valueList.add(valuePair);
         map[bucket] = valueList;
      }
      else
      {
         LinkedList valueList = map[bucket];       
         Iterator iter = valueList.iterator();
         Object[] newValuePair = {key, value};
         while(iter.hasNext())
         {
            Object[] temp = (Object[]) iter.next();
            if(temp[0] == key)  
            {
               iter.remove(); 
               itemsInHashMap--;
               break;
            }  
         }
         if(itemsInHashMap >= initializedSize)  
            return false; 
         valueList.add(newValuePair);
      }
      itemsInHashMap++;
      return true;   
   }
   public Object get(String key)
   {
      int bucket = Math.abs(key.hashCode() % size);
      if (map[bucket] != null)
      {
         LinkedList valueList = map[bucket];
         Iterator iter = valueList.iterator();
         while(iter.hasNext())
         {
            Object[] temp = (Object[]) iter.next();
            if(temp[0] == key)
               return temp[1];  
         }
      }
      return null;
   }
   public Object delete(String key)
   {
      int bucket = Math.abs(key.hashCode() % size);
      if (map[bucket] != null)
      {
         LinkedList valueList = map[bucket];
         Iterator iter = valueList.iterator();
         while(iter.hasNext())
         {
            Object[] temp = (Object[]) iter.next();
            if(temp[0] == key)
            {
               Object returnValue = temp[1];
               iter.remove();
               itemsInHashMap--;
               return returnValue;
            }
         }
      }
      return null;
   }
}",0,0,0,0,0,1,0,0,1
55,"package com.ks.hashmap;
public interface HashMap<K, V> {
    public int size();
    public float loadFactor();
    public boolean empty();
    public boolean hasKey(final K key);
    public boolean hasValue(final V value);
    public KeyValuePair<K, V>[] table();
    public HashFunction hashFunction();
    public void put(final K key, final V value);
    public void remove(final K key);
    public V get(final K key);
}",0,0,0,0,0,0,0,0,0
56,"""use strict"";
class HashMap {
    constructor() {
        this.buckets = {};
        this.currentSize = 0;
        this.put = this.put.bind(this);
        this.get = this.get.bind(this);
        this.remove = this.remove.bind(this);
        this.size = this.size.bind(this);
        this.clear = this.clear.bind(this);
    }
    put(key, value) {
        let hashCode = key.hashCode();
        let retValue = null;
        if (value == null) {
            throw new Error(""value cannot be null!"");
        }
        let bucket = this.buckets[hashCode];
        if (!bucket) {
            bucket = new Array();
            this.buckets[hashCode] = bucket;
        }
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key.equals(key)) {
                retValue = bucket[i].value;
                bucket[i].value = value;
                return retValue;
            }
        }
        this.currentSize++;
        bucket.push({key: key, value: value});
        return null;
    }
    get(key) {
        let hashCode = key.hashCode();
        let bucket = this.buckets[hashCode];
        if (!bucket) {
            return null;
        }
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key.equals(key)) {
                return bucket[i].value;
            }
        }
        return null;
    }
    remove(key) {
        let hashCode = key.hashCode();
        let retValue = null;
        let bucket = this.buckets[hashCode];
        if (!bucket) {
            return retValue;
        }
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key.equals(key)) {
                retValue = bucket[i].value;
                bucket.splice(i, 1);
                break;
            }
        }
        if (bucket.length == 0) {
            delete this.buckets[hashCode];
        }
        if (retValue != null) {
            this.currentSize--;
        }
        return retValue;
    }
    size() {
        return this.currentSize;
    }
    clear() {
        this.buckets = {};
        this.currentSize = 0;
    }
}
module.exports = HashMap;",0,0,0,0,0,1,0,0,1
57,"class HashMap(object):
 def __init__(self, size,probing='quadratic',verbose=False):
  if probing not in ['linear','quadratic']:
			raise ValueError('probing can only be linear or quadratic not %s'%probing)
  self.size = size
  self.probing = probing
  self.ctr = 1
  self.values = [None] * self.size
  self.keys = [None] * self.size
  self.verbose = verbose
 def reset(self):
  self.ctr = 1
  self.values = [None] * self.size
  self.keys = [None] * self.size
 def hash_index(self,key):
  _hash = key.__hash__()
  _idx = _hash & (self.size - 1) 
  return _idx
 def sanity_check_key(self,key):
  if not isinstance(key,str):
			raise ValueError('Key should be of type string')
 def probe(self,old_idx):
  if self.probing == 'linear':
			new_idx = (old_idx + self.ctr) % self.size
   self.ctr += 1
  if self.probing == 'quadratic':
			new_idx = (old_idx + self.ctr ** 2) % self.size
   self.ctr += 1
  return new_idx
 def set(self,key,value):
  if self.probing == 'quadratic':
			if self.load() > 0.45: 
				if self.verbose:
					print('Overflow!')
    return False
  if self.probing == 'linear':
			if self.load() == 1: 
				if self.verbose:
					print('Overflow!')
    return False
  self.sanity_check_key(key)
  _idx = self.hash_index(key)
  if self.verbose:
			print('for key=%s Hashed_index = %d'%(key,_idx))
  if self.keys[_idx] == None or self.keys[_idx] == key:
			if self.verbose:
				print('set key=%s, value=%s, at _idx=%d'%(key,value,_idx))
   self.keys[_idx] = key
   self.values[_idx] =  value
   return True
  else:
			while(True):
				if self.verbose:
					print('%d already occupied, probing...'%(_idx,))
    _temp_idx = self.probe(_idx)
    if self.verbose:
					print(_temp_idx)
    if self.keys[_temp_idx] == None or self.keys[_temp_idx] == key:
					if self.verbose:
						print('set key=%s, value=%s, at _temp_idx=%d'%(key,value,_temp_idx))
     self.keys[_temp_idx] = key
     self.values[_temp_idx] = value
     self.ctr = 1
     return True
 def get(self,key,return_idx = False):
  if key in self.keys:
			self.sanity_check_key(key)
   _idx = self.hash_index(key)
   if self.verbose:
				print('key=%s, hash_index=%d'%(key,_idx))
   if self.keys[_idx] == key:
				if self.verbose:
					print(""(without probing) key = %s found at %d with value %s""%(key,_idx,self.values[_idx]))
    if return_idx:
					return self.values[_idx],_idx
    else:
					return self.values[_idx]
   else:
				while(True):
					_temp_idx = self.probe(_idx)
     if self.verbose:
						print('key=%s probing %d to %d'%(key,_idx,_temp_idx))
     if self.keys[_temp_idx] == key:
						if  self.verbose:
							print(""(After probing)key = %s found at %d with value %s""%(key,_temp_idx,self.values[_temp_idx]))
      self.ctr = 1
      if return_idx:
							return self.values[_temp_idx],_temp_idx
      else:
							return self.values[_temp_idx]
  else:
			raise KeyError(""could'nt find key! '%s'""%key)
 def delete(self,key):
  _,_idx = self.get(key,return_idx=True)
  self.keys[_idx] = None
  self.values[_idx] = None
 def load(self):
  not_none_values = sum(x is not None for x in self.values)
  return not_none_values / self.size",0,0,0,0,0,0,0,0,1
58,"import java.util.*;
public class HashMapDriver
{
   public static void main(String[] args)
   {
      HashMap h1 = new HashMap(3);
      System.out.println(h1.load());
      System.out.println(h1.set(""Yellow"", ""Banana""));
      System.out.println(h1.load());
      System.out.println(""Yellow - > "" + h1.get(""Yellow""));
      System.out.println(""Yellow - > "" + h1.delete(""Yellow""));
      System.out.println(h1.load());
      System.out.println(h1.set(""Red"", ""Apple""));
      System.out.println(h1.set(""Purple"", ""Grape""));
      System.out.println(h1.set(""Blue"", ""Berry""));
      System.out.println(h1.load());
      System.out.println(h1.set(""Red"", ""Tomato""));
      System.out.println(""Red - > "" + h1.get(""Red""));
      System.out.println(h1.delete(""Red""));
      System.out.println(h1.load());
      System.out.println(h1.delete(""Red""));
      System.out.println(""Red -> "" + h1.get(""Red""));
      System.out.println(h1.set(""Orange"", ""Orange""));
      System.out.println(""Orange - > "" + h1.get(""Orange""));
      HashMap h2 = new HashMap(2);
      System.out.println(h2.load());
      h2.set(""A"",1);
      h2.set(""B"",2);
      System.out.println(h2.load());
      h2.delete(""A"");
      System.out.println(h2.load());
   }
}",0,0,0,0,0,0,0,0,0
59,"package com.kevinbohinski.algs;
public class HashMapEntry<K, V> {
	private K key;
	private V value;
	private HashMapEntry<K, V> next;
	public HashMapEntry(K key, V value) {
		this.key = key;
		this.value = value;
	}
	public K getKey() {
		return key;
	}
	public void setKey(K key) {
		this.key = key;
	}
	public V getValue() {
		return value;
	}
	public void setValue(V value) {
		this.value = value;
	}
	public HashMapEntry<K, V> getNext() {
		return next;
	}
	public void setNext(HashMapEntry<K, V> next) {
		this.next = next;
	}
	@Override
	public String toString() {
		return ""HashMapEntry [key="" + key + "", value="" + value + "", next=""
				+ next.toString() + ""]"";
	}
}",0,0,0,0,0,0,0,0,0
60,"import java.sql.SQLOutput;
import java.util.ArrayList;
class Node<K,V>
{
    int hashcode;
    K Key;
    V Value;
    Node next;
    public Node(K key, V value) {
        Key = key;
        Value = value;
        next=null;
    }
}
public class HashMapImplementation<K,V> {
    static int SIZE=16;
    Node arr[]= new Node[SIZE];
    public void put(K key, V value)
    {
        int hashcode= String.valueOf(key).hashCode()%SIZE;
        Node newNode=new Node(key,value);
        if(arr[hashcode]==null)
        {
            newNode.hashcode=hashcode;
            arr[hashcode]=newNode;
        }
        else {
            Node temp = arr[hashcode];
            if(temp.Key.equals(newNode.Key))
            {
                temp.Value=value;
                return;
            }
            while (temp.next != null) {
                if(temp.Key.equals(newNode.Key))
                {
                    temp.Value=value;
                    return;
                }
                temp = temp.next;
            }
            temp.next = newNode;
        }
    }
    public void get(K key)
    {
        int hashcode= String.valueOf(key).hashCode()%SIZE;
        if(arr[hashcode]==null)
        {
            System.out.println(""Value doesnot exist"");
        }
        else
        {
            Node temp=arr[hashcode];
            while(temp!=null)
            {
                if(temp.Key.equals(key))
                {
                    System.out.println(temp.Value+""----------"");
                    return;
                }
                temp=temp.next;
            }
            System.out.println(""This value doesnot exist"");
        }
    }
    public static void main(String[] args) {
        HashMapImplementation<String,String> hm= new HashMapImplementation<String, String>();
        hm.put(""abac"",""1"");
        hm.put(""abbc"",""2"");
        hm.put(""abac"",""3"");
        hm.get(""abac"");
        hm.get(""wefh"");
    }
}",0,0,0,0,0,1,0,0,1
61,"import java.util.Set;
import java.util.List;
public interface HashMapInterface<K, V> {
    int STARTING_SIZE = 9;
    double MAX_LOAD_FACTOR = 0.67;
    V add(K key, V value);
    V remove(K key);
    V get(K key);
    boolean contains(K key);
    void clear();
    int size();
    Set<K> keySet();
    List<V> values();
    void resizeBackingTable(int length);
    MapEntry<K, V>[] getTable();
}",0,0,0,0,0,0,0,0,0
62,"package cassandratest;
public class HashMapSeparateChaining<Key, Value>
{
	private static final int INIT_BUCKETS_SIZE = 888;
	private int capacity;
	private int chains;  
	private Node[] ht;
	private static class Node
	{
		private Object key;
		private Object val;
		private Node next;
		public Node(Object key, Object val, Node next)
		{
			this.key = key;
			this.val = val;
			this.next = next;
		}
	}
	public HashMapSeparateChaining()
	{
		this(INIT_BUCKETS_SIZE);
	}
	public HashMapSeparateChaining(int chains)
	{
		this.chains = chains;
		ht = new Node[chains];
	}
	private int hash(Key key)
	{
		int hash = 0;
		for (int i = 0; i < key.toString().length(); i++)
		{
			hash = hash + (int) key.toString().charAt(i);
		}
		hash %= INIT_BUCKETS_SIZE;
		return hash;		
	}
	@SuppressWarnings(""unchecked"")
	public Value get(Key key)
	{
		int h = hash(key);
		for (Node x = ht[h]; x != null; x = x.next)
		{
			if (key.equals(x.key)) 
			{
				return (Value) x.val;
			}
		}
		return null;
	}
	public void put(Key key, Value val)
	{
		int h = hash(key);
		for (Node x = ht[h]; x != null; x = x.next)
		{
			if (key.equals(x.key))
			{
				x.val = val;
				return;
			}
		}
		capacity++;
		ht[h] = new Node(key, val, ht[h]);
	}	
}",0,0,0,0,0,1,0,0,1
63,"package hashMapX;
import java.util.HashMap;
import java.util.Stack;
public class HashMapX {
	private HashMap<String,String> map_;
	private Stack<TransactionObj> activeXActions_;
	public HashMapX(){
		map_ = new HashMap<>();
		activeXActions_ = new Stack<>();
	}
	public void parseCommand(String command){
		String[] parsedCommand =  command.split("" "");
		if (parsedCommand[0].compareTo(""SET"")==0 && parsedCommand.length==3){
			if (activeXActions_.isEmpty()){
				if (parsedCommand[2]==null){
					System.out.println(""Cannot set null values"");
					return;
				}
				this.set(parsedCommand[1], parsedCommand[2]);
			}else {
				activeXActions_.peek().addSetCommand(parsedCommand);
			}
			return;
		}
		if (parsedCommand[0].compareTo(""GET"")==0){
			System.out.println(map_.get(parsedCommand[1]));
			return;
		}
		if (parsedCommand[0].compareTo(""UNSET"")==0){
			if (activeXActions_.isEmpty()){
				this.unset(parsedCommand[1]);
			}else {
				activeXActions_.peek().addUnsetCommand(parsedCommand);
			}
			return;
		}
		if (parsedCommand[0].compareTo(""BEGIN"")==0){
			this.startXaction();
			return;
		}
		if (parsedCommand[0].compareTo(""ROLLBACK"")==0){
			this.rollback();
			return;
		}
		if (parsedCommand[0].compareTo(""COMMIT"")==0){
			this.commit();
			return;
		}
		else {
			System.out.println(""Invalid command"");
		}
	}
	public String set(String key, String value){
		String old = null;
		if (map_.containsKey(key)){
			old = map_.get(key);
		} 
		map_.put(key, value);
		return old;
	}
	public String unset(String key){
		String value = null;
		if (map_.containsKey(key)){
			value = map_.get(key);
			map_.remove(key);
		}
		return value;
	}
	public String get(String key){
		return map_.get(key);
	}
	public void startXaction(){
		activeXActions_.push(new TransactionObj(this));
	}
	public void rollback(){
		if (activeXActions_.isEmpty()){
			System.out.println(""NO TRANSACTIONS IN PROGRESS"");
			return;
		}
		activeXActions_.pop().rollback();
	}
	public void commit(){
		if (activeXActions_.isEmpty()){
			System.out.println(""NO TRANSACTIONS IN PROGRESS"");
			return;
		}
		activeXActions_.clear();
	}
}",0,0,0,0,0,0,0,0,0
64,"@SuppressWarnings(""ALL"")
interface HashSequence {
  int size ();
  int first (Object key);
  int next ();
}",0,0,0,0,0,0,0,0,0
65,"package org.joyfulmonster.util.concurrent.internal;
public class HashStrategy {
    public static HashStrategy getInstance() {
        return new WangJinkensHash();
    }
    public int hash(int code) {
        return code;
    }
    private static class WangJinkensHash extends HashStrategy{
        @Override
        public int hash(int h) {
            h += (h <<  15) ^ 0xffffcd7d;
            h ^= (h >>> 10);
            h += (h <<   3);
            h ^= (h >>>  6);
            h += (h <<   2) + (h << 14);
            return h ^ (h >>> 16);
        }
    }
}",0,0,0,0,0,0,0,0,0
66,"@SuppressWarnings(""ALL"")
interface HashTable {
  boolean put(Object key, Object val);
  Object get(Object key);
  boolean remove(Object key);
  void dump();
}",0,0,0,0,0,0,0,0,0
67,"class HashTable {
    constructor(size) {
        this.values = {};
        this.size = size;
    }
    add(key, value) {
        const hash = this.genHash(key)
        if(!this.values.hasOwnProperty(hash))  
            this.values[hash] = {};
        this.values[hash][key] = value;
    }
    remove(key) {
        const hash = this.genHash(key);
        if(this.values.hasOwnProperty(hash) &&
                this.values[hash].hasOwnProperty(key)) {
            delete this.values[hash][key];  
        }
    }
    genHash(key) {
        var keyStr = key.toString();
        var sum = 0;
        for(let i = 0; i < keyStr.length; i++)
            sum += keyStr.charCodeAt(i);
        return sum % this.size
    }
    getValue(key) {
        const hash = this.genHash(key);
        if(this.values.hasOwnProperty(hash)
                && this.values[hash].hasOwnProperty(key))
            return this.values[hash][key];  
        else
            return undefined;
    }
    printAll() {
        for(const val in this.values)
            for(const key in this.values[val])
                console.log(""{"", key, "", "", 
                    this.values[val][key], ""}"")
    }
}
(function test() {
    var hashTable = new HashTable(5);
    hashTable.add(""key1"", ""value1"");
    hashTable.add(""key2"", ""value2"");
    hashTable.add(""key3"", ""value3"");
    hashTable.printAll();
    console.log(`value of key3: `, hashTable.getValue(""key3""))
    console.log(`delete key3`)
    hashTable.remove(""key3"")
    hashTable.printAll();
    console.log(`value of key3: `, hashTable.getValue(""key3""))
    console.log(`delete key2 & key1`)
    hashTable.remove(""key2"")
    hashTable.remove(""key1"")
    hashTable.printAll();
})()",0,0,0,0,0,0,0,0,1
68,"class HashTableChaining implements HashTable {
  private final ChainedList[] arr;
  private final HashFunction func;
  public HashTableChaining(HashFunction f) {
    arr = new ChainedList[f.size()];
    func = f;
  }
  @Override
  public boolean put(Object key, Object val) {
    if (key == null || val == null) return false;
    int i = func.compute(key);
    if (arr[i] == null) {
      arr[i] = new ChainedList(key, val);
      return true;
    }
    ChainedList.ListElement searchRes = arr[i].search(key);
    if (searchRes == null) {
      arr[i].add(key, val);
      return true;
    }
    searchRes.setVal(val);
    return true;
  }
  @Override
  public Object get(Object key) {
    if (key == null) return null;
    int i = func.compute(key);
    if (arr[i] == null) return null;
    if (arr[i].search(key) == null) return null;
    return arr[i].search(key).getVal();
  }
  @Override
  public boolean remove(Object key) {
    if (key == null) return false;
    int i = func.compute(key);
    if (arr[i] == null) return false;
    return arr[i].remove(key);
  }
  @Override
  public void dump() {
    StringBuilder out = new StringBuilder();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] != null) {
        out.append(arr[i].dump(i));
      }
    }
    System.out.print(out);
  }
  private static class ChainedList {
    private ListElement first;
    private ChainedList(Object firstKey, Object firstVal) {
      this.first = new ListElement(null, firstKey, firstVal);
    }
    private void add(Object key, Object val) {
      first = new ListElement(first, key, val);
    }
    private boolean remove(Object key) {
      if (first == null) return false;
      if (first.key.equals(key)) {
        first = first.next;
        return true;
      }
      ListElement prevKeyElem = first;
      while (prevKeyElem.next != null && !prevKeyElem.next.key.equals(key)) {
        prevKeyElem = prevKeyElem.next;
      }
      if (prevKeyElem.next == null) return false;
      prevKeyElem.next = prevKeyElem.next.next;
      return true;
    }
    private ListElement search(Object key) {
      if (first == null) return null;
      return first.search(key);
    }
    private String dump(int index) {
      if (first == null) return """";
      return first.dump(index);
    }
    private static class ListElement {
      private ListElement next;
      private final Object key;
      private Object val;
      private ListElement(ListElement next, Object key, Object val) {
        this.next = next;
        this.key = key;
        this.val = val;
      }
      private void setVal(Object val) {
        this.val = val;
      }
      private Object getVal() {
        return val;
      }
      private ListElement search(Object key) {
        if (this.key.equals(key)) {
          return this;
        }
        if (next == null) return null;
        return next.search(key);
      }
      private String dump(int index) {
        String out = String.format(""%d %s %s\n"", index, key, val);
        if (next == null) return out;
        return out += next.dump(index);
      }
    }
  }
}",0,0,0,0,0,0,0,0,1
69,"public class HashTableOpenAddressing implements HashTable {
  private final HashSequence seq;
  private final Entry[] arr;
  public HashTableOpenAddressing(HashSequence seq) {
    this.seq = seq;
    this.arr = new Entry[seq.size()];
  }
  private HelperObj helperFunc(Object key){
    int ind = seq.first(key);
    int remembered = -1;
    for(int j = 0; j < seq.size(); j++){
      if(arr[ind] == null) return new HelperObj(remembered == -1?ind:remembered, HelperObj.nichtVorhanden);
      if(arr[ind].isDelMarker() && remembered == -1) remembered = ind;
      if(!arr[ind].isDelMarker() && arr[ind].getKey().equals(key)) return new HelperObj(ind, HelperObj.vorhanden);
      ind = seq.next();
    }
    if(remembered != -1) return new HelperObj(remembered, HelperObj.nichtVorhanden);
    return new HelperObj(-1, HelperObj.tabelleVoll);
  }
  @Override
  public boolean put(Object key, Object val) {
    if(key == null || val == null) return false;
    HelperObj h = helperFunc(key);
    if(h.status == HelperObj.tabelleVoll) return false;
    arr[h.index] = new Entry(false, key, val);
    return true;
  }
  @Override
  public Object get(Object key) {
    if(key == null) return null;
    HelperObj h = helperFunc(key);
    if(h.status == HelperObj.vorhanden){
      Entry entry = arr[h.index];
      return entry.getVal();
    }
    return null;
  }
  @Override
  public boolean remove(Object key) {
    if(key == null) return false;
    HelperObj h = helperFunc(key);
    if(h.status == HelperObj.nichtVorhanden || h.status == HelperObj.tabelleVoll) return false;
    arr[h.index] = new Entry(true, null, null);
    return true;
  }
  @Override
  public void dump() {
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] != null && !arr[i].isDelMarker()) {
        Entry entry = arr[i];
        System.out.println(String.format(""%d %s %s"", i, entry.getKey(), entry.getVal()));
      }
    }
  }
  private static class HelperObj {
    static final int nichtVorhanden = -1;
    static final int vorhanden = 1;
    static final int tabelleVoll = 0;
    final int index;
    final int status;
    private HelperObj(int index, int status) {
      this.index = index;
      this.status = status;
    }
  }
  private static class Entry {
    private final boolean isDelMarker;
    private final Object key;
    private final Object val;
    private Entry(boolean isDelMarker, Object key, Object val) {
      this.isDelMarker = isDelMarker;
      this.key = key;
      this.val = val;
    }
    private boolean isDelMarker() {
      return isDelMarker;
    }
    private Object getVal() {
      return val;
    }
    private Object getKey() {
      return key;
    }
  }
}",0,0,0,0,0,0,0,0,1
70,"class HashTable {
  constructor(size) {
    this.data = new Array(size);
  }
  set(key, value) {
    const address = this._hash(key);
    if (!this.data[address]) {
      this.data[address] = [];
    }
    this.data[address].push([key, value]);
    return this.data;
  }
  get(key) {
    const address = this._hash(key);
    const currentBucket = this.data[address];
    if(currentBucket) {
      for(let i = 0; i < currentBucket.length; i++) {
        if(currentBucket[i][0] === key) {
          return currentBucket[i][1];
        }
      }
    }
    return undefined;
  }
  keys() {
    const keysArray = [];
    for(let i = 0; i < this.data.length; i++) {
      if(this.data[i]) {
        for(let j = 0; j < this.data[i].length; j++) {
          keysArray.push(this.data[i][j][0]);
        }
      }
    }
    return keysArray;
  }
  _hash(key) {
    let hash = 0;
    for(let i = 0; i < key.length; i++) {
      hash = (hash + key.charCodeAt(i) * key.length) % this.data.length;
    }
    return hash;
  }
}
const myHashTable = new HashTable(50);
console.log(myHashTable.set('grapes', 1000));
console.log(myHashTable.get('grapes'));
console.log(myHashTable.keys());",0,0,0,0,0,0,0,0,1
71,"package com.cfelde.bohmap;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
public class JavaSerializer {
    public static <T> Binary serialize(T o) {
        if (o == null)
            return null;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {
            oos.writeObject(o);
        } catch (IOException ex) {
            throw new RuntimeException(ex.getMessage(), ex);
        }
        return new Binary(baos.toByteArray());
    }
    public static <T> T deserialize(Binary b) {
        if (b == null)
            return null;
        ByteArrayInputStream bais = new ByteArrayInputStream(b.getValue());
        try (ObjectInputStream ois = new ObjectInputStream(bais)) {
            return (T) ois.readObject();
        } catch (IOException | ClassNotFoundException ex) {
            throw new RuntimeException(ex.getMessage(), ex);
        }
    }
}",0,0,0,0,0,0,0,0,0
72,"public class Key {
	private String key;
	private int hash; 
	public Key(String key) {
		this.key = key;
	}
	@Override 
	public int hashCode() {
		int h = hash;
		if(h == 0 && key.length() > 0) {
			char value[] = key.toCharArray();
			for(int i = 0 ; i < value.length; i++) {
				h = ((33 * h) + value[i]);
			}
			hash = h;
		}
		return h;
	}
	@Override
	public String toString() {
		return this.key;
	}
}",0,0,0,0,0,0,0,0,0
73,"""use strict"";
let hashEngine = require(""object-hash"");
const defaultOptions = {
    algorithm: ""sha1"",
    excludeValues: false,
    encoding: ""hex"",
    ignoreUnknown: true,
    respectFunctionProperties: false,  
    respectFunctionNames: false,  
    respectType: false  
};
class KeyedObject {
    constructor(anObject, options) {
        this.anObject = anObject;
        this.options = options || defaultOptions;
        this.objHashString = hashEngine(this.anObject, this.options);
        this.hashCode = this.hashCode.bind(this);
        this.equals = this.equals.bind(this);
    }
    hashCode() {
        return this.objHashString;
    }
    equals(anotherKey) {
        if (anotherKey && (typeof anotherKey.hashCode === ""function"")) {
            return this.hashCode() == anotherKey.hashCode();
        } else {
            return false;
        }
    }
}
function createKey(anObject) {
    if ((typeof anObject.hashCode !== ""function"") || (typeof anObject.equals !== ""function"")) {
        return new KeyedObject(anObject);
    } else {
        return anObject;
    }
}
module.exports = {
    createKey: createKey
};",0,0,0,0,0,0,0,0,0
74,"package com.jamierf.persistenthashmap;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.Iterator;
class KeyIterator<K extends Serializable, V extends Serializable> implements Iterator<K> {
	private PersistentHashMap<K, V> map;
	private Iterator<File> iterator;
	private K current;
	public KeyIterator(PersistentHashMap<K, V> map) {
		this.map = map;
		iterator = map.new FileIterator(map.keyStore);
		current = null;
	}
	public boolean hasNext() {
		return iterator.hasNext();
	}
	@SuppressWarnings(""unchecked"")
	public K next() {
		try {
			File keyFile = iterator.next();
			if (keyFile == null)
				return null;
			return (K) map.serializer.readObject(keyFile);
		}
		catch (IOException ioe) {
			return null;
		}
	}
	public void remove() {
		if (current == null)
			return;
		map.remove(current);
	}
}",0,0,0,0,0,0,0,0,0
75,"package com.fullstory;
public class KeyNotFoundException extends Throwable {
    private final String message;
    KeyNotFoundException(String message) {
        this.message = message;
    }
    @Override
    public String toString() {
        return ""KeyNotFoundException { "" +
                ""No key = '"" + message + '\'' +
                "" }"";
    }
}",0,0,0,0,0,0,0,0,0
76,"package com.jamierf.persistenthashmap;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Iterator;
class KeySet<K extends Serializable, V extends Serializable> extends AbstractSet<K> {
	private PersistentHashMap<K, V> map;
	public KeySet(PersistentHashMap<K, V> map) {
		this.map = map;
	}
	@Override
	public boolean contains(Object o) {
		return map.containsKey(o);
	}
	@Override
	@SuppressWarnings(""unchecked"")
	public boolean containsAll(Collection<?> c) {
		Collection<K> ec = (Collection<K>) c;
		for (K key : ec)
			if (!contains(key))
				return false;
		return true;
	}
	@Override
	public boolean isEmpty() {
		return map.isEmpty();
	}
	@Override
	public Iterator<K> iterator() {
		return new KeyIterator<K, V>(map);
	}
	@Override
	public int size() {
		return map.size();
	}
}",0,0,0,0,0,0,0,0,0
77,"package com.fullstory;
class KeyValueNode<K, V> {
    private final K key;
    private final V value;
    private KeyValueNode<K, V> next;
    private KeyValueNode<K, V> previous;
    KeyValueNode(K key, V value) {
        this.key = key;
        this.value = value;
        this.next = null;
        this.previous = null;
    }
    void next(KeyValueNode<K, V> next) {
        this.next = next;
    }
    KeyValueNode<K, V> next() {
        return this.next;
    }
    void previous(KeyValueNode<K, V> previous) {
        this.previous = previous;
    }
    KeyValueNode<K, V> previous() {
        return this.previous;
    }
    K key() {
        return key;
    }
    V value() {
        return value;
    }
    KeyValuePojo<K, V> pojo() {
        return new KeyValuePojo<>(key, value);
    }
}",0,0,0,0,0,0,0,0,0
78,"package com.ks.hashmap;
public interface KeyValuePair<K, V> {
    public K getKey();
    public V getValue();
    public KeyValuePair getNext();
    public void setNext(KeyValuePair<K, V> keyValuePair);
    public KeyValuePair<K, V> clone(KeyValuePair<K, V> keyValuePair);
}",0,0,0,0,0,0,0,0,0
79,"package com.fullstory;
import java.util.Objects;
public class KeyValuePojo<K, V> {
    private final K key;
    private final V value;
    KeyValuePojo(K key, V value) {
        this.key = key;
        this.value = value;
    }
    public K key() {
        return key;
    }
    public V value() {
        return value;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        KeyValuePojo<?, ?> that = (KeyValuePojo<?, ?>) o;
        return Objects.equals(key, that.key) &&
                Objects.equals(value, that.value);
    }
}",0,0,0,0,0,0,0,0,0
80,"public class KpcbHash<T> {
    private int size;
    private int TABLE_SIZE;
    private String[][] key_list;
    private T[][] value_list;
    private int[] cap_list;  
    @SuppressWarnings(""unchecked"")
    public KpcbHash(int size) {
        this.key_list = new String[size][];
        this.value_list = (T[][]) (new Object[size][]);
        this.cap_list = new int[size];
        for (int i = 0; i < size; i++) {
            this.key_list[i] = new String[1];
            this.value_list[i] = (T[]) (new Object[1]);
            cap_list[i] = 0;
        }
        this.size = 0;
        this.TABLE_SIZE = size;
    }
    public int hash(String key) {
        try {
            return key.hashCode() % this.TABLE_SIZE;
        } catch (Exception e) {
            return -1;
        }
    }
    @SuppressWarnings(""unchecked"")
    public boolean set(String key, T value) {
        int hash = this.hash(key);
        if (hash == -1) return false;  
        if (this.get(key) != null) {
            try {
                for (int i = 0; i < this.cap_list[hash]; i++)
                    if (this.key_list[hash][i].equals(key))
                        this.value_list[hash][i] = value;
                return true;
            } catch (Exception e) {
                return false;  
            }
        } else if (this.load() == 1) {
            try {
                String[][] old_key_list = this.key_list;
                T[][] old_value_list = this.value_list;
                int[] old_cap_list = this.cap_list;
                this.TABLE_SIZE *= 2;
                this.key_list = new String[this.TABLE_SIZE][];
                this.value_list = (T[][]) (new Object[this.TABLE_SIZE][]);
                this.cap_list = new int[this.TABLE_SIZE];
                this.size = 0;
                for (int i = 0; i < this.TABLE_SIZE; i++) {
                    this.key_list[i] = new String[1+old_cap_list[i/2]/2];
                    this.value_list[i] = (T[]) (new Object[1+old_cap_list[i/2]/2]);
                    this.cap_list[i] = 0;
                }
                for (int i = 0; i < TABLE_SIZE/2; i++) {
                    for (int j = 0; j < old_cap_list[i]; j++) {
                        String k = old_key_list[i][j];
                        T val = old_value_list[i][j];
                        this.set(k, val);
                    }
                }
                return this.set(key, value);
            } catch (Exception e) {
                return false;  
            }
        } else {
            try {
                if (this.key_list[hash].length == this.cap_list[hash]) {
                    String[] new_key_list = new String[this.cap_list[hash]*2];
                    @SuppressWarnings(""unchecked"")
                    T[] new_value_list = (T[]) (new Object[this.cap_list[hash]*2]);
                    for (int i = 0; i < this.key_list[hash].length; i++) {
                        new_key_list[i] = this.key_list[hash][i];
                        new_value_list[i] = this.value_list[hash][i];
                    }
                    this.key_list[hash] = new_key_list;
                    this.value_list[hash] = new_value_list;
                    return this.set(key, value);
                }
                this.key_list[hash][this.cap_list[hash]] = key;
                this.value_list[hash][this.cap_list[hash]] = value;
                this.cap_list[hash]++;
                this.size++;
                return true;
            } catch (Exception e) {
                return false;  
            }
        }
    }
    public T get(String key) {
        try {
            int hash = this.hash(key);
            if (hash == -1) return null;  
            for (int i = 0; i < this.cap_list[hash]; i++) {
                if (this.key_list[hash][i].equals(key)) {
                    return this.value_list[hash][i];
                }
            }
            return null;  
        } catch (Exception e) {
            return null;  
        }
    }
    public T delete(String key) {
        try {
            int hash = this.hash(key);
            if (hash == -1) return null;  
            for (int i = 0; i < this.cap_list[hash]; i++) {
                if (key_list[hash][i].equals(key)) {  
                    T ret = this.value_list[hash][i];
                    for (int j = i; j < this.cap_list[hash]-1; j++) {
                        this.key_list[hash][j] = this.key_list[hash][j+1];
                        this.value_list[hash][j] = this.value_list[hash][j+1];
                    }
                    this.cap_list[hash]--;
                    this.size--;
                    int curr_len = this.key_list[hash].length;
                    if (this.cap_list[hash]*2 <= curr_len && this.cap_list[hash] != 0) {
                        String[] new_key_list = new String[curr_len/2];
                        @SuppressWarnings(""unchecked"")
                        T[] new_value_list = (T[]) (new Object[curr_len/2]);
                        for (int k = 0; k < curr_len/2; k++) {
                            new_key_list[k] = this.key_list[hash][k];
                            new_value_list[k] = this.value_list[hash][k];
                        }
                        this.key_list[hash] = new_key_list;
                        this.value_list[hash] = new_value_list;
                    }
                    return ret;
                }
            }
            return null;  
        } catch (Exception e) {
            return null;  
        }
    }
    public float load() {
        return (float)this.size/(float)this.TABLE_SIZE;
    }
    public String toString() {
        String s = """";
        for (int i = 0; i < this.TABLE_SIZE; i++) {
            s += ""Row "" + (i+1) + "":\tSize "" + this.cap_list[i] + ""/"" + this.key_list[i].length + "":\t"";
            for (int j = 0; j < this.cap_list[i]; j++) {
                s += this.key_list[i][j] + "" | "" + this.value_list[i][j] + ""\t\t"";
            }
            s += "": \n"";
        }
        return s;
    }
}",0,0,0,0,0,1,0,0,1
81,"public class LazyStudent extends Student {
	public LazyStudent(String nume, int varsta) {
		super(nume, varsta);
	}
	@Override
	public int hashCode()
	{
		return 1;
	}
	@Override
	public boolean equals(Object o)
	{
		if(this.nume.equals(((LazyStudent)o).nume))
			if(this.varsta==((LazyStudent)o).varsta)
				return true;
		return false;
	}
}",0,0,0,0,0,0,0,0,0
82,"__author__ = ""streethacker""
class _MapEntry:
    def __init__(self, key, value):
        self.key = key
        self.value = value
class _MapIterator:
    def __init__(self, theMap):
        self._mapRef = theMap
        self._curNdx = 0
    def __iter__(self):
        return self
    def next(self):
        if self._curNdx < len(self._mapRef):
            item = self._mapRef[self._curNdx]
            self._curNdx += 1
            return item
        else:
            raise StopIteration
class Map:
    def __init__(self):
        self._entryList = list()
    def __len__(self):
        return len(self._entryList)
    def __contains__(self, key):
        ndx = self._findPosition(key)
        return ndx is not None
    def __getitem__(self, key):
        ndx = self._findPosition(key)
        assert ndx is not None, ""Invalid map key.""
        return self._entryList[ndx].value
    def __setitem__(self, key, value):
        ndx = self._findPosition(key)
        if ndx is not None:
            self._entryList[ndx].value = value
            return False
        else:
            entry = _MapEntry(key, value)
            self._entryList.append(entry)
            return True
    def remove(self, key):
        ndx = self._findPosition(key)
        assert ndx is not None, ""Invalid map key.""
        self._entryList.pop(ndx)
    def __iter__(self):
        return _MapIterator(self._entryList)
    def _findPosition(self, key):
        for i in range(len(self)):
            if self._entryList[i].key == key:
                return i
        else:
            return None
if __name__ == ""__main__"":
    m = Map()
    m[""ID""] = 1001
    m[""NAME""] = ""Jhon Smith""
    m[""AGE""] = 22
    print m[""ID""]
    print m[""NAME""]
    print m[""AGE""]",0,0,0,0,0,1,0,0,0
83,"class LinearProbing extends AbstractHashSequence {
  private int prev;
  public LinearProbing(HashFunction f) {
    super(f);
  }
  @Override
  public int first(Object key) {
    return prev = func.compute(key);
  }
  @Override
  public int next() {
    return prev = (prev + 1) % size();
  }
}",0,0,0,0,0,0,0,0,0
84,"package cuckoo;
import java.util.concurrent.atomic.AtomicMarkableReference;
public class LinkedList<T> {
    AtomicMarkableReference<Node<T>> head;
    public LinkedList() {
        head = new AtomicMarkableReference<Node<T>>(null, false);
    }
    public Node<T> insert(long v, T data) {
        AtomicMarkableReference<Node<T>> ch = head;
        Node<T> cr = ch.getReference();
        if (ch.getReference() == null || v > ch.getReference().version) {
            Node<T> newNode = new Node<T>(ch.getReference(), v, data);
            if (!head.compareAndSet(cr, newNode, false, false)) {
                return insert(v, data);
            }
            return newNode;
        }
        AtomicMarkableReference<Node<T>> cursor = ch;
        while(true) {
            AtomicMarkableReference<Node<T>> next = cursor.getReference().next;
            Node<T> nextNode = next.getReference();
            if (nextNode == null || v > nextNode.version) {
                if (nextNode != null && next.isMarked()) {
                    continue;
                }
                Node newNode = new Node<T>(next.getReference(), v, data);
                if (!next.compareAndSet(nextNode, newNode, false, false)) {
                    return insert(v, data);
                };
                return newNode;
            }
            cursor = cursor.getReference().next;
        }
    }
    public T getHeadObj() {
        return head.getReference().object;
    }
    public T latestVer(long v) {
        AtomicMarkableReference<Node<T>> cur = head;
        while (cur.getReference() != null && cur.getReference().version > v) {
            cur = cur.getReference().next;
        }
        if (cur.getReference() == null) {
            return null;
        }
        return cur.getReference().object;
    }
    public void delete(long version) {
        AtomicMarkableReference<Node<T>> prev = new AtomicMarkableReference<Node<T>>(null, false);
        AtomicMarkableReference<Node<T>> ch = head;
        AtomicMarkableReference<Node<T>> cursor = head;
        while(true) {
            if (cursor == null || cursor.getReference() == null)
                break;
            Node<T> currentObj = cursor.getReference();
            if (cursor.getReference().version == version) {
                if (!cursor.attemptMark(currentObj, true)) {
                    delete(version);
                    return;
                }
                boolean rt = false;
                AtomicMarkableReference<Node<T>> next;
                if (prev.getReference() != null) {
                    rt = prev.getReference().next.compareAndSet(prev.getReference().next.getReference(), cursor.getReference().next.getReference(), true, false);
                } else {
                    rt = ch.compareAndSet(ch.getReference(), cursor.getReference().next.getReference(), true, false);
                }
                if (!rt) {
                    delete(version);
                    return;
                }
                break;
            }
            prev = cursor;
            cursor = cursor.getReference().next;
        }
    }
    public long[] snapshot() {
        int length = 0;
        AtomicMarkableReference<Node<T>> cursor = head;
        while (cursor.getReference() != null) {
            if (!cursor.isMarked()) {
                length++;
            }
            cursor = cursor.getReference().next;
        }
        long[] l = new long[length];
        length = 0;
        cursor = head;
        while (cursor.getReference() != null) {
            if (!cursor.isMarked()) {
                l[length] = cursor.getReference().version;
                length++;
            }
            cursor = cursor.getReference().next;
        }
        return l;
    }
}",0,0,0,0,0,0,0,1,0
85,"class LinkedList {
	private Node Head;
	private int size;
	public LinkedList() {
		Head = null;
		size = 0;
	}
	public void insert(int data) {
		Node temp = Head;
		Node newnode = new Node(data);
		size++;
		if(Head == null) {
			Head = newnode;
		}
		else {
			newnode.next = Head;
			Head = newnode;
		}
	}
	public void delete(int data) {
		if(size == 0) {
			System.out.println(""UnderFlow!"");
			return;
		}
		else {
			Node curr = Head;
			if (curr.data == data) {
				Head = curr.next;
				size--;
				return;
			}
			else {
				while(curr.next.next != null) {
					if(curr.next.data == data){
							curr.next = curr.next.next;
							return;
						}
				}
				System.out.println(""Key not Found"");
			}
		}
	}
	public void display() {
		Node temp = Head;
		while(temp != null) {
			System.out.printf(""%d "",temp.data);
			temp = temp.next;
		}
		System.out.println();
	}
}",0,0,0,0,0,1,0,1,0
86,"package maps.lrucache;
import java.util.LinkedHashMap;
import java.util.Map;
public class LRUCache extends LinkedHashMap {
    private int maxSize;
    public LRUCache(int maxSize) {
        super(maxSize, 0.75F, true);
        this.maxSize = maxSize;
    }
    public boolean removeEldestEntry(Map.Entry map) {
        return super.size() > maxSize;
    }
}",0,0,0,0,0,0,0,0,0
87,"""use strict"";
let HashMap = require(""./HashMap""),
    KeyedObjectFactory = require(""./KeyedObjectFactory"");
class LRUCache {
    constructor(maxSize, evictionCallback) {
        this.maxSize = maxSize || 1000;
        this.hashMap = new HashMap();
        this.mapTail = null;
        this.mapHead = null;
        this.evictionCallback = evictionCallback;
        this.get = this.get.bind(this);
        this.peek = this.peek.bind(this);
        this.put = this.put.bind(this);
        this.size = this.size.bind(this);
        this.detachFromList = this.detachFromList.bind(this);
        this.insertInList = this.insertInList.bind(this);
        this.remove = this.remove.bind(this);
        this.clear = this.clear.bind(this);
    }
    get(key) {
        key = KeyedObjectFactory.createKey(key);
        let tempNode = this.hashMap.get(key);
        if (tempNode != null) {
            this.detachFromList(tempNode);
            this.insertInList(tempNode);
            return tempNode.value;
        }
        return null;
    }
    peek(key) {
        key = KeyedObjectFactory.createKey(key);
        return this.hashMap.get(key);
    }
    put(key, value) {
        key = KeyedObjectFactory.createKey(key);
        let tempNode = this.hashMap.get(key);
        let retVal = null;
        if (tempNode != null) {
            retVal = tempNode.value;
            tempNode.value = value;
            this.detachFromList(tempNode);
        } else {
            if (this.hashMap.size() >= this.maxSize) {
                let oldTailValue = this.mapTail.value;
                this.hashMap.remove(this.mapTail.key);
                this.detachFromList(this.mapTail);
                if (typeof this.evictionCallback == ""function"") {
                    this.evictionCallback(oldTailValue);
                }
            }
            tempNode = {
                nextNode: null,
                previousNode: null,
                key,
                value
            };
            this.hashMap.put(key, tempNode);
        }
        this.insertInList(tempNode);
        return retVal;
    }
    size() {
        return this.hashMap.size();
    }
    detachFromList(aNode) {
        let previousNodePtr = aNode.previousNode;
        let nextNodePtr = aNode.nextNode;
        if (previousNodePtr != null) {
            previousNodePtr.nextNode = nextNodePtr;
            if (nextNodePtr == null) {
                this.mapTail = previousNodePtr;
            }
        } else {
            this.mapHead = nextNodePtr;
        }
        if (nextNodePtr != null) {
            nextNodePtr.previousNode = previousNodePtr;
            if (previousNodePtr == null) {
                this.mapHead = nextNodePtr;
            }
        } else {
            this.mapTail = previousNodePtr;
        }
        aNode.nextNode = null;
        aNode.previousNode = null;
    }
    insertInList(aNode) {
        if (this.mapHead != null) {
            this.mapHead.previousNode = aNode;
        }
        aNode.previousNode = null;
        aNode.nextNode = this.mapHead;
        this.mapHead = aNode;
        if (this.mapTail == null) {
            this.mapTail = aNode;
        }
    }
    remove(key) {
        key = KeyedObjectFactory.createKey(key);
        let tempNode = this.hashMap.remove(key);
        let retVal = null;
        if (tempNode != null) {
            retVal = tempNode.value;
            this.detachFromList(tempNode);
        }
        return retVal;
    }
    clear() {
        while (this.mapTail !== null) {
            let oldTailValue = this.remove(this.mapTail.key);
            if (oldTailValue && (typeof this.evictionCallback == ""function"")) {
                this.evictionCallback(oldTailValue);
            }
        }
        this.hashMap.clear();
        this.mapTail = null;
        this.mapHead = null;
    }
}
module.exports = LRUCache;",0,0,0,0,0,0,0,0,0
88,"package Hashtables.Challenge2;
import Hashtables.Employee;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        LinkedList<Employee> employees = new LinkedList<>();
        employees.add(new Employee(""Jane"", ""Jones"", 123));
        employees.add(new Employee(""John"", ""Doe"", 5678));
        employees.add(new Employee(""Mike"", ""Wilson"", 45));
        employees.add(new Employee(""Mary"", ""Smith"", 5555));
        employees.add(new Employee(""John"", ""Doe"", 5678));
        employees.add(new Employee(""Bill"", ""End"", 3948));
        employees.add(new Employee(""Jane"", ""Jones"", 123));
        Map<Integer, Employee> hashMap = new HashMap<Integer, Employee>();
        ListIterator<Employee> iterator = employees.listIterator();
        List<Employee> rm = new ArrayList<>();
        while (iterator.hasNext()){
            Employee employee = iterator.next();
            if (hashMap.containsKey(employee.getId())){
                rm.add(employee);
            }
            else {
                hashMap.put(employee.getId(),employee);
            }
        }
        for (Employee employee:rm){
            employees.remove(employee);
        }
        employees.forEach(e -> System.out.println(e));
    }
    public static int hash(int value) {
        return Math.abs(value % 10);
    }
}",0,0,0,0,0,0,0,0,0
89,"package Hashtables.Challenge1;
public class Main {
    public static void main(String[] args) {
        int[] nums = new int[10];
        int[] numsToAdd = { 59382, 43, 6894, 500, 99, -58 };
        for (int i = 0; i < numsToAdd.length; i++) {
            nums[hash(numsToAdd[i])] = numsToAdd[i];
        }
        for (int i = 0; i < nums.length; i++) {
            System.out.println(nums[i]);
        }
    }
    public static int hash(int value) {
        return Math.abs(value%10);
    }
}",0,0,0,0,0,0,0,0,0
90,"public class Main {
    public static void main(String[] args) {
        ChainHashMap chainHashMap = new ChainHashMap(10000);
        ChainHashMap chainHashMap2 = new ChainHashMap(100);
        for (int i = 0; i < 1000000; i += 2) {
            String[] pares = { ""a"" + i, """" + (i + 1) };
            chainHashMap.put(pares[0], pares[1]);
        }
        for (int i = 0; i < 1000000; i += 2) {
            String[] pares = { ""b"" + i, """" + (i + 1) };
            chainHashMap2.put(pares[0], pares[1]);
        }
        System.out.println(chainHashMap.getLoadFactor());
        System.out.println(chainHashMap2.getLoadFactor());
        System.out.println(chainHashMap.get(""a999998""));
        System.out.println(chainHashMap2.get(""b999998""));
    }
}",0,0,0,0,0,0,0,0,0
91,"package net.data.fastmap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
public class Main {
    public static void main(String[] args) {
        Random r = new Random(42);
        ArrayList<Integer> values = new ArrayList<>();
        for (int i = 0; i < 2000000; i++) {
            values.add(r.nextInt(90000));
        }
        Map<Integer, Integer> verifyMap = new HashMap<>(100000);
        Map<Integer, Integer> testMap = new FastMap<>(100000);
        long start = System.currentTimeMillis();
        for (int i : values) {
            verifyMap.put(i, i + 1);
        }
        long verifyTime = System.currentTimeMillis() - start;
        System.out.println(""Old: "" + verifyTime);
        start = System.currentTimeMillis();
        for (int i : values) {
            testMap.put(i, i + 1);
        }
        verifyTime = System.currentTimeMillis() - start;
        System.out.println(""New: "" + verifyTime);
        System.out.println(""Size: "" + verifyMap.size() + "" / "" + testMap.size());
    }
}",0,0,0,0,0,0,0,0,0
92,"package Thomas;
import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.Random;
public class Main {
    public static void main(String[] args) {
        Random random = new Random(System.currentTimeMillis());
        int n = 64*64*64;
        int testSize = n;
        ArrayList<Vec3I> elelist = new ArrayList<>();
        for(int i = 0; i < n; i++) {
            Vec3I ele = new Vec3I(random.nextInt(56), random.nextInt(56), random.nextInt(56));  
            if(!elelist.contains(ele)) {
                elelist.add(ele);
            }
        }
        PSHOffsetTable table;
        table = new PSHOffsetTable(elelist);
        for(int i = 0; i < 10; i++) {
            Long timestart = System.currentTimeMillis();
            Vec3I ele = new Vec3I(random.nextInt(56), random.nextInt(56), random.nextInt(56));  
            if(!elelist.contains(ele)) {
                elelist.add(ele);
            }
            table.updateOffsets(elelist);
            System.out.println(""Time to do an update of offsettable: "" + (System.currentTimeMillis() - timestart));
        }
        ArrayList<Vec3I> hashCheck = new ArrayList<>();
        for(int i = 0; i < elelist.size(); i++) {
            Vec3I hash = table.hash(elelist.get(i));
            if(!hashCheck.contains(hash)) {
                hashCheck.add(hash);
            }
            else {
                System.out.println(""if this prints there is a hash collision which means there's a bug"");
            }
        }
        System.out.println(""stress test fin"");
        }
}",0,0,0,0,0,0,0,0,0
93,"package hashMapX;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
public class Main {
	public static void main(String[] args) throws IOException {
		HashMapX newDB = new HashMapX();
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		boolean isExit = false;
		while (!isExit){
			String command = reader.readLine();
			if (command.compareTo(""END"")==0){
				isExit = true;
			}else{
				newDB.parseCommand(command);
			}
		}
	}
}",0,0,0,0,0,0,0,0,0
94,"package Hashtables.LinearProbing;
import Hashtables.Employee;
public class Main {
    public static void main(String[] args) {
        Employee janeJones = new Employee(""Jane"", ""Jones"", 123);
        Employee johnDoe = new Employee(""John"", ""Doe"", 4567);
        Employee marySmith = new Employee(""Mary"", ""Smith"", 22);
        Employee mikeWilson = new Employee(""Mike"", ""Wilson"", 3245);
        Employee billEnd = new Employee(""Bill"", ""End"", 78);
        SimpleHashtable ht = new SimpleHashtable();
        ht.put(""Jones"", janeJones);
        ht.put(""Doe"", johnDoe);
        ht.put(""Wilson"", mikeWilson);
        ht.put(""Smith"", marySmith);
        ht.printHashtable();
        System.out.println(""Retrieve key Wilson: "" + ht.get(""Wilson""));
        System.out.println(""Retrieve key Smith: "" + ht.get(""Smith""));
        ht.printHashtable();
        System.out.println(""Retrieve key Smith: "" + ht.get(""Smith""));
    }
}",0,0,0,0,0,0,0,0,0
95,"import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		int choice, key;
		HashMap h = new HashMap(7);
		while (true) {
			System.out.println(""Enter your Choice :"");
			System.out.println(""1. Add Key"");
			System.out.println(""2. Delete Key"");
			System.out.println(""3. Print Table"");
			System.out.println(""4. Exit"");
			Scanner In = new Scanner(System.in);
			choice = In.nextInt();
			switch (choice) {
				case 1: {
					System.out.println(""Enter the Key: "");
					key = In.nextInt();
					h.insertHash(key);
					break;
				}
				case 2: {
					System.out.println(""Enter the Key delete:  "");
					key = In.nextInt();
					h.deleteHash(key);
					break;
				}
				case 3: {
					System.out.println(""Print table"");
					h.displayHashtable();
					break;
				}
				case 4: {
					return;
				}	
			}
		}
	}
}",0,0,0,0,0,0,0,0,0
96,"import java.util.*;
import java.util.Random;
public class MainClass {
	private static String getRandString()
	{
		int a;
		Random r = new Random();
		StringBuilder sb = new StringBuilder();
		for(int i=0;i<6;i++)
		{
			a=r.nextInt(20);
			char c = (char)(a + 'a');
			sb.append(c);
		}
		return sb.toString();
	}
	private static Integer getRandInt() {
		 Random r = new Random();
		 return new Integer( r.nextInt() +1);
		 }
	public static void main(String[] args) {
		Student student;
		LazyStudent lazy;
		String nume;
		int varsta;
		List<Student> list=new ArrayList<Student>();
		List<Student> list2=new ArrayList<Student>();
		List<LazyStudent> list3=new ArrayList<LazyStudent>();
		List<LazyStudent> list4=new ArrayList<LazyStudent>();
		for(int i=0;i<2000;i++)
			{
				nume=MainClass.getRandString();
				varsta=Math.abs(MainClass.getRandInt()%30);
				student=new Student(nume,varsta);
				lazy=new LazyStudent(nume,varsta);
				list.add(student);
				list3.add(lazy);
			}
		list2.addAll(list);
		MyHashMap<Student,Integer> map=new MyHashMapImpl<Student,Integer>(10);
		Iterator<Student> it=list.iterator();
		while(it.hasNext())
		{
			student=it.next();
			map.put(student, MainClass.getRandInt()%10+1);
		}
		long time1=System.currentTimeMillis();
		for(int i=0;i<1000;i++)
		{
			student=list2.get(Math.abs(MainClass.getRandInt()%2000));
			map.get(student);
		}
		long time2=System.currentTimeMillis();
		System.out.println(time2-time1);
		list4.addAll(list3);
		MyHashMap<LazyStudent,Integer> map2=new MyHashMapImpl<LazyStudent,Integer>(10);
		Iterator<LazyStudent> it2=list3.iterator();
		while(it2.hasNext())
		{
			lazy=it2.next();
			map2.put(lazy, MainClass.getRandInt()%10+1);
		}
		long time3=System.currentTimeMillis();
		for(int i=0;i<1000;i++)
		{
			lazy=list4.get(Math.abs(MainClass.getRandInt()%2000));
			map2.get(lazy);
		}
		long time4=System.currentTimeMillis();
		System.out.println(time4-time3);
	}
}",0,0,0,0,0,0,0,0,0
97,"import java.util.Map.Entry;
public interface Map<K, V> {
  int size();
  boolean isEmpty();
  V get(K key);
  V put(K key, V value);
  V remove(K key);
  Iterable<K> keySet();
  Iterable<V> values();
  Iterable<Entry<K, V>> entrySet();
}",0,0,0,0,0,0,0,0,0
98,"import Hash from './Hash';
function HashMap() {
  this.items = [];
  this.mapLength = 50;
}
HashMap.prototype.insert = function insert(key: any, value: any): HashMap {
  const generatedHashCode = Hash(key, this.mapLength);
  this.items[generatedHashCode] = value;
  return this;
};
HashMap.prototype.all = function all(): any[] {
  return this.items.filter((i: any): boolean => !!i);
};
HashMap.prototype.get = function get(key: any): any {
  const generatedHashCode = Hash(key, this.mapLength);
  return this.items[generatedHashCode];
};
HashMap.prototype.remove = function remove(key: any): HashMap {
  const generatedHashCode = Hash(key, this.mapLength);
  this.items.splice(generatedHashCode, 1);
  return this;
};
export default HashMap;",0,0,0,0,0,0,0,0,1
99,"import java.util.Objects;
public class MapEntry<K, V> {
    private K key;
    private V value;
    public MapEntry(K key, V value) {
        this.key = key;
        this.value = value;
    }
    public K getKey() {
        return key;
    }
    public void setKey(K key) {
        this.key = key;
    }
    public V getValue() {
        return value;
    }
    public void setValue(V value) {
        this.value = value;
    }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof MapEntry)) {
            return false;
        } else {
            MapEntry<K, V> that = (MapEntry<K, V>) o;
            return Objects.equals(key, that.key) 
                && Objects.equals(value, that.value);
        }
    }
    @Override
    public String toString() {
        return String.format(""%s: %s"", key.toString(), value.toString());
    }
}",0,0,0,0,0,0,0,0,0
100,"public class MapEntry<K,V> implements Entry<K,V>{
	private K key;
	private V value;
	private int count;
	public MapEntry(K key, V value) {
		this.key = key;
		this.value = value;
		this.count = 1;
	}
	@Override
	public int getCount() {
		return this.count;
	}
	@Override
	public K getKey() {
		return this.key;
	}
	@Override
	public V getValue() {
		return this.value;
	}
	protected void setKey(K key) {
		this.key = key;
	}
	protected V setValue(V value) {
		V old = this.value;
		this.value = value;
		return old;
	}
	protected void setCount(int count) {
		this.count = count;
	}
	protected void increaseCount() {
		this.count++;
	}
	@Override
	public int hashCode() {
		return this.key.hashCode();
	}
}",0,0,0,0,0,0,0,0,0
101,"public class MapEntry<K, V> {
    private boolean removed;
    private K key;
    private V value;
    public MapEntry(K k, V v) {
        key = k;
        value = v;
    }
    public boolean isRemoved() {
        return removed;
    }
    public void setRemoved(boolean removed) {
        this.removed = removed;
    }
    public K getKey() {
        return key;
    }
    public void setKey(K key) {
        this.key = key;
    }
    public V getValue() {
        return value;
    }
    public void setValue(V value) {
        this.value = value;
    }
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof MapEntry)) {
            return false;
        } else {
            MapEntry<K, V> that = (MapEntry<K, V>) o;
            return that.getKey().equals(key) && that.getValue().equals(value)
                    && (that.isRemoved() == removed);
        }
    }
    @Override
    public String toString() {
        return String.format(""%s%s: %s"", removed ? ""(Removed) "" : """",
                key.toString(), value.toString());
    }
}",0,0,0,0,0,0,0,0,0
102,"package Thomas;
public class MathGeneral {
    public static int gcd(int a, int b)
    {
        if(a == 0 || b == 0) return a+b;  
        return gcd(b,a%b);
    }
    public static void quicksort(int[] array, int start, int end) {
        int i = start;
        int j = end;
        int pivot = array[start + (end - start)/2];
        while(i<=j) {
            while(array[i] < pivot) {
                i++;
            }
            while(array[j] > pivot) {
                j--;
            }
            if (i <= j) {
                exchange( array, i, j);
                i++;
                j--;
            }
        }
        if (start < j)
            quicksort(array, start, j);
        if (i < end)
            quicksort(array, i, end);
    }
    private static void exchange(int[] numbers, int i, int j) {
        int temp = numbers[i];
        numbers[i] = numbers[j];
        numbers[j] = temp;
    }
}",1,0,0,0,0,0,0,0,0
103,"package org.joyfulmonster.util.concurrent.internal;
public interface MetricsSupport {
    int totalSplits();
    int getBucketCount();
    int getMaxBucketCountDifference();
}",0,0,0,0,0,0,0,0,0
104,"class MultiplicationMethod extends AbstractHashFunction {
  private static final int w = 32;
  private final int bits;
  private final int seed;
  public MultiplicationMethod(int p, int s) {
    super(1 << p);     
    bits = p;
    seed = s;
  }
  @Override
  public int compute(Object key) {
    final int hash = (key.hashCode() % size + size) % size;
    return ((hash * seed) >>> (w - bits)) % size();
  }
}",0,0,0,0,0,0,0,0,0
105,"package assignment6;
import java.util.*;
public class MultiStringColl {
    private btNode c;
    private int howmany;
    private int total;
    public MultiStringColl() {
        c = null;
        howmany = 0;
        total = 0;
    }
    public MultiStringColl(int i) {
        c = null;
        howmany = 0;
        total = 0;
    }
    public void copy(MultiStringColl obj) {
        if(!(this.equals(obj))){
            howmany=obj.howmany;
            total = obj.total;
            c = copytree(obj.c);
        }
    }
    public int belongs(String i) {
        btNode p = c;
        while((p!=null)&&(i.compareTo(p.info)!=0)){
            if(i.compareTo(p.info)<0){
                p = p.left;
            }else{
                p = p.right;
            }
        }
        if(p!=null){
            return p.count;
        }else{
            return 0;
        }
    }
    public void insert(String i) {
        btNode pred = null;
        btNode p = c;
        if(p!=null){
            while((p!=null)&&(p.info.compareTo(i)!=0)){
                pred = p;
                if(i.compareTo(p.info)<0){
                    p = p.left;
                }else{
                    p = p.right;
                }
            }
        }
        if(p!=null){
            p.count++;
            total++;
        }
        else if(p==null){
            howmany++;
            total++;
            p = new btNode(i, null, null, 1);
            if(pred!=null){
                if(i.compareTo(pred.info)<0){
                    pred.left=p;
                } else{
                    pred.right=p;
                }
            } else{
                c = p;
            }
        }
    }
	public void omit(String i) {
		if (c == null) return;  
		btNode parent = null;  
		btNode p = c;  
		while (!p.info.equals(i)) { 		 
			parent = p;
			if (p.info.compareTo(i) > 0)
				p = p.left;
			else
				p = p.right;
		}  
		if (p.count > 1) { 		 
			p.count--;
			total--;;
			return;
		}
		if(p.count == 1) {  
			howmany--;
		}
		btNode pbelow = p;  
		if (p.right == null) {  
			pbelow = p.left;  
		} else if (p.left == null) {  
			pbelow = p.right;  
		} else {  
			btNode pbelow2 = p.left;  
			if (pbelow2.right == null) {
				pbelow = pbelow2;
				pbelow.right = p.right;
			} else {
				while (pbelow2.right.right != null) {
					pbelow2 = pbelow2.right;
				}
				pbelow = pbelow2.right;
				pbelow2.right = pbelow.left;
				pbelow.right = p.right;
				pbelow.left = p.left;
			}
		}
		if (parent == null) {
			c = pbelow;  
		} else if (parent.right == p) {
			parent.right = pbelow;  
		} else {
			parent.left = pbelow;  
		}
		if(p.count > 1) {  
			howmany--;
		}
	total--;
	}
    public int get_howmany() {
        return howmany;
    }
    public int get_total(){
        return total;
    }
    public void print() {
        printtree(c);
    }
    public boolean equals(MultiStringColl obj) {
        if(howmany!=obj.howmany){
            return false;
        }
        else{
            btNode[] thisArray = new btNode[howmany];
            btNode[] objThisArray = new btNode[obj.howmany];
            toarray(c, thisArray, 0);
            toarray(obj.c, objThisArray, 0);
            for(int i = 0; i<thisArray.length; i++){
                if((thisArray[i].info.compareTo(objThisArray[i].info)!=0) || (thisArray[i].count!=objThisArray[i].count)){
                    return false;
                }
            }
        }
        return true;
    }
    private static class btNode{
        private String info;
        private btNode left;
        private btNode right;
        private int count;
        public btNode(){
            info = null;
            left = null;
            right = null;
            count = 0;
        }
        public btNode(String i, btNode lt, btNode rt, int ct){
            info = i;
            left = lt;
            right = rt;
            count = ct; 
        }
    }
    private static btNode copytree(btNode t){
        btNode result = null;
        if(t!=null){
            result = new btNode(t.info, copytree(t.left), copytree(t.right), t.count);
        }
        return result;
    }
    private static void printtree(btNode t){
        if(t!=null){
            printtree(t.left);
            System.out.println(t.info + ""(""+t.count+"")"");
            printtree(t.right);
        }
    }
    private static int toarray(btNode t, btNode[] a, int i){
        int num_nodes = 0;
        if(t!=null){
            num_nodes = toarray(t.left, a, i);
            a[num_nodes+i] = new btNode(t.info, null, null, t.count);
            num_nodes = num_nodes + 1 + toarray(t.right, a, num_nodes+i+1);
        }
        return num_nodes;
    }
}",0,0,0,0,0,0,0,0,0
106,"package assignment6;
import java.util.*;
public class MultiStringCollClient
{
   public static final String SENTINEL = ""###"";
   public static void main(String[] args)
   {
      String value; String firstCharacter; String reformatValue; Scanner keyboard=new Scanner(System.in);
      MultiStringColl P=new MultiStringColl(), N=new MultiStringColl(), L= new MultiStringColl();
      System.out.println(""Enter a +string to be inserted, -string to remove it, or ### to quit:"");
      value=keyboard.nextLine();
      firstCharacter = String.valueOf(value.charAt(0));
      reformatValue  = value.substring(1,value.length());
      while(!(value.equals(SENTINEL)))
      {
         if (firstCharacter.equals(""+"")) {
             P.insert(reformatValue); 
             L.insert(reformatValue);
         }
         else {N.insert(reformatValue); L.omit(reformatValue);}
         System.out.println(""Enter +string to insert another string, -string to remove another string, or ### to quit:"");
         value=keyboard.nextLine();
         firstCharacter = String.valueOf(value.charAt(0));
         reformatValue  = value.substring(1,value.length());
      }
      System.out.println(""\nThe values in collection P are:"");
      P.print();
      System.out.println(""\nThe number of distinct strings in collection P is:"");
      System.out.println(P.get_howmany());
      System.out.println(""\nThe total number of strings in collection P is:"");
      System.out.println(P.get_total());
      System.out.println(""\nThe values in collection N are:"");
      N.print();
      System.out.println(""\nThe number of distinct strings in collection N is:"");
      System.out.println(N.get_howmany());
      System.out.println(""\nThe total number of strings in collection N is:"");
      System.out.println(N.get_total());
      System.out.println(""\nThe values in collection L are:"");
      L.print();
      System.out.println(""\nThe number of distinct strings in collection L is:"");
      System.out.println(L.get_howmany());
      System.out.println(""\nThe total number of strings in collection L is:"");
      System.out.println(L.get_total());
      if (P.equals(N)) System.out.println(""\nP and N are equal."");
      else System.out.println(""\nP and N are NOT equal."");
      MultiStringColl A=new MultiStringColl(); A.copy(L);
      System.out.println(""\nThe values in the copy of L are:\n"");
      A.print();
   }
}",0,0,0,0,0,0,0,0,0
107,"package com.manish.hashmap;
import java.util.Arrays;
public class MyHashMap {
    public static void main(String args[]){
        HashMap hashMap = new HashMap(2);
        hashMap.put(""Jan"", ""January"");
        hashMap.put(""Feb"", ""Febuary1"");
        hashMap.put(""Feb"", ""February2""); 
        hashMap.put(""Mar"", ""March"");
        hashMap.put(""Apr"", ""April"");
        hashMap.delete(""Jan"");
        hashMap.delete(""Feb"");
        System.out.println(hashMap);
        System.out.println(""value of jan ""+hashMap.get(""Jan""));
        System.out.println(""value of feb ""+hashMap.get(""Feb""));
    }
}
class HashMap{
   static class Entry{
        String key;
        String value;
        Entry next=null;
        Entry(String key,String value){
            this.key=key;
            this.value=value;
        }
        @Override
        public String toString() {
            return ""Entry{"" +
                    ""key='"" + key + '\'' +
                    "", value='"" + value + '\'' +
                    "", next="" + next +
                    '}';
        }
    }
    private Entry entry;
    int BUCKET_SIZE=4;
    Entry []bucket;
    HashMap(int size){
         this.BUCKET_SIZE=size;
         bucket = new Entry[size];
    }
    public String get(String key){
        int hash= key.length()%BUCKET_SIZE;
        Entry entry = bucket[hash];
        if(entry==null){
            return ""0"";
        }else{
            while(entry!=null){
                if(entry.key.equalsIgnoreCase(key)){
                    return entry.value;
                }
                entry = entry.next;
            }
        }
    return ""0"";
    }
    public void put(String key,String value){
        boolean found= false;
        if(key!=null){
            int hash= key.length()%BUCKET_SIZE;
            Entry entry = bucket[hash];
            if(entry==null){
                entry = new Entry(key,value);
                bucket[hash]=entry; 
            }else{
                Entry cur = entry;
                while (cur!=null){
                        if(cur.key.equalsIgnoreCase(key)){
                            cur.value= value;
                            return;
                        }
                        cur = cur.next;
                }
                    cur= new Entry(key,value);
            }
        }
    }
    public void delete(String key){
        if(key!=null){
            int hash = key.length()%BUCKET_SIZE;
            Entry entry= bucket[hash];
            if(bucket==null){
                System.out.println(""No such key"");
                return;
            }
            Entry prev = entry;
            Entry cur = entry;
            while(cur!=null){
                if(cur.next==null){
                }
                if(cur.key.equalsIgnoreCase(key)){
                    prev.next= cur.next;
                    cur = null;
                    return;
                }else{
                    prev = cur;
                    cur = cur.next;
                }
            }
        }
    }
    @Override
    public String toString() {
        return ""MyHashMap{"" +
                ""bucket="" + Arrays.toString(bucket) +
                '}';
    }
}",0,0,0,0,0,1,0,0,1
108,"import java.util.List;
public interface MyHashMap<K, V> {
	public V get(K key);
	public V put(K key, V value);
	public V remove(K key);
	public int size();
	public List<? extends Bucket<K, V>> getBuckets();
	public static interface Entry<K, V> {
		public K getKey();
		public V getValue();
	}
	public static interface Bucket<K, V> {
		public List<? extends Entry<K, V>> getEntries();
	}
}",0,0,0,0,0,0,0,0,0
109,"import java.util.ArrayList;
import java.util.List;
public class MyHashMapImpl<K,V> implements MyHashMap<K, V> {
	private int numBuckets;
	private List<MyHashMap.Bucket<K, V>> list;
	private int size=0;
	MyHashMapImpl(int numBuckets)
	{
		list=new ArrayList<MyHashMap.Bucket<K, V>>();
		MyHashMap.Bucket<K,V> bucket;
		for(int i=0;i<numBuckets;i++)
			{
				bucket=new BucketImpl();
				list.add(bucket);
			}
		this.numBuckets=numBuckets;
	}
	@Override
	public V get(K key) {
		int i=translate(key.hashCode(),numBuckets);
		MyHashMap.Bucket<K,V> bucket=list.get(i);
		for(MyHashMap.Entry<K, V> entry:bucket.getEntries())
		{
			if(entry.getKey().equals(key))
				return entry.getValue();
		}
		return null;
	}
	@Override
	public V put(K key, V value) {
		int i=translate(key.hashCode(),numBuckets);
		MyHashMap.Bucket<K,V> bucket=list.get(i);
		for(MyHashMap.Entry<K, V> entry:bucket.getEntries())
		{
			if(entry.getKey().equals(key))
				{
					V val=((EntryImpl)entry).v;
					((BucketImpl)bucket).list2.remove(entry);
					((EntryImpl)entry).v=value;
					((BucketImpl)bucket).list2.add(entry);
					return val;
				}
		}
		MyHashMap.Entry<K, V> entryy=new EntryImpl();
		((EntryImpl)entryy).k=key;
		((EntryImpl)entryy).v=value;
		((BucketImpl)bucket).list2.add(entryy);
		size++;
		return null;
	}
	@Override
	public V remove(K key) {
		int i=translate(key.hashCode(),numBuckets);
		MyHashMap.Bucket<K,V> bucket=list.get(i);
		for(MyHashMap.Entry<K, V> entry:bucket.getEntries())
		{
			if(entry.getKey()==key)
			{
				V val=((EntryImpl)entry).v;
				((BucketImpl)bucket).list2.remove(entry);
				size--;
				return val;
			}
		}
		return null;
	}
	@Override
	public int size() {
		return size;
	}
	@Override
	public List<? extends MyHashMap.Bucket<K, V>> getBuckets() {
		return list;
	}
	public int translate(int hashCode, int size) {
		return Math.abs(hashCode) % size;
	}
	public class EntryImpl implements MyHashMap.Entry<K, V>
	{
		K k;
		V v;
		@Override
		public K getKey() {
			return k;
		}
		@Override
		public V getValue() {
			return v;
		}
	}
	public class BucketImpl implements MyHashMap.Bucket<K, V>
	{
		private List<MyHashMap.Entry<K, V>> list2=new ArrayList<MyHashMap.Entry<K, V>>();
		@Override
		public List<? extends MyHashMap.Entry<K, V>> getEntries() {
			return list2;
		}
	}
}",0,0,0,0,0,1,0,0,1
110,"public class Nashmap {
    private Bucket[] buckets;
    private static class Bucket<Type> {
        Type value;
        int key;
        Bucket(int key, Type value) {
            this.value = value;
            this.key = key;
        }
        Type getValue() {
            return value;
        }
        int getKey() {
            return key;
        }
    }
    public Nashmap(int size) {
        this.buckets = new Bucket<?>[size];
    }
    private int getHash(String key) {
        int hash = key.hashCode();
        if (hash < 0) {
            hash = hash * -1;
        }
        return hash;
    }
    private int findObject(int hashedKey) {
        int i = hashedKey % this.buckets.length;
        do {
            if (this.buckets[i] != null && this.buckets[i].getKey() == hashedKey) {
                return i;
            }
            i = (i + 3) % this.buckets.length;
        } while (buckets[i] == null);
        return -1;
    }
    private int findNull(int hashedKey) {
        hashedKey = hashedKey % this.buckets.length;
        do {
            if (this.buckets[hashedKey] == null) {
                return hashedKey;
            }
            hashedKey = (hashedKey + 3) % this.buckets.length;
        } while (buckets[hashedKey] != null);
        return -1;
    }
    public boolean put(String key, Object object) {
        int hashedKey = getHash(key);
        int index = findNull(hashedKey);
        if (index >= 0) {
            this.buckets[index] = new Bucket<>(hashedKey, object);
            return true;
        } else {
            return false;
        }
    }
    public Object get(String key) {
        int index = findObject(getHash(key));
        if (index >= 0) {
            return this.buckets[index].getValue();
        } else {
            return null;
        }
    }
    public boolean delete(String key) {
        int index = findObject(getHash(key));
        if (index >= 0) {
            this.buckets[index] = null;
            return true;
        } else {
            return false;
        }
    }
    public boolean exists(String key) {
        int index = findObject(getHash(key));
        return index >= 0;
    }
    public int elements() {
        int elements = 0;
        for (int i = 0; i < this.buckets.length; i++) {
            if (this.buckets[i] != null) {
                elements++;
            }
        }
        return elements;
    }
    public boolean isEmpty() {
        return elements() == 0;
    }
    public void clear() {
        for (int i = 0; i < this.buckets.length; i++) {
            this.buckets[i] = null;
        }
    }
    public int size() {
        return this.buckets.length;
    }
}",0,0,0,0,0,1,0,0,1
111,"package cuckoo;
public class NeedExpansionException extends Exception {
    NeedExpansionException(String s) {
        super(s);
    }
}",0,0,0,0,0,0,0,0,0
112,"package com.contactsunny.poc.HashMapImplementation.hashMap;
public class Node<K, V> {
    private K key;
    private V value;
    private Node<K, V> next;
    private long hashCode;
    public K getKey() {
        return key;
    }
    public void setKey(K key) {
        this.key = key;
    }
    public V getValue() {
        return value;
    }
    public void setValue(V value) {
        this.value = value;
    }
    public Node<K, V> getNext() {
        return next;
    }
    public void setNext(Node<K, V> next) {
        this.next = next;
    }
    public long getHashCode() {
        return hashCode;
    }
    public void setHashCode(long hashCode) {
        this.hashCode = hashCode;
    }
}",0,0,0,0,0,0,0,0,0
113,"package cuckoo;
import java.util.concurrent.atomic.AtomicMarkableReference;
public class Node<T> {
    AtomicMarkableReference<Node<T>> next;
    long version;
    T object;
    Node(T o) {
        object = o;
    }
    public Node(Node<T> next, long version, T object) {
        this.next = new AtomicMarkableReference<Node<T>>(next, false);
        this.version = version;
        this.object = object;
    }
}",0,0,0,0,0,0,0,0,0
114,"class Node {
	int data;
	Node next;
	public Node(int data) {
		this.data = data;
		this.next = null;
	}
}",0,0,0,0,0,0,0,0,0
115,"package net.intelie.tinymap;
public interface ObjectCache {
    Double get(double value);
    String get(CharSequence cs);
    <B extends CacheableBuilder<B, T>, T> T get(B builder);
    <B, T> T get(B builder, CacheAdapter<B, T> adapter);
}",0,0,0,0,0,0,0,0,0
116,"package org.perfecthashmap;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class PerfectHashMap<K, V> implements Map<K, V> {
	private final Object[] keys;
	private final Object[] values;
	private PerfectHashMap(Object[] keys, Object[] values) {
		this.keys   = keys;
		this.values = values;
	}
	@Override public boolean containsKey(Object key) {
		return keys[indexFor(key)] != null;
	}
	@Override public boolean containsValue(Object value) {
		for (Object v: values) {
			if(v == null && value == null)   return true;
			if(v != null && v.equals(value)) return true;
		}
		return false;
	}
	@Override public void clear() {
		for(int i = 0, n = values.length; i < n; ++i) {
			keys[i]   = null;
			values[i] = null;
		}
	}
	@SuppressWarnings(""unchecked"")
	@Override public V get(Object key) {
		return (V)values[indexFor(key)];
	}
	@Override public boolean isEmpty() {
		return size() == 0;
	}
	@Override public Set<Entry<K, V>> entrySet() {
		Set<Entry<K, V>> result = new HashSet<Entry<K, V>>(keys.length);
		for (final Object key: keys) {
			Entry<K, V> entry = new Entry<K, V>() {
				@SuppressWarnings(""unchecked"")
				@Override public K getKey() {
					return (K)key;
				}
				@SuppressWarnings(""unchecked"")
				@Override public V getValue() {
					return (V)PerfectHashMap.this.values[PerfectHashMap.this.indexFor(key)];
				}
				@SuppressWarnings(""unchecked"")
				@Override public V setValue(V value) {
					int index = PerfectHashMap.this.indexFor(key);
					V oldValue = (V)PerfectHashMap.this.values[index];
					PerfectHashMap.this.values[index] = value;
					return oldValue;
				}
			};
			result.add(entry);
		}
		return result;
	}
	@SuppressWarnings(""unchecked"")
	@Override public Set<K> keySet() {
		Set<K> keySet = new HashSet<K>();
		for (Object key: keys) {
			if (key != null) keySet.add((K)key);
		}
		return keySet;
	}
	@Override public Collection<V> values() {
		List<V> values = new ArrayList<V>();
		for (Object key: keys) {
			if (key != null) values.add(get(key));
		}
		return values;
	}
	@SuppressWarnings(""unchecked"")
	@Override public V put(K key, V value) {
		int index = indexFor(key);
		Object oldKey   = keys[index];
		Object oldValue = values[index];
		if (oldKey != null && !oldKey.equals(key)) {
			throw new IllegalArgumentException(""Cannot insert key '""+key+""' because it's a new key."");
		}
		keys[index]   = key;
		values[index] = value;
		return (V)oldValue;
	}
	@Override public void putAll(Map<? extends K, ? extends V> map) {
		for(Entry<? extends K, ? extends V> entry: map.entrySet()) {
			put(entry.getKey(), entry.getValue());
		}
	}
	@SuppressWarnings(""unchecked"")
	@Override public V remove(Object key) {
		int index = indexFor(key);
		Object o = values[index];
		keys[index]   = null;
		values[index] = null;
		return (o == null)? null : (V)o;
	}
	@Override public int size() {
		int size = 0;
		for (Object o: keys) {
			if (o != null) ++size;
		}
		return size;
	}
	private int indexFor(Object key) {
		return indexFor(key, keys.length);
	}
	private static int indexFor(Object key, int size) {
		return key.hashCode() & (size - 1);
	}
	public static <K, V> Builder<K, V> newBuilder() {
		return new Builder<K, V>();
	}
	public static class Builder<K, V> {
		private final Map<K, V> map = new HashMap<K, V>();
		private Builder() {}
		public Builder<K, V> add(K key, V value) {
			map.put(key, value);
			return this;
		}
		public Builder<K, V> addAll(Map<K, V> map) {
			for (Entry<K, V> entry: map.entrySet()) {
				add(entry.getKey(), entry.getValue());
			}
			return this;
		}
		public <K1 extends K, V1 extends V> Map<K1, V1> build() {
			if (map.size() == 0) return new PerfectHashMap<K1, V1>(new Object[0], new Object[0]);
			assertCollisionFree();
			int size = findSize();
			Object[] keys   = new Object[size];
			Object[] values = new Object[size];
			for (Entry<K, V> entry: map.entrySet()) {
				int index = indexFor(entry.getKey(), size);
				keys[index]   = entry.getKey();
				values[index] = entry.getValue();
			}
			return new PerfectHashMap<K1, V1>(keys, values);
		}
		public float fillrate() {
			if (map.size() == 0) return 0;
			int size = findSize();
			return ((float)map.size())/size;
		}
		private int findSize() {
			Set<K> keys = map.keySet();
			int size = 1;
			while(hasCollisions(size, keys)) size <<= 1;
			return size;
		}
		private void assertCollisionFree() {
			final Set<Integer> hashCodes = new HashSet<Integer>();
			for (K key: map.keySet()) {
				int hashCode = key.hashCode();
				if(hashCodes.contains(hashCode)) throw new IllegalArgumentException(""HashCode collision."");
				hashCodes.add(hashCode);
			}
		}
		private boolean hasCollisions(int size, Set<K> keys) {
			final BitSet usedIndexes = new BitSet(size);
			for (K key: keys) {
				int index = indexFor(key, size);
				if (usedIndexes.get(index)) return true;
				usedIndexes.set(index);
			}
			return false;
		}
	}
}",0,0,0,0,0,0,0,0,1
117,"package com.jamierf.persistenthashmap;
import com.jamierf.persistenthashmap.serializers.OOSSerializer;
import com.jamierf.persistenthashmap.serializers.ObjectSerializer;
import com.jamierf.persistenthashmap.util.FileUtils;
import java.io.*;
import java.text.DecimalFormat;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
public class PersistentHashMap<K extends Serializable, V extends Serializable> implements Map<K, V> {
	protected static final int MAX_CAPACITY = 1000000001;
	protected static final DecimalFormat format = new DecimalFormat(""000000000"");
	protected static final int ZIP_BUFFER_SIZE = 4096;
	protected EntrySet<K, V> entrySet;
	protected KeySet<K, V> keySet;
	protected ValueSet<K, V> valueSet;
	protected File root;
	protected File keyStore;
	protected File valueStore;
	protected boolean force;
	protected ObjectSerializer serializer;
	public PersistentHashMap(File root) {
		this(root, true);
	}
	public PersistentHashMap(File root, boolean force) {
		this(root, new OOSSerializer(), force);
	}
	public PersistentHashMap(File root, ObjectSerializer serializer, boolean force) {
		this.root = root;
		this.serializer = serializer;
		this.force = force;
		if (!root.isDirectory())
			root.mkdir();
		keyStore = new File(root, ""keys"");
		if (!keyStore.isDirectory())
			keyStore.mkdir();
		valueStore = new File(root, ""values"");
		if (!valueStore.isDirectory())
			valueStore.mkdir();
		entrySet = new EntrySet<K, V>(this);
		keySet = new KeySet<K, V>(this);
		valueSet = new ValueSet<K, V>(this);
	}
	public synchronized boolean containsKey(Object key) {
		try {
			return getFileName(key, false) != null;
		}
		catch (IOException ioe) {
			return false;
		}
	}
	public synchronized boolean containsValue(Object v) {
		Collection<V> values = values();
		for (V value : values)
			if (v.equals(value))
				return true;
		return false;
	}
	@SuppressWarnings(""unchecked"")
	public synchronized V get(Object key) {
		try {
			String fileName = getFileName(key, false);
			if (fileName == null)
				return null;
			File valueFile = new File(valueStore, fileName);
			return (V) serializer.readObject(valueFile);
		}
		catch (IOException ioe) {
			return null;
		}
	}
	@SuppressWarnings(""unchecked"")
	public synchronized V put(K key, V value) {
		try {
			V oldValue = null;
			String fileName = getFileName(key, true);
			File keyFile = new File(keyStore, fileName);
			File valueFile = new File(valueStore, fileName);
			if (valueFile.exists())
				oldValue = (V) serializer.readObject(valueFile);
			serializer.writeObject(keyFile, key, force);
			serializer.writeObject(valueFile, value, force);
			return oldValue;
		}
		catch (IOException ioe) {
			return null;
		}
	}
	public synchronized void putAll(Map<? extends K, ? extends V> m) {
		for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
			put (e.getKey(), e.getValue());
		}
	}
	@SuppressWarnings(""unchecked"")
	public synchronized V remove(Object key) {
		try {
			String fileName = getFileName(key, false);
			File keyFile = new File(keyStore, fileName);
			File valueFile = new File(valueStore, fileName);
			V oldValue = (V) serializer.readObject(valueFile);
			keyFile.delete();
			valueFile.delete();
			while(!keyFile.getParentFile().equals(keyStore)
				&& keyFile.getParentFile().listFiles().length == 0) {
					keyFile.getParentFile().delete();
					keyFile = keyFile.getParentFile();		
			}
			while(!valueFile.getParentFile().equals(valueStore)
				&& valueFile.getParentFile().listFiles().length == 0) {
					valueFile.getParentFile().delete();
					valueFile = valueFile.getParentFile();
			}
			return oldValue;
		}
		catch (IOException ioe) {
			return null;
		}
	}
	public synchronized boolean isEmpty() {
		return keyStore.listFiles().length == 0;
	}
	public synchronized int size() {
		if (isEmpty())
			return 0;
		return countDirectory(keyStore);
	}
	public synchronized void clear() {
		File[] keyFiles = root.listFiles();
        if (keyFiles != null) {
            for (File f : keyFiles) {
                FileUtils.deleteDirectory(f);
            }
        }
		keyStore.mkdir();
		valueStore.mkdir();
	}
	public synchronized Collection<V> values() {
		return valueSet;
	}
	public synchronized Set<K> keySet() {
		return keySet;
	}
	public synchronized Set<Map.Entry<K, V>> entrySet() {
		return entrySet;
	}
	public synchronized boolean toZip(File zipFile) {
		try {
			FileOutputStream fos = new FileOutputStream(zipFile);
			fos.getChannel().force(force);
			ZipOutputStream zos = new ZipOutputStream(fos);
			zipDirectory(root, zos);
			zos.close();
			return true;
		}
		catch (IOException ioe) {
			return false;
		}
	}
	protected void zipDirectory(File dir, ZipOutputStream zos) throws IOException {
		File[] files = dir.listFiles();
		for (File f : files) {
			if (f.isDirectory()) {
				zipDirectory(f, zos);
				continue;
			}
			zos.putNextEntry(new ZipEntry(f.getPath()));
			BufferedInputStream in = new BufferedInputStream(new FileInputStream(f), ZIP_BUFFER_SIZE);
			byte[] buffer = new byte[ZIP_BUFFER_SIZE];
			for (int count;(count = in.read(buffer, 0, ZIP_BUFFER_SIZE)) != -1;)
				zos.write(buffer, 0, count);
			in.close();
		}
	}
	protected int countDirectory(File dir) {
		if (!dir.isDirectory())
			return 0;
		int count = 0;
		File[] files = dir.listFiles();
		for (File f : files) {
			if (f.isDirectory())
				count += countDirectory(f);
			else
				count++;
		}
		return count;
	}
	@SuppressWarnings(""unchecked"")
	protected String getFileName(Object key, boolean create) throws IOException {
		String fileName = getFileName(key);
		File keyFile = null;
		String dirName = fileName.substring(0, 9);
		File keyDir = new File(keyStore, dirName);
		File valueDir = new File(valueStore, dirName);
		if (create) {
			keyDir.mkdirs();
			valueDir.mkdirs();
		}
		else if (!keyDir.isDirectory() || !valueDir.isDirectory())
			return null;
		String fileNameI = null;
		for (int i = 0;true;i++) {
			fileNameI = fileName + i;
			keyFile = new File(keyStore, fileNameI);
			if (!keyFile.exists()) {  
				if (!create)
					return null;
				else
					break;
			}
			K candidateKey = (K) serializer.readObject(keyFile);
			if (key.equals(candidateKey))  
				break;
		}
		return fileNameI;
	}
	protected String getFileName(Object key) {
		String fileName = format.format((key.hashCode() & 0x7FFFFFFF) % MAX_CAPACITY);
		StringBuffer buffer = new StringBuffer(12);
		buffer.append(fileName.substring(7)).append(File.separator);	 
		buffer.append(fileName.substring(5,7)).append(File.separator);	 
		buffer.append(fileName.substring(3,5)).append(File.separator);	 
		buffer.append(fileName.substring(0,3));
		return buffer.toString();
	}
	protected class FileIterator implements Iterator<File> {
		private static final int MAX_DEPTH = 4;
		private static final int NOT_STARTED = -1;
		protected File root;
		protected File current;
		protected File[][] files;
		protected int[] indices;
		public FileIterator(File root) {
			this.root = root;
			files = new File[MAX_DEPTH][];
			indices = new int[MAX_DEPTH];
			Arrays.fill(indices, NOT_STARTED);
			current = null;
		}
		public boolean hasNext() {
			synchronized (PersistentHashMap.this) {
				try {
					return iterateFiles(root, 0, false) != null;
				} catch (IOException e) {
					return false;
				}
			}
		}
		public File next() {
			synchronized (PersistentHashMap.this) {
				try {
					current = iterateFiles(root, 0, true);
					return current;
				}
				catch (IOException ioe) {
					return null;
				}
			}
		}
		public void remove() {
			synchronized (PersistentHashMap.this) {
				if (current == null)
					return;
				current.delete();
			}
		}
		protected File iterateFiles(File dir, int index, boolean increment) throws IOException {
			if (!dir.exists())
				return null;
			if (indices[index] == NOT_STARTED) {
				indices[index] = 0;
				files[index] = dir.listFiles();
			}
			if (indices[index] >= files[index].length){
				indices[index] = NOT_STARTED;
				files[index] = null;
				return null;
			}
			File currentFile = files[index][indices[index]];
			if (currentFile.isDirectory()) {
				File subFile = null;
				while ((subFile = iterateFiles(currentFile, index + 1, increment)) == null) {
					indices[index]++;
					if (indices[index] >= files[index].length) {
						indices[index] = NOT_STARTED;
						files[index] = null;
						return null;
					}
					currentFile = files[index][indices[index]];
				}
				return subFile;
			}
			else {
				if (increment)
					indices[index]++;
				return currentFile;
			}
		}
	}
}",0,0,0,0,0,1,0,0,1
118,"package com.simplemapstore;
import java.io.UnsupportedEncodingException;
public class PersistentMapException extends RuntimeException {
    public PersistentMapException(Exception e) {
        super(e);
    }
}",0,0,0,0,0,0,0,0,0
119,"from .hash_table import HashTable
class QuadraticProbing(HashTable):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    def _colision_resolution(self, key, data=None):
        i = 1
        new_key = self.hash_function(key + i*i)
        while self.values[new_key] is not None                and self.values[new_key] != key:
            i += 1
            new_key = self.hash_function(key + i*i) if not                self.balanced_factor() >= self.lim_charge else None
            if new_key is None:
                break
        return new_key",0,0,0,0,0,0,0,0,0
120,"class QuadraticProbing extends AbstractHashSequence {
  private int j;
  public QuadraticProbing(HashFunction f) {
    super(f);
  }
  @Override
  public int first(Object key) {
    j = 0;
    return prev = func.compute(key);
  }
  @Override
  public int next() {
    j += 1;
    return prev = (prev + j) % size();
  }
}",0,0,0,0,0,0,0,0,0
121,"package main;
import java.util.LinkedList;
public class RedBlackTree<K extends Comparable<? super K>, V> {
    public TreeNode<K, V> root;
    public void leftRotate(TreeNode<K, V> x) {  
        TreeNode<K, V> y = x.right;
        x.right = y.left;
        if(y.left != null)y.left.parent = x;
        y.parent = x.parent;
        if (x.parent == null) {
            assert this.root == x;
            root = y;
        } else if (x == x.parent.left) {
            x.parent.left = y;
        } else {
            x.parent.right = y;
        }
        y.left = x;
        x.parent = y;
    }
    public void rightRotate(TreeNode<K, V> y) {  
        TreeNode<K, V> x = y.left;
        y.left = x.right;
        if(x.right != null)x.right.parent = y;
        x.parent = y.parent;
        if (y.parent == null) {
            assert this.root == y;
            this.root = x;
        } else if (y == y.parent.right) {
            y.parent.right = x;
        } else {
            y.parent.left = x;
        }
        x.right = y;
        y.parent = x;
    }
    public V insert(K key, V val) {
        if(key == null) return null;
        TreeNode<K, V> y = null;
        TreeNode<K, V> x = this.root;
        while (x != null) {
            y = x;
            if (key.compareTo(x.key) == -1) {
                x = x.left;
            } else if (key.compareTo(x.key) == 1) {
                x = x.right;
            } else {
                x.val = val;
                return val;
            }
        }
        TreeNode<K, V> z = new TreeNode<>(Color.RED, key, val);
        z.parent = y;
        if (y == null) {
            root = z;
        } else if (z.key.compareTo(y.key) == -1) {
            y.left = z;
        } else {
            y.right = z;
        }
        insertFixup(z);
        return val;
    }
    public void insertFixup(TreeNode<K, V> z) {
        while (z.parent != null && z.parent.parent != null && z.parent.color == Color.RED) {
            if (z.parent == z.parent.parent.left) {
                TreeNode<K, V> y = z.parent.parent.right;
                if (y != null && y.color == Color.RED) {
                    z.parent.color = Color.BLACK;
                    y.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    z = z.parent.parent;
                } else {
                    if (z == z.parent.right) {
                        z = z.parent;
                        leftRotate(z);
                    }
                    z.parent.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    rightRotate(z.parent.parent);
                }
            } else {
                TreeNode<K, V> y = z.parent.parent.left;
                if (y != null && y.color == Color.RED) {
                    z.parent.color = Color.BLACK;
                    y.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    z = z.parent.parent;
                } else {
                    if (z == z.parent.left) {
                        z = z.parent;
                        rightRotate(z);
                    }
                    z.parent.color = Color.BLACK;
                    z.parent.parent.color = Color.RED;
                    leftRotate(z.parent.parent);
                }
            }
        }
        this.root.color = Color.BLACK;
    }
    public TreeNode<K, V> higherEntry(K key){
        TreeNode<K, V> x = this.find(key);
        if(x == null) return null;
        if(x.right != null){
            x = x.right;
            while(x.left != null){
                x = x.left;
            }
            return x;
        }else{
            while(x.parent != null){
                if(x.parent.left == x)return x;
                x = x.parent;
            }
            return null;
        }
    }
    public TreeNode<K, V> find(K key){
        TreeNode<K, V> x = this.root;
        while(x != null){
            if(key.compareTo(x.key) == 0){
                return x;
            }else if(key.compareTo(x.key) == -1){
                x = x.left;
            }else{
                x = x.right;
            }
        }
        return null;
    }
    public V get(K key){
        TreeNode<K,V> res = find(key);
        if(res == null) return null;
        return res.val;
    }
    public TreeNode<K, V> getMinimum(TreeNode<K, V> x){
        if(x == null) return null;
        while(x.left != null) x = x.left;
        return x;
    }
    public TreeNode<K, V> getSuccessor(TreeNode<K, V> x){
        if(x == null) return null;
        if(x.right != null){
            return getMinimum(x.right);
        }
        TreeNode<K, V> y = x.parent;
        while(y != null && x == y.right){
            x = y;
            y = y.parent;
        }
        return y;
    }
    public V delete(K key){
        if(key == null)return null;
        TreeNode<K, V> z = this.find(key);
        if(z == null){
            return null;
        }
        V removedVal = z.val;
        TreeNode<K, V> y = null;
        if(z.left == null || z.right == null){
            y = z;
        }else{
            y = getSuccessor(z);
        }
        TreeNode<K, V> x = null;
        if(y.left != null){
            x = y.left;
        }else{
            x = y.right;
        }
        if(x != null)x.parent = y.parent;
        if(y.parent == null){
            this.root = x;
        }else if(y == y.parent.left){
            y.parent.left = x;
        }else{
            y.parent.right = x;
        }
        if(y != z){
            z.key = y.key;
            z.val = y.val;
        }
        if(y.color == Color.BLACK){
            deleteFixup(x);
        }
        return removedVal;
    }
    public void deleteFixup(TreeNode<K, V> x){
        if(x == null) return;
        TreeNode<K, V> w = null;
        while(x != this.root && x.color == Color.BLACK){
            if(x == x.parent.left){
                w = x.parent.right;
                if(w.color == Color.RED){
                    w.color = Color.BLACK;
                    x.parent.color = Color.RED;
                    leftRotate(x.parent);
                    w = x.parent.right;
                }
                if((w.left == null || w.left.color == Color.BLACK) && (w.right == null || w.right.color == Color.BLACK)){
                    w.color = Color.RED;
                    x = x.parent;
                }else if(w.right == null || w.right.color == Color.BLACK){
                    if(w.left != null)w.left.color = Color.BLACK;
                    w.color = Color.RED;
                    rightRotate(w);
                    w = x.parent.right;
                    x.parent.color = Color.BLACK;
                    if(w.right != null)w.right.color = Color.BLACK;
                    leftRotate(x.parent);
                    x = this.root;
                }
            }else{
                w = x.parent.left;
                if(w.color == Color.RED){
                    w.color = Color.BLACK;
                    x.parent.color = Color.RED;
                    rightRotate(x.parent);
                    w = x.parent.left;
                }
                if((w.right == null ||w.right.color == Color.BLACK) && (w.left == null || w.left.color == Color.BLACK)){
                    w.color = Color.RED;
                    x = x.parent;
                }else if(w.left == null || w.left.color == Color.BLACK){
                    if(w.right != null)w.right.color = Color.BLACK;
                    w.color = Color.RED;
                    leftRotate(w);
                    w = x.parent.left;
                    x.parent.color = Color.BLACK;
                    if(w.left != null)w.left.color = Color.BLACK;
                    rightRotate(x.parent);
                    x = this.root;
                }
            }
        }
        x.color = Color.BLACK;
    }
    @Override
    public String toString(){
        LinkedList<TreeNode<K, V>> queue = new LinkedList<>();
        StringBuilder sb = new StringBuilder();
        queue.addLast(root);
        while(!queue.isEmpty()){
            int size = queue.size();
            while(size != 0){
                TreeNode<K, V> node = queue.removeFirst();
                size--;
                if(node == null){
                    sb.append(""#,"");
                }else{
                    sb.append(node.key.toString());
                    sb.append(""("");
                    sb.append(node.val.toString());
                    sb.append("","");
                    sb.append(node.color);
                    sb.append("")"");
                    sb.append("","");
                    queue.addLast(node.left);
                    queue.addLast(node.right);
                }
            }
        }
        return sb.toString();
    }
}",0,0,0,0,0,0,0,0,0
122,"package main;
public class RedBlackTreeInteger extends RedBlackTree<Integer, Integer>{
    public Integer increase(Integer key, Integer addition){
        TreeNode<Integer,Integer> node = find(key);
        if(node == null){
            if(addition <= 0){
                return 0;
            }else{
                insert(key, addition);
            }
            return addition;
        }else{
            node.val = node.val + addition;
            if(node.val <= 0){
                delete(key);
            }
            return node.val;
        }
    }
    public Integer reduce(Integer key, Integer substraction){
        TreeNode<Integer,Integer> node = find(key);
        if(node == null){
            return 0;
        }else{
            node.val = node.val - substraction;
            Integer value = node.val;
            if(node.val <= 0){
                delete(key);
            }
            return value < 0 ? 0 : value;
        }
    }
    public Integer count(Integer key){
        TreeNode<Integer,Integer> node = find(key);
        if(node == null) return 0;
        else return node.val;
    }
    public Integer inRange(Integer id1, Integer id2){
        return inRangeHelper(root, id1, id2);
    }
    public Integer inRangeHelper(TreeNode<Integer, Integer> node, Integer id1, Integer id2){
        if(id1 > id2 || node == null) return 0;
        Integer sum = 0;
        if(node.key <= id2 && node.key >= id1){
            sum += node.val;
        }
        if(node.key > id1 && node.key < id2){
            sum += inRangeHelper(node.left, id1, id2);
            sum += inRangeHelper(node.right, id1, id2);
        }else if(node.key >= id2){
            sum += inRangeHelper(node.left, id1, id2);
        }else if(node.key <= id1){
            sum += inRangeHelper(node.right, id1, id2);
        }
        return sum;
    }
    public TreeNode<Integer, Integer> next(Integer theId){
        TreeNode<Integer, Integer> res = nextHelper(this.root, theId, null);
        if(res == null) return new TreeNode<Integer,Integer>(Color.BLACK, 0, 0);
        else return res;
    }
    public TreeNode<Integer, Integer> nextHelper(TreeNode<Integer, Integer> node, Integer target, TreeNode<Integer, Integer> candidate){
        if(node == null) return candidate;
        if(node.key > target) candidate = node;
        if(node.key <= target) return nextHelper(node.right, target, candidate);
        else return nextHelper(node.left, target, candidate);
    }
    public TreeNode<Integer, Integer> previous(Integer theId){
        TreeNode<Integer, Integer> res = previousHelper(this.root, theId, null);
        if(res == null) return new TreeNode<Integer,Integer>(Color.BLACK, 0, 0);
        else return res;
    }
    public TreeNode<Integer, Integer> previousHelper(TreeNode<Integer, Integer> node, Integer target, TreeNode<Integer, Integer> candidate){
        if(node == null) return candidate;
        if(node.key < target) candidate = node;
        if(node.key < target) return previousHelper(node.right, target, candidate);
        else return previousHelper(node.left, target, candidate);
    }
}",0,0,0,0,0,0,0,0,0
123,"package Hashtables.LinearProbing;
import Hashtables.Employee;
public class SimpleHashtable {
    private StoredEmployee[] hashtable;
    public SimpleHashtable() {
        hashtable = new StoredEmployee[10];
    }
    public void put(String key, Employee employee) {
        int hashedKey = hashKey(key);
        if (occupied(hashedKey)) {
            int stopIndex = hashedKey;  
            if (hashedKey == hashtable.length - 1) {  
                hashedKey = 0;
            }
            else {
                hashedKey++;
            }
            while (occupied(hashedKey) && hashedKey != stopIndex) {  
                hashedKey = (hashedKey + 1) % hashtable.length;
            }
        }
        if (occupied(hashedKey)) {
            System.out.println(""Sorry, there's already an employee at position "" + hashedKey);
        }
        else {
            hashtable[hashedKey] = new StoredEmployee(key, employee);
        }
    }
    public Employee remove(String key) {
        int hashedKey = findKey(key);
        if (hashedKey == -1) {
            return null;
        } else {
            Employee employee = hashtable[hashedKey].employee;
            hashtable[hashedKey] = null;
            StoredEmployee[] oht = hashtable;  
            hashtable = new StoredEmployee[oht.length];
            for (int i = 0; i < oht.length ; i++) {
                if (oht[i]!=null){
                    put(oht[i].key,oht[i].employee);
                }
            }
            return employee;
        }
    }
    public Employee get(String key) {
        int hashedKey = findKey(key);
        if (hashedKey == -1) {
            return null;  
        }
        return hashtable[hashedKey].employee;
    }
    private int hashKey(String key) {
        return key.length() % hashtable.length;
    }
    private int findKey(String key) {
        int hashedKey = hashKey(key);
        if (hashtable[hashedKey] != null && hashtable[hashedKey].key.equals(key)) {
            return hashedKey;
        }
        int stopIndex = hashedKey;
        if (hashedKey == hashtable.length - 1) {
            hashedKey = 0;
        }
        else {
            hashedKey++;
        }
        while (hashedKey != stopIndex && hashtable[hashedKey] != null && !hashtable[hashedKey].key.equals(key)) {
            hashedKey = (hashedKey + 1) % hashtable.length;
        }
        if (hashtable[hashedKey]!=null && hashtable[hashedKey].key.equals(key)){
            return hashedKey;
        }
        else{
            return -1;
        }
    }
    private boolean occupied(int index) {
        return hashtable[index] != null;
    }
    public void printHashtable() {
        for (int i = 0; i < hashtable.length; i++) {
            if (hashtable[i] == null) {
                System.out.println(""empty"");
            }
            else {
                System.out.println(""Position "" + i + "": "" +hashtable[i].employee);
            }
        }
    }
}",0,0,0,0,0,1,0,0,1
124,"package Hashtables.ByArray;
import Hashtables.Employee;
public class SimpleHashtable {
    private Employee[] hashtable;
    public SimpleHashtable() {
        hashtable = new Employee[10];
    }
    public void put(String key, Employee employee) {
        int hashedKey = hashKey(key);  
        if (hashtable[hashedKey] != null) {  
            System.out.println(""Sorry, there's already an employee at position "" + hashedKey);
        }
        else {  
            hashtable[hashedKey] = employee;
        }
    }
    public Employee get(String key) {
        int hashedKey = hashKey(key);  
        return hashtable[hashedKey];  
    }
    private int hashKey(String key) {
        return key.length() % hashtable.length;
    }
    public void printHashtable() {
        for (int i = 0; i < hashtable.length; i++) {
            System.out.println(hashtable[i]);
        }
    }
}",0,0,0,0,0,0,0,0,1
125,"package maps.sortofvaluesinmap;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
public class SortOnValuesInMap {
    private SortOnValuesInMap() {
    }
    public static Map<String, Integer> sortOnValuesInMap(Map<String, Integer> inputMap) {
        ValueComparator valueComparator = new ValueComparator(inputMap);
        Map<String, Integer> sortedMapOnValue = new TreeMap<>(valueComparator);
        sortedMapOnValue.putAll(inputMap);
        return sortedMapOnValue;
    }
    static class ValueComparator implements Comparator<String> {
        private Map<String, Integer> inputMap;
        public ValueComparator(Map<String, Integer> inputMap) {
            this.inputMap = inputMap;
        }
        @Override
        public int compare(String string1, String string2) {
            if (inputMap.get(string1) > inputMap.get(string2)) {
                return -1;
            } else {
                return 1;
            }
        }
    }
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put(""A"", 2);
        map.put(""B"", 1);
        map.put(""C"", 3);
        map.put(""D"", 0);
        map.put(""E"", 8);
        Map<String, Integer> output = sortOnValuesInMap(map);
        for (String temp : output.keySet()) {
            System.out.println(temp);
        }
    }
}",0,0,0,0,0,0,0,0,0
126,"package Hashtables.LinearProbing;
import Hashtables.Employee;
public class StoredEmployee {
    public String key;  
    public Employee employee;
    public StoredEmployee(String key, Employee employee) {
        this.key = key;
        this.employee = employee;
    }
}",0,0,0,0,0,0,0,0,0
127,"package assignment6;
import java.util.*;
public class StringColl {
    private btNode c;  
    private int howmany;  
    public StringColl() {
        c = null;  
        howmany = 0;  
    }
    public StringColl(int i) {
        c = null;
        howmany = 0;
    }
    public void copy(StringColl obj) {
        if (this != obj) {  
            howmany = obj.howmany;  
            c = copytree(obj.c);  
        }
    }
    private static btNode copytree(btNode t) {
        btNode root = null;  
        if (t != null) {  
            root = new btNode();  
            root.info = t.info;  
            root.left = copytree(t.left);  
            root.right = copytree(t.right);  
        }
        return root;  
    }
    public boolean belongs(String i) {
        btNode p = c;  
        while ((p != null) && !(p.info.equals(i))) {  
            if (p.info.compareTo(i) > 0) {  
                p = p.left;  
            } else {
                p = p.right;  
            }
        }
        return (p != null);  
    }    
    public void insert(String i) {
        btNode pred = null, p = c;  
        while ((p != null) && !(p.info.equals(i))) {  
            pred = p;  
            if (p.info.compareTo(i) > 0) p = p.left;  
            else p = p.right;  
        }
        if (p == null) {  
            howmany++;  
            p = new btNode(i, null, null);  
            if (pred != null) {  
                if (pred.info.compareTo(i) > 0) pred.left = p;  
                else pred.right = p;  
            } else c = p;  
        }
    }
    public void omit(String i) {
        btNode p = c, pred = null;  
        while ((p != null) && !(p.info.equals(i))) {  
            pred = p;  
            if (p.info.compareTo(i) > 0) p = p.left;  
            else p = p.right;  
        }
        if (p != null) {  
            if (pred == null) {  
                if (p.left != null) {  
                    btNode last = p;  
                    pred = p.left;  
                    p = p.left.right;  
                    while (p != null) {  
                        last = pred;  
                        pred = p;  
                        p = p.right;  
                    } 
                    c.info = pred.info;  
                    if (last == c) c.left = pred.left;  
                    else last.right = pred.left;  
                } else {
                    c = c.right;  
                }
            } else {
                if (p.left != null) {  
                    if(p.right != null) {  
                        btNode d = p, last = p;  
                        pred = d.left;  
                        d = d.left.right;  
                        while (d != null) {  
                            last = pred;  
                            pred = d;  
                            d = d.right;  
                        }
                        p.info = pred.info;  
                        if (last == p) last.left = pred.left;  
                        else last.right = pred.left;  
                    } else {
                        if (pred.info.compareTo(p.info) > 0) pred.left = p.left;  
                        else pred.right = p.left;  
                    }
                } else {
                    if (pred.info.compareTo(p.info) > 0) pred.left = p.right;  
                    else pred.right = p.right;  
                }
            }
            howmany--;  
        }
    }
    public int get_howmany() {
        return howmany;
    }
    public void print() {
        printtree(c);
    }
    private static void printtree(btNode t) {
        if (t != null) {
            printtree(t.left);
            System.out.println(t.info);
            printtree(t.right);
        }
    }
    public boolean equals(StringColl obj) {
        int j = 0; boolean result = (howmany == obj.howmany);  
        if (result) {  
            String[] a = new String[howmany];  
            String[] b = new String[howmany];  
            toarray(c, a, 0);  
            toarray(obj.c, b, 0);  
            j = 0;  
            while ((result) && (j < howmany)) {  
                result = (a[j].equals(b[j])); j++;  
            }
        }
        return result;  
    }
    private static int toarray(btNode t, String[] a, int i) {
        int num_nodes = 0;  
        if (t != null) {  
            num_nodes = toarray(t.left, a, i);  
            a[num_nodes + i] = t.info;  
            num_nodes = num_nodes + 1 + toarray(t.right, a, num_nodes + i + 1);  
        }
        return num_nodes;  
    }
    private static class btNode {
        private String info;
        private btNode left;
        private btNode right;
        private btNode(String s, btNode lt, btNode rt) {
            info = s; left = lt; right = rt;
        }
        private btNode() {
            info = null; left = null; right = null;
        }
    }
}",0,0,0,0,0,0,0,0,0
128,"package assignment6;
import java.util.*;
public class StringCollClient
{
   public static final String SENTINEL = ""###"";
   public static void main(String[] args)
   {
      String input; Scanner keyboard=new Scanner(System.in);
      StringColl P=new StringColl(), N=new StringColl(), L= new StringColl();
      System.out.println(""Enter a +String to be inserted or a -String to be removed or ### to quit:"");
      input=keyboard.nextLine();
      while(!(input.equals(SENTINEL)))
      {
         if (input.charAt(0) == '+') {P.insert(input.substring(1)); L.insert(input.substring(1));}
         else if(input.charAt(0) == '-') {N.insert(input.substring(1)); L.omit(input.substring(1));}
         System.out.println(""Enter next string to be inserted or removed or ### to quit:"");
         input=keyboard.nextLine();
      }
      System.out.println(""\nThe inputs in collection P are:"");
      P.print();
      System.out.println(""\nThe inputs in collection N are:"");
      N.print();
      System.out.println(""\nThe inputs in collection L are:"");
      L.print();
      if (P.equals(L)) System.out.println(""\nP and L are equal."");
      else System.out.println(""\nP and L are NOT equal."");
      StringColl A=new StringColl(); A.copy(L);
      System.out.println(""\nThe inputs in the copy of L are:\n"");
      A.print();
      String x = ""test"";
      if(P.belongs(x))
         System.out.println(""\n"" + x + "" is in collection P"");
      else
         System.out.println(""\n"" + x + "" is not in collection P"");
   }
}",0,0,0,0,0,0,0,0,0
129,"public class Student {
	String nume;
	int varsta;
	public Student(String nume,int varsta)
	{
		this.nume=nume;
		this.varsta=varsta;
	}
	@Override
	public int hashCode()
	{
		int h=17;
		h=37*h+nume.hashCode();
		h=37*h+varsta;
		return h;
	}
	@Override
	public boolean equals(Object o)
	{
		if(this.nume.equals(((Student)o).nume))
			if(this.varsta==((Student)o).varsta)
				return true;
		return false;
	}
}",0,0,0,0,0,0,0,0,0
130,"public class Test {
    public static void main(String[] args) {
        Nashmap map = new Nashmap(10);
        System.out.println(20 % 10);
        map.put(""foobkkar"", ""shrek"");
        System.out.println(map.get(""foobkkar""));
        System.out.println(map.isEmpty());
        map.delete(""foobar"");
        System.out.println(map.isEmpty());
        map.get(""foobar"");
        map.put(""foobar"", ""zoop"");
        System.out.println(map.get(""foobar""));
    }
}",0,0,0,0,0,0,0,0,0
131,"package net.intelie.tinymap;
import net.intelie.tinymap.base.IndexedListBase;
import java.io.Serializable;
public class TinyList<T> extends IndexedListBase<T> implements Serializable, IndexedListBase.Immutable<T> {
    private static final long serialVersionUID = 1L;
    private final Object[] values;
    public TinyList(Object[] values) {
        this.values = values;
    }
    public static <T> TinyListBuilder<T> builder() {
        return new TinyListBuilder<>();
    }
    @Override
    public int size() {
        return values.length;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public T getEntryAt(int index) {
        return (T) values[index];
    }
}",0,0,0,0,0,0,0,0,0
132,"package net.intelie.tinymap;
import net.intelie.tinymap.base.IndexedListBase;
import net.intelie.tinymap.util.Preconditions;
import java.io.Serializable;
import java.util.Arrays;
public class TinyListBuilder<T> extends IndexedListBase<T> implements CacheableBuilder<TinyListBuilder<T>, TinyList<T>>, Serializable {
    private static final long serialVersionUID = 1L;
    private static final Adapter<?> adapter = new Adapter<>();
    private Object[] values = new Object[4];
    private int size = 0;
    @Override
    public int addOrGetIndex(T obj) {
        int index = size++;
        if (index == values.length)
            values = Arrays.copyOf(values, values.length * 2);
        values[index] = obj;
        return ~index;
    }
    @Override
    public T set(int index, T obj) {
        T old = getEntryAt(index);
        values[index] = obj;
        return old;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public T getEntryAt(int index) {
        Preconditions.checkElementIndex(index, size);
        return (T) values[index];
    }
    public int size() {
        return size;
    }
    @Override
    public T removeLast() {
        T old = set(size - 1, null);
        size--;
        return old;
    }
    @Override
    public TinyList<T> build() {
        return new TinyList<>(Arrays.copyOf(values, size));
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public Adapter<T> adapter() {
        return (Adapter<T>) adapter;
    }
    public void clear() {
        Arrays.fill(values, 0, size, null);
        size = 0;
    }
    public TinyList<T> buildAndClear() {
        TinyList<T> answer = build();
        clear();
        return answer;
    }
    public static class Adapter<T> implements CacheAdapter<TinyListBuilder<T>, TinyList<T>> {
        @Override
        public int contentHashCode(TinyListBuilder<T> builder) {
            int hash = 1;
            for (int i = 0; i < builder.size; i++)
                if (!builder.isRemoved(i))
                    hash = 31 * hash + System.identityHashCode(builder.values[i]);
            return hash;
        }
        @SuppressWarnings(""unchecked"")
        @Override
        public TinyList<T> contentEquals(TinyListBuilder<T> builder, Object cached) {
            if (!(cached instanceof TinyList<?>) || builder.size != ((TinyList<?>) cached).size())
                return null;
            TinyList<T> list = (TinyList<T>) cached;
            for (int i = 0; i < builder.size; i++) {
                if (builder.values[i] != list.get(i))
                    return null;
            }
            return list;
        }
        @Override
        public TinyList<T> build(TinyListBuilder<T> builder, ObjectCache cache) {
            return builder.build();
        }
    }
}",0,0,0,0,0,0,0,0,0
133,"package net.intelie.tinymap;
import net.intelie.tinymap.base.IndexedMapBase;
import net.intelie.tinymap.util.TinyMapGenerated;
import java.io.Serializable;
public abstract class TinyMap<K, V> extends IndexedMapBase<K, V> implements Serializable {
    private static final long serialVersionUID = 1L;
    private final TinySet<K> keys;
    protected TinyMap(TinySet<K> keys) {
        this.keys = keys;
    }
    public static <K, V> TinyMap<K, V> createUnsafe(TinySet<K> keys, Object[] values) {
        return TinyMapGenerated.createUnsafe(keys, values);
    }
    public static <K, V> TinyMapBuilder<K, V> builder() {
        return new TinyMapBuilder<>();
    }
    public boolean sharesKeysWith(TinyMap<K, V> other) {
        return keys == other.keys;
    }
    public long debugCollisions(V key) {
        return keys.debugCollisions(key);
    }
    @Override
    public K getKeyAt(int index) {
        return keys.getEntryAt(index);
    }
    @Override
    public int size() {
        return keys.size();
    }
    @Override
    public int getIndex(Object key) {
        return keys.getIndex(key);
    }
    @Override
    public TinySet<K> keySet() {
        return keys;
    }
}",0,0,0,0,0,0,0,0,0
134,"package net.intelie.tinymap;
import net.intelie.tinymap.base.IndexedMapBase;
import net.intelie.tinymap.util.Preconditions;
import java.io.Serializable;
import java.util.Arrays;
public class TinyMapBuilder<K, V> extends IndexedMapBase<K, V> implements CacheableBuilder<TinyMapBuilder<K, V>, TinyMap<K, V>>, Serializable {
    private static final long serialVersionUID = 1L;
    public static final Object TOMBSTONE = new Serializable() {
        private static final long serialVersionUID = 1L;
        @Override
        public String toString() {
            return ""TOMBSTONE"";
        }
    };
    private static final Adapter<?, ?> adapter = new Adapter<>();
    private final TinySetBuilder<K> keys;
    private Object[] values;
    public TinyMapBuilder() {
        this(16);
    }
    public TinyMapBuilder(int expectedSize) {
        values = new Object[expectedSize];
        keys = new TinySetBuilder<K>(expectedSize) {
            private static final long serialVersionUID = 1L;
            @Override
            public void compact() {
                if (size() == rawSize()) return;
                int index = 0;
                int rawSize = rawSize();
                for (int i = 0; i < rawSize; i++) {
                    if (values[i] == TOMBSTONE) continue;
                    values[index++] = values[i];
                }
                Arrays.fill(values, index, rawSize, null);
                super.compact();
            }
        };
    }
    public void compact() {
        keys.compact();
    }
    public V put(K key, V value) {
        int index = keys.addOrGetIndex(key);
        if (index >= 0)
            return setValueAt(index, value);
        index = ~index;
        if (index >= values.length)
            values = Arrays.copyOf(values, values.length + (values.length >> 1));
        values[index] = value;
        return null;
    }
    @Override
    public int getIndex(Object key) {
        return keys.getIndex(key);
    }
    @Override
    public K getKeyAt(int index) {
        return keys.getEntryAt(index);
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public V getValueAt(int index) {
        Preconditions.checkElementIndex(index, rawSize());
        return (V) values[index];
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public V setValueAt(int index, V value) {
        Preconditions.checkElementIndex(index, rawSize());
        Object old = values[index];
        values[index] = value;
        return (V) old;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public V removeAt(int index) {
        keys.removeAt(index);
        Object old = values[index];
        values[index] = TOMBSTONE;
        return (V) old;
    }
    @Override
    public boolean isRemoved(int index) {
        return keys.isRemoved(index);
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public Adapter<K, V> adapter() {
        return (Adapter<K, V>) adapter;
    }
    public int size() {
        return keys.size();
    }
    @Override
    public int rawSize() {
        return keys.rawSize();
    }
    @Override
    public TinyMap<K, V> build() {
        return buildWithKeys(buildKeys());
    }
    public TinySet<K> buildKeys() {
        return this.keys.build();
    }
    public TinyMap<K, V> buildWithKeys(TinySet<K> keys) {
        compact();
        Preconditions.checkArgument(keys.size() == size(), ""Must have same size"");
        return TinyMap.createUnsafe(keys, Arrays.copyOf(values, keys.size()));
    }
    @Override
    public void clear() {
        Arrays.fill(values, 0, keys.rawSize(), null);
        keys.clear();
    }
    public static class Adapter<K, V> implements CacheAdapter<TinyMapBuilder<K, V>, TinyMap<K, V>> {
        @Override
        public int contentHashCode(TinyMapBuilder<K, V> builder) {
            int hash = 1;
            for (int i = 0; i < builder.rawSize(); i++) {
                if (builder.isRemoved(i)) continue;
                hash = (hash * 31) + System.identityHashCode(builder.getKeyAt(i));
                hash = (hash * 31) + System.identityHashCode(builder.getValueAt(i));
            }
            return hash;
        }
        @SuppressWarnings(""unchecked"")
        @Override
        public TinyMap<K, V> contentEquals(TinyMapBuilder<K, V> builder, Object cached) {
            if (!(cached instanceof TinyMap<?, ?>) || builder.size() != ((TinyMap<?, ?>) cached).size())
                return null;
            TinyMap<?, ?> map = (TinyMap<?, ?>) cached;
            int j = 0;
            for (int i = 0; i < builder.rawSize(); i++) {
                if (builder.isRemoved(i)) continue;
                if (builder.getKeyAt(i) != map.getKeyAt(j) || builder.getValueAt(i) != map.getValueAt(j))
                    return null;
                j++;
            }
            return (TinyMap<K, V>) cached;
        }
        @Override
        public TinyMap<K, V> build(TinyMapBuilder<K, V> builder, ObjectCache cache) {
            return builder.buildWithKeys(cache.get(builder.keys));
        }
    }
}",0,0,0,0,0,0,0,0,1
135,"package net.intelie.tinymap;
import net.intelie.tinymap.base.IndexedSetBase;
import net.intelie.tinymap.util.Preconditions;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;
public abstract class TinySet<T> extends IndexedSetBase<T> implements Serializable {
    private static final long serialVersionUID = 1L;
    public static int tableSize(int length) {
        return Integer.highestOneBit(length * 2 - 1) * 2;
    }
    private static int hash(Object key) {
        int h;
        return key == null ? 0 : (h = key.hashCode() * 0x85ebca6b) ^ h >>> 16;
    }
    public static <T> TinySet<T> createUnsafe(Object[] keys) {
        if (keys.length == 0)
            return new TinySet.Empty<>();
        else if (keys.length < 0xFF)
            return new Small<>(keys);
        else if (keys.length < 0xFFFF)
            return new Medium<>(keys);
        else
            return new Large<>(keys);
    }
    public static <T> TinySetBuilder<T> builder() {
        return new TinySetBuilder<>();
    }
    public abstract int debugCollisions(Object key);
    public static class Empty<T> extends TinySet<T> implements TinySet.Immutable<T> {
        private static final long serialVersionUID = 1L;
        @Override
        public int debugCollisions(Object key) {
            return 0;
        }
        @Override
        public int getIndex(Object key) {
            return -1;
        }
        @Override
        public int size() {
            return 0;
        }
        @Override
        public T getEntryAt(int index) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
    }
    private static abstract class ArrayTableSet<T, A> extends TinySet<T> implements TinySet.Immutable<T> {
        private static final long serialVersionUID = 1L;
        protected final Object[] keys;
        protected final A table;
        private ArrayTableSet(Object[] keys) {
            this.keys = keys;
            this.table = newTable(tableSize(keys.length));
            for (int j = 0; j < keys.length; j++) {
                Object key = keys[j];
                int hash = ~getIndex(key);
                Preconditions.checkArgument(hash >= 0, ""duplicate key: %s"", key);
                tableSet(table, hash, j);
            }
        }
        @SuppressWarnings(""unchecked"")
        @Override
        public T getEntryAt(int index) {
            return (T) keys[index];
        }
        @Override
        public int size() {
            return keys.length;
        }
        protected abstract A newTable(int size);
        protected abstract void tableSet(A table, int index, int value);
    }
    public static class Small<T> extends ArrayTableSet<T, byte[]> {
        private static final long serialVersionUID = 1L;
        private Small(Object[] keys) {
            super(keys);
        }
        @Override
        protected byte[] newTable(int size) {
            byte[] table = new byte[size];
            Arrays.fill(table, (byte) 0xFF);
            return table;
        }
        @Override
        protected void tableSet(byte[] table, int index, int value) {
            table[index] = (byte) value;
        }
        @Override
        public int debugCollisions(Object key) {
            byte[] table = this.table;
            int mask = table.length - 1;
            int hash = hash(key) & mask;
            int collisions = 0;
            for (int i = table[hash] & 0xFF; i < 0xFF; i = table[hash = (hash + ++collisions) & mask] & 0xFF)
                if (Objects.equals(key, keys[i]))
                    return collisions;
            return collisions;
        }
        @Override
        public int getIndex(Object key) {
            byte[] table = this.table;
            int mask = table.length - 1;
            int hash = hash(key) & mask;
            int collisions = 0;
            for (int i = table[hash] & 0xFF; i < 0xFF; i = table[hash = (hash + ++collisions) & mask] & 0xFF)
                if (Objects.equals(key, keys[i]))
                    return i;
            return ~hash;
        }
    }
    public static class Medium<T> extends ArrayTableSet<T, short[]> {
        private static final long serialVersionUID = 1L;
        private Medium(Object[] keys) {
            super(keys);
        }
        @Override
        protected short[] newTable(int size) {
            short[] table = new short[size];
            Arrays.fill(table, (short) 0xFFFF);
            return table;
        }
        @Override
        protected void tableSet(short[] table, int index, int value) {
            table[index] = (short) value;
        }
        @Override
        public int debugCollisions(Object key) {
            short[] table = this.table;
            int mask = table.length - 1;
            int hash = hash(key) & mask;
            int collisions = 0;
            for (int i = table[hash] & 0xFFFF; i < 0xFFFF; i = table[hash = (hash + ++collisions) & mask] & 0xFFFF)
                if (Objects.equals(key, keys[i]))
                    return collisions;
            return collisions;
        }
        @Override
        public int getIndex(Object key) {
            short[] table = this.table;
            int mask = table.length - 1;
            int hash = hash(key) & mask;
            int collisions = 0;
            for (int i = table[hash] & 0xFFFF; i < 0xFFFF; i = table[hash = (hash + ++collisions) & mask] & 0xFFFF)
                if (Objects.equals(key, keys[i]))
                    return i;
            return ~hash;
        }
    }
    public static class Large<T> extends ArrayTableSet<T, int[]> {
        private static final long serialVersionUID = 1L;
        private Large(Object[] keys) {
            super(keys);
        }
        @Override
        protected int[] newTable(int size) {
            int[] table = new int[size];
            Arrays.fill(table, -1);
            return table;
        }
        @Override
        protected void tableSet(int[] table, int index, int value) {
            table[index] = value;
        }
        @Override
        public int debugCollisions(Object key) {
            int[] table = this.table;
            int mask = table.length - 1;
            int hash = hash(key) & mask;
            int collisions = 0;
            for (int i = table[hash]; i >= 0; i = table[hash = (hash + ++collisions) & mask])
                if (Objects.equals(key, keys[i]))
                    return collisions;
            return collisions;
        }
        @Override
        public int getIndex(Object key) {
            int[] table = this.table;
            int mask = table.length - 1;
            int hash = hash(key) & mask;
            int collisions = 0;
            for (int i = table[hash]; i >= 0; i = table[hash = (hash + ++collisions) & mask])
                if (Objects.equals(key, keys[i]))
                    return i;
            return ~hash;
        }
    }
}",0,0,0,0,0,0,0,0,0
136,"package net.intelie.tinymap;
import net.intelie.tinymap.base.IndexedCollectionBase;
import net.intelie.tinymap.base.IndexedSetBase;
import net.intelie.tinymap.util.Preconditions;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;
public class TinySetBuilder<T> extends IndexedSetBase<T> implements
        CacheableBuilder<TinySetBuilder<T>, TinySet<T>>, Serializable, IndexedCollectionBase.NoAdditiveChange<T> {
    private static final long serialVersionUID = 1L;
    private static final Object TOMBSTONE = new Serializable() {
        private static final long serialVersionUID = 1L;
        @Override
        public String toString() {
            return ""TOMBSTONE"";
        }
    };
    private static final Adapter<?> adapter = new Adapter<>();
    private Object[] keys;
    private int[] inverse;
    private int[] table;
    private int rawSize = 0;
    private int size = 0;
    public TinySetBuilder() {
        this(16);
    }
    public TinySetBuilder(int expectedSize) {
        this.keys = new Object[expectedSize];
        this.inverse = new int[expectedSize];
        forceRehash(TinySet.tableSize(expectedSize));
    }
    private static int hash(Object key) {
        int h;
        return key == null ? 0 : (h = key.hashCode() * 0x85ebca6b) ^ h >>> 16;
    }
    private static int[] newTable(int size) {
        int[] table = new int[size];
        Arrays.fill(table, -1);
        return table;
    }
    public void compact() {
        if (rawSize == size) return;
        softClearTable();
        int index = 0;
        for (int i = 0; i < rawSize; i++) {
            if (keys[i] == TOMBSTONE) continue;
            keys[index] = keys[i];
            int hash = ~getIndex(keys[index]);
            assert hash >= 0;
            table[hash] = index;
            inverse[index] = hash;
            index++;
        }
        Arrays.fill(keys, index, rawSize, null);
        this.size = index;
        this.rawSize = index;
    }
    private void forceRehash(int newSize) {
        this.table = newTable(newSize);
        this.size = 0;
        compact();
    }
    private void softClearTable() {
        for (int i = 0; i < rawSize; i++)
            table[inverse[i]] = -1;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public T getEntryAt(int index) {
        Preconditions.checkElementIndex(index, rawSize);
        return (T) keys[index];
    }
    @Override
    public int addOrGetIndex(T key) {
        int index = getIndex(key);
        if (index >= 0)
            return index;
        index = checkOverflow(key, index);
        int hash = ~index;
        int newIndex = rawSize++;
        keys[newIndex] = key;
        table[hash] = newIndex;
        inverse[newIndex] = hash;
        size++;
        return ~newIndex;
    }
    private int checkOverflow(T key, int index) {
        if (rawSize == keys.length) {
            int newSize = keys.length + (keys.length >> 1);
            keys = Arrays.copyOf(keys, newSize);
            inverse = Arrays.copyOf(inverse, newSize);
        }
        if (2 * (rawSize + 1) > table.length) {
            forceRehash(table.length * 2);
            index = getIndex(key);
        }
        return index;
    }
    @Override
    public int getIndex(Object key) {
        int collisions = 0;
        int mask = table.length - 1;
        int hash = hash(key) & mask;
        for (int i = table[hash]; i >= 0; i = table[hash = (hash + ++collisions) & mask]) {
            if (Objects.equals(key, keys[i]))
                return i;
        }
        return ~hash;
    }
    @Override
    public boolean removeAt(int index) {
        Preconditions.checkElementIndex(index, rawSize);
        keys[index] = TOMBSTONE;
        size--;
        return false;
    }
    @Override
    public boolean isRemoved(int index) {
        return keys[index] == TOMBSTONE;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public Adapter<T> adapter() {
        return (Adapter<T>) adapter;
    }
    public int size() {
        return size;
    }
    @Override
    public int rawSize() {
        return rawSize;
    }
    @Override
    public TinySet<T> build() {
        compact();
        return TinySet.createUnsafe(Arrays.copyOf(keys, size));
    }
    @Override
    public void clear() {
        Arrays.fill(keys, 0, rawSize, null);
        softClearTable();
        size = rawSize = 0;
    }
    public static class Adapter<T> implements CacheAdapter<TinySetBuilder<T>, TinySet<T>> {
        @Override
        public int contentHashCode(TinySetBuilder<T> builder) {
            int hash = 1;
            for (int i = 0; i < builder.rawSize(); i++) {
                if (builder.isRemoved(i)) continue;
                hash = (hash * 31) + System.identityHashCode(builder.keys[i]);
            }
            return hash;
        }
        @SuppressWarnings(""unchecked"")
        @Override
        public TinySet<T> contentEquals(TinySetBuilder<T> builder, Object cached) {
            if (!(cached instanceof TinySet<?>) || builder.size() != ((TinySet<?>) cached).size())
                return null;
            TinySet<?> set = (TinySet<?>) cached;
            int j = 0;
            for (int i = 0; i < builder.rawSize(); i++) {
                if (builder.isRemoved(i)) continue;
                if (builder.getEntryAt(i) != set.getEntryAt(j))
                    return null;
                j++;
            }
            return (TinySet<T>) cached;
        }
        @Override
        public TinySet<T> build(TinySetBuilder<T> builder, ObjectCache cache) {
            return builder.build();
        }
    }
}",0,0,0,0,0,0,0,0,0
137,"package hashMapX;
import java.util.Stack;
public class TransactionObj {
	private Stack<String> commands_;
	private HashMapX db_;
	public TransactionObj(HashMapX db){
		db_ = db;
		commands_ = new Stack<>();
	}
	public void addSetCommand(String[] command){
		if (command[2]==null){
			System.out.println(""Cannot set null values"");
			return;
		}
		String oldValue = db_.set(command[1], command[2]);
		if (oldValue == null){
			commands_.push(command[1]);
		}else {
			commands_.push(command[1]+"" ""+oldValue);
		}
	}
	public void addUnsetCommand(String[] command){
		String oldValue = db_.unset(command[1]);
		if (oldValue!=null){
			commands_.push(command[1]+"" ""+oldValue);
		}
	}
	public void rollback(){
		while (!commands_.isEmpty()){
			String command = commands_.pop();
			String[] parsed = command.split("" "");
			if (parsed.length==1){
				db_.unset(parsed[0]);
			}else {
				db_.set(parsed[0],parsed[1]);
			}
		}
	}
}",0,0,0,0,0,0,0,0,0
138,"package main;
public class TreeNode<K extends Comparable, V> {
    public Color color;
    public K key;
    public V val;
    public TreeNode<K, V> parent;
    public TreeNode<K, V> left;
    public TreeNode<K, V> right;
    public TreeNode(){
        this.color = Color.RED;
        this.key = null;
        this.val = null;
        this.left = null;
        this.right = null;
    }
    public TreeNode(Color color, K key, V val) {
        this.color = color;
        this.key = key;
        this.val = val;
        this.left = null;
        this.right = null;
    }
}",0,0,0,0,0,0,0,0,0
139,"package Mini_algorithms;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
public class UnsortedTableMap<K,V> extends AbstractMap<K,V>{
	private ArrayList<MapEntry<K,V>> table = new ArrayList<>();
	public UnsortedTableMap(){	}
	public void clear() {
		table.clear();
	}
	private int findIndex(K key){
		int n = table.size();
		for(int j = 0; j < n; j++){
			if(table.get(j).getKey().equals(key)){
				return j;
			}
		}
		return -1;
	}
	private int findValue(V value){
		int n = table.size();
		for(int j = 0; j < n; j++){
			if(table.get(j).getValue() == value){
				return j;
			}
		}
		return -1;
	}
	public boolean containsKey(Object key) {
		int j = findIndex((K)key);
		if(j == -1){
			return false;
		} else{
			return true;
		}
	}
	public boolean containsValue(Object value) {
		int j = findValue((V)value);
		if(j == -1){
			return false;
		} else{
			return true;
		}
	}
	private class EntryIterator implements Iterator<Entry<K,V>> {
		private int j = 0;
		public boolean hasNext(){
			return j < table.size();
		}
		public Entry<K,V> next(){
			if(j == table.size()){
				throw new NoSuchElementException();
			}
			return table.get(j++);
		}
		public void remove(){
			throw new UnsupportedOperationException();
		}
	}
	private class EntryIterable implements Iterable<Entry<K,V>> {
		public Iterator<Entry<K, V>> iterator() {
			return new EntryIterator();
		}
	}
	public Set<Entry<K, V>> entrySet() {
		return (Set<Entry<K, V>>) new EntryIterable();
	}
	public V get(Object key) {
		int j = findIndex((K)key);
		if(j == -1){
			return null;
		}
		return table.get(j).getValue();
	}
	public V put(K key, V value) {
		int j = findIndex(key);
		if(j == -1){
			table.add(new MapEntry<>(key,value));
			return null;
		} else {
			return table.get(j).setValue(value);
		}
	}
	public void putAll(Map<? extends K, ? extends V> m) {
		table.addAll((Collection<? extends MapEntry<K, V>>) m);
	}
	public V remove(Object key) {
		int j = findIndex((K)key);
		int n = size();
		if(j == -1){
			return null;
		} 
		V answer = table.get(j).getValue();
		if(j != n - 1){
			table.set(j, table.get(n-1));
		}
		table.remove(n-1);
		return answer;
	}
	public int size() {
		return table.size();
	}
}",0,0,0,0,0,1,0,0,1
140,"package com.jamierf.persistenthashmap;
import java.io.Serializable;
import java.util.Iterator;
class ValueIterator<K extends Serializable, V extends Serializable> implements Iterator<V> {
	private PersistentHashMap<K, V> map;
	private Iterator<K> iterator;
	private K current;
	public ValueIterator(PersistentHashMap<K, V> map) {
		this.map = map;
		iterator = new KeyIterator<K, V>(map);
		current = null;
	}
	public boolean hasNext() {
		return iterator.hasNext();
	}
	public V next() {
		current = iterator.next();
		return map.get(current);
	}
	public void remove() {
		if (current != null)
			map.remove(current);
	}
}",0,0,0,0,0,0,0,0,0
141,"package Thomas;
public class Vec3I {
    public int x, y, z;
    public Vec3I() {}
    public Vec3I(Vec3I vector) {
        this.x = vector.x;
        this.y = vector.y;
        this.z = vector.z;
    }
    public Vec3I(int amplitutde) {
        this.x = amplitutde;
        this.y = amplitutde;
        this.z = amplitutde;
    }
    public Vec3I(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    public void  mod(Vec3I rhs) {
        x = x % rhs.x;
        y = y % rhs.y;
        z = z % rhs.z;
        this.add(rhs);
        x = x % rhs.x;
        y = y % rhs.y;
        z = z % rhs.z;
    }
    public Vec3I add(Vec3I rhs) {
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
        return this;
    }
    public void add(int rhs) {
        x += rhs;
        y += rhs;
        z += rhs;
    }
    public Vec3I mul(int rhs) {
        x *= rhs;
        y *= rhs;
        z *= rhs;
        return this;
    }
    public void div(int rhs) {
        x /= rhs; y /= rhs; z /= rhs;
    }
    public boolean isInBounds(Vec3I minBound, Vec3I maxBound) {
        if (this.x < minBound.x)
            return false;
        if (this.y < minBound.y)
            return false;
        if (this.z < minBound.z)
            return false;
        if (this.x >= maxBound.x)
            return false;
        if (this.y >= maxBound.y)
            return false;
        if (this.z >= maxBound.z)
            return false;
        return true;
    }
    public static Vec3I add(Vec3I lhs, int rhs) {
        return new Vec3I(lhs.x + rhs, lhs.y + rhs, lhs.z + rhs);
    }
    public static Vec3I add(Vec3I lhs, Vec3I rhs){
        return new Vec3I(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z);
    }
    public static Vec3I subtract(Vec3I lhs, Vec3I rhs) {
        return new Vec3I(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z);
    }
    public static Vec3I subtract(Vec3I lhs, int rhs) {
        return new Vec3I(lhs.x - rhs, lhs.y - rhs, lhs.z - rhs);
    }
    public static Vec3I mul(Vec3I lhs, Vec3I rhs) {
        return new Vec3I(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z);
    }
    public static Vec3I mul(Vec3I lhs, int rhs) {
        return new Vec3I(lhs.x * rhs, lhs.y * rhs, lhs.z * rhs);
    }
    public static Vec3I div(Vec3I lhs, int rhs) {
        return new Vec3I(lhs.x / rhs, lhs.y / rhs, lhs.z / rhs);
    }
    public static Vec3I mod(Vec3I lhs, Vec3I rhs) {
        Vec3I answer = new Vec3I((lhs.x % rhs.x), (lhs.y % rhs.y) ,(lhs.z % rhs.z));
        answer.add(rhs);
        answer.x %= rhs.x;
        answer.y %= rhs.y;
        answer.z %= rhs.z;
        return answer;
    }
    public static Vec3I mod(Vec3I lhs, int rhs) {
        Vec3I answer = new Vec3I((lhs.x % rhs), (lhs.y % rhs) ,(lhs.z % rhs));
        answer.add(rhs);
        answer.x %= rhs;
        answer.y %= rhs;
        answer.z %= rhs;
        return answer;
    }
    @Override
    public String toString() {
        return String.format(""{X:%s, Y:%s, Z:%s}"", String.valueOf(x), String.valueOf(y), String.valueOf(z));
    }
    @Override
    public int hashCode() {
        int result = 1;
        result = result * 31 + x;
        result = result * 31 + y;
        result = result * 31 + z;
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (obj == this)
            return true;
        if (!(obj instanceof Vec3I))
            return false;
        Vec3I v3 = (Vec3I) obj;
        if (this.x != v3.x)
            return false;
        if (this.y != v3.y)
            return false;
        if (this.z != v3.z)
            return false;
        return true;
    }
}",0,0,0,0,0,0,0,0,0
142,"public class View{
	public View() {
		System.out.print(""------ Brents Method Hashing ------"");
	}
	public void printNewSearch() {
		System.out.print(""\n\nSearch : "");
	}
	public void printResults(int key, int count, int index) {
		System.out.println(""Key : "" + key + 
						   ""\nCount : "" + count +
						   ""\nIndex : "" + index) ;
	}
	public void printNotFound(String search) {
		System.out.println(search + "" is not found in text file."");
	}
	public void printClosedMessage() {
		System.out.println(""Program is closed."");
	}
	public void printTxtReadError() {
		System.out.println(""\n\nERROR : Txt file is not found."");
	}
	public void printTableLine(int i, Key key, int hashCode, int count) {
		System.out.println(String.format(""%d. Key: %-20s HashCode: %-20d Count: %-5d"", i, key, hashCode, count));
	}
	public void printTotalValues(int word,int differentWords) {
		System.out.println(""\nTotal words : "" + word + 
							""\nTotal unique words : "" + differentWords);
	}
}",0,0,0,0,0,0,0,0,0
143,"import java.util.Date;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
public class WeakConcurrentHashMap<K, V> extends ConcurrentHashMap<K, V> {
	private static final long serialVersionUID = 1L;
	private Map<K, Long> timeMap = new ConcurrentHashMap<K, Long>();
	private WeakConcurrentHashMapListener<K, V> listener;
	private long expiryInMillis;
	private boolean mapAlive = true;
	public WeakConcurrentHashMap() {
		this.expiryInMillis = 10000;
		initialize();
	}
	public WeakConcurrentHashMap(WeakConcurrentHashMapListener<K, V> listener) {
		this.listener = listener;
		this.expiryInMillis = 10000;
		initialize();
	}
	public WeakConcurrentHashMap(long expiryInMillis) {
		this.expiryInMillis = expiryInMillis;
		initialize();
	}
	public WeakConcurrentHashMap(long expiryInMillis, WeakConcurrentHashMapListener<K, V> listener) {
		this.expiryInMillis = expiryInMillis;
		this.listener = listener;
		initialize();
	}
	void initialize() {
		new CleanerThread().start();
	}
	public void registerRemovalListener(WeakConcurrentHashMapListener<K, V> listener) {
		this.listener = listener;
	}
	@Override
	public V put(K key, V value) {
		if (!mapAlive) {
			throw new IllegalStateException(""WeakConcurrent Hashmap is no more alive.. Try creating a new one."");	 
		}
		Date date = new Date();
		timeMap.put(key, date.getTime());
		V returnVal = super.put(key, value);
		if (listener != null) {
			listener.notifyOnAdd(key, value);
		}
		return returnVal;
	}
	@Override
	public void putAll(Map<? extends K, ? extends V> m) {
		if (!mapAlive) {
			throw new IllegalStateException(""WeakConcurrent Hashmap is no more alive.. Try creating a new one."");	 
		}
		for (K key : m.keySet()) {
			put(key, m.get(key));
		}
	}
	@Override
	public V putIfAbsent(K key, V value) {
		if (!mapAlive) {
			throw new IllegalStateException(""WeakConcurrent Hashmap is no more alive.. Try creating a new one."");	 
		}
		if (!containsKey(key)) {
			return put(key, value);
		} else {
			return get(key);
		}
	}
	public void quitMap() {
		mapAlive = false;
	}
	public boolean isAlive() {
		return mapAlive;
	}
	class CleanerThread extends Thread {
		@Override
		public void run() {
			while (mapAlive) {
				cleanMap();
				try {
					Thread.sleep(expiryInMillis / 2);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		private void cleanMap() {
			long currentTime = new Date().getTime();
			for (K key : timeMap.keySet()) {
				if (currentTime > (timeMap.get(key) + expiryInMillis)) {
					V value = remove(key);
					timeMap.remove(key);
					if (listener != null) {
						listener.notifyOnRemoval(key, value);
					}
				}
			}
		}
	}
}",0,0,0,0,0,0,0,0,0
144,"public interface WeakConcurrentHashMapListener<K,V> {
	public void notifyOnAdd(K key, V value);
	public void notifyOnRemoval(K key, V value);
}",0,0,0,0,0,0,0,0,0
145,"package com.blogspot.mydailyjava.weaklockfree;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicLong;
public class WeakConcurrentMap<K, V> extends AbstractWeakConcurrentMap<K, V, WeakConcurrentMap.LookupKey<K>> {
    private static final ThreadLocal<LookupKey<?>> LOOKUP_KEY_CACHE = new ThreadLocal<LookupKey<?>>() {
        @Override
        protected LookupKey<?> initialValue() {
            return new LookupKey<Object>();
        }
    };
    private static final AtomicLong ID = new AtomicLong();
    private final Thread thread;
    private final boolean reuseKeys;
    public WeakConcurrentMap(boolean cleanerThread) {
        this(cleanerThread, isPersistentClassLoader(LookupKey.class.getClassLoader()));
    }
    private static boolean isPersistentClassLoader(ClassLoader classLoader) {
        try {
            return classLoader == null  
                    || classLoader == ClassLoader.getSystemClassLoader()
                    || classLoader == ClassLoader.getSystemClassLoader().getParent();  
        } catch (Throwable ignored) {
            return false;
        }
    }
    public WeakConcurrentMap(boolean cleanerThread, boolean reuseKeys) {
        this(cleanerThread, reuseKeys, new ConcurrentHashMap<WeakKey<K>, V>());
    }
    public WeakConcurrentMap(boolean cleanerThread, boolean reuseKeys, ConcurrentMap<WeakKey<K>, V> target) {
        super(target);
        this.reuseKeys = reuseKeys;
        if (cleanerThread) {
            thread = new Thread(this);
            thread.setName(""weak-ref-cleaner-"" + ID.getAndIncrement());
            thread.setPriority(Thread.MIN_PRIORITY);
            thread.setDaemon(true);
            thread.start();
        } else {
            thread = null;
        }
    }
    @Override
    @SuppressWarnings(""unchecked"")
    protected LookupKey<K> getLookupKey(K key) {
        LookupKey<K> lookupKey;
        if (reuseKeys) {
            lookupKey = (LookupKey<K>) LOOKUP_KEY_CACHE.get();
        } else {
            lookupKey = new LookupKey<K>();
        }
        return lookupKey.withValue(key);
    }
    @Override
    protected void resetLookupKey(LookupKey<K> lookupKey) {
        lookupKey.reset();
    }
    public Thread getCleanerThread() {
        return thread;
    }
    static final class LookupKey<K> {
        private K key;
        private int hashCode;
        LookupKey<K> withValue(K key) {
            this.key = key;
            hashCode = System.identityHashCode(key);
            return this;
        }
        void reset() {
            key = null;
            hashCode = 0;
        }
        @Override
        public boolean equals(Object other) {
            if (other instanceof WeakConcurrentMap.LookupKey<?>) {
                return ((LookupKey<?>) other).key == key;
            } else {
                return ((WeakKey<?>) other).get() == key;
            }
        }
        @Override
        public int hashCode() {
            return hashCode;
        }
    }
    public static class WithInlinedExpunction<K, V> extends WeakConcurrentMap<K, V> {
        public WithInlinedExpunction() {
            super(false);
        }
        @Override
        public V get(K key) {
            expungeStaleEntries();
            return super.get(key);
        }
        @Override
        public boolean containsKey(K key) {
            expungeStaleEntries();
            return super.containsKey(key);
        }
        @Override
        public V put(K key, V value) {
            expungeStaleEntries();
            return super.put(key, value);
        }
        @Override
        public V remove(K key) {
            expungeStaleEntries();
            return super.remove(key);
        }
        @Override
        public Iterator<Map.Entry<K, V>> iterator() {
            expungeStaleEntries();
            return super.iterator();
        }
        @Override
        public int approximateSize() {
            expungeStaleEntries();
            return super.approximateSize();
        }
    }
}",0,0,0,0,0,0,0,0,1
146,"package com.blogspot.mydailyjava.weaklockfree;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
public class WeakConcurrentSet<V> implements Runnable, Iterable<V> {
    final WeakConcurrentMap<V, Boolean> target;
    public WeakConcurrentSet(Cleaner cleaner) {
        switch (cleaner) {
            case INLINE:
                target = new WeakConcurrentMap.WithInlinedExpunction<V, Boolean>();
                break;
            case THREAD:
            case MANUAL:
                target = new WeakConcurrentMap<V, Boolean>(cleaner == Cleaner.THREAD);
                break;
            default:
                throw new AssertionError();
        }
    }
    public boolean add(V value) {
        return target.put(value, Boolean.TRUE) == null;  
    }
    public boolean contains(V value) {
        return target.containsKey(value);
    }
    public boolean remove(V value) {
        return target.remove(value) != null;  
    }
    public void clear() {
        target.clear();
    }
    public int approximateSize() {
        return target.approximateSize();
    }
    @Override
    public void run() {
        target.run();
    }
    public enum Cleaner {
        THREAD, INLINE, MANUAL
    }
    public void expungeStaleEntries() {
        target.expungeStaleEntries();
    }
    public Thread getCleanerThread() {
        return target.getCleanerThread();
    }
    @Override
    public Iterator<V> iterator() {
        return new ReducingIterator<V>(target.iterator());
    }
    @Override
    public String toString(){
        return Collections.newSetFromMap(target.target).toString();
    }
    private static class ReducingIterator<V> implements Iterator<V> {
        private final Iterator<Map.Entry<V, Boolean>> iterator;
        private ReducingIterator(Iterator<Map.Entry<V, Boolean>> iterator) {
            this.iterator = iterator;
        }
        @Override
        public void remove() {
            iterator.remove();
        }
        @Override
        public V next() {
            return iterator.next().getKey();
        }
        @Override
        public boolean hasNext() {
            return iterator.hasNext();
        }
    }
}",0,0,0,0,0,0,0,0,0
147,"package com.deepak.data.structures.Hashing;
import java.util.Map;
import java.util.WeakHashMap;
public class WeakHashMapImplementation {
	public static void main(String[] args) {
		Map<Orders, Integer> ordersMap = new WeakHashMap<>();
		Orders order = new Orders(1, ""Details of Order 1"");
		ordersMap.put(order, 60);
		ordersMap.put(new Orders(2, ""Details of Order 2""), 50);
		ordersMap.put(new Orders(3, ""Details of Order 3""), 30);
		System.out.println(""Size of Map after one Strong reference and two weak references insertion. => ""
				+ ordersMap.size());
		System.gc();
		System.runFinalization();
		System.out.println(""Size of Map after Gargabe Collection => "" + ordersMap.size());
	}
}
class Orders {
	int orderId;
	String orderDetails;
	public Orders(int iOrderId, String iOrderDetails) {
		orderId = iOrderId;
		orderDetails = iOrderDetails;
	}
}",0,0,0,0,0,0,0,0,0
148,"package Mini_algorithms;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
public class WordCount {
	public static void main(String[] args) throws FileNotFoundException {
		Map<String, Integer> freq = new ChainHashMap<>();
		File f = new File(""C:/Users/Norbert/Desktop/Thank You Letter.docx"");
		Scanner doc = new Scanner(f);
		doc.useDelimiter(""[^a-zA-Z]+"");
		while(doc.hasNext()){
			String word = doc.next().toLowerCase();
			Integer count = freq.get(word);
			if(count == null){
				count = 0;
			}
			freq.put(word, 1 + count);
		}
		Iterator<Integer> values = freq.values().iterator();
		Iterator<String> keys = freq.keySet().iterator();
		while(keys.hasNext()){
			System.out.println(keys.next() + "" : "" + values.next());
		}
	}
}",0,0,0,0,0,0,0,0,0
149,"import java.util.Random;
class WordCount {
  public static void main(String[] args) throws java.io.IOException {
    java.io.BufferedReader r = new java.io.BufferedReader(
            new java.io.InputStreamReader(System.in));
    args = r.readLine().split("" "");
    int Np = Integer.parseInt(args[2]);
    HashFunction f;
    switch (args[1]) {
      case ""d"":
        f = new DivisionMethod(Np);
        break;
      case ""m"":
        int s = Integer.parseInt(args[3]);
        f = new MultiplicationMethod(Np, s);
        break;
      default:
        return;
    }
    HashTable tab;
    if (args[0].equals(""c"")) {
      tab = new HashTableChaining(f);
    }else {
      HashSequence s;
      switch (args[0]) {
        case ""l"":
          s = new LinearProbing(f);
          break;
        case ""q"":
          s = new QuadraticProbing(f);
          break;
        case ""d"":
          class HashFunction2 extends AbstractHashFunction {
            public HashFunction2(int N) {
              super(N);
            }
            public int compute(Object key) {
              int h = Math.abs(key.hashCode()) % (size - 1);
              if (h % 2 == 0) h++;
              return h;
            }
          }
          s = new DoubleHashing(f, new HashFunction2(f.size()));
          break;
        default:
          return;
      }
      tab = new HashTableOpenAddressing(s);
    }
    int currentDataType = 0;
    while (true) {
      String word = r.readLine();
      if (word == null) break;
      String[] input = word.split("" "");
      switch (input[0]) {
        case ""add"":
          if (currentDataType == 0)
            tab.put(input[1], input[2]);
          if (currentDataType == 1)
            tab.put(Integer.parseInt(input[1]), input[2]);
          if (currentDataType == 2)
            tab.put(Float.parseFloat(input[1]), input[2]);
          if (currentDataType == 3)
            tab.put(new TestClass(Integer.parseInt(input[1]), Integer.parseInt(input[2])), input[3]);
          break;
        case ""get"":
          String out = """";
          if (currentDataType == 0)
            System.out.println(tab.get(input[1]));
          if (currentDataType == 1)
            System.out.println(tab.get(Integer.parseInt(input[1])));
          if (currentDataType == 2)
            System.out.println(tab.get(Float.parseFloat(input[1])));
          if (currentDataType == 3)
            System.out.println(tab.get(new TestClass(Integer.parseInt(input[1]), Integer.parseInt(input[2]))));
          break;
        case ""remove"":
          if (currentDataType == 0)
            tab.remove(input[1]);
          if (currentDataType == 1)
            tab.remove(Integer.parseInt(input[1]));
          if (currentDataType == 2)
            tab.remove(Float.parseFloat(input[1]));
          if (currentDataType == 3)
            tab.remove(new TestClass(Integer.parseInt(input[1]), Integer.parseInt(input[2])));
          break;
        case ""dump"":
          tab.dump();
          break;
        case ""int"":
          currentDataType = 1;
          break;
        case ""String"":
          currentDataType = 0;
          break;
        case ""float"":
          currentDataType = 2;
          break;
        case ""Object"":
          currentDataType = 3;
          break;
        default:
          return;
      }
    }
  }
}
  class TestClass {
    private int x;
    private int y;
    public TestClass(int x, int y) {
      Random r = new Random();
      this.x = x;
      this.y = y;
    }
    public void setX(int x) {
      this.x = x;
    }
    public void setY(int y) {
      this.y = y;
    }
    public int add() {
      return x + y;
    }
    @Override
    public int hashCode() {
      return x + y;
    }
    @Override
    public boolean equals(Object obj) {
      if (!(obj instanceof TestClass))
        return false;
      if (((TestClass) obj).add() == this.add())
        return true;
      return false;
    }
    @Override
    public String toString() {
      return ""x + y = "" + x + y;
    }
  }",0,0,0,0,0,0,0,0,0
150,"package Lists;
import java.util.List;
public class ArrayList {
    public static void main(String[] args) {
        List<Employee> employeeList = new java.util.ArrayList<>();
        employeeList.add(new Employee(""Jane"",""Jones"",123));
        employeeList.add(new Employee(""Mary"",""Smith"",22));
        employeeList.add(new Employee(""John"",""Doe"",4567));
        employeeList.add(new Employee(""Mike"",""Wilson"",3245));
        System.out.println(employeeList.size());
        employeeList.add(3,new Employee(""Yo"",""Yo"",741));
        Object[] employeeArray = employeeList.toArray(new Employee[employeeList.size()]);
        for (Object employee : employeeArray) {
            System.out.println(employee);
        }
        System.out.println(employeeList.contains(new Employee(""Mary"",""Smith"",22)));
        System.out.println(employeeList.indexOf(new Employee(""John"",""Doe"",4567)));
        employeeList.remove(3);
        employeeList.forEach(employee -> System.out.println(employee));  
    }
}",0,0,0,0,0,0,0,0,0
151,"from .node import Node
class BaseLinkedList:
    def __init__(self):
        self.node = None
        self.length = 0
    def __iter__(self):
        current = self.node
        while current is not None:
            yield current
            current = current.next
    def __str__(self):
        return f""{self.node}""
    def __len__(self):
        length = 0
        runner: Node = self.node
        while runner is not None:
            length += 1
            runner = runner.next
        return length
    def print(self):
        current = self.node
        while current is not None:
            print(current.data)
            current = current.next",0,0,0,0,0,0,0,0,0
152,"public class CircleLinkedList<E>{
     private static class Node<E>{
         Node<E> next;
         E value;
         private Node(E value, Node<E> next){
              this.value = value;
              this.next = next;
         }
     }
     private int size; 
     private Node<E> head; 
     public CircleLinkedList(){ 
         head = new Node<E>(null,head); 
         size = 0;
     }
     public int getSize(){ return size;} 
     public void append(E value){ 
         if(value == null){
         	throw new NullPointerException(""Cannot add null element to the list""); 
         }
         head.next = new Node<E>(value,head); 
         size++;}
     public E remove(int pos){
     	if(pos>size || pos< 0){
     		throw new IndexOutOfBoundsException(""position cannot be greater than size or negative""); 
     	}
     	Node<E> iterator = head.next; 
     	Node<E> before = head;
     	for(int i = 1; i<=pos; i++){
            iterator = iterator.next;
            before = before.next;   
     	}
     	E saved = iterator.value;
     	before.next = iterator.next; 
     	iterator.next = null; 
     	iterator.value = null; 
     	return saved;
     	}
     }",0,0,0,0,0,0,0,1,0
153,"from .node import Node
from .base_linked_list import BaseLinkedList
class CircularLinkedList(BaseLinkedList):
    def __init__(self):
        super(CircularLinkedList, self).__init__()
        self.is_circular_yet = False
        self.first_element = None
    def add(self, data, join=False):
        if self.is_circular_yet:
            raise Exception(""Cannot add any more"")
        if not isinstance(data, Node):
            raise TypeError()
        if self.node is None:
            self.node = data
            self.first_element = data
        else:
            current = self.node
            while current.next is not None:
                current = current.next
            current.next = data
        if join:
            self.is_circular_yet = True
            current.next.next = self.first_element
        self.length += 1",0,0,0,0,0,0,0,0,0
154,"package LinkedList;
public class CircularDoublyLinkedList {
    private static ListNode head;
    private static ListNode tail;
    private int length;
    private static class ListNode {
        private final int data;
        private ListNode next;
        private ListNode previous;
        public ListNode(int data) {
            this.data = data;
            this.next = null;
            this.previous = null;
        }
    }
    public CircularDoublyLinkedList() {
        head = null;
        tail = null;
        length = 0;
    }
    private void getLength() {
        System.out.println(""Length of the list is: "" + length);
    }
    private boolean isEmpty() {
        return length == 0;
    }
    private void printList() {
        if(isEmpty()) {
            System.out.println(""List is Empty"");
            return;
        }
        if(length == 1) {
            System.out.println(head.data);
            return;
        }
        ListNode current  = head;
        while (current != tail) {
            System.out.print(current.data + "" "");
            current = current.next;
        }
        System.out.println(current.data);
    }
    private void printReverse() {
        if(isEmpty()) {
            System.out.println(""List is Empty"");
            return;
        }
        if(length == 1) {
            System.out.println(""Reversed List : ""+tail.data);
            return;
        }
        ListNode current = tail;
        System.out.print(""Reversed List : "");
        while (current != head) {
                System.out.print(current.data + "" "");
                current = current.previous;
        }
        System.out.println(current.data);
    }
    private void insertFirst(int value) {
        ListNode newNode = new ListNode(value);
        if(isEmpty()) {
            head = newNode;
            tail = newNode;
            newNode.next = newNode;
            length++;
            return;
        }
        newNode.next = head;
        head.previous = newNode;
        head = newNode;
        tail.next = newNode;
        length++;
    }
    private void insertLast(int value) {
        ListNode newNode = new ListNode(value);
        if (isEmpty()) {
            head = newNode;
            tail = newNode;
            newNode.next = newNode;
            length++;
            return;
        }
        tail.next = newNode;
        newNode.previous = tail;
        tail = newNode;
        tail.next = head;
        length++;
    }
    public static void main(String[] args) {
        CircularDoublyLinkedList cdll = new CircularDoublyLinkedList();
        cdll.insertLast(11);
        cdll.insertFirst(2);
        cdll.insertFirst(10);
        cdll.printList();
        cdll.printReverse();
        cdll.getLength();
    }
}",0,0,0,0,0,0,0,1,0
155,"public class MyClass{
    class Node{
        int data;
        Node next;
        public Node(int data){
            this.data=data;
            this.next=next;
        }
    }
    public Node head=null;
    public Node tail=null;
    void add(int d){
        Node new_node=new Node(d);
        if(head==null){
            head=new_node;
            tail=new_node;
        }else{
            tail.next=new_node;
            tail=new_node;
            tail.next=head;
        }
    }
    void insertFirst(int d){
        Node new_node=new Node(d);
        if(head==null){
            head=new_node;
            tail=new_node;
        }
        else{
             Node current=head;
            while(current.next!=head){
                current=current.next;
            }
            new_node.next=head;
            head=new_node;
            current.next=head;
        }
    }
      void deleteFirst(){
       if(head==null){
           System.out.print(""List is empty"");
       }else{
           Node current=head;
           while(current.next!=head){
               current=current.next;
           }
           head=head.next;
           current.next=head;
       }
    }
    void deleteLast(){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
             Node current=head;
             Node prev=head;
            while(current.next!=head){
                prev=current;
                current=current.next;
            }
            prev.next=current.next;
        }
    }
    void display(){
        Node current=head;
        while(current.next!=head){
             System.out.print("" ""+current.data);
            current=current.next;
        }
         System.out.print("" ""+current.data);
    }
    public static void main(String args[]){
        MyClass cList=new MyClass();
        cList.add(10);
        cList.add(20);
        cList.add(30);
         cList.add(40);
          cList.add(50);
          cList.insertFirst(5);
          cList.insertFirst(2);
           cList.add(55);
        cList.display();
        System.out.println(""____________"");
          cList.deleteFirst();
           cList.display();
            System.out.println(""____________"");
          cList.deleteFirst();
           cList.display();
           System.out.println(""____________"");
          cList.deleteLast();
           cList.display();
    }
}",0,0,0,0,0,0,0,1,0
156,"public class CircularLinkedList{
	static class Node{
		int key;     
		Node next;   
		public Node(int data){
			this.key=data;
			this.next=null;
		}
	}
	static Node head;    
	public CircularLinkedList(){
		head=null;
	}
	static public void pushFront(int number){
		System.out.println(""Inserting data at front : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			node.next=head;
			return;
		}
		if(head.next==head){
			node.next=head;
			head=node;
			node.next.next=head;   
			return;
		}
		Node temp=head;
		while(temp.next!=head){
			temp=temp.next;
		}
		node.next=head;
		head=node;
		temp.next=head;   
	}
	static public void pushBack(int number){
		System.out.println(""Inserting data at back  : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			node.next=head;
			return;
		} 		
		if(head.next==head){
			head.next=node;
			node.next=head;
			return;
		}
		Node temp = head;
		while(temp.next!=head){
			temp=temp.next;
		}
		temp.next=node;
		node.next=head;
	}
	public static void popFront(){
		System.out.print(""PopFront Operation : "");
		if(head==null){
			System.out.println(""Empty List."");
			return;
		}
		if(head.next==head){
			head=null;
			System.out.println(""Successfull."");
			return;
		}
		Node temp=head;
		while(temp.next!=head){
			temp=temp.next;
		}
		head=head.next;
		temp.next=head;   
		System.out.println(""Successfull."");
	}
	public static void popBack(){
		System.out.print(""PopBack Operation  : "");
		if(head==null){
			System.out.println(""Empty List."");
			return;
		}
		if(head.next==head){
			head=null;
			System.out.println(""Successfull."");
			return;
		}
		Node temp=head;
		while(temp.next.next!=head){
			temp=temp.next;
		}
		temp.next=temp.next.next;  
		System.out.println(""Successfull."");
	}
	public static void display(){
		System.out.print(""List : "");
		if(head==null){
			System.out.println(""Empty List."");
			return;
		}
		Node temp=head;
		while(temp.next!=head){
			System.out.print(temp.key + "" "");
			temp=temp.next;
		}
		System.out.println(temp.key);
	}
	public static void main(String [] args){
		CircularLinkedList list = new CircularLinkedList();
		list.pushFront(10);
		list.pushBack(12);
		list.pushFront(8);
		list.pushBack(14);
		list.display();
		list.popFront();
		list.display();
		list.popBack();
		list.display();
		list.popFront();
		list.popBack();
		list.display();
	}
}",0,0,0,0,0,0,0,1,0
157,"package com.lists;
import java.util.Iterator;
public class CircularLinkedList<Item> implements Iterable<Item>{
    LinkedListNode head, tail;
    int size;
    public CircularLinkedList(){
        head = null;
        tail = null;
        size = 0;
    }
    public int getSize(){
        return size;
    }
    public boolean isEmpty(){
        return size == 0;
    }
    public void add(Item item){
        LinkedListNode linkedListNode = new LinkedListNode(item);
        if(isEmpty()){
            head = linkedListNode;
            tail = linkedListNode;
        }
        else{
            tail.next = linkedListNode;
            tail = linkedListNode;
        }
        linkedListNode.next = head;
        size++;
    }
    public void add(Item item, int index)throws IndexOutOfBoundsException{
        if(index < 0 || index > size - 1){
            throw new IndexOutOfBoundsException();
        }
        LinkedListNode linkedListNode = new LinkedListNode(item);
        if(index == size - 1){
            add(item);
        }
        else if(index == 0){
            linkedListNode.next = head.next;
            head = linkedListNode;
            size++;
        }
        else {
            LinkedListNode start = head;
            while (index != 1) {
                index--;
                start = start.next;
            }
            linkedListNode.next = start.next;
            start.next = linkedListNode;
            size++;
        }
    }
    public Item get(int index) throws IndexOutOfBoundsException{
        if(index < 0 || index > size - 1){
            throw new IndexOutOfBoundsException();
        }
        if(index == 0){
            return head.item;
        }
        else if(index == size - 1){
            return tail.item;
        }
        else{
            LinkedListNode start = head;
            while (index != 0) {
                index--;
                start = start.next;
            }
            return start.item;
        }
    }
    public void remove(int index) throws IndexOutOfBoundsException{
        if(index < 0 || index > size - 1){
            throw new IndexOutOfBoundsException();
        }
        if(index == 0){
            head = head.next;
            tail.next = head;
        }
        else{
            LinkedListNode start = head;
            int temp = index;
            while(temp != 1){
                temp--;
                start = start.next;
            }
            start.next = start.next.next;
            if(index == size - 1){
                tail = start;
            }
            size--;
        }
    }
    public Iterator<Item> iterator(){
        return new CircularLinkedListIterator();
    }
    class CircularLinkedListIterator implements Iterator<Item> {
        private LinkedListNode current = head;
        public boolean hasNext(){
            return true;
        }
        public void remove(){
            throw new UnsupportedOperationException();
        }
        public Item next(){
            Item item = current.item;
            current = current.next;
            return item;
        }
    }
    class LinkedListNode{
        Item item;
        LinkedListNode next;
        LinkedListNode(Item item){
            this.item = item;
            next = null;
        }
    }
}",0,0,0,0,0,0,0,1,0
158,"package LinkedList;
public class CircularSinglyLinkedList {
    private static ListNode tail;
    private static int length;
    private static class ListNode {
        private final int data;
        private ListNode next;
        public ListNode(int data) {
            this.data = data;
            this.next = null;
        }
    }
    public CircularSinglyLinkedList() {
        length = 0;
        tail = null;
    }
    private boolean isEmpty() {
        return length == 0;
    }
    private void getLength() {
        System.out.println(""No. of Nodes : ""+ length);
    }
    private void printList() {
        if(isEmpty()){
            System.out.println(""List is Empty"");
            return;
        }
        ListNode head = tail.next;
        while (head != tail) {
            System.out.print(head.data+"" "");
            head = head.next;
        }
        System.out.println(head.data);
    }
    private void insertFirst(int value) {
        ListNode newNode = new ListNode(value);
        if(isEmpty()) {
            tail = newNode;
            tail.next = newNode;
            length++;
            return;
        }
        newNode.next = tail.next;
        tail.next = newNode;
        length++;
    }
    private void insertLast(int value) {
        ListNode newNode = new ListNode(value);
        if(isEmpty()) {
            tail = newNode;
            tail.next = newNode;
            length++;
            return;
        }
        if(length == 1) {
            tail.next = newNode;
            newNode.next = tail;
            tail = tail.next;
            length++;
            return;
        }
        ListNode head = tail.next;
        tail.next = newNode;
        newNode.next = head;
        tail = tail.next ;
        length++;
    }
    public static void main(String[] args) {
        CircularSinglyLinkedList csll = new CircularSinglyLinkedList();
        csll.insertFirst(3);
        csll.insertLast(8);
        csll.insertLast(10);
        csll.insertLast(1);
        csll.insertLast(11);
        csll.printList();
        csll.getLength();
    }
}",0,0,0,0,0,0,0,1,0
159,"import java.util.Random;
public class CoinFlipper {
    private Random gen;
    private int numFlips;
    public CoinFlipper() {
        this(new Random());
    }
    public CoinFlipper(Random gen) {
        this.gen = gen;
    }
    public Coin flipCoin() {
        numFlips++;
        if (gen.nextBoolean()) {
            return Coin.HEADS;
        } else {
            return Coin.TAILS;
        }
    }
    public int getNumFlips() {
        return numFlips;
    }
    public static enum Coin {
        HEADS, TAILS
    }
}",0,0,0,0,0,0,0,0,0
160,"package DataStructures.Lists;
import java.util.Objects;
public class CursorLinkedList<T> {
    private static class Node<T> {
        T element;
        int next;
        Node(T element, int next) {
            this.element = element;
            this.next = next;
        }
        boolean isEmpty() {
            return element == null;
        }
    }
    private final int os;
    private int head;
    private final Node<T>[] cursorSpace;
    private int count;
    private final static int CURSOR_SPACE_SIZE = 100;
    {
        cursorSpace = new Node[CURSOR_SPACE_SIZE];
        for (int i = 0; i < CURSOR_SPACE_SIZE; i++) {
            cursorSpace[i] = new Node<>(null, i + 1);
        }
        cursorSpace[CURSOR_SPACE_SIZE - 1].next = 0;
    }
    public CursorLinkedList() {
        os = 0;
        count = 0;
        head = -1;
    }
    public void printList() {
        if (head != -1) {
            int start = head;
            while (start != -1) {
                T element = cursorSpace[start].element;
                System.out.println(element.toString());
                start = cursorSpace[start].next;
            }
        }
    }
    public int indexOf(T element) {
        Objects.requireNonNull(element);
        Node<T> iterator = cursorSpace[head];
        for (int i = 0; i < count; i++) {
            if (iterator.element.equals(element)) {
                return i;
            }
            iterator = cursorSpace[iterator.next];
        }
        return -1;
    }
    public T get(int position) {
        if (position >= 0 && position < count) {
            int start = head;
            int counter = 0;
            while (start != -1) {
                T element = cursorSpace[start].element;
                if (counter == position) {
                    return element;
                }
                start = cursorSpace[start].next;
                counter++;
            }
        }
        return null;
    }
    public void removeByIndex(int index) {
        if (index >= 0 && index < count) {
            T element = get(index);
            remove(element);
        }
    }
    public void remove(T element) {
        Objects.requireNonNull(element);
        T temp_element = cursorSpace[head].element;
        int temp_next = cursorSpace[head].next;
        if (temp_element.equals(element)) {
            free(head);
            head = temp_next;
        } else {  
            int prev_index = head;
            int current_index = cursorSpace[prev_index].next;
            while (current_index != -1) {
                T current_element = cursorSpace[current_index].element;
                if (current_element.equals(element)) {
                    cursorSpace[prev_index].next = cursorSpace[current_index].next;
                    free(current_index);
                    break;
                }
                prev_index = current_index;
                current_index = cursorSpace[prev_index].next;
            }
        }
        count--;
    }
    private void free(int index) {
        Node os_node = cursorSpace[os];
        int os_next = os_node.next;
        cursorSpace[os].next = index;
        cursorSpace[index].element = null;
        cursorSpace[index].next = os_next;
    }
    public void append(T element) {
        Objects.requireNonNull(element);
        int availableIndex = alloc();
        cursorSpace[availableIndex].element = element;
        if (head == -1) {
            head = availableIndex;
        }
        int iterator = head;
        while (cursorSpace[iterator].next != -1) {
            iterator = cursorSpace[iterator].next;
        }
        cursorSpace[iterator].next = availableIndex;
        cursorSpace[availableIndex].next = -1;
        count++;
    }
    private int alloc() {
        int availableNodeIndex = cursorSpace[os].next;
        if (availableNodeIndex == 0) {
            throw new OutOfMemoryError();
        }
        int availableNext = cursorSpace[availableNodeIndex].next;
        cursorSpace[os].next = availableNext;
        cursorSpace[availableNodeIndex].next = -1;
        return availableNodeIndex;
    }
}",0,0,0,0,0,1,0,1,0
161,"from __future__ import print_function
class Node(object):
    def __init__(self, data, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev
    def __str__(self):
        return str(self.data)
    def get_next(self, isnext):
        return self.next if isnext else self.prev
    def get_prev(self, isnext):
        return self.get_next(not isnext)
    def add_next(self, isnext, node):
        if isnext:
            self.next = node
        else:
            self.prev = node
    def add_prev(self, isnext, node):
        self.add_next(not isnext, node)
    def verbose(self):
        return ('prev:' + str(self.prev) +
                ' data:' + str(self.data) +
                ' next:' + str(self.next))
class Nil(Node):
    def __init__(self):
        self.data = None
        self.next = None
        self.prev = None
        super().__init__(data=self.data, next=self.next, prev=self.prev)
class LinkedList(object):
    def __init__(self):
        self.head = Nil()
        self.tail = Nil()
        self.isnext = True
    def add(self, data):
        node = Node(data)
        node.add_next(self.isnext, self.head)
        if self.head.data is None:
            self.tail = node
        else:
            self.head.add_prev(self.isnext, node)
        self.head = node
    def reversed(self):
        self.head, self.tail = self.tail, self.head
        self.isnext = not self.isnext
        self.tail.add_next(self.isnext, Nil())
    def search(self, value):
        current = self.head
        while current.data is not None:
            if current.data == value:
                return current
            current = current.get_next(self.isnext)
        return None
    def remove(self, value):
        current = self.head
        while current.data is not None and current.data != value:
            current = current.get_next(self.isnext)
        if current.data is not None:
            next_ = current.get_next(self.isnext)
            previous = current.get_prev(self.isnext)
            previous.add_next(self.isnext, next_)
            next_.add_prev(self.isnext, previous)
    def __str__(self):
        string = ''
        current = self.head
        while current.get_next(self.isnext) is not None:
            string += str(current.data) + ' -> '
            current = current.get_next(self.isnext)
        string += str(current.data)
        return string
if __name__ in ""__main__"":
    print('create initial linked list')
    LIST = LinkedList()
    for i in [1, -10, 3]:
        print('add {}'.format(i))
        LIST.add(i)
    print()
    print('linked list:', LIST, '\n')
    LIST.reversed()
    print('list reversed\n')
    print('linked list:', LIST, '\n')
    LIST.reversed()
    print('list reversed\n')
    print('linked list:', LIST, '\n')
    for i in [3, 10]:
        print('search {}'.format(i), LIST.search(i))
    print('')
    for i in [1, 4, -10]:
        LIST.remove(i)
        print('remove {}'.format(i))
        print('linked list:', LIST, '\n')",0,0,0,0,0,1,0,1,0
162,"from __future__ import print_function
class LinkedList:           
    def __init__(self):
        self.head = None
        self.tail = None
    def insertHead(self, x):
        newLink = Link(x)                            
        if(self.isEmpty() == True):                  
            self.tail = newLink
        else:
            self.head.previous = newLink             
        newLink.next = self.head                     
        self.head = newLink                          
    def deleteHead(self):
        temp = self.head
        self.head = self.head.next                   
        self.head.previous = None                    
        if(self.head is None):
            self.tail = None                         
        return temp
    def insertTail(self, x):
        newLink = Link(x)
        newLink.next = None                         
        self.tail.next = newLink                    
        newLink.previous = self.tail                
        self.tail = newLink                         
    def deleteTail(self):
        temp = self.tail
        self.tail = self.tail.previous              
        self.tail.next = None                       
        return temp
    def delete(self, x):
        current = self.head
        while(current.value != x):                  
            current = current.next
        if(current == self.head):
            self.deleteHead()
        elif(current == self.tail):
            self.deleteTail()
        else: 
            current.previous.next = current.next 
            current.next.previous = current.previous 
    def isEmpty(self):                               
        return(self.head is None)
    def display(self):                                
        current = self.head
        while(current != None):
            current.displayLink()
            current = current.next  
        print()
class Link:
    next = None                                       
    previous = None                                   
    def __init__(self, x):
        self.value = x
    def displayLink(self):
        print(""{}"".format(self.value), end="" "")",0,0,0,0,0,0,0,1,0
163,"package DataStructures.Lists;
public class DoublyLinkedList {
    private Link head;
    private Link tail;
    public DoublyLinkedList() {
        head = null;
        tail = null;
    }
    public DoublyLinkedList(int[] array) {
        if (array == null) throw new NullPointerException();
        for (int i : array) {
            insertTail(i);
        }
    }
    public void insertHead(int x) {
        Link newLink = new Link(x);  
        if (isEmpty())  
            tail = newLink;
        else
            head.previous = newLink;  
        newLink.next = head;  
        head = newLink;  
    }
    public void insertTail(int x) {
        Link newLink = new Link(x);
        newLink.next = null;  
        if (isEmpty()) {         
            tail = newLink;
            head = tail;
        } else {
            tail.next = newLink;  
            newLink.previous = tail;  
            tail = newLink;  
        }
    }
    public Link deleteHead() {
        Link temp = head;
        head = head.next;  
        head.previous = null;  
        if (head == null)
            tail = null;
        return temp;
    }
    public Link deleteTail() {
        Link temp = tail;
        tail = tail.previous;  
        tail.next = null;  
        if (tail == null) {
            head = null;
        }
        return temp;
    }
    public void delete(int x) {
        Link current = head;
        while (current.value != x) { 
            if (current != tail) {
                current = current.next;
            } else { 
                throw new RuntimeException(""The element to be deleted does not exist!"");
            }
        }
        if (current == head)
            deleteHead();
        else if (current == tail)
            deleteTail();
        else {  
            current.previous.next = current.next;   
            current.next.previous = current.previous;  
        }
    }
    public void insertOrdered(int x) {
        Link newLink = new Link(x);
        Link current = head;
        while (current != null && x > current.value)  
            current = current.next;
        if (current == head)
            insertHead(x);
        else if (current == null)
            insertTail(x);
        else {  
            newLink.previous = current.previous;  
            current.previous.next = newLink;  
            newLink.next = current;  
            current.previous = newLink;  
        }
    }
    public boolean isEmpty() {
        return (head == null);
    }
    public void display() {  
        Link current = head;
        while (current != null) {
            current.displayLink();
            current = current.next;
        }
        System.out.println();
    }
}
class Link {
    public int value;
    public Link next;
    public Link previous;
    public Link(int value) {
        this.value = value;
    }
    public void displayLink() {
        System.out.print(value + "" "");
    }
    public static void main(String args[]) {
        DoublyLinkedList myList = new DoublyLinkedList();
        myList.insertHead(13);
        myList.insertHead(7);
        myList.insertHead(10);
        myList.display();  
        myList.insertTail(11);
        myList.display();  
        myList.deleteTail();
        myList.display();  
        myList.delete(7);
        myList.display();  
        myList.insertOrdered(23);
        myList.insertOrdered(67);
        myList.insertOrdered(3);
        myList.display();  
    }
}",0,0,0,0,0,0,0,1,0
164,"public class DoublyLinkedList{
	Node head;   
	Node tail;   
	int size;    
	public DoublyLinkedList(){
		head=null;
		tail=null;
		size=0;
	}
	public void pushFront(int data){
		System.out.println(""Inserting data at front : "" + data);
		Node node = new Node(data);
		if(head==null && tail==null){
			head=node;
			tail=node;
			size++;
			return;
		}
		node.next=head;
		head.prev=node;
		head=node;
		size++;
	}
	public void pushBack(int data){
		System.out.println(""Inserting data at back  : "" + data);
		Node node = new Node(data);
		if(tail==null && head==null){
			head=node;
			tail=node;
			size++;
			return;
		}
		tail.next=node;
		node.prev=tail;
		tail=node;
		size++;
	}
	public void popFront() throws Exception{
		System.out.println(""PopFront Operation."");
		if(head==null && tail==null){
			throw new Exception(""List is empty!"");
		}
		if(head==tail){
			head=null;
			tail=null;
			size--;
			return;
		}
		head.next.prev=null;
		head=head.next;
		size--;
	}
	public void popBack() throws Exception{
		System.out.println(""PopBack Operation."");
		if(head==null && tail==null){
			throw new Exception(""List is empty!"");
		}
		if(head==tail){
			head=null;
			tail=null;
			size--;
			return;
		}
		tail.prev.next=null;
		tail=tail.prev;
		size--;
	}
	public int topFront() throws Exception{
		if(head==null){
			throw new Exception(""List is empty!"");
		}
		return head.key;
	}
	public int topBack() throws Exception{
		if(tail==null){
			throw new Exception(""List is empty!"");
		}
		return tail.key;
	}
	public boolean Find(int data){
		Node temp=head;
		while(temp!=null){
			if(temp.key==data){
				return true;
			}
			temp=temp.next;
		}
		return false;
	}
	public int size(){
		return size;
	}
	public void forwardDisplay() throws Exception{
		System.out.print(""List : "");
		Node temp = head;
		if(temp==null){
			throw new Exception(""List is empty!"");
		}
		while(temp!=null){
			System.out.print(temp.key + "" "");
			temp=temp.next;
		}
		System.out.println();
	}
	public void reverseDisplay() throws Exception{
		System.out.print(""Reverse List : "");
		Node temp = tail;
		if(temp==null){
			throw new Exception(""List is empty!"");
		}
		while(temp!=null){
			System.out.print(temp.key + "" "");
			temp=temp.prev;
		}
		System.out.println();
	}
	public void remove(int data) throws Exception{
		System.out.println(""Remove data : "" + data);
		Node temp = head;
		Node prevNode = null;
		if(temp==null){
			throw new Exception(""List is empty!"");
		}
		size--;
		if(temp==tail){
			if(temp.key==data){
				head=null;
				tail=null;
				return;
			}
			else{
				throw new Exception(""Data not found"");
			}
		}
		if(head.key==data){
			head=head.next;
			head.prev=null;
			return;
		}
		while(temp!=null && temp.key!=data){
			prevNode=temp;
			temp=temp.next;
		}
		prevNode.next=prevNode.next.next;
		prevNode.next.prev=prevNode;
		temp=null;
	}
}",0,0,0,0,0,1,0,1,0
165,"public class DoublyLinkedList{
	static class Node{
		int key;    
		Node next;  
		Node prev;  
		public Node(int data){
			this.key=data;
			this.next=null;
			this.prev=null;
		}
	}
	static Node head;   
	static Node tail;   
	static int size;    
	public DoublyLinkedList(){
		head=null;
		tail=null;
		size=0;		
	}
	public static void pushFront(int number){
		System.out.println(""Inserting data at front : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			tail=node;
			size++;
			return;
		}
		node.next=head;
		head.prev=node;
		head=node;
		size++;
	}
	public static void pushBack(int number){
		System.out.println(""Inserting data at back  : "" + number);
		Node node =new Node(number);
		if(head==null){
			head=node;
			tail=node;
			size++;
			return;
		}
		Node temp=head;
		while(temp.next!=null){
			temp=temp.next;
		}
		temp.next=node;
		node.prev=temp;
		tail=node;
		size++;
	}
	public static void popFront(){
		System.out.println(""PopFront Operation."");
		if(head==null){
			System.out.println(""Empty List."");
			return;
		}
		if(head.next==null){
			head=null;
			tail=null;
			size--;
			return;
		}
		head=head.next;
		head.prev=null;
		size--;
	}
	public static void popBack(){
		System.out.println(""PopBack Operation."");
		if(head==null){
			System.out.println(""Empty List."");
			return;
		}
		if(head.next==null){
			head=null;
			tail=null;
			size--;
			return;
		}
		Node temp=head;
		while(temp.next.next!=null){
			temp=temp.next;
		}
		temp.next.prev=null;
		temp.next=null;
		tail=temp;
		size--;
	}
	public static void displayF(){
		System.out.print(""List : "");
		if(head==null){
			System.out.println(""Empty List."");
			return;
		}
		Node temp=head;
		while(temp!=null){
			System.out.print(temp.key + "" "");
			temp=temp.next;
		}
		System.out.println();
	}
	public static void displayB(){
		System.out.print(""Reverse List : "");
		if(head==null && tail==null){
			System.out.println(""Empty List."");
			return;
		}
		Node temp=tail;
		while(temp!=null){
			System.out.print(temp.key + "" "");
			temp=temp.prev;
		}
		System.out.println();
	}
	public static void main(String [] args){
		DoublyLinkedList list = new DoublyLinkedList();
		list.pushFront(10);
		list.pushBack(12);
		list.pushFront(8);
		list.pushBack(14);
		list.displayF();
		list.displayB();
		list.popFront();
		list.displayF();
		list.displayB();
		list.popBack();
		list.displayF();
		list.displayB();
		list.popFront();
		list.displayB();
		list.popFront();
		list.displayF();
	}
}",0,0,0,0,0,0,0,1,0
166,"class Node {
  data: Object = {};
  next: Node | boolean = false;
  constructor(data: any = {}, next: Node | boolean = false) {
    this.data = data;
    this.next = next;
  }
  hasNext(): boolean {
    return this.next !== false;
  }
}
export default class DoublyLinkedList {
  head: Node;
  tail: Node;
  head: Node;
  integrity = new Set();
  constructor() {
    this.head = new Node({});
    this.tail = this.head;
  }
  isEmpty(): boolean {
    return !!this.head;
  }
  remove() {
    if (!this.isEmpty() && this.head.hasNext()) {
      this.head = this.head.next;
    }
  }
  has() {}
  next() {}
  insert(data: any, begin?: Node): boolean {
    const target: Node = begin || this.tail;
    const node: Node = new Node(data);
    const tempNext = target.next;
    node.next = tempNext;
    target.next = node;
    return true;
  }
}",0,0,0,0,0,0,0,1,0
167,"public class DoublyLinkedList {
    class Node{
        Node prev;
        int data;
        Node next;
        Node(int data){
            this.data=data;
        }
    }
    Node head=null;
    Node tail=null;
    void addNode(int d){
        Node new_node=new Node(d);
        if(head==null){
            head=tail=new_node;
            new_node.prev=null;
            new_node.next=null;
        }else{
            new_node.prev=tail;
            tail.next=new_node;
            tail=new_node;
        }
    }
    void insertStart(int d){
        Node new_node =new Node(d);
        if (head==null){
            System.out.print(""List is empty"");
        }else{
            new_node.prev=null;
            new_node.next=head;
            head.prev=new_node;
            head=new_node;
        }
    }
    void deleteEnd(){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            Node current=head;
            while(current.next.next!=null){
                current=current.next;
            }
            current.next=null;
        }
    }
    void insertMiddle(int d,int n){
        Node new_node=new Node(d);
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            Node current=head;
            Node previous=head;
            for(int i=0;i<n;i++){
                previous=current;
                current=current.next;
            }
            new_node.prev=previous;
            new_node.next=current;
            previous.next=new_node;
            current.prev=new_node;
        }
    }
    void deleteMiddle(int n){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            Node current=head;
            Node previous=head;
            for(int i=0;i<n;i++){
                previous=current;
                current=current.next;
            }
            previous.next=current.next;
            current.next.prev=previous;
        }
    }
    void display(){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
           Node  current=head;
           while(current!=null){
               System.out.print(""  ""+current.data);
               current=current.next;
           }
        }
    }
    public static void main(String args[]){
        DoublyLinkedList dlist= new DoublyLinkedList();
        dlist.addNode(10);
        dlist.addNode(20);
        dlist.addNode(30);
        dlist.addNode(40);
        dlist.insertStart(5);
        dlist.insertStart(2);
        dlist.insertMiddle(25,3);
        dlist.display();
    }
}",0,0,0,0,0,0,0,1,0
168,"class DoublyLinkedList{
	private Link head;
	private Link tail;
	public DoublyLinkedList(){
		head = null;
		tail = null;
	}
	public void insertHead(int x){
		Link newLink = new Link(x);  
		if(isEmpty())  
			tail = newLink;
		else
			head.previous = newLink;  
		newLink.next = head;  
		head = newLink;  
	}
	public void insertTail(int x){
		Link newLink = new Link(x);
		newLink.next = null;  
		tail.next = newLink;  
		newLink.previous = tail;  
		tail = newLink;  
	}
	public Link deleteHead(){
		Link temp = head;
		head = head.next;  
		head.previous = null;  
		if(head == null)
			tail = null;
		return temp;
	}
	public Link deleteTail(){
		Link temp = tail;
		tail = tail.previous;  
 		tail.next = null;  
		return temp;
	}
	public Link delete(int x){
		Link current = head;
		while(current.value != x)  
			current = current.next;
		if(current == head)
			deleteHead();
		else if(current == tail)
			deleteTail();
		else{  
			current.previous.next = current.next;   
			current.next.previous = current.previous;  
		}
		return current;
	}
	public void insertOrdered(int x){
		Link newLink = new Link(x);
		Link current = head;
		while(current != null && x > current.value)  
			current = current.next;
		if(current == head)
			insertHead(x);
		else if(current == null)
			insertTail(x);
		else{  
			newLink.previous = current.previous;  
			current.previous.next = newLink;  
			newLink.next = current;  
			current.previous = newLink;  
		}
	}
	public boolean isEmpty(){
		return(head == null);
	}
	public void display(){  
		Link current = head;
		while(current!=null){
			current.displayLink();
			current = current.next;
		}
		System.out.println();
	}
}
class Link{
	public int value;
	public Link next;
	public Link previous;
	public Link(int value){
		this.value = value;
	}
	public void displayLink(){
		System.out.print(value+"" "");
	}
	public static void main(String args[]){
		DoublyLinkedList myList = new DoublyLinkedList();
		myList.insertHead(13);
		myList.insertHead(7);
		myList.insertHead(10);
		myList.display();  
		myList.insertTail(11);
		myList.display();  
		myList.deleteTail();
		myList.display();  
		myList.delete(7);
		myList.display();  
		myList.insertOrdered(23);
		myList.insertOrdered(67);
		myList.insertOrdered(3);
		myList.display();  
	}
}",0,0,0,0,0,0,0,1,0
169,"package com.deepak.data.structures.LinkedList;
public class DoublyLinkedList<E> {
	private Node<E> head;
	private Node<E> tail;
	private int size = 0;
	public void insertAtHead(E value) {
		Node<E> newNode = new Node<E>(value);
		if (null == head) { 
			newNode.next = null;
			newNode.prev = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			newNode.next = head;
			newNode.prev = null;
			head.prev = newNode;
			head = newNode;
			size++;
		}
	}
	public void insertAtTail(E value) {
		Node<E> newNode = new Node<E>(value);
		if (null == tail) { 
			newNode.next = null;
			newNode.prev = null;
			head = newNode;
			tail = newNode;
			size++;
		} else {
			tail.next = newNode;
			newNode.next = null;
			newNode.prev = tail;
			tail = newNode;
			size++;
		}
	}
	public void insertAtPosition(E value, int position) {
		if (position < 0 || position > size) {
			throw new IllegalArgumentException(""Position is Invalid"");
		} 
		if (position == 0) { 
			insertAtHead(value);
		} else if (position == size -1) { 
			insertAtTail(value);
		} else { 
			Node<E> currentNode = head;
			for (int i = 0; i < position; i++) {
				currentNode = currentNode.next;
			}
			Node<E> previousNode = currentNode.prev;
			Node<E> newNode = new Node<E>(value);
			newNode.next = currentNode;
			newNode.prev = previousNode;
			previousNode.next = newNode;
			currentNode.prev = newNode;
			size++;
		}
	}
	public void traverseForward() {
		Node<E> temp = head;
		while (temp != null) {
			System.out.println(temp.item);
			temp = temp.next;
		}
	}
	public void traverseBackward() {
		Node<E> temp = tail;
		while (temp != null) {
			System.out.println(temp.item);
			temp = temp.prev;
		}
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0;
	}
	public Node<E> searchByIndex(int index) {
		if (index < 0 || index >= size) {
			throw new IndexOutOfBoundsException(""Invalid index passed while searching for a value"");
		} 
		Node<E> temp = head;
		for (int i = 0; i < index; i++) { 
			temp = temp.next;
		}
		return temp;
	}
	public Node<E> searchByValue(E value) { 
		Node<E> temp = head;
		while (null != temp.next && temp.item != value) {
			temp = temp.next;
		}
		if (temp.item == value) {
			return temp;
		}
		return null;
	}
	public void deleteFromHead() {
		if (null == head) { 
			return;
		}
		Node<E> temp = head;
		head = temp.next;
		head.prev = null;
		size--;
	}
	public void deleteFromTail() {
		if (null == tail) { 
			return;
		}
		Node<E> temp = tail;
		tail = temp.prev;
		tail.next = null;
		size--;
	}
	public void deleteFromPosition(int position) {
		if (position < 0 || position >= size) {
			throw new IllegalArgumentException(""Position is Invalid"");
		} 
		Node<E> nodeToBeDeleted = head;
		for (int i = 0; i < position; i++) {
			nodeToBeDeleted = nodeToBeDeleted.next;
		}
		Node<E> previousNode = nodeToBeDeleted.prev;
		Node<E> nextNode = nodeToBeDeleted.next;
		previousNode.next = nextNode;
		nextNode.prev = previousNode;
		size--;
	}
	public Object[] toArray() {
		Object[] result = new Object[size];
		int i = 0;
		for (Node<E> x = head; x != null; x = x.next) {
			result[i++] = x.item;
		}
		return result;
	}
	public class Node<T> {
		T item;
		Node<T> next;
		Node<T> prev;
		public Node(T item) {
			this.item = item;
		}
		@Override
		public String toString() {
			return String.valueOf(item);
		}
	}
}",0,0,0,0,0,1,0,1,0
170,"package LinkedList;
import java.util.*;
public class DoublyLinkedList {
    private static int length;
    private static ListNode head;
    private static ListNode tail;
    private static class ListNode {
        private final int data;
        private ListNode previous;
        private ListNode next;
        public ListNode(int data){
            this.data = data;
        }
    }
    public DoublyLinkedList() {
        head = null;
        tail = null;
        length = 0;
    }
    private boolean isEmpty() {
        return length == 0;
    }
    private void getLength() {
        System.out.println(length);
    }
    private void printList(ListNode head) {
        if(isEmpty()) {
            return;
        }
        ListNode current = head;
        while (current != null) {
            System.out.print(current.data + ""-->"");
            current = current.next;
        }
        System.out.println(""null"");
    }
    private void reverseList(ListNode tail) {
        ListNode current = tail;
        while (current != null) {
            System.out.print(current.data+""-->"");
            current = current.previous;
        }
        System.out.println(""null"");
    }
    private void insertFirst(int value) {
        ListNode newNode = new ListNode(value);
        if (isEmpty()) {
            head = newNode;
            tail = newNode;
        }else {
            newNode.next = head;
            head.previous = newNode;
            head = newNode;
        }
        length++;
    }
    private void insertLast(int value) {
        ListNode newNode = new ListNode(value);
        if(isEmpty()) {
            head = newNode;
        }else {
            tail.next = newNode;
            newNode.previous = tail;
        }
        tail = newNode;
        length++;
    }
    private void deleteFirst() {
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        if(head == tail) {
            head = null;
            tail = null;
            return;
        }
        ListNode temp = head;
        temp.next.previous = null;
        head = temp.next;
        temp.next = null;
        length--;
    }
    private void deleteLast() {
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        if(head == tail){
            head = null;
            tail = null;
            return;
        }
        ListNode temp = tail;
        temp.previous.next = null;
        tail = temp.previous;
        temp.previous = null;
        length--;
    }
    public static void main(String[] args) {
        DoublyLinkedList dll = new DoublyLinkedList();
        dll.insertFirst(10);
        dll.insertLast(8);
        dll.insertLast(2);
        dll.printList(head);
        dll.deleteLast();
        dll.deleteFirst();
        dll.printList(head);
        dll.reverseList(tail);
        dll.getLength();
    }
}",0,0,0,0,0,0,0,1,0
171,"package structures;
public class DoublyLinkedList {
    int[] next;
    int[] prev;
    public DoublyLinkedList(int maxSize) {
        next = new int[maxSize + 1];
        prev = new int[maxSize + 1];
    }
    public void insert(int x, int insertAfter) {
        prev[x] = insertAfter;
        next[x] = next[insertAfter];
        prev[next[x]] = x;
        next[prev[x]] = x;
    }
    public void remove(int x) {
        next[prev[x]] = next[x];
        prev[next[x]] = prev[x];
    }
    public static void main(String[] args) {
        int n = 10;
        DoublyLinkedList list = new DoublyLinkedList(n);
        for (int i = 1; i <= n; i++) {
            list.insert(i, i - 1);
        }
        list.remove(1);
        list.remove(10);
        list.remove(5);
        for (int i = list.next[0]; i != 0; i = list.next[i]) {
            System.out.print(i + "" "");
        }
        System.out.println();
    }
}",0,0,0,0,0,0,0,1,0
172,"const { Node } = require('./Node');
class DoublyLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.count = 0;
    }
    any() {
        return this.head !== null;
    }
    addFront(value) {
        const node = new Node(value);
        node.next = this.head;
        if (this.head === null) {
            this.tail = node;
        } else {
            this.head.previous = node;
        }
        this.head = node;
        this.count++;
    }
    addEnd(value) {
        const node = new Node(value);
        if (this.tail === null) {
            this.head = node;
        } else {
            this.tail.next = node;
            node.previous = this.tail;
        }
        this.tail = node;
        this.count++;
    }
    removeFront() {
        if (this.head === null) {
            return null;
        }
        const deletedNode = this.head;
        if (this.head.next == null) {
            this.tail = null;
        } else {
            this.head.next.previous = null;
        }
        this.head = this.head.next;
        deletedNode.next = null;
        this.count--;
        return deletedNode;
    }
    removeEnd() {
        if (this.tail === null) {
            return null;
        }
        const deletedNode = this.tail;
        if (this.tail.previous === null) {
            this.head = null;
        } else {
            this.tail.previous.next = null;
        }
        this.tail = this.tail.previous;
        deletedNode.previous = null;
        this.count--;
        return deletedNode;
    }
    toArray() {
        const nodes = [];
        let currentNode = this.head;
        while (currentNode != null) {
            nodes.push(currentNode.value);
            currentNode = currentNode.next;
        }
        return nodes;
    }
    toString() {
        const nodes = this.toArray();
        return `DoublyLinkedList [ ${nodes.join(' <-> ')} ]`;
    }
}
module.exports = { DoublyLinkedList };",0,0,0,0,0,0,0,1,0
173,"class Node {
  constructor(value) {
    this.value = value;
    this.previous = null;
    this.next = null;
  }
}
class DoublyLinkedList {
  constructor(value) {
    this.head = new Node(value);
    this.tail = this.head;
    this.length = 1;
  }
  printLinkedList() {
    let currentNode = this.head;
    const listElements = [];
    while (currentNode) {
      listElements.push(currentNode.value);
      currentNode = currentNode.next;
    }
    console.log(listElements);
  }
  append(value) {
    const newNode = new Node(value);
    newNode.previous = this.tail;
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
  }
  prepend(value) {
    const newNode = new Node(value);
    newNode.next = this.head;
    this.head.previous = newNode;
    this.head = newNode;
    this.length++;
  }
  _traverseToIndex(index) {
    let counter = 0;
    let currentNode = this.head;
    while (counter != index) {
      currentNode = currentNode.next;
      counter++;
    }
    return currentNode;
  }
  insert(index, value) {
    if (index === 0) {
      this.prepend(value);
      return;
    }
    if (index >= this.length) {
      this.append(value);
      return;
    }
    const newNode = new Node(value);
    const leader = this._traverseToIndex(index - 1);
    const follower = leader.next;
    leader.next = newNode;
    newNode.previous = leader;
    newNode.next = follower;
    follower.previous = newNode;
    this.length++;
  }
  remove(index) {
    if (index === 0) {
      this.head = this.head.next;
      this.head.previous = null;
      this.length--;
      return;
    }
    if (index === this.length - 1) {
      this.tail = this.tail.previous;
      this.tail.next = null;
      this.length--;
      return;
    }
    const leader = this._traverseToIndex(index - 1);
    const unwantedNode = leader.next;
    const follower = unwantedNode.next;
    leader.next = follower;
    follower.previous = leader;
    this.length--;
  }
}
const myLinkedList = new DoublyLinkedList(10);
myLinkedList.printLinkedList();
myLinkedList.append(20);
myLinkedList.append(30);
myLinkedList.prepend(1);
myLinkedList.printLinkedList();
myLinkedList.insert(2, 99);
myLinkedList.insert(2, 69);
myLinkedList.insert(0, 420);
myLinkedList.insert(20, 666);
myLinkedList.printLinkedList();
myLinkedList.remove(0);
myLinkedList.remove(2);
myLinkedList.remove(5);
myLinkedList.printLinkedList();",0,0,0,0,0,0,0,1,0
174,"public class DoublyLinkedListImplementation{
	public static void main(String [] args){
		DoublyLinkedList list = new DoublyLinkedList();   
		try{
			list.pushBack(10);
			list.pushBack(20);
			list.pushFront(8);
			list.pushFront(6);
			list.pushBack(22);
			list.pushBack(16);
			System.out.println(""Front element : "" + list.topFront());
			System.out.println(""Last element : "" + list.topBack());
			System.out.println(""List size : "" + list.size());
			list.forwardDisplay();
			list.remove(6);
			list.reverseDisplay();
			System.out.println(""Find 8 : "" + list.Find(8));
			list.popFront();
			System.out.println(""List size : "" + list.size());
			list.forwardDisplay();
			list.popBack();
			System.out.println(""Find 20 : "" + list.Find(20));
			System.out.println(""List size : "" + list.size());
			list.reverseDisplay();
			list.popFront();
			System.out.println(""List size : "" + list.size());
			list.forwardDisplay();
		}
		catch(Exception e){
			System.out.println(e);
		}
	}
}",0,0,0,0,0,0,0,0,0
175,"package Lists.SinglyLinkedList;
public class Employee {
    private String firstName;
    private String lastName;
    private int id;
    public Employee(String firstName, String lastName, int id) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.id = id;
    }
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        if (id != employee.id) return false;
        if (!firstName.equals(employee.firstName)) return false;
        return lastName.equals(employee.lastName);
    }
    @Override
    public int hashCode() {
        int result = firstName.hashCode();
        result = 31 * result + lastName.hashCode();
        result = 31 * result + id;
        return result;
    }
    @Override
    public String toString() {
        return ""Employee{"" +
                ""firstName='"" + firstName + '\'' +
                "", lastName='"" + lastName + '\'' +
                "", id="" + id +
                '}';
    }
}",0,0,0,0,0,0,0,0,0
176,"package Lists.Challenges.Challenge1;
import Lists.DoublyLinkedList.Employee;
import Lists.DoublyLinkedList.EmployeeNode;
public class EmployeeDoublyLinkedList {
    private EmployeeNode head;
    private EmployeeNode tail;
    private int size;
    public void addToFront(Employee employee) {
        EmployeeNode node = new EmployeeNode(employee);
        if (head == null) {
            tail = node;
        }
        else {
            head.setPrevious(node);
            node.setNext(head);
        }
        head = node;
        size++;
    }
    public void addToEnd(Employee employee) {
        EmployeeNode node = new EmployeeNode(employee);
        if (tail == null) {
            head = node;
        }
        else {
            tail.setNext(node);
            node.setPrevious(tail);
        }
        tail = node;
        size++;
    }
    public boolean addBefore(Employee newEmployee, Employee existingEmployee) {
        if(head == null){
            return false;
        }
        EmployeeNode current = head;
        while(current != null && !current.getEmployee().equals(existingEmployee)){
            current = current.getNext();
        }
        if(current==null) return false;
        EmployeeNode newNode = new EmployeeNode(newEmployee);  
        newNode.setPrevious(current.getPrevious());  
        newNode.setNext(current);  
        current.setPrevious(newNode);  
        if (head == current) {
            head = newNode;
        }
        else {
            newNode.getPrevious().setNext(newNode);  
        }
        size++;
        return false;
    }
    public EmployeeNode removeFromFront() {
        if (isEmpty()) {
            return null;
        }
        EmployeeNode removedNode = head;
        if (head.getNext() == null) {
            tail = null;
        }
        else {
            head.getNext().setPrevious(null);
        }
        head = head.getNext();
        size--;
        removedNode.setNext(null);
        return removedNode;
    }
    public EmployeeNode removeFromEnd() {
        if (isEmpty()) {
            return null;
        }
        EmployeeNode removedNode = tail;
        if (tail.getPrevious() == null) {
            head = null;
        }
        else {
            tail.getPrevious().setNext(null);
        }
        tail = tail.getPrevious();
        size--;
        removedNode.setPrevious(null);
        return removedNode;
    }
    public int getSize() {
        return size;
    }
    public boolean isEmpty() {
        return head == null;
    }
    public void printList() {
        EmployeeNode current = head;
        System.out.print(""HEAD -> "");
        while (current != null) {
            System.out.print(current);
            System.out.print("" <=> "");
            current = current.getNext();
        }
        System.out.println(""null"");
    }
}",0,0,0,0,0,0,0,1,0
177,"package Lists.DoublyLinkedList;
public class EmployeeDoublyLinkedList {
    private EmployeeNode head;
    private EmployeeNode tail;
    private int size;
    public void addToFront(Employee employee) {
        EmployeeNode node = new EmployeeNode(employee);
        if (head == null) {  
            tail = node;
        }
        else {
            head.setPrevious(node);  
            node.setNext(head);  
        }
        head = node;  
        size++;
    }
    public void addToEnd(Employee employee) {
        EmployeeNode node = new EmployeeNode(employee);
        if (tail == null) {  
            head = node;
        }
        else {
            tail.setNext(node);  
            node.setPrevious(tail);  
        }
        tail = node;  
        size++;
    }
    public EmployeeNode removeFromFront() {
        if (isEmpty()) {
            return null;
        }
        EmployeeNode removedNode = head;  
        if (head.getNext() == null) {  
            tail = null;
        }
        else {
            head.getNext().setPrevious(null);  
        }
        head = head.getNext();  
        size--;
        removedNode.setNext(null);  
        return removedNode;  
    }
    public EmployeeNode removeFromEnd() {
        if (isEmpty()) {
            return null;
        }
        EmployeeNode removedNode = tail;  
        if (tail.getPrevious() == null) {  
            head = null;
        }
        else {
            tail.getPrevious().setNext(null);  
        }
        tail = tail.getPrevious();  
        size--;
        removedNode.setPrevious(null);  
        return removedNode;  
    }
    public int getSize() {
        return size;
    }
    public boolean isEmpty() {
        return head == null;
    }
    public void printList() {
        EmployeeNode current = head;
        System.out.print(""HEAD -> "");
        while (current != null) {
            System.out.print(current);
            System.out.print("" <=> "");
            current = current.getNext();
        }
        System.out.println(""null"");
    }
}",0,0,0,0,0,0,0,1,0
178,"package com.mehmetpekdemir.list.doublylinkedlist;
import com.mehmetpekdemir.shared.Employee;
public class EmployeeDoublyLinkedList {
	private EmployeeNode head = null;
	private EmployeeNode tail = null;
	private int size = 0;
	public void addToFront(Employee employee) {
		EmployeeNode node = new EmployeeNode(employee);
		if (head == null) {
			tail = node;
		} else {
			head.setPrevious(node);
			node.setNext(head);
		}
		head = node;
		size++;
	}
	public void addToEnd(Employee employee) {
		EmployeeNode node = new EmployeeNode(employee);
		if (tail == null) {
			head = node;
		} else {
			tail.setNext(node);
			node.setPrevious(tail);
		}
		tail = node;
		size++;
	}
	public EmployeeNode removeFromFront() {
		if (isEmpty()) {
			return null;
		}
		EmployeeNode node = head;
		if (head.getNext() == null) {
			tail = null;
		} else {
			head.getNext().setPrevious(null);
		}
		head = head.getNext();
		size--;
		node.setNext(null);
		return node;
	}
	public EmployeeNode removeFromEnd() {
		if (isEmpty()) {
			return null;
		}
		EmployeeNode node = tail;
		if (tail.getPrevious() == null) {
			head = null;
		} else {
			tail.getPrevious().setNext(null);
		}
		tail = tail.getPrevious();
		size--;
		node.setPrevious(null);
		return node;
	}
	public boolean isEmpty() {
		return head == null;
	}
	public int getSize() {
		return size;
	}
	public void printList() {
		EmployeeNode current = head;
		System.out.print(""HEAD -> "");
		while (current != null) {
			System.out.print(current);
			System.out.print("" <=> "");
			current = current.getNext();
		}
		System.out.println(""null"");
	}
}",0,0,0,0,0,0,0,1,0
179,"package Lists.SinglyLinkedList;
public class EmployeeLinkedList {
    private EmployeeNode head;
    private int size;
    public void addToFront(Employee employee) {
        EmployeeNode node = new EmployeeNode(employee);
        node.setNext(head);
        head = node;
        size++;
    }
    public EmployeeNode removeFromFront() {
        if (isEmpty()) {
            return null;
        }
        EmployeeNode removedNode = head;
        head = head.getNext();
        size--;
        removedNode.setNext(null);
        return removedNode;
    }
    public int getSize() {
        return size;
    }
    public boolean isEmpty() {
        return head == null;
    }
    public void printList() {
        EmployeeNode current = head;
        System.out.print(""HEAD -> "");
        while (current != null) {
            System.out.print(current);
            System.out.print("" -> "");
            current = current.getNext();
        }
        System.out.println(""null"");
    }
}",0,0,0,0,0,0,0,1,0
180,"package com.mehmetpekdemir.list.singlylinkedlist;
import com.mehmetpekdemir.shared.Employee;
public class EmployeeLinkedList {
	private EmployeeNode head = null;
	private int size = 0;
	public void addToFront(Employee employee) {
		EmployeeNode node = new EmployeeNode(employee);
		node.setNext(head);
		head = node;
		size++;
	}
	public EmployeeNode removeFromFront() {
		if (isEmpty()) {
			return null;
		}
		EmployeeNode node = head;
		head = head.getNext();
		size--;
		node.setNext(null);
		return node;
	}
	public boolean isEmpty() {
		return head == null;
	}
	public int getSize() {
		return size;
	}
	public void printList() {
		EmployeeNode current = head;
		System.out.print(""HEAD -> "");
		while (current != null) {
			System.out.print(current);
			System.out.print("" -> "");
			current = current.getNext();
		}
		System.out.println(""null"");
	}
}",0,0,0,0,0,0,0,1,0
181,"package Lists.SinglyLinkedList;
public class EmployeeNode {
    private Employee employee;
    private EmployeeNode next;
    public EmployeeNode(Employee employee) {
        this.employee = employee;
    }
    public Employee getEmployee() {
        return employee;
    }
    public void setEmployee(Employee employee) {
        this.employee = employee;
    }
    public EmployeeNode getNext() {
        return next;
    }
    public void setNext(EmployeeNode next) {
        this.next = next;
    }
    public String toString() {
        return employee.toString();
    }
}",0,0,0,0,0,0,0,0,0
182,"package Lists.DoublyLinkedList;
public class EmployeeNode {
    private Employee employee;
    private EmployeeNode next;
    private EmployeeNode previous;
    public EmployeeNode(Employee employee) {
        this.employee = employee;
    }
    public Employee getEmployee() {
        return employee;
    }
    public void setEmployee(Employee employee) {
        this.employee = employee;
    }
    public EmployeeNode getNext() {
        return next;
    }
    public void setNext(EmployeeNode next) {
        this.next = next;
    }
    public EmployeeNode getPrevious() {
        return previous;
    }
    public void setPrevious(EmployeeNode previous) {
        this.previous = previous;
    }
    public String toString() {
        return employee.toString();
    }
}",0,0,0,0,0,0,0,0,0
183,"package com.mehmetpekdemir.list.doublylinkedlist;
import com.mehmetpekdemir.shared.Employee;
class EmployeeNode {
	private Employee employee;
	private EmployeeNode next;
	private EmployeeNode previous;
	public EmployeeNode(Employee employee) {
		this.employee = employee;
	}
	public Employee getEmployee() {
		return employee;
	}
	public void setEmployee(Employee employee) {
		this.employee = employee;
	}
	public EmployeeNode getNext() {
		return next;
	}
	public void setNext(EmployeeNode next) {
		this.next = next;
	}
	public EmployeeNode getPrevious() {
		return previous;
	}
	public void setPrevious(EmployeeNode previous) {
		this.previous = previous;
	}
	@Override
	public String toString() {
		return employee.toString();
	}
}",0,0,0,0,0,0,0,0,0
184,"package linkedlist;
public class EmptyListException extends Exception{
    public EmptyListException()
    {
        super(""List"");
    }
    public EmptyListException(String name)
    {
        super(name+"" is empty"");
    }
}",0,0,0,0,0,0,0,0,0
185,"package intcoll4;
public class Intcoll4 {
	private ListNode c;
	private int howmany;
	public Intcoll4() {
		c = null;
		howmany = 0;
	}
	public Intcoll4(int i) {
		this();
	}
	private class ListNode {
		private ListNode link;  
		private int info;  
		public ListNode() {
			link = null;  
			info = 0;  
		}
	}
	public void copy(Intcoll4 obj) {
		if (this != obj) {  
			ListNode newlist;  
			if (obj.howmany == 0) {  
				newlist = null;  
			} else {
				ListNode cur = obj.c;  
				newlist = new ListNode();  
				newlist.info = cur.info;  
				ListNode p = newlist;   
				cur = cur.link;  
				while (cur != null) {
					p.link = new ListNode();  
					p = p.link;  
					p.info = cur.info;  
					cur = cur.link;    
				}
			}
			c = newlist;
			howmany = obj.howmany;
		}
	}
	public boolean belongs(int i) {
		if (i < 0)
			return false;
		ListNode cur = c;  
		while (cur != null && cur.info != i)
			cur = cur.link;
		if (cur == null)  
			return false;
		else  
			return true;
	}
	public void insert(int i) {
		if (!belongs(i)) {
			ListNode next = new ListNode();
			next.info = i;
			next.link = this.c;  
			c = next;
			howmany++;
		}
	}
	public void omit(int i) {
		if (belongs(i)) {
			ListNode cur = c;  
			ListNode prev = null;  
			while (cur != null && cur.info != i) {  
				prev = cur;  
				cur = cur.link;  
			}
			if (cur != null) { 
				if (prev == null) {
					c = cur.link; 
				} else {
					prev.link = cur.link;
				}
				this.howmany--;  
			}
		}
	}
	public int get_howmany() {
		return this.howmany;
	}
	public void print() {
		ListNode cur = c;
		while (cur != null) {
			System.out.println(cur.info);
			cur = cur.link;
		}
	}
	public boolean equals(Intcoll4 obj) {
		boolean result = (this.howmany == obj.howmany);
		ListNode cur = this.c;
		while (cur != null && result) {
			result = obj.belongs(cur.info);
			cur = cur.link;
		}
		return result;
	}
}",0,0,0,0,0,0,0,1,0
186,"package intcoll5;
import java.util.LinkedList;
import java.util.ListIterator;
public class Intcoll5 {
	private LinkedList<Integer> c;
	public Intcoll5() {
		c = new LinkedList<>();
	}
	public Intcoll5(int i) {
		this();
	}
	public void copy(Intcoll5 obj) {
		if (this != obj) {  
			LinkedList<Integer> newlist = new LinkedList<>();
			ListIterator<Integer> iter = obj.c.listIterator();
			while (iter.hasNext()) {
				newlist.add(iter.next());
			}
			c = newlist;
		}
	}
	public boolean belongs(int i) {
		if (i < 0)
			return false;
		return this.c.contains(i);
	}
	public void insert(int i) {
	      Integer I=new Integer(i);
	      if ((i>0)&&(!c.contains(i)))  {  c.addFirst(I); 
		}
	}
	public void omit(int i) {
		this.c.remove(new Integer(i));
	}
	public int get_howmany() {
		return this.c.size();
	}
	public void print() {
		ListIterator<Integer> iter = this.c.listIterator();
		while (iter.hasNext()) {
			System.out.println(iter.next().intValue());
		}
	}
	public boolean equals(Intcoll5 obj) {
		boolean result = (this.get_howmany() == obj.get_howmany());
		ListIterator<Integer> iter = obj.c.listIterator();
		while (iter.hasNext() && result) {
			result = this.belongs(iter.next());
		}
		return result;
	}
}",0,0,0,0,0,0,0,1,0
187,"package Lists.Challenges.Challenge2;
import java.util.List;
public class IntegerLinkedList {
    private IntegerNode head;
    private int size;
    public void addToFront(Integer value) {
        IntegerNode node = new IntegerNode(value);
        node.setNext(head);
        head = node;
        size++;
    }
    public IntegerNode removeFromFront() {
        if (isEmpty()) {
            return null;
        }
        IntegerNode removedNode = head;
        head = head.getNext();
        size--;
        removedNode.setNext(null);
        return removedNode;
    }
    public void insertSorted(Integer value) {
        if (head == null || head.getValue() >= value){
            addToFront(value);
            return;
        }
        IntegerNode current =head.getNext();  
        IntegerNode previous = head;  
        while (current!=null && current.getValue()<value){
            previous = current;
            current = current.getNext();
        }
        IntegerNode newNode = new IntegerNode(value);
        newNode.setNext(current);  
        previous.setNext(newNode);  
        size++;
    }
    public int getSize() {
        return size;
    }
    public boolean isEmpty() {
        return head == null;
    }
    public void printList() {
        IntegerNode current = head;
        System.out.print(""HEAD -> "");
        while (current != null) {
            System.out.print(current);
            System.out.print("" -> "");
            current = current.getNext();
        }
        System.out.println(""null"");
    }
}",0,0,0,0,0,0,0,1,0
188,"package Lists.Challenges.Challenge2;
public class IntegerNode {
    private Integer value;
    private IntegerNode next;
    public IntegerNode(Integer value) {
        this.value = value;
    }
    public Integer getValue() {
        return value;
    }
    public void setValue(Integer value) {
        this.value = value;
    }
    public IntegerNode getNext() {
        return next;
    }
    public void setNext(IntegerNode next) {
        this.next = next;
    }
    public String toString() {
        return value.toString();
    }
}",0,0,0,0,0,0,0,0,0
189,"def is_palindrome(head):
    if not head:
        return True
    fast, slow = head.next, head
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
    second = slow.next
    slow.next = None  
    node = None
    while second:
        nxt = second.next
        second.next = node
        node = second
        second = nxt
    while node:
        if node.val != head.val:
            return False
        node = node.next
        head = head.next
    return True
def is_palindrome_stack(head):
    if not head or not head.next:
        return True
    slow = fast = cur = head
    while fast and fast.next:
        fast, slow = fast.next.next, slow.next
    stack = [slow.val]
    while slow.next:
        slow = slow.next
        stack.append(slow.val)
    while stack:
        if stack.pop() != cur.val:
            return False
        cur = cur.next
    return True
def is_palindrome_dict(head):
    if not head or not head.next:
        return True
    d = {}
    pos = 0
    while head:
        if head.val in d.keys():
            d[head.val].append(pos)
        else:
            d[head.val] = [pos]
        head = head.next
        pos += 1
    checksum = pos - 1
    middle = 0
    for v in d.values():
        if len(v) % 2 != 0:
            middle += 1
        else:
            step = 0
            for i in range(0, len(v)):
                if v[i] + v[len(v) - 1 - step] != checksum:
                    return False
                step += 1
        if middle > 1:
            return False
    return True",0,0,0,0,0,0,0,0,0
190,"from __future__ import print_function
class Node(object):
	def __init__(self, data):
		self.data = data
  self.nextnode = None
class LinkedList(object):
	def __init__(self, head=None):
		self.head = head
 def search(self, head, data, index):
		if head.data == data:
			print (index)
  else:
			if head.nextnode:
				return self.search(head.nextnode, data, index+1)
   else:
				raise ValueError(""Node not in linked list"")
 def print_list(self):
		if self.head == None:
			raise ValueError(""List is empty"")
  current = self.head 
  while(current):
			print (current.data, end=""  "")
   current = current.nextnode
  print ('\n')
 def size(self):
		if self.head == None:
			return 0
  size = 0
  current = self.head
  while(current):
			size += 1
   current = current.nextnode
  return size
 def insert(self, data):
		node = Node(data)
  if not self.head:
			self.head = node
  else:
			node.nextnode = self.head
   self.head = node
 def delete(self, data):
		if not self.head:
			return
  temp = self.head
  if head.data == data:
			head = temp.nextnode
   print (""Deleted node is "" + str(head.data))
   return
  while(temp.nextnode):
			if (temp.nextnode.data == data):
				print (""Node deleted is "" + str(temp.nextnode.data))
    temp.nextnode = temp.nextnode.nextnode
    return
   temp = temp.nextnode
  print (""Node not found"")
  return",0,0,0,0,0,1,0,1,0
191,"from .base_linked_list import BaseLinkedList
from .node import Node
class LinkedList(BaseLinkedList):
    def __init__(self):
        super(LinkedList, self).__init__()
    def add(self, data: Node):
        if not isinstance(data, Node):
            raise TypeError()
        if self.node is None:
            self.node: Node = data
        else:
            current = self.node
            while current.next is not None:
                current = current.next
            current.next = data
        self.length += 1
    @classmethod
    def create(cls, node: Node) -> 'LinkedList':
        linked_list = LinkedList()
        if node is None:
            return linked_list
        current = node
        while current is not None:
            linked_list.add(Node(current.data))
            current = current.next
        return linked_list",0,0,0,0,0,0,0,0,0
192,"class linkedList:
    def __init__(self, value=0, pointer=None):
        self.value=value
        self.pointer=pointer
def main():
    import random
    node = linkedList(0)
    last=node
    for i in range(random.randint(10, 25)):
        newNode=linkedList(random.randint(1, 100))
        last.pointer=newNode
        last=newNode
    current_node = node
    while(current_node.pointer != None):
        print(current_node.value, '=> ', end='')
        current_node=current_node.pointer
    print(current_node.value)
if __name__ == ""__main__"":
    main()",0,0,0,0,0,0,0,0,0
193,"from typing import Any
class Node:
    def __init__(self, data: Any):
        self.data = data
        self.next = None
    def __repr__(self):
        return self.data
class LinkedList:
    def __init__(self):
        self.head = None
    def __repr__(self):
        node = self.head
        nodes = []
        while node is not None:
            nodes.append(node.data)
            node = node.next
        nodes.append(""None"")
        return "" -> "".join(nodes)
    def __iter__(self):
        node = self.head
        while node is not None:
            yield node
            node = node.next
    def append(self, data: Any) -> None:
        if self.head is None:
            self.head = Node(data)
            return
        current = self.head
        while current.next is not None:
            current = current.next
        current.next = Node(data)
    def prepend(self, data: Any) -> None:
        new_head = Node(data)
        new_head.next = self.head
        self.head = new_head
    def add_after(self, target_data: Any, new_data: Any) -> None:
        if not self.head:
            raise Exception(""List is empty"")
        current = self.head
        while current.next is not None:
            if current.data == target_data:
                new_node = Node(new_data)
                new_node.next = current.next
                current.next = new_node
                return
            current = current.next
    def add_before(self, target_data: Any, new_data: Any) -> None:
        if not self.head:
            raise Exception(""List is empty"")
        current = self.head
        while current.next is not None:
            if current.next.data == target_data:
                new_node = Node(new_data)
                new_node.next = current.next
                current.next = new_node
                return
            current = current.next
    def delete_with_value(self, data: Any) -> None:
        if self.head is None:
            return
        if self.head.data == data:
            self.head = self.head.next
            return
        current = self.head
        while current.next is not None:
            if current.next.data == data:
                current.next = current.next.next
                return
            current = current.next
if __name__ == ""__main__"":
    llist = LinkedList()
    llist.append(""a"")
    llist.append(""b"")
    llist.append(""c"")
    llist.append(""d"")
    llist.append(""f"")
    print(llist)
    llist.delete_with_value(""c"")
    print(llist)
    llist.add_after(""b"", ""c"")
    print(llist)
    llist.delete_with_value(""d"")
    print(llist)
    llist.add_before(""f"", ""d"")
    print(llist)",0,0,0,0,0,1,0,1,0
194,"class linkedList:
    def __init__(self, value=0, pointer=None):
        self.value=value
        self.pointer=pointer
    def reverse(self, to = None):
        deepest_node = None
        if self.pointer != None:
            deepest_node = self.pointer.reverse(self)
            self.pointer = to
        else :
            self.pointer = to
            return self
        return deepest_node
    def __str__(self):
        if self.pointer==None:
            return str(self.value)
        return f""{self.value} => {str(self.pointer)}""
def main():
    import random
    node = linkedList(0)
    last=node
    for i in range(random.randint(10, 25)):
        newNode=linkedList(random.randint(1, 100))
        last.pointer=newNode
        last=newNode
    print('linked list: ', node)
    node = node.reverse()
    print('reversed   : ', node)
if __name__ == ""__main__"":
    main()",0,0,0,0,0,0,0,0,0
195,"package com.lists;
import java.util.Iterator;
import java.util.NoSuchElementException;
public class LinkedList<Item> implements Iterable<Item>{
	private Node head;
	private int N;
	public LinkedList() {
		head = null;	
		N = 0;
	}
	public int size(){
		return N;
	}
	public boolean isEmpty(){
		return N == 0;
	}
	public void add(Item item) {
		Node currentNode = head;  
		Node newNode = new Node(item); 
		if(isEmpty()){
			head = newNode;
			N++;
			return;
		}
		while (currentNode.next != null) {
			currentNode = currentNode.next;
		}
		currentNode.next = newNode;
		N++;
	}
	public void add(Item item, int index) throws IndexOutOfBoundsException{
		if (index <= 0 || index > size()) {
			throw new IndexOutOfBoundsException();
		}
		Node currentNode = head;
		Node newNode = new Node(item);
		if(isEmpty()){
			head = newNode;
			N++;
			return;
		}
		int position = index-1;
		for (int i = 1; i < position && currentNode.next != null; i++) {
			currentNode = currentNode.next;
		}
		newNode.next = currentNode.next;
		currentNode.next = newNode;
		N++;
	}
	public Item get(int index) throws IndexOutOfBoundsException {
		if (index <= 0 || index > size()) {
			throw new IndexOutOfBoundsException();
		}
		Node temp = head;
		for (int i = 1; i < index; i++) {
			if (temp.next == null)
				return null;
			temp = temp.next;
		}
		return temp.item;
	}
	public boolean remove(int index) {
		if (index <= 0 || index > size()) {
			return false;
		}
		Node current = head;
		for (int i = 1; i < index; i++) {
			if (current.next == null)
				return false;
			current = current.next;
		}
		current.next = current.next.next;
		N--;
		return true;
	}
	public Iterator<Item> iterator()  { return new LinkedListIterator(); }
	private class LinkedListIterator implements Iterator<Item> {
        private Node current = head;
        public boolean hasNext()  { return current != null;                     }
        public void remove()      { throw new UnsupportedOperationException();  }
        public Item next() {
            if (!hasNext()) throw new NoSuchElementException();
            Item item = current.item;
            current = current.next; 
            return item;
        }
    }
	private class Node {
		Node next;
		Item item;
		public Node(Item item) {
			this.item = item;
			this.next = null;
		}
		public Node() {
			this.item = null;
			this.next = null;
		}
		public Node(Item item, Node next) {
			this.item = item;
			this.next = next;
		}
	}
}",0,0,0,0,0,0,0,1,0
196,"export default class LinkedList {
  head: Node;
  tail: Node;
  integrity = new Set();
  constructor() {
    this.head = new Node({});
  }
  isEmpty(): boolean {
    return !!this.head;
  }
  revese(node: Node = this.head) {
    if (!node || !node.next) return node;
    const reversedNode = this.revese(node.next);
    node.next.next = node;
    node.next = null;
    return reversedNode;
  }
  delete(node: Node) {
    let curr = this.head;
    let prev = null;
    while (curr) {
      if (curr === node) {
        if (prev) {
          prev.next = curr.next;
          curr = null;
        } else {
          this.head = curr.next;
        }
        break;
      } else {
        prev = curr;
        curr = curr.next;
      }
    }
  }
  sort() {
    let { head } = this;
    while (head.hasNext()) {
      let innerHead = this.head;
      while (innerHead.hasNext()) {
        if (head.data > innerHead.data && head.data < innerHead.next.data) {
        }
        innerHead = innerHead.next;
      }
      head = head.next;
    }
  }
  find(data: any): Node | false {
    let node = this.head;
    while (node.hasNext()) {
      if (node.data === data) {
        return node;
      }
      node = node.next;
    }
    return false;
  }
  insertAfter = this.insert;
  insert(data: any, begin?: Node): boolean {
    const node = new Node(data);
    if (begin && this.integrity.has(node)) return false;
    const headNext = (begin || this.head).next;
    this.integrity.add(node);
    this.head.next = node;
    this.head.next.next = headNext;
    return true;
  }
  toString() {
    const items = [];
    let node = this.head;
    items.push(node);
    while (node.next) {
      items.push(node.next);
      node = node.next;
    }
    return items;
  }
}
class Node {
  data: number | string = 0;
  next: Node | boolean = false;
  constructor(data: any = {}, next: Node | boolean = false) {
    this.data = data;
    this.next = next;
  }
  hasNext(): boolean {
    return this.next !== false;
  }
  remove() {
    if (!this.isEmpty() && this.head.hasNext()) {
      this.head = this.head.next;
    }
  }
  append(data: any): boolean {
    const node = new Node(data);
    const { next } = this;
    node.next = next;
    this.next = node;
    return true;
  }
}",0,0,0,0,0,1,0,1,0
197,"package list;
public class LinkedList<T> {
    private T value;
    private LinkedList<T> next;
    private boolean empty;
    public LinkedList() { empty = true; }
    private LinkedList(T value) {
        this.empty = false;
        this.value = value;
    }
    public int length() {
        if(empty) {
            return 0;
        } else if(next == null) {
            return 1;
        } else {
            return 1 + next.length();
        }
    }
    public boolean isEmpty() {
        return empty;
    }
    public T get(int index) {
        if(index < 0 || index > this.length() - 1) {
            throw new IndexOutOfBoundsException();
        } else if(index == 0) {
            return this.value;
        } else {
            return next.get(index - 1);
        }
    }
    public void add(T value) {
        if(empty) {
            this.value = value;
            empty = false;
        } else if(next == null) {
            next = new LinkedList<>(value);
        } else {
            next.add(value);
        }
    }
    public void add(T value, int index) {
        if(index < 0 || index > this.length()) {
            throw new IndexOutOfBoundsException();
        } else if(index == 0){
            this.value = value;
            empty = false;  
        } else if(index == 1) {
            LinkedList<T> tmp = next;
            next = new LinkedList<>(value);
            next.next = tmp;
        } else {
            next.add(value, index - 1);
        }
    }
    public void set(T value, int index) {
        if(index < 0 || index > this.length() - 1) {
            throw new IndexOutOfBoundsException();
        } else if(index == 0) {
            this.value = value;
        } else {
            next.set(value, index - 1);
        }
    }
    public int indexOf(T target) {
        if(!this.contains(target)) {
            return -1;
        } else if(this.value.equals(target)) {
            return 0;
        } else {
            return next.indexOf(target) + 1;
        }
    }
    public boolean contains(T target) {
        return this.value.equals(target) || (this.next != null && this.next.contains(target));
    }
}",0,0,0,0,0,1,0,1,0
198,"function LinkedList(value) {
    this.next = null;
    this.value = value !== undefined ? value : null;  
}
LinkedList.prototype = (function() {
    function add(value, index) {
        if(this.value === null) {
            this.value = value;
        } else if(index !== 0 && !index) {
            if(this.next) {
                this.next.add(value);
            } else {
                this.next = new LinkedList(value);
            }
        } else {
            if(invalidIndex(index, this.length())) {
                console.log('warning: invalid index ' + index + ' passed to LinkedListNode.add()');
                console.log(length());
                return;
            }
            if(index === 0) {
                if(this.next != null) {
                    var tmp = this.next;
                    this.next = new LinkedList(value);
                    this.next.next = tmp;
                } else {
                    this.next = new LinkedList(value);
                }
            } else {
                this.next.add(value, index - 1);
            }
        }
    }
    function get(index) {
        if(invalidIndex(index, this.length())) {
            console.log('warning: invalid index ' + index + ' passed to LinkedListNode.get()');
            return null;
        } else if(index === 0) {
            return this.value;
        } else {
            return this.next.get(index - 1);
        }
    }
    function set(index, value) {
        if(invalidIndex(index, this.length())) {
            console.log('warning: invalid index ' + index + ' passed to LinkedListNode.set()');
        } else if(index === 0) {
            this.value = value;
        } else {
            this.next.set(index - 1, value);
        }
    }
    function remove(index) {
        if(invalidIndex(index, this.length())) {
            console.log('warning: invalid index ' + index + ' passed to LinkedListNode.remove()');
        } else if(index === 0) {
            this.value = this.next.value;
            this.next = this.next.next;
        } else {
            if(index === 1) {
                this.next = this.next.next;
            } else {
                this.next.remove(index - 1);
            }
        }
    }
    function length() {
        if(this.value === null) {
            return 0;
        } else if(this.next) {
            return this.next.length() + 1;
        } else {
            return 1;
        }
    }
    function contains(target, comparator) {
        if(this.equals(target, comparator)) {
            return true;
        } else if (this.next) {
            return this.next.contains(target, comparator);
        } else {
            return false;
        }
    }
    function indexOf(target, comparator) {
        if(this.equals(target, comparator)) {
            return 0;
        } else if(this.next) {
            var index = this.next.indexOf(target, comparator);
            return index === -1 ? index : index + 1;  
        } else {
            return -1;
        }
    }
    function equals(value, comparator) {
        return (comparator && comparator(this.value, value)) || (!comparator && this.value === value);
    }
    function invalidIndex(index, len) {
        return typeof(index) !== 'number' || index < 0 || index >= len;
    }
    return {
        add: add,
        get: get,
        set: set,
        remove: remove,
        length: length,
        contains: contains,
        indexOf: indexOf,
        equals: equals
    }
}.call(this))",0,0,0,0,0,1,0,1,0
199,"public class LinkedList{
	int data;    
	LinkedList nextPointer;
	static int numofElements;
	static LinkedList headPointer;
	static LinkedList tailPointer;
	public LinkedList(){
		nextPointer=null;
	}
	public void add(int number){
		System.out.println(""Adding element at the back of the list : "" + number);
		LinkedList node = new LinkedList();
		node.data=number;
		if(numofElements==0){
			headPointer=node;
			tailPointer=node;
		}
		else{
			tailPointer.nextPointer=node;
			tailPointer=node;
		}
		numofElements++;
	}
	public void pushFront(int number){
		System.out.println(""Inserting element at the front of the list : "" + number);
		LinkedList node = new LinkedList();
		node.data=number;
		numofElements++;	
		if(headPointer==null){
			headPointer=node;
			tailPointer=node;
		}
		else{
			if(headPointer==tailPointer){
				node.nextPointer=tailPointer;
				headPointer=node;
			}
			else{
				node.nextPointer=headPointer;
				headPointer=node;
			}
		}
	}
	public int topFront() throws Exception{
		if(headPointer==null){
			throw new Exception(""LinkedList is empty"");
		}
		return headPointer.data;
	}
	public void popFront() throws Exception{
		System.out.println(""PopFront Operation."");
		if(headPointer==null){
			throw new Exception(""LinkedList is empty"");
		}
		numofElements--; 
		if(headPointer==tailPointer){
			headPointer=null;
			tailPointer=null;
		}
		else{
			headPointer=headPointer.nextPointer;
		}
	}
	public void pushBack(int number){
		System.out.println(""Inserting element at the back of the list : "" + number);
		LinkedList node = new LinkedList();
		node.data=number;
		numofElements++;
		if(tailPointer==null){
			headPointer=node;
			tailPointer=node;
		}
		else{
			tailPointer.nextPointer=node;
			tailPointer=node;
		}
	}
	public int topBack() throws Exception{
		if(tailPointer==null){
			throw new Exception(""LinkedList is empty!"");
		}
		return tailPointer.data;
	}
	public void display(){
		System.out.print(""LinkedList : "");
		System.out.print(""[ "");
		LinkedList temp = headPointer;
		while(temp!=null){
			System.out.print(temp.data + "" "");
			temp=temp.nextPointer;
		}
		System.out.println(""]"");
	}
	public int size(){
		return numofElements;
	}
}",0,0,0,0,0,0,0,1,0
200,"public class LinkedList{
	static class Node{
		int key;    
		Node next;  
		public Node(int data){
			this.key=data;
			this.next=null;
		}
	}
	static Node head;   
	static int size;    
	public LinkedList(){
		head=null;
		size=0;
	}
	static public void pushFront(int number){
		System.out.println(""Inserting node at front : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			size++;
			return;
		}
		node.next=head;
		head=node;
		size++;
	}
	static public void pushBack(int number){
		System.out.println(""Inserting node at back  : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			size++;
			return;
		}
		Node temp=head;
		while(temp.next!=null){
			temp=temp.next;
		}
		temp.next=node;
		size++;
	}
	static public void popFront(){
		System.out.println(""PopFront Operation."");
		if(head==null){
			return;
		}
		head=head.next;
		size--;
	}
	static public void popBack(){
		System.out.println(""PopBack Operation."");
		if(head==null){
			return;
		}
		if(head.next==null){
			head=null;
			size--;
			return;
		}
		Node temp=head;
		while(temp.next.next!=null){
			temp=temp.next;
		}
		temp.next=null;
		size--;
	}
	static public void pop(int position){
		System.out.println(""Poping element at pos : "" + position);
		if(head==null){
			return;
		}
		if(position==0){
			head=head.next;
			size--;
			return;
		}
		Node temp=head;
		int x=0;
		while(temp.next!=null && x<position-1){
			temp=temp.next;	
			x++;
		}
		if(temp.next==null){
			return;
		}
		temp.next=temp.next.next;
		size--;
	}
	static public void display(){
		System.out.print(""LinkedList : "");
		if(head==null){
			System.out.println("" "");
			return;
		}
		Node temp=head;
		while(temp!=null){
			System.out.print(temp.key +  "" "");
			temp=temp.next;
		}
		System.out.println();
	}
	public static void main(String [] args){
		LinkedList list = new LinkedList();
		list.pushFront(10);
		list.pushBack(12);
		list.display();
		list.pushFront(8);
		list.pushFront(6);
		list.pushBack(20);
		list.display();
		list.pop(3);
		list.display();
		list.popFront();
		list.display();
		list.popBack();
		list.display();
	}
}",0,0,0,0,0,0,0,1,0
201,"public class LinkedList{
	static class Node{
		int key;     
		Node next;   
		public Node(int data){
			this.key=data;
			this.next=null;
		}
	}
	static Node head;   
	static int size;    
	public LinkedList(){
		head=null;
	}
	static public void pushFront(int number){
		System.out.println(""Inserting data at front : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			size++;
			return;
		}
		node.next=head;
		head=node;
		size++;
	}
	static public void pushBack(int number){
		System.out.println(""Inserting data at back  : "" + number);
		Node node = new Node(number);
		if(head==null){
			head=node;
			size++;
			return;
		}
		Node temp=head;
		while(temp.next!=null){
			temp=temp.next;
		}
		temp.next=node;
		size++;
	}
	public static void swap(){
		System.out.println(""Swapping data values of first and last node."");
		if(head==null || head.next==null){
			return;
		}
		Node temp=head;
		Node headNode = head;
		while(temp.next!=null){
			temp=temp.next;
		}
		int data = headNode.key;
		headNode.key=temp.key;
		temp.key=data;
	}
	static public void display(){
		System.out.print(""List : "");
		if(head==null){
			System.out.println(""Empty."");
			return;
		}
		Node temp=head;
		while(temp!=null){
			System.out.print(temp.key +  "" "");
			temp=temp.next;
		}
		System.out.println();
	}
	public static void main(String [] args){
		LinkedList list = new LinkedList();
		list.pushFront(10);
		list.pushBack(12);
		list.pushFront(8);
		list.pushFront(6);
		list.display();
		list.swap();
		list.display();
	}
}",0,0,0,0,0,0,0,1,0
202,"package Data_Structures;
class linkedlist
{
    static node head;
    static int j=1;
    static class node
    {
        int data;
        node next;
        node prev;
        node(int d)
        {
            prev = null;
            data = d;
            next = null;
        }
    }
    public void add(int data)
    {
        node node = new node(data);
        node.next = head;
        head = node;
        j++;
    }
    public void insert(node prev, int data)
    {
        node node = new node(data);
        node.next = prev.next;
        prev.next = node;
        j++;
    }
    public void print()
    {
        node node = head;
        while(node!=null)
        {
            System.out.println(node.data);
            node = node.next;
        }
    }
    public static void main(String args[])
    {
        linkedlist list = new linkedlist();
        list.head = null;
        list.add(5);
        list.add(9);
        list.add(13);
        list.add(25);
        list.add(100);
        list.add(200);
        list.add(300);
        node temp;
        temp = head;
        for(int i=1;i<2;i++)
        {
            temp = temp.next;
        }
        list.insert(temp,500);
        temp = head;
        for(int i=1;i<j-1;i++)
        {
            temp = temp.next;
        }
        list.insert(temp, 1);
        list.print();
    }
}",0,0,0,0,0,0,0,1,0
203,"import java.util.NoSuchElementException;
class Node<T> {
    public T data;      
    public Node<T> next;      
    public Node(T input) {
        this.data = input;
        this.next = null;
    }
}
class LinkedList<T> {
    private Node<T> head;      
    private int sizeOfList = 0;      
    public LinkedList() {
        head = null;
    }
    public void addFront(T input) {
        Node<T> newNode = new Node<T>(input);
        newNode.next = head;
        head = newNode;
        sizeOfList++;
    }
    public void addLast(T input) {
        if (head == null) {
            Node<T> newNode = new Node<T>(input);
            head = newNode;
            sizeOfList = 1;
        }
        else {
            Node<T> temp = head;
            while (temp.next != null)
                temp = temp.next;
            Node<T> newNode = new Node<T>(input);
            temp.next = newNode;
            sizeOfList++;
        }
    }
    public void add(T input, int index) {
        if (index < 0 || index > sizeOfList)
            throw new IndexOutOfBoundsException(""Invalid Index"");
        Node<T> temp = head;
        if (index == 0)
            addFront(input);
        else {
            for (int i = 0; i < index-1; i++)
                temp = temp.next;
            Node<T> newNode = new Node<T>(input);
            newNode.next = temp.next;
            temp.next = newNode;
            sizeOfList++;
        }
    }
    public T removeFront() {
        if (isEmpty())
            throw new NoSuchElementException();
        T removedElement = head.data;
        head = head.next;
        sizeOfList--;
        return removedElement;
    }
    public T removeLast() {
        if (isEmpty())
            throw new NoSuchElementException();
        T removedElement;
        if (head.next == null) {
            removedElement = head.data;
            head = null;
        }
        else {
            Node<T> temp = head;
            while (temp.next.next != null)
                temp = temp.next;
            removedElement = temp.next.data;
            temp.next = null;
        }
        sizeOfList--;
        return removedElement;
    }
    public T remove(int index) {
        if (isEmpty())
            throw new NoSuchElementException();
        if (index < 0 || index > sizeOfList)
            throw new IndexOutOfBoundsException(""Invalid Index"");
        if (index > 0) {
            Node<T> temp = head;
            for (int i = 0; i < index-1; i++)
                temp = temp.next;
            T removedElement = temp.next.data;
            temp.next = temp.next.next;
            sizeOfList--;
            return removedElement;
        }
        return removeFront();
    }
    public int search(T input) {
        Node<T> temp = head;
        for (int i = 0; i < sizeOfList; i++) {
            if (temp.data == input)
                return i;
            else
                temp = temp.next;
        }
        return -1;      
    }
    public void display() {
        Node<T> temp = head;
        if (temp != null) {
            System.out.print(""["");
            while (temp != null) {
                System.out.print(temp.data+"", "");
                temp = temp.next;
            }
            System.out.print(""\b\b]\n"");
        }
    }
    public int size() {
        return sizeOfList;
    }
    public boolean isEmpty() {
        return sizeOfList == 0;
    }
    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<Integer>();      
        list.addFront(3);
        list.display();
        list.addLast(5);
        list.addLast(6);
        list.display();
        list.addFront(2);
        list.addFront(1);
        list.display();
        list.add(4, 3);
        list.display();
        list.removeFront();
        list.display();
        list.removeLast();
        list.display();
        list.remove(2);
        list.display();
        int found = list.search(5);
        if (found >= 0)
            System.out.println(""Element found at index: "" + list.search(5));
        else
            System.out.println(""Element not found"");
        if (list.isEmpty())
            System.out.println(""List is empty"");
        else
            System.out.println(""List is not empty, Size of list: "" + list.size());
        while (!list.isEmpty())
            list.removeLast();
        try {
            list.removeLast();
        } catch (NoSuchElementException e) {
            System.out.println(""List Empty"");
        }
    }
}",0,0,0,0,0,1,0,1,0
204,"class Node {
	constructor (data) {
		this.data = data;
		this.next = null;
	}
}
class LinkedList {
	constructor (size = 0) {
		this.head = null;
		this.length = size;
	}
	add (value, index) {
		let temp = this.head;
		if (index === 0) {
			let n = new Node(value);
			n.next = this.head;
			this.head = n;
		} else if (index < 0 || index >= this.length) {
			throw new Error('Index Out of Bound');
		} else {
			for (let i = 0; i < index - 1; i++) {
				temp = temp.next;
			}
			let n = new Node(value);
			n.next = temp.next;
			temp.next = n;
		}
		this.length++;
	}
	addFirst (value) {
		return this.add(value, 0);
	}
	addLast (value) {
		if (this.head === null) {
			this.addFirst(value);
		} else {
			let temp = this.head;
			while (temp.next !== null) {
				temp = temp.next;
			}
			let n = new Node(value);
			temp.next = n;
			this.length++;
		}
	}
	remove (index) {
		if (this.isEmpty()) {
			throw new Error('List is Empty');
		} else if (index < 0 || index >= this.length) {
			throw new Error('Index out of Bound');
		} else if (index === 0) {
			this.head = this.head.next;
		} else {
			let temp = this.head;
			if (temp.next == null) {
				this.head = null;
			} else {
				for (let i = 0; i < index - 1; i++) {
					temp = temp.next;
				}
				temp.next = temp.next.next;
			}
		}
		this.length--;
	}
	removeFront () {
		this.remove(0);
	}
	removeLast () {
		this.remove(this.length - 1);
	}
	removeByValue (value) {
		this.remove(this.findFirst(value));
	}
	search (input) {
		let head = this.head;
		for (let i = 0; i < this.length; i++) {
			if (head.data === input) {
				return i;
			} else {
				head = head.next;
			}
		}
		throw new Error('Value not found');
	}
	findFirst (input) {
		return this.search(input);
	}
	findLast (input) {
		let newList = new LinkedList();
		newList = this.clone();
		newList.reverse();
		return this.length - newList.search(input) - 1;
	}
	setData (input, index) {
		if (index >= this.length) {
			this.add(input, index);
		} else {
			let head = this.head;
			for (let i = 0; i < this.length; i++) {
				if (i === index) {
					head.data = input;
				}
				head = head.next;
			}
		}
	}
	clone () {
		let newList = new LinkedList();
		let temp = this.head;
		while (temp.next) {
			newList.addLast(temp.data);
			temp = temp.next;
		}
		newList.addLast(temp.data);
		return newList;
	}
	reverse () {
		let prev = null;
		let current = this.head;
		while (current) {
			let next = current.next;
			current.next = prev;
			prev = current;
			current = next;
		}
		this.head = prev;
	}
	isEmpty () {
		return (this.length === 0);
	}
	clear () {
		this.head = null;
		this.length = 0;
	}
	show () {
		let list = [];
		let head = this.head;
		while (head) {
			list.push(head.data);
			head = head.next;
		}
		return list;
	}
}
function main () {
	let linkedList = new LinkedList();
	linkedList.add(5, 0);
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	linkedList.addFirst(25);
	linkedList.addFirst(251);
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	linkedList.addFirst(5);
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	try {
		console.log('Fist Occurrence at index: ' + linkedList.findFirst(5));
	} catch (err) {
		console.log('Value not found');
	}
	try {
		console.log('Last Occurrence at index: ' + linkedList.findLast(5));
	} catch (err) {
		console.log('Value not found');
	}
	try {
		linkedList.setData(12325, 1);
		console.log(linkedList.show());
		console.log('Size : ' + linkedList.length);
	} catch (err) {
		console.log('Index out of bound');
	}
	try {
		linkedList.removeByValue(12325);
		console.log(linkedList.show());
		console.log('Size : ' + linkedList.length);
	} catch (err) {
		console.log('Value not found');
	}
	linkedList.addLast(125);
	linkedList.addLast(11);
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	try {
		console.log('Element found at index: ' + linkedList.search(1125));
	} catch (err) {
		console.log('Value not found');
	}
	console.log('Cloned : ', linkedList.clone().show());
	try {
		linkedList.remove(6);
		console.log(linkedList.show());
		console.log('Size : ' + linkedList.length);
	} catch (err) {
		console.log('Index Out of Bound');
	}
	try {
		linkedList.remove(2);
	} catch (err) {
		console.log('Index Out of Bound');
	}
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	linkedList.removeFront();
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	linkedList.removeLast();
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
	linkedList.clear();
	console.log(linkedList.show());
	console.log('Size : ' + linkedList.length);
}
main();",0,0,0,0,0,1,0,1,0
205,"function Node(data) {
    this.data = data;
    this.next = null;
}
class LinkedList {
    constructor() {
        this.head = null;    
        this.tail = null;    
    }
    addNode(data) {
        const node = new Node(data);   
        if(!this.head) {
            this.head = node;
            this.tail = node;
        } else {
            this.tail.next = node;
            this.tail = node;
        }
    }
    removeNode(data) {
        let previous = this.head;
        let current = this.head;
        while(current) {
            if(current.data === data) {
                if(current === this.head) 
                    this.head = this.head.next;  
                else if(current === this.tail)
                    this.tail = previous;        
                previous.next = current.next;    
                break;
            } 
            previous = current;
            current = current.next;
        }
    }
    traverse(cb) {
        let current = this.head;
        if(cb)   
            while (current) {
                cb(current);
                current = current.next;   
            }
    }
}
(function test() {
    let linkedList = new LinkedList();
    linkedList.addNode(""first node"");
    linkedList.addNode(""second node"");
    linkedList.addNode(""third node"");
    linkedList.addNode(""fourth node"")
    console.log(""Nodes: "")
    linkedList.traverse((node) => { console.log(node.data) });
    removeAndLog(linkedList, ""third node"");      
    removeAndLog(linkedList, ""first node"");      
    removeAndLog(linkedList, ""fourth node"");     
    removeAndLog(linkedList, ""second node"");     
})()
function removeAndLog(linkedList, str) {
    console.log(`\nRemove node: ${str}`);
    linkedList.removeNode(str);
    console.log(""Updated nodes: "");
    linkedList.traverse((node) => { console.log(node.data) });
}",0,0,0,0,0,0,0,1,0
206,"class NodeIterator:
      def __init__(self,listHead):
          self._currNode = listHead
      def __iter__(self):
          return self
      def next(self):
          if self._currNode is None:
             raise StopIteration
          else:
             item = self._currNode.info
             self._currNode = self._currNode.next
          return item  
class Node:
      def __init__(self,info):
          self.info = info 
          self.next = None 
class LinkedList:
      def __init__(self):
          self._head = None
          self._size = 0
      def __len__(self):
          return self._size
      def add(self,item):
          newNode = Node(item)
          newNode.next = self._head
          self._head = newNode
          self._size += 1   
          return None
      def remove(self,what):
          predNode = None
          currNode = self._head
          while currNode is not None and currNode.info != what:
                predNode = currNode
                currNode = currNode.next
          assert currNode is not None, ""The item must be in the list""
          self._size -=1
          if currNode == self._head:
             self._head = currNode.next
          else:
             predNode.next = currNode.next
          return currNode.info
      def __contains__(self,search):
          currNode = self._head
          while currNode is not None and currNode.info != search:
                currNode = currNode.next
          return currNode is not None
      def __iter__(self):
          return NodeIterator(self._head) 
      def __str__(self): 
          out = '[LinkedList: '
          curr = self._head
          while curr != None:
               out += str(curr.info) + "" ""
               curr = curr.next
          out += ']' 
          return out
      def reverse(self):
          curr, prev = self._head, None
          while curr:
               next, curr.next = curr.next, prev
               prev, curr = curr, next
          self._head = prev
l = LinkedList()
l.add(1);         
l.add(2);
l.add(3);
l.add(5);
l.add(7);
l.add(8);
l.add(41);
for i in l:
    print i
if 12 in l:
   print '12 exits'
else:
   print '12 not exist' 
print '-----------'
print '-----------'
for i in l:
    print i
print ""Length of list:"", len(l)
l.reverse()
print l",0,0,0,0,0,0,0,1,0
207,"public class LinkedListImplementation{
	public static void main(String [] args){
		LinkedList list = new LinkedList();  
		try{
			list.add(10);
			list.popFront();
			list.add(12);
			list.display();
			list.pushFront(22);
			list.display();
			list.add(14);
			list.display();
			list.add(16);
			list.display();
			System.out.println(""Size : "" + list.size());
			System.out.println(""Top elements is : "" + list.topFront());
			list.popFront();
			list.display();
			System.out.println(""Size : "" + list.size());
			System.out.println(""Last element is : "" + list.topBack());
			list.pushBack(24);
			System.out.println(""Last element is : "" + list.topBack());
			list.add(18);
			System.out.println(""Size : "" + list.size());
			list.pushFront(20);
			System.out.println(""Size : "" + list.size());
			list.display();
		}
		catch(Exception e){
			System.out.println(e);
		}
	}
}",0,0,0,0,0,0,0,0,0
208,"public interface LinkedListInterface<T extends Comparable<? super T>> {
    void addToFront(T data);
    void addAtIndex(T data, int index);
    void addToBack(T data);
    T removeFromFront();
    T removeAtIndex(int index);
    T removeFromBack();
    T get(int index);
    T findLargestElement();
    int size();
    Object[] toArray();
    void clear();
    boolean isEmpty();
    SLLNode<T> getHead();
    SLLNode<T> getTail();
}",0,0,0,0,0,0,0,0,0
209,"public interface LinkedListInterface<T> {
    public void addAtIndex(int index, T data);
    public void addToFront(T data);
    public void addToBack(T data);
    public T get(int index);
    public T removeAtIndex(int index);
    public T removeFromFront();
    public T removeFromBack();
    public boolean removeAllOccurrences(T data);
    public Object[] toArray();
    public boolean isEmpty();
    public int size();
    public void clear();
    public LinkedListNode<T> getHead();
    public LinkedListNode<T> getTail();
}",0,0,0,0,0,0,0,0,0
210,"public class LinkedListNode<T> {
    private T data;
    private LinkedListNode<T> next;
    public LinkedListNode(T data, LinkedListNode<T> next) {
        this.data = data;
        this.next = next;
    }
    public LinkedListNode(T data) {
        this(data, null);
    }
    public T getData() {
        return data;
    }
    public LinkedListNode<T> getNext() {
        return next;
    }
    public void setNext(LinkedListNode<T> next) {
        this.next = next;
    }
    @Override
    public String toString() {
        return ""Node containing: "" + data;
    }
}",0,0,0,0,0,0,0,0,0
211,"__author__ = ""streethacker""
class _BagIterator:
    def __init__(self, theHead):
        self._curNode = theHead
    def __iter__(self):
        return self
    def next(self):
        if self._curNode is None:
            raise StopIteration
        else:
            item = self._curNode.data
            self._curNode = self._curNode.next
            return item
class _BagListNode:
    def __init__(self, data):
        self.data = data
        self.next = None
class Bag:
    def __init__(self):
        self._head = None
        self._size = 0
    def __len__(self):
        return self._size
    def __iter__(self):
        return _BagIterator(self._head)
    def __contains__(self, target):
        curNode = self._head
        while curNode is not None and curNode.data != target:
            curNode = curNode.next
        return curNode is not None
    def add(self, data):
        newNode = _BagListNode(data)
        newNode.next = self._head
        self._head = newNode
        self._size += 1
    def remove(self, data):
        preNode = None
        curNode = self._head
        while curNode is not None and curNode.data != data:
            preNode = curNode
            curNode = curNode.next
        assert curNode is not None, ""The item must be in the bag.""
        self._size -= 1
        if curNode is self._head:
            self._head = curNode.next
        else:
            preNode.next = curNode.next
        return curNode.data
    def printBagElements(self):
        for b in self:
            print b
if __name__ == ""__main__"":
    bag = Bag()
    bag.add(10)
    bag.add(12)
    bag.add(36)
    bag.add(77)
    bag.printBagElements()
    bag.remove(12)
    print
    bag.printBagElements()",0,0,0,0,0,0,0,1,0
212,"package linkedlist;
public class List<T>{
    Node<T> fnode;
    Node<T> lnode;
    String name;
    public List()
    {
        name=""List"";
        fnode=lnode=null;
    }
    public List(String lname)
    {
        name=lname;
        fnode=lnode=null;
    }
    public boolean IsEmpty()
    {
        return fnode==null;
    }
    public void Insertfront(T item)
    {
        if(IsEmpty())
        {
            fnode=lnode=new Node<T>(item);
        }
        else
            fnode=lnode=new Node<T>(item,fnode);
    }
    public void Insertback(T item)
    {
        if(IsEmpty())
        {
            fnode=lnode=new Node<T>(item);
        }
        else
        {
           lnode.next=new Node<T>(item);
           lnode=lnode.next;
        }
    }
    public String Print()
    {
        String s=null;
        if(IsEmpty())
        {
            s=""Empty""+name;
            return s;
        }
        else
        {
           s=""The"" + name + ""is : \n\n""; 
        }
        Node<T> temp=fnode;
        while(temp!=null)
        {
            s=s+temp.getData()+""\n"";
            temp=temp.getNext();
        }
        s=s+""\n"";
        s=s+""End ""+name+"" \n"";
        return s;
    }
    public void removeAll()
    {
        lnode=fnode=null;
    }
    public T removeFromFront()throws EmptyListException
    {
        if(IsEmpty())
        {
            throw new EmptyListException(name);
        }
        T removeItem =fnode.getData();
        if(fnode==lnode) 
            fnode=lnode=null;
        else
            fnode=fnode.getNext();
        return removeItem;
    } 
    public T removeFromBack()throws EmptyListException
    {
        if(IsEmpty())
        {
            throw new EmptyListException(name);
        }
        T removeitem=lnode.getData();
        if(fnode==lnode)
            fnode=lnode=null;
        else
        {
            Node<T> temp=fnode;
            while(temp.getNext()!=lnode)
            {
                temp=temp.getNext();
            }
                lnode=temp;
                temp.setNext(null);
        }
        return removeitem;
    }
}",0,0,0,0,0,0,0,1,0
213,"__author__ = ""streethacker""
class _StackNode(object):
    def __init__(self, item, link):
        self.item = item
        self.next = link
class Stack:
    def __init__(self):
        self._top = None
        self._size = 0
    def isEmpty(self):
        return self._top is None
    def __len__(self):
        return self._size
    def peek(self):
        assert not self.isEmpty(), ""Cannot peek at an empty stack.""
        return self._top.item
    def pop(self):
        assert not self.isEmpty(), ""Cannot pop from an empty stack.""
        node = self._top
        self._top = self._top.next
        self._size -= 1
        return node.item
    def push(self, item):
        self._top = _StackNode(item, self._top)
        self._size += 1
if __name__ == ""__main__"":
    pass",0,0,0,0,0,0,0,0,0
214,"package Lists.JDKLinkedList;
import java.util.Iterator;
import java.util.LinkedList;
public class Main {
    public static void main(String[] args) {
        Employee janeJones = new Employee(""Jane"", ""Jones"", 123);
        Employee johnDoe = new Employee(""John"", ""Doe"", 4567);
        Employee marySmith = new Employee(""Mary"", ""Smith"", 22);
        Employee mikeWilson = new Employee(""Mike"", ""Wilson"", 3245);
        Employee billEnd = new Employee(""Bill"", ""End"", 78);
        LinkedList<Employee> list = new LinkedList<>();
        list.addFirst(janeJones);
        list.addFirst(johnDoe);
        list.addFirst(marySmith);
        list.addFirst(mikeWilson);
        Iterator iter = list.iterator();
        System.out.print(""HEAD -> "");
        while (iter.hasNext()) {
            System.out.print(iter.next());
            System.out.print(""<=>"");
        }
        System.out.println(""null"");
        list.addLast(billEnd);
        iter = list.iterator();
        System.out.print(""HEAD -> "");
        while (iter.hasNext()) {
            System.out.print(iter.next());
            System.out.print(""<=>"");
        }
        System.out.println(""null"");
        list.removeFirst();
        iter = list.iterator();
        System.out.print(""HEAD -> "");
        while (iter.hasNext()) {
            System.out.print(iter.next());
            System.out.print(""<=>"");
        }
        System.out.println(""null"");
        list.removeLast();
        iter = list.iterator();
        System.out.print(""HEAD -> "");
        while (iter.hasNext()) {
            System.out.print(iter.next());
            System.out.print(""<=>"");
        }
        System.out.println(""null"");
    }
}",0,0,0,0,0,0,0,0,0
215,"package Lists.DoublyLinkedList;
public class Main {
    public static void main(String[] args) {
        Employee janeJones = new Employee(""Jane"", ""Jones"", 123);
        Employee johnDoe = new Employee(""John"", ""Doe"", 4567);
        Employee marySmith = new Employee(""Mary"", ""Smith"", 22);
        Employee mikeWilson = new Employee(""Mike"", ""Wilson"", 3245);
        EmployeeDoublyLinkedList list = new EmployeeDoublyLinkedList();
        list.addToFront(janeJones);
        list.addToFront(johnDoe);
        list.addToFront(marySmith);
        list.addToFront(mikeWilson);
        list.printList();
        System.out.println(list.getSize());
        Employee billEnd = new Employee(""Bill"", ""End"", 78);
        list.addToEnd(billEnd);
        list.printList();
        System.out.println(list.getSize());
        list.removeFromFront();
        list.printList();
        System.out.println(list.getSize());
        list.removeFromEnd();
        list.printList();
        System.out.println(list.getSize());
    }
}",0,0,0,0,0,0,0,0,0
216,"package Lists.Challenges.Challenge2;
public class Main {
    public static void main(String[] args) {
        Integer one = 1;
        Integer two = 2;
        Integer three = 3;
        Integer four = 4;
        IntegerLinkedList list = new IntegerLinkedList();
        list.insertSorted(three);
        list.printList();
        list.insertSorted(two);
        list.printList();
        list.insertSorted(one);
        list.printList();
        list.insertSorted(four);
        list.printList();
    }
}",0,0,0,0,0,0,0,0,0
217,"package Lists.SinglyLinkedList;
public class Main {
    public static void main(String[] args) {
        Employee janeJones = new Employee(""Jane"", ""Jones"", 123);
        Employee johnDoe = new Employee(""John"", ""Doe"", 4567);
        Employee marySmith = new Employee(""Mary"", ""Smith"", 22);
        Employee mikeWilson = new Employee(""Mike"", ""Wilson"", 3245);
        EmployeeLinkedList list = new EmployeeLinkedList();
        System.out.println(list.isEmpty());
        list.addToFront(janeJones);
        list.addToFront(johnDoe);
        list.addToFront(marySmith);
        list.addToFront(mikeWilson);
        System.out.println(list.getSize());
        list.printList();
        list.removeFromFront();
        System.out.println(list.getSize());
        list.printList();
    }
}",0,0,0,0,0,0,0,0,0
218,"package linkedlist;
public class Main{
    public static void main(String[] args) {
        NewJFrame f = new  NewJFrame();
        f.setVisible(true);
        f.setResizable(true);
    }
}",0,0,0,0,0,0,0,0,0
219,"package Lists.Challenges.Challenge1;
import Lists.DoublyLinkedList.Employee;
public class Main {
    public static void main(String[] args) {
        Employee janeJones = new Employee(""Jane"", ""Jones"", 123);
        Employee johnDoe = new Employee(""John"", ""Doe"", 4567);
        Employee marySmith = new Employee(""Mary"", ""Smith"", 22);
        Employee mikeWilson = new Employee(""Mike"", ""Wilson"", 3245);
        Employee billEnd = new Employee(""Bill"", ""End"", 78);
        EmployeeDoublyLinkedList list = new EmployeeDoublyLinkedList();
        list.addToFront(janeJones);
        list.addToFront(johnDoe);
        list.addToFront(marySmith);
        list.addToFront(mikeWilson);
        list.printList();
        list.addBefore(billEnd, johnDoe);
		list.addBefore(new Employee(""Someone"", ""Else"", 1111), mikeWilson);
        list.printList();
    }
}",0,0,0,0,0,0,0,0,0
220,"package DataStructures.Lists;
import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;
public class Merge_K_SortedLinkedlist {
    Node mergeKList(Node[] a, int N) {
        PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));
        min.addAll(Arrays.asList(a).subList(0, N));
        Node head = min.poll();
        min.add(head.next);
        Node curr = head;
        while (!min.isEmpty()) {
            Node temp = min.poll();
            curr.next = temp;
            curr = temp;
            if (temp.next != null) {
                min.add(temp.next);
            }
        }
        return head;
    }
    private class Node {
        private int data;
        private Node next;
        public Node(int d) {
            this.data = d;
            next = null;
        }
    }
}",0,0,0,0,0,0,0,0,0
221,"package linkedlist;
import java.util.logging.Level;
import java.util.logging.Logger;
public class NewJFrame extends javax.swing.JFrame {
    List list=new List(""My List"");
    public NewJFrame() {
        initComponents();
    }
    @SuppressWarnings(""unchecked"")
    private void initComponents() {
        jLabel1 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jButton2 = new javax.swing.JButton();
        jTextField2 = new javax.swing.JTextField();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jButton6 = new javax.swing.JButton();
        jButton7 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        jLabel1.setFont(new java.awt.Font(""Tahoma"", 1, 11));  
        jLabel1.setText(""Insert Elment "");
        jButton1.setText(""InsertAtFront"");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        jLabel2.setFont(new java.awt.Font(""Tahoma"", 1, 11));  
        jLabel2.setText(""Insert Elment "");
        jButton2.setText(""InsertAtBack"");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        jButton3.setText(""RandomList"");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });
        jButton4.setText(""RemoveFromFront"");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });
        jButton5.setText(""RemoveFromBack"");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });
        jButton6.setText(""RemoveAll"");
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });
        jButton7.setText(""Print List"");
        jButton7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton7ActionPerformed(evt);
            }
        });
        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);
        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(32, 32, 32)
                        .addComponent(jButton7))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 156, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton5, javax.swing.GroupLayout.PREFERRED_SIZE, 156, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(27, 27, 27)
                                .addComponent(jButton1))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(27, 27, 27)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jButton3)
                                    .addComponent(jButton2)))
                            .addComponent(jButton6, javax.swing.GroupLayout.PREFERRED_SIZE, 156, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, Short.MAX_VALUE)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 260, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(22, 22, 22))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(29, 29, 29)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jButton7)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton1))
                        .addGap(28, 28, 28)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton2)
                            .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(jButton3)
                        .addGap(18, 18, 18)
                        .addComponent(jButton4)
                        .addGap(18, 18, 18)
                        .addComponent(jButton5)
                        .addGap(18, 18, 18)
                        .addComponent(jButton6))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane1)))
                .addContainerGap(24, Short.MAX_VALUE))
        );
        pack();
    } 
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) { 
        String s=jTextField1.getText();
        list.Insertfront(s);
        jLabel3.setText(""Insert at Front"");
    } 
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) { 
         String s=jTextField2.getText();
        list.Insertback(s);
        jLabel3.setText(""Insert at Back"");
    } 
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) { 
        for(int i=0;i<10;i++)
        {
            list.Insertfront(i*i+i);
        }
    } 
    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) { 
        try
        {
            list.removeFromFront();
        }
        catch (EmptyListException ex)
        {
            Logger.getLogger(NewJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    } 
    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) { 
        try
        {
            list.removeFromBack();
        }
        catch (EmptyListException ex)
        {
            Logger.getLogger(NewJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    } 
    private void jButton6ActionPerformed(java.awt.event.ActionEvent evt) { 
        list.removeAll();
    } 
    private void jButton7ActionPerformed(java.awt.event.ActionEvent evt) { 
        jTextArea1.setText(list.Print());
    } 
    public static void main(String args[]) {
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if (""Nimbus"".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JButton jButton5;
    private javax.swing.JButton jButton6;
    private javax.swing.JButton jButton7;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
}",0,0,0,0,0,0,0,0,0
222,"package linkedlist;
public class Node<T> {
        private T data;
        Node<T> next;
        public Node(T data)
        {
            this.data=data;
            next=null;
        }
        public Node(T data,Node<T> next)
        {
            this.data=data;
            this.next=next;
        }
        public void setData(T Data)
        {
            this.data=data;
        }
        public T getData()
        {
            return data;
        }
        public void setNext(Node <T> next)
        {
            this.next=next;
        }
        public Node<T> getNext()
        {
            return next;
        }
}",0,0,0,0,0,0,0,0,0
223,"class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
    toString() {
        return this.value.toString();
    }
}
module.exports = { Node };",0,0,0,0,0,0,0,0,0
224,"public class Node{
	int key;    
	Node next;  
	Node prev;  
	public Node(int data){
		this.key=data;
		this.next=null;
		this.prev=null;
	}
}",0,0,0,0,0,0,0,0,0
225,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
    def __str__(self):
        return f""Node({self.data}, {self.next})""
    def __repr__(self):
        return str(self)",0,0,0,0,0,0,0,0,0
226,"from __future__ import print_function
class LinkedList(object):
    def __init__(self, size):
        self.size = size
        self.head = 0
        self.keys = [None for _ in range(self.size * 3)]
        self.free = list(reversed(range(1, self.size)))
    def add(self, key):
        if not self.free:
            raise Exception('The linked list is full')
        position = self.free.pop()
        self.keys[position * 3] = key
        self.keys[position * 3 + 1] = self.head
        self.keys[(position - 1) * 3 + 2] = position * 3
        self.head = position * 3
    def search(self, key, default=None):
        i = self.head
        val = self.keys[i]
        while val is not None and val != key:
            i = self.keys[i + 1]
            val = self.keys[i]
        return val if val else default
    def remove(self, key):
        i = self.head
        val = self.keys[i]
        while val is not None and val != key:
            i = self.keys[i + 1]
            val = self.keys[i]
        if val is None:
            return None
        self.free.append(i // 3)
        if self.head == i:
            self.head = self.keys[i + 1]
            self.keys[self.head + 1] = None
            self.keys[self.head + 2] = None
        else:
            self.keys[i] = None
            next_ = self.keys[i + 1]
            prev = self.keys[i + 2]
            self.keys[prev + 1] = next_
            self.keys[next_ + 2] = prev
        self.keys[i] = None
        self.keys[i + 1] = None
        self.keys[i + 2] = None
        return val
    def __str__(self):
        i = self.head
        val = self.keys[i]
        string = ''
        while val is not None:
            string += str(val) + ' -> '
            i = self.keys[i + 1]
            val = self.keys[i]
        return '{' + string + 'None}'
if __name__ in '__main__':
    LINKED_LIST = LinkedList(size=5)
    for k in [10, 20]:
        LINKED_LIST.add(k)
        print('add {}'.format(k))
    print('linked list: ', LINKED_LIST)
    for k in [10, 20, 30]:
        print('search key {}:'.format(k), LINKED_LIST.search(k))
    for k in [10, 30]:
        LINKED_LIST.remove(k)
        print('remove {}'.format(k))
    print('linked list: ', LINKED_LIST)
    for k in [10, 0, -10]:
        LINKED_LIST.add(k)
        print('add {}'.format(k))
    print('linked list: ', LINKED_LIST)",0,0,0,0,0,1,0,1,0
227,"class Queue(object):
    def __init__(self):
        self._list = []
    def count(self):
        return len(self._list)
    def is_empty(self):
        return self.count() == 0
    def enqueue(self, item):
        self._list.append(item)
    def dequeue(self):
        try:
            return self._list.pop(0)
        except IndexError:
            raise IndexError('pop from empty stack')
def main():
    queue = Queue()
    n = 100
    print('Empty queue: {0}'.format(queue.is_empty()))
    while queue.count() < 5:
        print('pushing elements: {0}'.format(n))
        queue.enqueue(n)
        n = n + 100
    print('Number of items: {0}'.format(queue.count()))
    print('Empty queue: {0}'.format(queue.is_empty()))
    while True:
        try:
            print('Removing element: {0}'.format(queue.dequeue()))
        except Exception as e:
            print('Exception: {0}'.format(e))
            break
    print('Number of items: {0}'.format(queue.count()))
    print('Empty queue: {0}'.format(queue.is_empty()))
if __name__ == '__main__':
    main()",0,0,0,0,0,0,0,0,0
228,"import java.util.NoSuchElementException;
public class Queue<T> {
    private int total;
    private Node first, last;
    private class Node {
        private T data;
        private Node next;
        public Node(T data) {
            this.data = data;
        }
    }
    public boolean add(T element) {
        Node newNode = new Node(element);
        Node current = last;
        last = newNode;
        if (total == 0) {
            first = last;
        } else {
            current.next = last;
        }
        total++;
        return true;
    }
    public boolean offer(T element) {
        try {
            return add(element);
        } catch (Exception ex) {
            return false;
        }
    }
    public T remove() throws NoSuchElementException {
        if (total == 0) {
            throw new NoSuchElementException();
        }
        T element = first.data;
        first = first.next;
        total--;
        if (total == 0) {
            last = null;
        }
        return element;
    }
    public T poll() {
        try {
            return remove();
        } catch (Exception ex) {
            return null;
        }
    }
    public T element() throws NoSuchElementException {
        if (total == 0) {
            throw new NoSuchElementException();
        }
        return first.data;
    }
    public T peek() {
        return total == 0 ? null : first.data;
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        Node tmp = first;
        while (tmp != null) {
            sb.append(tmp.data).append("", "");
            tmp = tmp.next;
        }
        return sb.toString();
    }
    public static void main(String[] args) {
        Queue<Integer> queue = new Queue<>();
        for (int i = 1; i <= 10; i++) {  
            queue.add(i);
        }
        System.out.println(""Queue :"");
        while (queue.peek() != null) {
            System.out.println(queue.poll());
        }
    }
}",0,0,0,0,0,0,0,1,0
229,"class Queue {
    constructor() {
        this.queue = [];
    }
    enqueue(value) {
        this.queue.push(value); 
    }
    dequeue() {
        return this.queue.shift();
    }
    peek() {
        return this.queue[0]
    }
    length() {
        return this.queue.length;
    }
    print() {
        console.log(this.queue.join(' -> '))
    }
}
(function test() {
    var queue = new Queue();
    queue.enqueue('Node1')
    queue.enqueue('Node2')
    queue.enqueue('Node3')
    queue.enqueue('Node4')
    queue.print()
    queue.dequeue()
    queue.print()
    console.log(queue.peek())
    console.log(queue.length())
})()",0,0,0,0,0,0,0,0,0
230,"class Node(object):
	def __init__(self, data, nextnode=None):
		self.data = data
  self.nextnode = nextnode
class Queue(object):
	def __init__(self):
		self.first = None
  self.last = None
 def enqueue(self, data):
  node = Node(data)
  if self.first is None:
			self.first = node
   self.last = node
  else:
			self.last.nextnode = node
   self.last = self.last.nextnode
 def deque(self):
  if self.first is None:
			raise ValueError(""Queue is empty"")
  print self.first.data, ""is removed""
  self.first = self.first.nextnode
 def isEmpty(self):
  if self.first is None:
			return True
  return False
 def peek(self):
  if self.last is None:
			raise ValueError(""No element is there in queue"")
  return self.last.data",0,0,0,0,0,0,0,1,0
231,"class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}
class Queue {
  constructor() {
    this.first = null;
    this.last = null;
    this.length = 0;
  }
  peek() {
    return this.first;
  }
  enqueue(value) {
    const newNode = new Node(value);
    if (!this.length) {
      this.first = newNode;
      this.last = newNode;
    } else {
      this.last.next = newNode;
      this.last = newNode;
    }
    this.length++;
  }
  dequeue() {
    if (!this.length) {
      return null;
    }
    if (this.first === this.last) {
      this.last = null;
    }
    const removedNode = this.first;
    this.first = this.first.next;
    this.length--;
    return removedNode;
  }
}
const myQueue = new Queue();
console.log(myQueue.peek());
myQueue.enqueue('Michael');
console.log(myQueue.peek());
myQueue.enqueue('Dwight');
myQueue.enqueue('Jim');
console.log(JSON.stringify(myQueue));
console.log(myQueue.dequeue());
console.log(JSON.stringify(myQueue));
console.log(myQueue.dequeue());
console.log(myQueue.dequeue());
console.log(JSON.stringify(myQueue));",0,0,0,0,0,0,0,1,0
232,"class Stack {
  constructor() {
    this.stackData = [];
  }
  peek() {
    return this.stackData[this.stackData.length - 1];
  }
  push(value) {
    this.stackData.push(value);
  }
  pop() {
    return this.stackData.pop();
  }
}
class Queue {
  constructor() {
    this.queueDataStack = new Stack();
  }
  peek() {
    return this.queueDataStack.peek();
  }
  enqueue(value) {
    const tempStack = new Stack();
    while (this.queueDataStack.peek()) {
      tempStack.push(this.queueDataStack.pop());
    }
    tempStack.push(value);
    while (tempStack.peek()) {
      this.queueDataStack.push(tempStack.pop());
    }
  }
  dequeue() {
    return this.queueDataStack.pop();
  }
}
const myQueue = new Queue();
console.log(myQueue.peek());
myQueue.enqueue('Michael');
console.log(myQueue.peek());
myQueue.enqueue('Dwight');
myQueue.enqueue('Jim');
console.log(JSON.stringify(myQueue));
console.log(myQueue.dequeue());
console.log(JSON.stringify(myQueue));
console.log(myQueue.dequeue());
console.log(myQueue.dequeue());
console.log(JSON.stringify(myQueue));",0,0,0,0,0,0,0,0,0
233,"public class Recursion {
    public boolean isPalindrome(String text) {
        if (text == null) {
            throw new java.lang.IllegalArgumentException(""Input text is null."");
        }
        return isPalindromeHelper(text);
    }
    private boolean isPalindromeHelper(String text) {
        if (text.length() == 0 || text.length() == 1) {
            return true;
        } else if (text.charAt(0) == text.charAt(text.length() - 1)) {
            return isPalindromeHelper(text.substring(1, text.length() - 1));
        } else {
            return false;
        }
    }
    public int gcd(int x, int y) {
        return gcdHelper(x, y);
    }
    private int gcdHelper(int x, int y) {
        if (x < 0 || y < 0) {
            return -1;
        }
        if (x == 0) {
            return y;
        }
        if (y == 0) {
            return x;
        }
        if (x > y) {
            return gcdHelper(x - y, y);
        } else if (y > x) {
            return gcdHelper(x, y - x);
        } else {
            return x;
        }
    }
}",0,0,0,0,0,0,0,0,0
234,"public class MyClass{
    class Node{
        int data;
        Node next;
        public Node(int d){
            this.data=d;
            this.next=null;
        }
    }
        public Node head=null;
        public Node tail=null;
        void add(int d){
            Node new_node=new Node(d);
            if(head==null){
                head=new_node;
                tail=new_node;
            }else{
                tail.next=new_node;
                tail=new_node;
            }
        }
        void display(){
            Node curr=head;
            while(curr!=null){
                System.out.print("" ""+curr.data);
                curr=curr.next;
            }
        }
        void reverse(){
            Node curr=head;
            Node prev=null;
            while(curr!=null){
                Node next=curr.next;
                curr.next=prev;
                prev=curr;
                curr=next;
            }
            head=prev;
        }
        public static void main(String args[]){
            MyClass slist=new MyClass();
            slist.add(10);
            slist.add(20);
            slist.add(30);
            slist.add(40);
            slist.add(50);
            slist.display();
            System.out.println("""");
            System.out.println(""revered linked list is"");
           slist.reverse();
           slist.display();
        }
    }",0,0,0,0,0,0,0,1,0
235,"from .base_linked_list import BaseLinkedList
from .node import Node
class RLinkedList(BaseLinkedList):
    def __init__(self):
        super().__init__()
    def add(self, data):
        if not isinstance(data, Node):
            raise TypeError()
        if self.node is None:
            self.node = data
        else:
            data.next = self.node
            self.node = data
        self.length += 1",0,0,0,0,0,0,0,0,0
236,"class Stack {
  constructor() {
    this.stackData = [];
  }
  peek() {
    return this.stackData[this.stackData.length - 1];
  }
  push(value) {
    this.stackData.push(value);
  }
  pop() {
    return this.stackData.pop();
  }
}
const myStack = new Stack();
console.log(myStack.peek());
myStack.push(10);
myStack.push(20);
myStack.push(30);
console.log(JSON.stringify(myStack));
console.log(myStack.peek());
console.log(myStack.pop());
console.log(myStack.pop());
console.log(myStack.pop());
console.log(JSON.stringify(myStack));",0,0,0,0,0,0,0,0,0
237,"class Node:
    def __init__(self, data, next_=None):
        self.data = data
        self.next = next_
    def __str__(self):
        return str(self.data)
class LinkedList:
    def __init__(self):
        self.head = None
    def add(self, data):
        node = Node(data, self.head)
        self.head = node
    def search(self, value):
        current = self.head
        while current is not None:
            if current.data == value:
                return current
            current = current.next
        return None
    def remove(self, value):
        current = self.head
        previous = None
        while current is not None and current.data != value:
            previous = current
            current = current.next
        if previous is None:
            self.head = current.next
        elif current is not None:
            previous.next = current.next
    def __str__(self):
        string = ''
        current = self.head
        while current.next is not None:
            string += str(current.data) + ' -> '
            current = current.next
        string += str(current.data) + ' -> ' + str(None)
        return string
if __name__ in ""__main__"":
    print('create initial linked list')
    lst = LinkedList()
    for i in [1, 7, 2, 3, -10]:
        print('add {}'.format(i))
        lst.add(i)
    print()
    print('linked list:', lst, '\n')
    for i in [2, 4, -10]:
        lst.remove(i)
        print('remove {}'.format(i))
        print('linked list:', lst, '\n')
    for i in [3, 10]:
        print('search {}'.format(i), lst.search(i))",0,0,0,0,0,1,0,1,0
238,"from __future__ import print_function
class Node:  
    def __init__(self, data):
        self.data = data  
        self.next = None  
class Linked_List:
    def __init__(self):
        self.Head = None    
    def insert_tail(self, data):
        if(self.Head is None): self.insert_head(data)    
        else:
            temp = self.Head
            while(temp.next != None):    
                temp = temp.next
            temp.next = Node(data)    
    def insert_head(self, data):
        newNod = Node(data)    
        if self.Head != None:
            newNod.next = self.Head     
        self.Head = newNod    
    def printList(self):  
        tamp = self.Head
        while tamp is not None:
            print(tamp.data)
            tamp = tamp.next
    def delete_head(self):  
        temp = self.Head
        if self.Head != None:
            self.Head = self.Head.next
            temp.next = None
        return temp
    def delete_tail(self):  
        tamp = self.Head
        if self.Head != None:
            if(self.Head.next is None):    
                self.Head = None
            else:
                while tamp.next.next is not None:  
                    tamp = tamp.next
                tamp.next, tamp = None, tamp.next    
        return tamp
    def isEmpty(self):
        return self.Head is None  
    def reverse(self):
        prev = None
        current = self.Head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        self.Head = prev
def main():
    A = Linked_List()
    print(""Inserting 1st at Head"")
    a1=input()
    A.insert_head(a1)
    print(""Inserting 2nd at Head"")
    a2=input()
    A.insert_head(a2)
    print(""\nPrint List : "")
    A.printList()
    print(""\nInserting 1st at Tail"")
    a3=input()    
    A.insert_tail(a3)
    print(""Inserting 2nd at Tail"")
    a4=input()
    A.insert_tail(a4)
    print(""\nPrint List : "")
    A.printList()
    print(""\nDelete Head"")
    A.delete_head()
    print(""Delete Tail"")
    A.delete_tail()
    print(""\nPrint List : "")
    A.printList()
    print(""\nReverse Linked List"")
    A.reverse()
    print(""\nPrint List : "")
    A.printList()
if __name__ == '__main__':
	main()",0,0,0,0,0,0,0,1,0
239,"package DataStructures.Lists;
public class SinglyLinkedList {
    private Node head;
    public void insertHead(int x) {
        Node newNode = new Node(x);
        newNode.next = head;
        head = newNode;
    }
    public void insertNth(int data, int position) {
        if (position < 0 || position > getSize()) {
            throw new RuntimeException(""position less than zero or position more than the count of list"");
        } else if (position == 0)
            insertHead(data);
        else {
            Node cur = head;
            Node node = new Node(data);
            for (int i = 1; i < position; ++i) {
                cur = cur.next;
            }
            node.next = cur.next;
            cur.next = node;
        }
    }
    public void deleteHead() {
        if (isEmpty()) {
            throw new RuntimeException(""The list is empty!"");
        }
        head = head.next;
    }
    public void deleteNth(int position) {
        if (position < 0 || position >= getSize()) {
            throw new RuntimeException(""position less than zero or position more than the count of list"");
        } else if (position == 0)
            deleteHead();
        else {
            Node cur = head;
            for (int i = 1; i < position; ++i) {
                cur = cur.next;
            }
            cur.next = cur.next.next;
        }
    }
    public boolean isEmpty() {
        return getSize() == 0;
    }
    public void display() {
        Node current = head;
        while (current != null) {
            System.out.print(current.value + "" "");
            current = current.next;
        }
        System.out.println();
    }
    public int getSize() {
        if (head == null)
            return 0;
        else {
            Node current = head;
            int size = 1;
            while (current.next != null) {
                current = current.next;
                size++;
            }
            return size;
        }
    }
    public static void main(String args[]) {
        SinglyLinkedList myList = new SinglyLinkedList();
        assert myList.isEmpty();
        myList.insertHead(5);
        myList.insertHead(7);
        myList.insertHead(10);
        myList.display();  
        myList.deleteHead();
        myList.display();  
        myList.insertNth(11, 2);
        myList.display();  
        myList.deleteNth(1);
        myList.display();  
    }
}
class Node {
    int value;
    Node next;
    Node(int value) {
        this.value = value;
        this.next = null;
    }
}",0,0,0,0,0,0,0,1,0
240,"public class SinglyLinkedList<T extends Comparable<? super T>> implements
        LinkedListInterface<T> {
    private SLLNode<T> head;
    private SLLNode<T> tail;
    private int size;
    @Override
    public void addToFront(T data) {
        if (data == null) {
            throw new java.lang.IllegalArgumentException(""Input data is null."");
        }
        head = new SLLNode<T>(data, head);
        if (size == 0) {
            tail = head;
        }
        ++size;
    }
    @Override
    public void addAtIndex(T data, int index) {
        if (data == null) {
            throw new java.lang.IllegalArgumentException(""Input data is null."");
        }
        if (index < 0 || index > size) {
            throw new java.lang.IndexOutOfBoundsException(
                    ""Input index is out of bounds."");
        }
        if (index == 0) {
            addToFront(data);
        } else if (index == size) {
            addToBack(data);
        } else {
            SLLNode<T> current = head;
            for (int i = 0; i < index - 1; ++i) {
                current = current.getNext();
            }
            current.setNext(new SLLNode<T>(data, current.getNext()));
            ++size;
        }
    }
    @Override
    public void addToBack(T data) {
        if (data == null) {
            throw new java.lang.IllegalArgumentException(""Input data is null."");
        }
        if (size == 0) {
            addToFront(data);
        } else {
            tail.setNext(new SLLNode<T>(data));
            tail = tail.getNext();
            ++size;
        }
    }
    @Override
    public T removeFromFront() {
        if (size == 0) {
            return null;
        } else {
            T temp = head.getData();
            head = head.getNext();
            if (size == 1) {
                tail = null;
            }
            --size;
            return temp;
        }
    }
    @Override
    public T removeAtIndex(int index) {
        if (index < 0 || index >= size) {
            throw new java.lang.IndexOutOfBoundsException(
                    ""Input index is out of bounds."");
        }
        if (index == 0) {
            return removeFromFront();
        } else if (index == size - 1) {
            return removeFromBack();
        } else {
            SLLNode<T> current = head;
            T temp;
            for (int i = 0; i < index - 1; ++i) {
                current = current.getNext();
            }
            temp = current.getNext().getData();
            current.setNext(current.getNext().getNext());
            --size;
            return temp;
        }
    }
    @Override
    public T removeFromBack() {
        if (size == 0) {
            return null;
        } else if (size == 1) {
            return removeFromFront();
        } else {
            T temp = tail.getData();
            SLLNode<T> current = head;
            for (int i = 1; i < size - 1; ++i) {
                current = current.getNext();
            }
            current.setNext(null);
            tail = current;
            --size;
            return temp;
        }
    }
    @Override
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new java.lang.IndexOutOfBoundsException(
                    ""Input index is out of bounds."");
        }
        if (index == 0) {
            return head.getData();
        } else if (index == size - 1) {
            return tail.getData();
        } else {
            SLLNode<T> current = head;
            for (int i = 0; i < index; ++i) {
                current = current.getNext();
            }
            return current.getData();
        }
    }
    @Override
    public T findLargestElement() {
        if (size == 0) {
            return null;
        }
        T temp = head.getData();
        SLLNode<T> current = head;
        while (current != null) {
            if (temp.compareTo(current.getData()) < 0) {
                temp = current.getData();
            }
            current = current.getNext();
        }
        return temp;
    }
    @Override
    public Object[] toArray() {
        Object[] arrayToReturn = new Object[size];
        SLLNode<T> current = head;
        for (int i = 0; i < size; ++i) {
            arrayToReturn[i] = current.getData();
            current = current.getNext();
        }
        return arrayToReturn;
    }
    @Override
    public int size() {
        return size;
    }
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
    @Override
    public void clear() {
        head = null;
        tail = null;
        size = 0;
    }
    @Override
    public SLLNode<T> getHead() {
        return head;
    }
    @Override
    public SLLNode<T> getTail() {
        return tail;
    }
}",0,0,0,0,0,0,0,1,0
241,"public class SinglyLinkedList{
    class Node{
        int data;
        Node next;
        public Node(int data){
            this.data=data;
            this.next=null;
        }
    }
     public Node head=null;
     public Node tail=null;
    void addNode(int d){
        Node new_node=new Node(d);
        if(head==null){
            head=new_node;
            tail=new_node;
        }else{
            tail.next=new_node;
            tail=new_node;
        }
    }
    void insertStart(int d){
        Node new_node=new Node(d);
        if(head==null){
            head=new_node;
            tail=new_node;
        }else{
            new_node.next=head;
            head=new_node;
        }
    }
    void deleteStart(){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            head=head.next;
        }
    }
    void deleteEnd(){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            Node current=head;
            while(current.next.next!=null){
                current=current.next;
            }
            current.next=null;
            tail=current;
        }
    }
    void deleteMiddle(int n){
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            Node current=head;
            Node previous=head;
            for(int i=0;i<n;i++){
                previous=current;
                current=current.next;
            }
            previous.next=current.next;
        }
    }
    void insertMiddle(int d,int n){
        Node new_node=new Node(d);
        if(head==null){
            System.out.println(""List is empty"");
        }else{
            Node current=head;
            Node previous=head;
            for(int i=0;i<n;i++){
                previous=current;
                current=current.next;
            }
           new_node.next=current;
           previous.next=new_node;
        }
    }
    void display(){
           Node  current=head;
           while(current!=null){
               System.out.print(""  ""+current.data);
               current=current.next;
           }
    }
    public static void main(String args[]){
        SinglyLinkedList slist=new SinglyLinkedList();
        slist.addNode(10);
        slist.addNode(20);
        slist.addNode(30);
        slist.addNode(40);
        slist.addNode(50);
        slist.insertStart(5);
        slist.insertStart(7);
        slist.display();
        System.out.println("""");
        slist.deleteStart();
        slist.deleteEnd();
        slist.deleteMiddle(3);
        slist.insertMiddle(25,2);
        slist.display();
    }
}",0,0,0,0,0,0,0,1,0
242,"class SinglyLinkedList{
	private Node head;
	public SinglyLinkedList(){
		head = null;
	}
	public void insertHead(int x){
		Node newNode = new Node(x);  
		newNode.next = head; 		 
		head = newNode; 			 
	}
    Node InsertNth(Node head, int data, int position) {
        Node newNode = new Node();
        newNode.data = data;
        if (position == 0) {
            newNode.next = head;
            return newNode;
        }
        Node current = head;
        while (--position > 0) {
            current = current.next;
        }
        newNode.next = current.next;
        current.next = newNode;
        return head;
    }
	public Node deleteHead(){
		Node temp = head;
		head = head.next;  
		return temp;
	}
	public boolean isEmpty(){
		return(head == null);
	}
	public void display(){
		Node current = head;
		while(current!=null){
			System.out.print(current.getValue()+"" "");
			current = current.next;
		}
		System.out.println();
	}
	public static void main(String args[]){
		SinglyLinkedList myList = new SinglyLinkedList();
		System.out.println(myList.isEmpty());  
		myList.insertHead(5);
		myList.insertHead(7);
		myList.insertHead(10);
		myList.display();  
		myList.deleteHead();
		myList.display();  
	}
}
class Node{
	public int value;
	public Node next;  
	public Node(int valuein){
		value = valuein;
	}
	public int getValue(){
		return value;
	}
}",0,0,0,0,0,0,0,1,0
243,"package com.deepak.data.structures.LinkedList;
public class SinglyLinkedList<E> {
	private Node<E> head;
	private int size = 0;
	public void insertAtHead(E value) {
		Node<E> newNode = new Node<E>(value); 
		newNode.next = head; 
		head = newNode;
		size++;
	}
	public void insertAtTail(E value) {
		Node<E> newNode = new Node<E>(value);
		newNode.next = null; 
		if (null == head) { 
			head = newNode;
		} else {
			Node<E> tempNode = head;
			while (null != tempNode.next) {
				tempNode = tempNode.next;
			}
			tempNode.next = newNode;
		}
		size++;
	}
	public void insertAtPosition(E value, int position) {
		if (position < 0 || position > size) {
			throw new IllegalArgumentException(""Position is Invalid"");
		} 
		Node<E> newNode = new Node<E>(value);
		if (position == 0) {
			newNode.next = head;
		} else {
			Node<E> tempNode = head;
			for (int i = 0; i < position - 1; i++) {
				tempNode = tempNode.next;
			}
			Node<E> nodeNextToNewNode = tempNode.next;
			tempNode.next = newNode;
			newNode.next = nodeNextToNewNode;
		}
		size++;
	}
	public void traverse() {
		Node<E> temp = head;
		while (temp != null) {
			System.out.println(temp.item);
			temp = temp.next;
		}
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0;
	}
	public Node<E> searchByIndex(int index) {
		if (index < 0 || index >= size) {
			throw new IndexOutOfBoundsException(""Invalid index passed while searching for a value"");
		} 
		Node<E> temp = head;
		for (int i = 0; i < index; i++) { 
			temp = temp.next;
		}
		return temp;
	}
	public Node<E> searchByValue(E value) { 
		Node<E> temp = head;
		while (null != temp.next && temp.item != value) {
			temp = temp.next;
		}
		if (temp.item == value) {
			return temp;
		}
		return null;
	}
	public void deleteFromHead() {
		if (null == head) { 
			return;
		}
		head = head.next;
		size--;
	}
	public void deleteFromTail() {
		if (null == head) {
			return;
		}
		Node<E> currentNode = head;
		Node<E> nextNode = currentNode.next;
		while (currentNode.next != null && nextNode.next != null) {
			currentNode = currentNode.next;
			nextNode = nextNode.next;
		}
		currentNode.next = null;
		size--;
	}
	public void deleteFromPosition(int position) {
		if (position < 0 || position >= size) {
			throw new IllegalArgumentException(""Position is Invalid"");
		} 
		Node<E> nodeToBeDeleted = head;
		for (int i = 0; i < position; i++) {
			nodeToBeDeleted = nodeToBeDeleted.next;
		}
		if (nodeToBeDeleted.next == null) { 
			deleteFromTail();
		} else {
			nodeToBeDeleted.item = nodeToBeDeleted.next.item;
			nodeToBeDeleted.next = nodeToBeDeleted.next.next;
		}
	}
	public Object[] toArray() {
		Object[] result = new Object[size];
		int i = 0;
		for (Node<E> x = head; x != null; x = x.next) {
			result[i++] = x.item;
		}
		return result;
	}
	public class Node<T> {
		T item;
		Node<T> next;
		public Node(T item) {
			this.item = item;
		}
		@Override
		public String toString() {
			return ""Data Item = "" + item;
		}
	}
}",0,0,0,0,0,1,0,1,0
244,"package LinkedList;
public class SinglyLinkedList {
    private static class ListNode {
        private final int data;
        private ListNode next;
        public  ListNode(int data) {
            this.data = data ;
            this.next = null ;
        }
    }
    private  static ListNode head;
    private void length() {
        int counter = 0;
        ListNode current = head;
        while(current != null) {
            counter++;
            current = current.next;
        }
        System.out.println(""\n""+""Length of list is :"" + counter);
    }
    private void Search(int SearchKey) {
        if(head == null) {
            System.out.println(""SearchKey not found!!"");
        }
        ListNode current = head ;
        int counter = -1;
        while (current != null) {
            counter ++ ;
            if(current.data == SearchKey) {
                System.out.println(""SearchKey Found at "" + counter + "" node"" );
                return;
            }
            current = current.next ;
        }
        System.out.println(""SearchKey not Found!!"");
    }
    private void display(ListNode head) {
        ListNode current = head ;
        while(current != null ) {
            System.out.print(current.data + ""-->"");
            current = current.next;
        }
        System.out.print(""null"");
    }
    private void insertFirst(int value) {
        ListNode newNode = new ListNode(value);
        newNode.next = head ;
        head = newNode ;
    }
    private void insertEnd(int value) {
        ListNode newNode = new ListNode(value);
        if (head == null) {
            head = newNode;
            return;
        }
        ListNode current = head ;
        while(current.next != null){
            current = current.next;
        }
        current.next = newNode;
    }
    private void findMiddleNode() {
        ListNode fastPtr = head ;
        ListNode slowPtr = head ;
        while (fastPtr != null && fastPtr.next != null) {
            slowPtr = slowPtr.next ;
            fastPtr = fastPtr.next.next;
        }
        assert slowPtr != null;
        System.out.println(slowPtr.data);
    }
    private ListNode insertInSortedList(int value) {
        ListNode newNode = new ListNode(value);
        if(head == null) {
            return newNode;
        }
        ListNode current = head;
        ListNode temp = null;
        while (current != null && current.data < newNode.data) {
            temp = current ;
            current = current.next;
        }
        newNode.next = current;
        assert temp != null;
        temp.next = newNode ;
        return head;
    }
    private void getNthNodeFromEnd(int n) {
        if(head == null) {
            return ;
        }
        if(n <= 0) {
            throw  new IllegalArgumentException(""Invalid Value:""+n);
        }
        ListNode mainPtr = head;
        ListNode refPtr = head ;
        int count = 0;
        while (count < n) {
            if(refPtr == null) {
                throw new IllegalArgumentException(n + "" is greater than number of nodes in the list"");
            }
            refPtr = refPtr.next;
            count++;
        }
        while (refPtr != null) {
            refPtr = refPtr.next;
            mainPtr = mainPtr.next;
        }
        System.out.println(mainPtr.data);
    }
    private ListNode reverseList() {
        ListNode current = head;
        ListNode previous = null;
        ListNode next ;
        while (current != null) {
            next = current.next ;
            current.next = previous ;
            previous = current ;
            current = next ;
        }
        return  previous;
    }
    private void deleteNode(int Key) {
        ListNode current = head;
        ListNode temp = null;
        if(current != null && current.data == Key) {
            head = current.next;
            return;
        }
        while (current != null && current.data != Key) {
            temp = current ;
            current = current.next;
        }
        if(current == null) {
            return;
        }
        temp.next = current.next;
    }
    private boolean detectLoop() {
        ListNode fastPtr = head ;
        ListNode slowPtr = head ;
        while (fastPtr != null && fastPtr.next !=null) {
            fastPtr = fastPtr.next.next ;
            slowPtr = slowPtr.next;
            if(slowPtr == fastPtr) {
                return true;
            }
        }
        return false;
    }
    public static void main(String[]  args) {
          SinglyLinkedList sll = new SinglyLinkedList();
    }
}",0,0,0,0,0,1,0,1,0
245,"public class SinglyLinkedList<T> implements LinkedListInterface<T> {
    private LinkedListNode<T> head;
    private LinkedListNode<T> tail;
    private int size;
    @Override
    public void addAtIndex(int index, T data)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (index < 0 || index > this.size) {
            throw new IndexOutOfBoundsException(""Index can't be negative""
                    + "" or greater than the size of the Linked List."");
        } else if (data == null) {
            throw new IllegalArgumentException(""Data stored in node cannot""
                    + "" be null"");
        }
        LinkedListNode<T> node = head;
        LinkedListNode<T> temp = new LinkedListNode<T>(data);
        if (index == 0) {
            this.addToFront(data);
        } else if (index == this.size) {
            this.addToBack(data);
        } else {
            while (--index > 0) {
                node = node.getNext();
            }
            temp.setNext(node.getNext());
            node.setNext(temp);
            size++;
        }
    }
    @Override
    public T get(int index) throws IndexOutOfBoundsException {
        if (index < 0 || index >= this.size) {
            throw new IndexOutOfBoundsException(""Index can't be negative ""
                    + ""or greater than/equal to size of linked list"");
        }
        LinkedListNode<T> node = head;
        if (index == 0) {
            return this.head.getData();
        } else if (index == this.size - 1) {
            return this.tail.getData();
        } else {
            while (index > 0) {
                index--;
                node = node.getNext();
            }
            return node.getData();
        }
    }
    @Override
    public T removeAtIndex(int index) throws IndexOutOfBoundsException {
        if (index < 0 || index >= this.size) {
            throw new IndexOutOfBoundsException(""Index can't be negative ""
                    + ""or greater than/equal to size of linked list"");
        }
        LinkedListNode<T> node = head;
        LinkedListNode<T> pre = null;
        T answer;
        if (index == 0) {
            answer = this.removeFromFront();
        } else if (index == this.size - 1) {
            answer = this.removeFromBack();
        } else {
            for (int i = 0; i < index; i++) {
                pre = node;
                node = node.getNext();
            }
            if (pre != null) {
                pre.setNext(node.getNext());
            } else {
                head = head.getNext();
            }
            answer = node.getData();
            size--;
        }
        return answer;
    }
    @Override
    public void addToFront(T data) throws IllegalArgumentException {
        if (data == null) {
            throw new IllegalArgumentException(""Node data cannot be null"");
        }
        this.head = new LinkedListNode<T>(data, this.head);
        if (this.size == 0) {
            tail = head;
        }
        this.size++;
    }
    @Override
    public void addToBack(T data) throws IllegalArgumentException {
        if (data == null) {
            throw new IllegalArgumentException(""Node data cannot be null"");
        }
        LinkedListNode<T> node = new LinkedListNode<T>(data, null);
        if (head == null) {
            this.head = node;
        } else {
            this.tail.setNext(node);
        }
        this.tail = node;
        this.size++;
    }
    @Override
    public T removeFromFront() {
        if (head == null) {
            return null;
        }
        T answer = this.head.getData();
        this.head = this.head.getNext();
        this.size--;
        if (this.size == 0) {
            this.tail = null;
        }
        return answer;
    }
    @Override
    public T removeFromBack() {
        LinkedListNode<T> node = head;
        LinkedListNode<T> pre = null;
        if (head == null) {
            return null;
        }
        while (node.getNext() != null) {
            pre = node;
            node = node.getNext();
        }
        T answer = this.tail.getData();
        if (pre != null) {
            pre.setNext(null);
        } else {
            head = null;
        }
        this.tail = pre;
        size--;
        if (this.size == 0) {
            this.tail = null;
        }
        return answer;
    }
    @Override
    public boolean removeAllOccurrences(T data)
            throws IllegalArgumentException {
        boolean answer = false;
        LinkedListNode<T> node = head;
        if (data == null) {
            throw new IllegalArgumentException(""Data cannot be null"");
        } else {
            int index = 0;
            while (node != null) {
                if (node.getData().equals(data)) {
                    this.removeAtIndex(index);
                    answer = true;
                } else {
                    index++;
                }
                node = node.getNext();
            }
        }
        return answer;
    }
    @Override
    public Object[] toArray() {
        LinkedListNode<T> node = head;
        Object[] arr = new Object[this.size];
        for (int i = 0; i < this.size; i++) {
            arr[i] = node.getData();
            node = node.getNext();
        }
        return arr;
    }
    @Override
    public boolean isEmpty() {
        return (this.size == 0);
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public void clear() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    @Override
    public LinkedListNode<T> getHead() {
        return head;
    }
    @Override
    public LinkedListNode<T> getTail() {
        return tail;
    }
}",0,0,0,0,0,0,0,1,0
246,"const { Node } = require('./Node');
class SinglyLinkedList {
    constructor() {
        this.head = null;
        this.count = 0;
    }
    any() {
        return this.head !== null;
    }
    addFront(value) {
        const node = new Node(value);
        node.next = this.head;
        this.head = node;
        this.count++;
    }
    removeFront() {
        if (!this.any()) {
            return null;
        }
        const removedNode = this.head;
        this.head = removedNode.next;
        removedNode.next = null;
        this.count--;
        return removedNode;
    }
    toArray() {
        const nodes = [];
        let currentNode = this.head;
        while (currentNode != null) {
            nodes.push(currentNode.value);
            currentNode = currentNode.next;
        }
        return nodes;
    }
    toString() {
        const nodes = this.toArray();
        return `SinglyLinkedList [ ${nodes.join(' -> ')} ]`;
    }
}
module.exports = { SinglyLinkedList };",0,0,0,0,0,0,0,1,0
247,"class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor(value) {
    this.head = new Node(value);
    this.tail = this.head;
    this.length = 1;
  }
  printLinkedList() {
    let currentNode = this.head;
    const listElements = [];
    while (currentNode) {
      listElements.push(currentNode.value);
      currentNode = currentNode.next;
    }
    console.log(listElements);
  }
  append(value) {
    const newNode = new Node(value);
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
  }
  prepend(value) {
    const newNode = new Node(value);
    newNode.next = this.head;
    this.head = newNode;
    this.length++;
  }
  _traverseToIndex(index) {
    let counter = 0;
    let currentNode = this.head;
    while (counter != index) {
      currentNode = currentNode.next;
      counter++;
    }
    return currentNode;
  }
  insert(index, value) {
    if (index === 0) {
      this.prepend(value);
      return;
    }
    if (index >= this.length) {
      this.append(value);
      return;
    }
    const newNode = new Node(value);
    const leader = this._traverseToIndex(index - 1);
    const holdingPointer = leader.next;
    leader.next = newNode;
    newNode.next = holdingPointer;
    this.length++;
  }
  remove(index) {
    if (index === 0) {
      this.head = this.head.next;
      return;
    }
    const leader = this._traverseToIndex(index - 1);
    const unwantedNode = leader.next;
    leader.next = unwantedNode.next;
    this.length--;
  }
  reverse() {
    if (!this.head.next) {
      return this.head;
    }
    let first = this.head;
    this.tail = this.head;
    let second = first.next;
    while(second) {
      let temp = second.next;
      second.next = first;
      first = second;
      second = temp;
    }
    this.head.next = null;
    this.head = first;
  }
}
const myLinkedList = new SinglyLinkedList(10);
myLinkedList.printLinkedList();
myLinkedList.append(20);
myLinkedList.append(30);
myLinkedList.prepend(1);
myLinkedList.printLinkedList();
console.log(JSON.stringify(myLinkedList));
myLinkedList.insert(2, 99);
myLinkedList.insert(2, 69);
myLinkedList.insert(0, 420);
myLinkedList.insert(20, 666);
myLinkedList.printLinkedList();
myLinkedList.remove(0);
myLinkedList.remove(2);
myLinkedList.remove(5);
myLinkedList.printLinkedList();
myLinkedList.reverse();
myLinkedList.printLinkedList();",0,0,0,0,0,1,0,1,0
248,"import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Set;
public class SkipList<T extends Comparable<? super T>>
    implements SkipListInterface<T> {
    private CoinFlipper coinFlipper;
    private int size;
    private SkipListNode<T> head;
    public SkipList(CoinFlipper coinFlipper) {
        this.coinFlipper = coinFlipper;
        this.head = new SkipListNode<>(null, 1);
        this.size = 0;
    }
    @Override
    public T first() {
        if (this.size == 0) {
            throw new NoSuchElementException(""Skip list is empty."");
        }
        SkipListNode<T> node = head;
        while (node.getDown() != null) {
            node = node.getDown();
        }
        return node.getNext().getData();
    }
    @Override
    public T last() {
        if (this.size == 0) {
            throw new NoSuchElementException(""Skip list is empty."");
        }
        SkipListNode<T> node = head;
        boolean boo = true;
        while (boo) {
            while (node.getNext() != null) {
                node = node.getNext();
            }
            if (node.getLevel() != 1) {
                node = node.getDown();
            } else {
                boo = false;
            }
        }
        return node.getData();
    }
    @Override
    public void put(T data) {
        if (data == null) {
            throw new IllegalArgumentException(""Data cannot be null."");
        }
        SkipListNode<T> node = search(data);
        SkipListNode<T> toAdd = new SkipListNode<T>(data, 1);
        int add = 0;
        while (coinFlipper.flipCoin() == CoinFlipper.Coin.HEADS) {
            add++;
        }
        toAdd.setNext(node.getNext());
        if (node.getNext() != null) {
            node.getNext().setPrev(toAdd);
        }
        node.setNext(toAdd);
        toAdd.setPrev(node);
        int i = add + 2;
        int ht = head.getLevel();
        while (i > ht) {
            addLevel();
            i--;
        }
        while (add > 0) {
            while (node.getUp() == null) {
                node = node.getPrev();
            }
            node = node.getUp();
            SkipListNode<T> addNode = new SkipListNode<T>(data,
                    node.getLevel());
            addNode.setPrev(node);
            addNode.setNext(node.getNext());
            addNode.setDown(toAdd);
            if (node.getNext() != null) {
                node.getNext().setPrev(addNode);
            }
            node.setNext(addNode);
            toAdd.setUp(addNode);
            toAdd = addNode;
            add--;
        }
        size++;
    }
    private void addLevel() {
        SkipListNode<T> node = new SkipListNode<T>(null, head.getLevel() + 1);
        node.setNext(null);
        node.setDown(head);
        head.setUp(node);
        head = node;
    }
    private SkipListNode<T> search(T data) {
        SkipListNode<T> node = head;
        if (size > 1) {
            node = node.getDown();
        }
        boolean boo = true;
        while (boo) {
            while (node.getNext() != null && data.compareTo(node.getNext()
                    .getData()) >= 0) {
                node = node.getNext();
            }
            if (node.getLevel() != 1) {
                node = node.getDown();
            } else {
                boo = false;
            }
        }
        return node;
    }
    @Override
    public T remove(T data) {
        if (data == null) {
            throw new IllegalArgumentException(""Data cannot be null."");
        }
        SkipListNode<T> node = search(data);
        if (data.compareTo(node.getData()) == 0) {
            T toreturn = node.getData();
            while (node != null) {
                if (node.getPrev().getData() == null
                        && node.getNext() == null) {
                    node.getPrev().setUp(null);
                    node.getPrev().setNext(null);
                    node.setUp(null);
                    head = node.getPrev();
                } else if (node.getNext() != null) {
                    node.getPrev().setNext(node.getNext());
                    node.getNext().setPrev(node.getPrev());
                } else {
                    node.getPrev().setNext(null);
                }
                node = node.getUp();
            }
            size--;
            return toreturn;
        } else {
            throw new NoSuchElementException(""Skip list does not contain this ""
                    + ""data"");
        }
    }
    @Override
    public boolean contains(T data) {
        if (data == null) {
            throw new IllegalArgumentException(""Data cannot be null."");
        }
        try {
            get(data);
        } catch (NoSuchElementException e) {
            return false;
        }
        return true;
    }
    @Override
    public T get(T data) {
        if (data == null) {
            throw new IllegalArgumentException(""Data cannot be null."");
        }
        SkipListNode<T> node = search(data);
        if (node.getData() != null && node.getData().compareTo(data) == 0) {
            return node.getData();
        } else {
            throw new NoSuchElementException(""Skip list does not contain this ""
                    + ""data"");
        }
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public void clear() {
        this.head = new SkipListNode<T>(null, 1);
        this.size = 0;
    }
    @Override
    public Set<T> dataSet() {
        Set<T> dataset = new HashSet<>();
        if (size == 0) {
            return dataset;
        }
        SkipListNode<T> node = head;
        while (node.getLevel() != 1) {
            node = node.getDown();
        }
        while (node.getNext() != null) {
            node = node.getNext();
            dataset.add(node.getData());
        }
        return dataset;
    }
    @Override
    public SkipListNode<T> getHead() {
        return head;
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(""**********************\n"");
        builder.append(String.format(""SkipList (size = %d)\n"", size()));
        SkipListNode<T> levelCurr = getHead();
        while (levelCurr != null) {
            SkipListNode<T> curr = levelCurr;
            int level = levelCurr.getLevel();
            builder.append(String.format(""Level: %2d   "", level));
            while (curr != null) {
                builder.append(String.format(""(%s)%s"", curr.getData(),
                            curr.getNext() == null ? ""\n"" : "", ""));
                curr = curr.getNext();
            }
            levelCurr = levelCurr.getDown();
        }
        builder.append(""**********************\n"");
        return builder.toString();
    }
}",0,0,0,0,0,0,0,0,0
249,"import java.util.Set;
public interface SkipListInterface<T extends Comparable<? super T>> {
    public T first();
    public T last();
    public void put(T data);
    public T remove(T data);
    public boolean contains(T data);
    public T get(T data);
    public int size();
    public void clear();
    public Set<T> dataSet();
    public SkipListNode<T> getHead();
}",0,0,0,0,0,0,0,0,0
250,"package com.jwetherell.algorithms.data_structures;
import com.jwetherell.algorithms.data_structures.SkipList.Node;
import com.jwetherell.algorithms.data_structures.interfaces.IMap;
@SuppressWarnings(""unchecked"")
public class SkipListMap<K extends Comparable<K>, V> implements SkipList.INodeCreator<K>, IMap<K,V> {
    private SkipList<K> list = null;
    public SkipListMap() {
        list = new SkipList<K>(this);
    }
    @Override
    public V put(K key, V value) {
        V prev = null;
        SkipList.Node<K> node = list.addValue(key);
        if (node instanceof SkipListMapNode) {
            SkipListMapNode<K, V> treeMapNode = (SkipListMapNode<K, V>) node;
            if (treeMapNode.value!=null) prev = treeMapNode.value;
            treeMapNode.value = value;
        }
        return prev;
    }
    @Override
    public V get(K key) {
        SkipList.Node<K> node = list.getNode(key);
        if (node instanceof SkipListMapNode) {
            SkipListMapNode<K, V> mapNode = (SkipListMapNode<K, V>) node;
            return mapNode.value;
        }
        return null;
    }
    @Override
    public boolean contains(K key) {
        return list.contains(key);
    }
    @Override
    public V remove(K key) {
        Node<K> node = list.removeValue(key);
        V value = null;
        if (node instanceof SkipListMapNode) {
            SkipListMapNode<K, V> treeMapNode = (SkipListMapNode<K, V>) node;
            value = treeMapNode.value;
            treeMapNode.data = null;
            treeMapNode.value = null;
        }
        return value;
    }
    @Override
    public void clear() {
        list.clear();
    }
    @Override
    public int size() {
        return list.size();
    }
    @Override
    public boolean validate() {
        if (list==null) return true;
        java.util.Set<K> keys = new java.util.HashSet<K>();
        Node<K> node = list.head;
        if (node==null) return true;
        if (!validate(node,keys)) return false;
        Node<K> next = node.getNext(0);
        while (next!=null) {
            if (!validate(next, keys)) return false;
            next = next.getNext(0);
        }
        return (keys.size()==size());
    }
    private boolean validate(Node<K> node, java.util.Set<K> keys) {
        if (!(node instanceof SkipListMapNode)) return false;
        SkipListMapNode<K,V> tmn = (SkipListMapNode<K,V>)node;
        K k = tmn.data;
        V v = tmn.value;
        if (k==null || v==null) return false;
        if (keys.contains(k)) return false;
        keys.add(k);
        return true;
    }
    @Override
    public java.util.Map<K,V> toMap() {
        return (new JavaCompatibleTreeMap<K,V>(this));
    }
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        if (list!=null && list.head!=null) {
            Node<K> node = list.head;
            while (node!=null) {
                if (!(node instanceof SkipListMapNode)) continue;
                SkipListMapNode<K,V> sln = (SkipListMapNode<K, V>) node;
                builder.append(sln.data).append(""="").append(sln.value);
                node = node.getNext(0);
                if (node!=null) builder.append(""\n"");
            }
        }
        return builder.toString();
    }
    @Override
    public SkipList.Node<K> createNewNode(int level, K key) {
        return (new SkipListMapNode<K, V>(level, key));
    }
    @Override
    public void swapNode(Node<K> node, Node<K> next) {
        K key = node.data;
        node.data = next.data;
        next.data = key;
        if (node instanceof SkipListMapNode && next instanceof SkipListMapNode) {
            SkipListMapNode<K,V> node2 = (SkipListMapNode<K,V>) node;
            SkipListMapNode<K,V> next2 = (SkipListMapNode<K,V>) next;
            V value = node2.value;
            node2.value = next2.value;
            next2.value = value;
        }
    }
    protected static class SkipListMapNode<K extends Comparable<K>, V> extends SkipList.Node<K> {
        protected V value = null;
        protected SkipListMapNode(int level, K key) {
            super(level, key);
        }
        @Override
        public String toString() {
            StringBuilder builder = new StringBuilder();
            builder.append(super.toString());
            builder.append(""value = "").append(value).append(""\n"");
            return builder.toString();
        }
    }
    private static class JavaCompatibleIteratorWrapper<K extends Comparable<K>,V> implements java.util.Iterator<java.util.Map.Entry<K, V>> {
        private SkipListMap<K,V> map = null;
        private java.util.Iterator<java.util.Map.Entry<K, V>> iter = null;
        private java.util.Map.Entry<K, V> lastEntry = null;
        public JavaCompatibleIteratorWrapper(SkipListMap<K,V> map, java.util.Iterator<java.util.Map.Entry<K, V>> iter) {
            this.map = map;
            this.iter = iter;
        }
        @Override
        public boolean hasNext() {
            if (iter==null) return false;
            return iter.hasNext();
        }
        @Override
        public java.util.Map.Entry<K, V> next() {
            if (iter==null) return null;
            lastEntry = iter.next();
            return lastEntry;
        }
        @Override
        public void remove() {
            if (iter==null || lastEntry==null) return;
            map.remove(lastEntry.getKey());
            iter.remove();
        }
    }
    private static class JavaCompatibleMapEntry<K extends Comparable<K>,V> extends java.util.AbstractMap.SimpleEntry<K,V> {
        private static final long serialVersionUID = 3282082818647198608L;
        public JavaCompatibleMapEntry(K key, V value) {
            super(key, value);
        }
    }
    private static class JavaCompatibleTreeMap<K extends Comparable<K>,V> extends java.util.AbstractMap<K,V> {
        private SkipListMap<K,V> map = null;
        protected JavaCompatibleTreeMap(SkipListMap<K,V> map) {
            this.map = map;
        }
        @Override
        public V put(K key, V value) {
            return map.put(key, value);
        }
        @Override
        public V remove(Object key) {
            return map.remove((K)key);
        }
        @Override
        public void clear() {
            map.clear();
        }
        @Override
        public boolean containsKey(Object key) {
            return map.contains((K)key);
        }
        @Override
        public int size() {
            return map.size();
        }
        @Override
        public java.util.Set<java.util.Map.Entry<K, V>> entrySet() {
            java.util.Set<java.util.Map.Entry<K, V>> set = new java.util.HashSet<java.util.Map.Entry<K, V>>() {
                private static final long serialVersionUID = 1L;
                @Override
                public java.util.Iterator<java.util.Map.Entry<K, V>> iterator() {
                    return (new JavaCompatibleIteratorWrapper<K,V>(map,super.iterator()));
                }
            };
            if (map.list!=null && map.list.head!=null) {
                Node<K> n = map.list.head;
                while (n!=null) {
                    if (!(n instanceof SkipListMapNode)) continue;
                    SkipListMapNode<K,V> node = (SkipListMapNode<K,V>)n;
                    set.add(new JavaCompatibleMapEntry<K,V>(node.data,node.value));
                    n = node.getNext(0);    
                }
            }
            return set;
        }
    }
}",0,0,0,0,0,0,0,0,0
251,"public class SkipListNode<T extends Comparable<? super T>> {
    private T data;
    private int level;
    private SkipListNode<T> prev;
    private SkipListNode<T> next;
    private SkipListNode<T> up;
    private SkipListNode<T> down;
    public SkipListNode(T data, int level) {
        this(data, level, null, null, null, null);
    }
    public SkipListNode(T data, int level,
                SkipListNode<T> prev, SkipListNode<T> next, SkipListNode<T> up,
                SkipListNode<T> down) {
        this.data = data;
        this.level = level;
        this.prev = prev;
        this.next = next;
        this.up = up;
        this.down = down;
    }
    public T getData() {
        return data;
    }
    public int getLevel() {
        return level;
    }
    public SkipListNode<T> getPrev() {
        return prev;
    }
    public SkipListNode<T> getNext() {
        return next;
    }
    public SkipListNode<T> getUp() {
        return up;
    }
    public SkipListNode<T> getDown() {
        return down;
    }
    public void setData(T data) {
        this.data = data;
    }
    public void setLevel(int level) {
        this.level = level;
    }
    public void setPrev(SkipListNode<T> prev) {
        this.prev = prev;
    }
    public void setNext(SkipListNode<T> next) {
        this.next = next;
    }
    public void setUp(SkipListNode<T> up) {
        this.up = up;
    }
    public void setDown(SkipListNode<T> down) {
        this.down = down;
    }
    @Override
    public String toString() {
        return String.format(""Node at level %d containing %s"", level, data);
    }
}",0,0,0,0,0,0,0,0,0
252,"public class SLLNode<T extends Comparable<? super T>> {
    private T data;
    private SLLNode<T> next;
    public SLLNode(T data, SLLNode<T> next) {
        this.data = data;
        this.next = next;
    }
    public SLLNode(T data) {
        this(data, null);
    }
    public T getData() {
        return data;
    }
    public SLLNode<T> getNext() {
        return next;
    }
    public void setNext(SLLNode<T> next) {
        this.next = next;
    }
    @Override
    public String toString() {
        return ""Node containing: "" + data;
    }
}",0,0,0,0,0,0,0,0,0
253,"__author__ = ""streethacker""
from linklistbag import Bag
class _BagListNode:
    def __init__(self, data):
        self.data = data
        self.next = None
class sortedBag(Bag):
    def __contains__(self, target):
        curNode = self._head
        while curNode is not None and curNode.data <= target:
            if curNode.data == target:
                return True
            else:
                curNode = curNode.next
        return False
    def add(self, data):
        preNode = None
        curNode = self._head
        while curNode is not None and curNode.data < data:
            preNode = curNode
            curNode = curNode.next
        newNode = _BagListNode(data)
        if curNode is self._head:
            newNode.next = self._head
            self._head = newNode
        else:
            newNode.next = preNode.next
            preNode.next = newNode
        self._size += 1
    def remove(self, data):
        preNode = None
        curNode = self._head
        while curNode is not None and curNode.data <= data:
            if curNode.data == data:
                if curNode is self._head:
                    self._head = curNode.next
                else:
                    preNode.next = curNode.next
                self._size -= 1
                return curNode.data
            else:
                preNode = curNode
                curNode = curNode.next
        raise AttributeError(""The item must be in the bag."")
if __name__ == ""__main__"":
    bag = sortedBag()
    bag.add(10)
    bag.add(12)
    bag.add(36)
    bag.add(77)
    bag.printBagElements()
    bag.remove(10)
    print
    bag.printBagElements()",0,0,0,0,0,1,0,1,0
254,"package com.stacks;
import java.util.Iterator;
import java.util.NoSuchElementException;
public class Stack<Item> implements Iterable<Item> {
	private Node first;
	public Stack() {
		first = null;
	}
	public void push(Item item) {
		Node oldfirst = first;
		first = new Node();
		first.item = item;
		first.next = oldfirst;
	}
	public Item pop() {
		if(isEmpty())
			throw new NoSuchElementException(""No item present on stack"");
		Item item = first.item;
		first = first.next;
		return item;
	}
	public Item peek() {
		if(isEmpty())
			throw new NoSuchElementException(""No item present on stack"");
		Item item = first.item;
		return item;
	}
	public boolean isEmpty() {
		return (first == null);
	}
	public int size() {
		int count = 0;
		for(Item item : this) {
			count++;
		}
		return count;
	}
	public void clear() {
		first = null;
	}
	public Iterator<Item> iterator() {
		return new StackIterator();
	}
	private class Node {
		Item item;
		Node next;
	}
	private class StackIterator implements Iterator<Item> {
		private Node current = first;
		public boolean hasNext() {	
			return current != null;	
		}
		public Item next() {
			Item item = current.item;
			current = current.next;
			return item;
		}
		public void remove() {
			throw new UnsupportedOperationException(""Remove operation not supported on stack"");
		}	
	}
}",0,0,0,0,0,0,0,0,0
255,"class Node(object):
	def __init__(self, data, nextnode=None):
		self.data = data
  self.nextnode = nextnode
class Stack(object):
	def __init__(self):
		self.top = None
 def is_empty(self):
  if self.top is None:
			return True
  return False
 def push(self, data):
  node = Node(data=data)
  if self.top is None:
			self.top = node
  else:
			temp = self.top
   self.top = node
   self.top.nextnode = temp
 def pop(self):
  if self.top is None:
			raise ValueError(""Stack is empty"")
  else:
			print self.top.data, ""is deleted""
   self.top = self.top.nextnode
 def peek(self):
  if self.top is None:
			raise ValueError(""Stack is empty"")
  else:
			return (self.top.data)",0,0,0,0,0,0,0,0,0
256,"class Stack {
  constructor() {
    this.stackData = [];
    this.top = null;
    this.bottom = null;
    this.length = 0;
  }
  peek() {
    return this.top;
  }
  push(value) {
    this.stackData.push(value);
    this.length++;
    if (this.length === 1) {
      this.bottom = this.stackData[0];
    }
    this.top = this.stackData[this.length - 1];
  }
  pop(value) {
    if (!this.length) {
      return null;
    }
    const deletedValue = this.stackData.pop();
    this.length--;
    if (!this.length) {
      this.bottom = null;
      this.top = null;
    }
    return deletedValue;
  }
}
const myStack = new Stack();
console.log(myStack.peek());
myStack.push(10);
myStack.push(20);
myStack.push(30);
console.log(JSON.stringify(myStack));
console.log(myStack.peek());
console.log(myStack.pop());
console.log(myStack.pop());
console.log(myStack.pop());
console.log(JSON.stringify(myStack));",0,0,0,0,0,0,0,0,0
257,"class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}
class Stack {
  constructor() {
    this.top = null;
    this.bottom = null;
    this.length = 0;
  }
  peek() {
    return this.top;
  }
  push(value) {
    const newNode = new Node(value);
    if (!this.bottom) {
      this.bottom = newNode;
    }
    newNode.next = this.top;
    this.top = newNode;
    this.length++;
  }
  pop() {
    if (!this.top) {
      return null;
    }
    if (!this.top.next) {
      this.bottom = null;
    }
    const removedNode = this.top;
    this.top = this.top.next;
    this.length--;
    return removedNode;
  }
}
const myStack = new Stack();
console.log(myStack.peek());
myStack.push(10);
myStack.push(20);
myStack.push(30);
console.log(JSON.stringify(myStack));
console.log(myStack.peek());
console.log(myStack.pop());
console.log(myStack.pop());
console.log(myStack.pop());
console.log(JSON.stringify(myStack));",0,0,0,0,0,0,0,1,0
258,"class Node:
    def __init__(self, data):
        self.data = data;
        self.next = None
class Linkedlist:
    def __init__(self):
        self.head = None
    def print_list(self):
        temp = self.head
        while temp is not None:
            print(temp.data)
            temp = temp.next
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node
    def swapNodes(self, d1, d2):
        prevD1 = None
        prevD2 = None
        if d1 == d2:
            return
        else:
            D1 = self.head
            while D1 is not None and D1.data != d1:
                prevD1 = D1
                D1 = D1.next
            D2 = self.head
            while D2 is not None and D2.data != d2:
                prevD2 = D2
                D2 = D2.next
            if D1 is None and D2 is None:
                return
            if prevD1 is not None:
                prevD1.next = D2
            else:
                self.head = D2
            if prevD2 is not None:
                prevD2.next = D1
            else:
                self.head = D1
            temp = D1.next
            D1.next = D2.next
            D2.next = temp
if __name__ == '__main__':
    list = Linkedlist()
    list.push(5)
    list.push(4)
    list.push(3)
    list.push(2)
    list.push(1)
    list.print_list()
    list.swapNodes(1, 4)
    print(""After swapping"")
    list.print_list()",0,0,0,0,0,0,0,1,0
259,"from unittest import TestCase
from data_structures.python.linked_list import LinkedList
class TestLinkedList(TestCase):
    def setUp(self):
        self.linked_list = LinkedList()
    def test_append(self):
        self.linked_list.append(""a"")
        self.assertEqual(""a"", self.linked_list.head.data)
    def test_prepend(self):
        self.linked_list.append(""a"")
        self.linked_list.prepend(""z"")
        self.assertEqual(""z"", self.linked_list.head.data)
    def test_add_after(self):
        self.linked_list.append(""a"")
        self.linked_list.append(""c"")
        self.linked_list.add_after(""a"", ""b"")
        self.assertEqual(""b"", self.linked_list.head.next.data)
    def test_add_before(self):
        self.linked_list.append(""a"")
        self.linked_list.append(""c"")
        self.linked_list.add_before(""c"", ""b"")
        self.assertEqual(""b"", self.linked_list.head.next.data)
    def test_delete_with_value(self):
        self.linked_list.append(""a"")
        self.linked_list.append(""c"")
        self.linked_list.delete_with_value(""c"")
        self.assertIsNone(self.linked_list.head.next)",0,0,0,0,0,0,0,0,0
260,"function Node(data) {
    this.data = data;
    this.children = [];
}
class Tree {
    constructor() {
        this.root = null;
    }
    add(data, toNodeData) {
        const node = new Node(data);
        const parent = toNodeData ? this.findBFS(toNodeData) : null;
        if(parent) {
            parent.children.push(node)
        } else {
            if(!this.root)
                this.root = node;
            else
                return ""Tried to store node as root when root already exists.""
        }
    }
    findBFS(data) {
        const queue = [this.root];
        let _node = null;
        this.traverseBFS((node) => {
            if(node.data === data) {
                _node = node;
            }
        })
        return _node;
    }
    traverseBFS(cb) {
        const queue = [this.root];
        if(cb)
            while(queue.length) {
                const node = queue.shift();
                cb(node)
                    for(const child of node.children) {
                    queue.push(child);
                }
            }
    }
}
(function test() {
    let tree = new Tree()
    tree.add('Node1')
    tree.add('Node2', 'Node1')
    tree.add('Node3', 'Node1')
    console.log(tree.findBFS('Node1'))
})()",0,0,0,0,0,0,0,0,0
261,"package Lists;
import java.util.List;
public class Vectors {
    public static void main(String[] args) {
        List<Employee> employeeList = new java.util.Vector<>();
        employeeList.add(new Employee(""Jane"",""Jones"",123));
        employeeList.add(new Employee(""Mary"",""Smith"",22));
        employeeList.add(new Employee(""John"",""Doe"",4567));
        employeeList.add(new Employee(""Mike"",""Wilson"",3245));
        employeeList.forEach(employee -> System.out.println(employee));  
    }
}",0,0,0,0,0,0,0,0,0
262,"from TreeNode import *
from BaseTree import *
def height(node):
    if not node:
        return 0
    if node.left and not node.right:
        return height(node.left) + 1
    if not node.left and node.right:
        return height(node.right) + 1
    if node.left and node.right:
        return max(height(node.left), height(node.right)) + 1
    return 0
def adjust_height(node):
    if not node:
        return
    node.height = max(height(node.left), height(node.right)) + 1
def balance_factor(node):
    if not node:
        return 0
    return height(node.left) - height(node.right)
def left_left_rotation(node):
    l = node.left
    lr = l.right
    node.left = lr
    l.right = node
    return l
def right_right_rotation(node):
    r = node.right
    rl = r.left
    node.right = rl
    r.left = node
    return r
def left_right_rotation(node):
    l = node.left
    lr = l.right
    lrl = lr.left
    lrr = lr.right
    l.right = lrl
    lr.left = l
    node.left = lr
    node.left = lrr
    lr.right = node
    return lr
def right_left_rotation(node):
    r = node.right
    rl = r.left
    rll = rl.left
    rlr = rl.right
    r.left = rlr
    rl.right = r
    node.right = rl
    node.right = rll
    rl.left = node
    return rl
def balance(node):
    if balance_factor(node) > 1:
        if balance_factor(node.left) > 0:
            return left_left_rotation(node)
        else:
            return left_right_rotation(node)
    elif balance_factor(node) < -1:
        if balance_factor(node.right) < 0:
            return right_right_rotation(node)
        else:
            return right_left_rotation(node)
    return node
class AVL(Tree):
    def insert_helper(self, node, val):
        if not node:
            node = Node(val)
            return node
        if val < node.val:
            node.left = self.insert_helper(node.left, val)
        elif val > node.val:
            node.right = self.insert_helper(node.right, val)
        adjust_height(node)
        node = balance(node)
        return node
    def insert(self, val):
        self.root = self.insert_helper(self.root, val)",0,0,0,0,0,0,0,0,0
263,"package com.namesny.binarysearchtree;
public class AVLTree<T extends Comparable<? super T>> implements BinarySearchTree<T> {
    protected AVLNode<T> root;
    public AVLTree() {
        root = null;
    }
    protected static class AVLNode<T extends Comparable<? super T>> {
        protected T value;
        protected int height;
        protected AVLNode<T> left;
        protected AVLNode<T> right;
        public AVLNode(T value, AVLNode<T> left, AVLNode<T> right) {
            this.value = value;
            this.left = left;
            this.right = right;
        }
        public AVLNode(T value) {
            this(value, null, null);
        }
    }
    @Override
    public void insert(T value) throws DuplicateValueException {
        if (value == null) {
            throw new IllegalArgumentException(""Value cannot be null"");
        }
        this.root = insert(value, root);
    }
    @Override
    public void delete(T value) {
        if (value == null) {
            throw new IllegalArgumentException(""Value cannot be null"");
        }
        this.root = delete(value, root);
    }
    @Override
    public T find(T key) {
        if (key == null) {
            throw new IllegalArgumentException(""Value cannot be null"");
        }
        return find(key, root);
    }
    @Override
    public void clear() {
        root = null;
    }
    @Override
    public boolean isEmpty() {
        return root == null;
    }
    @Override
    public T findMin() {
        return findMin(root).value;
    }
    @Override
    public T findMax() {
        return findMax(root).value;
    }
    private AVLNode<T> findMin(AVLNode<T> node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
    private AVLNode<T> findMax(AVLNode<T> node) {
        while (node.right != null) {
            node = node.right;
        }
        return node;
    }
    private AVLNode<T> insert(T value, AVLNode<T> node) throws DuplicateValueException {
        if (node == null) {
            node = new AVLNode<>(value);
        } else if (value.compareTo(node.value) < 0) {
            node.left = insert(value, node.left);
        } else if (value.compareTo(node.value) > 0) {
            node.right = insert(value, node.right);
        } else {
            throw new DuplicateValueException(""Duplicate value: "" + value);
        }
        node = rebalance(node);
        return node;
    }
    private AVLNode<T> delete(T value, AVLNode<T> node) {
        if (node == null) {
            return null;
        }
        if (node.value == value) {
            if ((node.left == null) && (node.right == null)) {
                node = null;
            } else if (node.left == null) {
                node = node.right;
            } else if (node.right == null) {
                node = node.left;
            } else {
                AVLNode<T> successor = findMin(node.right);
                node.value = successor.value;
                node = delete(successor.value, node);
            }
        } else if (value.compareTo(node.value) < 0) {
            node.left = delete(value, node.left);
        } else {
            node.right = delete(value, node.right);
        }
        node = rebalance(node);
        return node;
    }
    private T find(T key, AVLNode<T> node) {
        if (node == null) {
            return null;
        }
        if (node.value == key) {
            return node.value;
        } else if (key.compareTo(node.value) < 0) {
            return find(key, node.left);
        } else {
            return find(key, node.right);
        }
    }
    private void updateHeight(AVLNode<T> node) {
        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));
    }
    private int getHeight(AVLNode<T> node) {
        return node == null ? -1 : node.height;
    }
    private AVLNode<T> rebalance(AVLNode<T> node) {
        if (node == null) {
            return null;
        }
        updateHeight(node);
        int balance = getHeight(node.right) - getHeight(node.left);
        if (balance == -2) {
            if (getHeight(node.left.left) >= getHeight(node.left.right)) {
                node = rotateRight(node);
            } else {
                node = rotateLeftRight(node);
            }
        } else if (balance == 2) {
            if (getHeight(node.right.right) >= getHeight(node.right.left)) {
                node = rotateLeft(node);
            } else {
                node = rotateRightLeft(node);
            }
        }
        return node;
    }
    private AVLNode<T> rotateLeft(AVLNode<T> node) {
        AVLNode<T> newRoot = node.right;
        node.right = newRoot.left;
        newRoot.left = node;
        updateHeight(node);
        updateHeight(newRoot);
        return newRoot;
    }
    private AVLNode<T> rotateRight(AVLNode<T> node) {
        AVLNode<T> newRoot = node.left;
        node.left = newRoot.right;
        newRoot.right = node;
        node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
        newRoot.height = Math.max(getHeight(newRoot.left), getHeight(newRoot.right)) + 1;
        return newRoot;
    }
    private AVLNode<T> rotateLeftRight(AVLNode<T> node) {
        node.left = rotateLeft(node.left);
        return rotateRight(node);
    }
    private AVLNode<T> rotateRightLeft(AVLNode<T> node) {
        node.right = rotateRight(node.right);
        return rotateLeft(node);
    }
}",0,0,0,0,0,0,0,0,0
264,"def bin_search(item_list,item):
	first = 0
 last = len(item_list)-1
 found = False
 while( first<=last and not found):
		mid = (first + last)/2
  if item_list[mid] == item :
			found = True
  else:
			if item < item_list[mid]:
				last = mid - 1
   else:
				first = mid + 1 
 return found
print bin_search([1,2,3,5,8],6)
print bin_search([1,2,3,5,8],5)",0,0,0,0,0,0,1,0,0
265,"import java.util.*;
class BinarySearch 
{ 
    int binarySearch(int array[], int element) 
    { 
        int left = 0, right = array.length - 1; 
        while (left <= right) 
        { 
            int mid = left + (right - left) / 2; 
            if (array[mid] == element) 
            {
                return mid;
            }
            if (array[mid] < element)
            {
                left = mid + 1;
            }
            else
            {
                right = mid - 1;
            }
        }
        return -1; 
    } 
    public static void main(String args[]) 
    { 
        BinarySearch bs = new BinarySearch();
        Scanner sc = new Scanner(System.in);
        System.out.println(""Enter the number of elements : "");
        int n = sc.nextInt();
        System.out.println(""Enter "" + n + "" elements"");
        int array[] = new int [n];
        for(int i=0;i<n;i++)
        {
            array[i] = sc.nextInt();
        }
        System.out.println(""Enter the element you are searching for : "");
        int element = sc.nextInt(); 
        int result = bs.binarySearch(array, element); 
        if (result == -1) 
            System.out.println(""Element not found""); 
        else
            System.out.println(""Element found at "" + (result+1)); 
        sc.close();
    } 
} ",0,0,0,0,0,0,1,0,0
266,"def contains(arr, value):
    if len(arr) == 1:
        return arr[0] == value
    elif not arr:
        return False
    index = int(len(arr) / 2)
    if arr[index] == value:
        return True
    elif arr[index] < value:
        return contains(arr[index + 1:], value)
    else:
        return contains(arr[:index], value)",0,0,0,0,0,0,1,0,0
267,"package Searching_Algorithm;
import java.util.Scanner;
public class Binary_Search {
     public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          int[] A = new int[10];
          int low, high, Xm, z, mid;
          boolean flag = false;
          low = 0;
          high = A.length - 1;
          z = 51;        
          System.out.println(""Enter 10 int number:"");
          for (int i=0; i<A.length; i++){
              A[i] = scanner.nextInt();
          }
          do {
               mid = (low + high)/2;
               Xm = A[mid];
               if (Xm < z){
                    low = mid + 1;
               }else if (Xm > z){
                    high = high - 1;
               }else {
                    flag = true;
               }
          }while (low <= high && !flag);
          if (flag){
               System.out.println(""Found"");
          }else {
               System.out.println(""Not Found"");
          }
     }
}",0,0,0,0,0,0,1,0,0
268,"from random import randint
def binary_search(array, element):
    left = 0
    right = len(array) - 1
    while left <= right:
        mid = (right + left) // 2
        if array[mid] == element:
            return mid
        elif array[mid] > element:
            right = mid - 1
        else:
            left = mid + 1
    return None
def binary_search_recursive(array, element, left=0, right=None):
    right = len(array) - 1 if right is None else right
    if right >= left:
        mid = (right + left) // 2
        if array[mid] == element:
            return mid
        elif array[mid] > element:
            return binary_search_recursive(array, element, left, mid - 1)
        else:
            return binary_search_recursive(array, element, mid + 1, right)
    else:
        return None
def main():
    size = 100  
    domain = 100  
    array = [1, 9, 11, 13, 5, 7, 8, 5, 17, 1156, 114]
    array.sort()
    element = 13
    result = binary_search_recursive(array, element)
    if result is None:
        print('Recursive Binary Search : Element not present in array')
    else:
        print('Recursive Binary Search : Element is present at index', result)
    result = binary_search(array, element)
    if result is None:
        print('Iterative Binary Search : Element not present in array')
    else:
        print('Iterative Binary Search : Element is present at index', result)
if __name__ == '__main__':
    main()",0,0,0,0,0,0,1,0,0
269,"def binary_search_first_true(predicate, from_inclusive, to_inclusive):
    lo = from_inclusive - 1
    hi = to_inclusive + 1
    while hi - lo > 1:
        mid = (lo + hi) // 2
        if not predicate(mid):
            lo = mid
        else:
            hi = mid
    return hi
def test():
    assert 4 == binary_search_first_true(lambda x: x * x >= 10, 0, 10)
test()",0,0,0,0,0,0,1,0,0
270,"from bisect import bisect_left
def pythonic_binary_search(lis, elem):
    index = bisect_left(lis, elem)
    if index != len(lis) and lis[index] == elem:
        return index
    return -1
def binary_search(lis, elem, start, end):
    assert 0 <= start <= end < len(lis)
    if end == start:
        if lis[start] == elem:
            return start
        return -1
    mid = (start + end) // 2
    mid_elem = lis[mid]
    if mid_elem == elem:
        return mid
    if mid_elem < elem:
        if end > mid:
            return binary_search(lis, elem, mid + 1, end)
        return -1
    if mid_elem > elem:
        if start < mid:
            return binary_search(lis, elem, start, mid - 1)
        return -1
def main():
    lis1 = [1, 2, 3, 4, 6, 7, 9]
    assert binary_search(lis1, 5, 0, 5) == -1
    assert pythonic_binary_search(lis1, 5) == -1
    lis2 = [-1, 0, 1, 5, 6, 9, 15, 15]
    assert pythonic_binary_search(lis2, 15) == 6
    assert binary_search(lis2, 15, 0, 7) != -1  
    lis3 = [-1, 0, 0, 0, 0, 1]
    assert pythonic_binary_search(lis3, 0) == 1
    assert binary_search(lis3, 0, 0, 5) != -1
if __name__ == '__main__':
    main()",0,0,0,0,0,0,1,0,0
271,"def binary_search(arr, key, l=0, r=-1):
    if r == -1:
        r = len(arr) - 1
    if r >= l:
        mid = l + (r - l) // 2
        if arr[mid] == key:
            return mid
        elif arr[mid] > key:
            return binary_search(arr, key, l, mid-1)
        else:
            return binary_search(arr, key, mid+1, r)
    else:
        return -1",0,0,0,0,0,0,1,0,0
272,"from __future__ import print_function
import bisect
try:
    raw_input          
except NameError:
    raw_input = input  
def binary_search(sorted_collection, item):
    left = 0
    right = len(sorted_collection) - 1
    while left <= right:
        midpoint = (left + right) // 2
        current_item = sorted_collection[midpoint]
        if current_item == item:
            return midpoint
        else:
            if item < current_item:
                right = midpoint - 1
            else:
                left = midpoint + 1
    return None
def binary_search_std_lib(sorted_collection, item):
    index = bisect.bisect_left(sorted_collection, item)
    if index != len(sorted_collection) and sorted_collection[index] == item:
        return index
    return None
def binary_search_by_recursion(sorted_collection, item, left, right):
    if (right < left):
        return None
    midpoint = left + (right - left) // 2
    if sorted_collection[midpoint] == item:
        return midpoint
    elif sorted_collection[midpoint] > item:
        return binary_search_by_recursion(sorted_collection, item, left, midpoint-1)
    else:
        return binary_search_by_recursion(sorted_collection, item, midpoint+1, right)
def __assert_sorted(collection):
    if collection != sorted(collection):
        raise ValueError('Collection must be sorted')
    return True
if __name__ == '__main__':
    import sys
    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]
    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be sorted to apply binary search')
    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = binary_search(collection, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')",0,0,0,0,0,0,1,0,0
273,"def binary_search(array, element, start=0, end=0):
    mid = (end - start)//2 + start
    if array[mid] == element:
        return mid
    if start==end:
        return -1
    if array[mid] > element:
        return binary_search(array, element, start, mid-1)
    else:
        return binary_search(array, element, mid+1, end)
    return -1
def main():
    count = int(input())
    array = []
    find = int(input())
    for i in range(count):
        array.append(int(input()))
    print(binary_search(array, find, 0, len(array)-1))
if __name__ == ""__main__"":
    main()",0,0,0,0,0,0,1,0,0
274,"package Algorithm.Searching_Sorting;
import java.util.*; 
import java.lang.*; 
import java.io.*; 
class Binary_search 
{ 
    static int countRotations(int arr[], int low, 
                                       int high) 
    { 
        if (high < low) 
            return 0; 
        if (high == low) 
            return low; 
        int mid = low + (high - low)/2;  
        if (mid < high && arr[mid+1] < arr[mid]) 
            return (mid + 1); 
        if (mid > low && arr[mid] < arr[mid - 1]) 
            return mid; 
        if (arr[high] > arr[mid]) 
            return countRotations(arr, low, mid - 1); 
        return countRotations(arr, mid + 1, high); 
    } 
    public static void main (String[] args)  
    { 
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); 
        int arr[ ]= new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        System.out.println(countRotations(arr, 0, n-1)); 
    } 
}",0,0,0,0,0,0,1,0,0
275,"def binary_search(lst, target):
    first = 0
    last = len(lst) - 1
    while first <= last:
        midpoint = (
            first + last
        ) // 2  
        if lst[midpoint] == target:
            return midpoint
        elif lst[midpoint] < target:
            first = midpoint + 1
        else:
            last = midpoint - 1
    return None
def verify(index):
    if index is not None:
        print(""Target found at index: "", index)
    else:
        print(""Target not found in list"")
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = binary_search(numbers, 12)
verify(result)
result = binary_search(numbers, 6)
verify(result)",0,0,0,0,0,0,1,0,0
276,"class Node(object):
 def __init__(self, data):
		self.data = data
  self.left = None
  self.right = None
class BinarySearchTree(object):
 def __init__(self):
		self.root = None
 def insert(self, data, root):
  if root is None:
			return Node(data)
  elif data <= root.data:
			root.left = self.insert(data, root.left)
  else:
			root.right = self.insert(data, root.right)
  return root
 def inorder(self, node):
  if node is None:
			return
  self.inorder(node.left)
  print (node.data)
  self.inorder(node.right)
def initialize():
 bst = BinarySearchTree()
 bst.root = bst.insert(6, bst.root)
 bst.insert(1, bst.root)
 bst.insert(9, bst.root)
 bst.insert(3, bst.root)
 bst.inorder(bst.root)
 return bst
if __name__ == ""__main__"":
	initialize()",0,0,0,0,0,0,0,0,0
277,"import java.util.Scanner;
import java.lang.Math;
class binarySearch{
	public static void main(String [] args){
		Scanner scan = new Scanner(System.in);
		int [] arr = {1, 5, 2, 4, 1, 2, 5, 9, 7, 0, 3};
		int key = scan.nextInt();
		if (findIt(arr, key)) System.out.print(""here"");
		else System.out.print(""It is not here"");
	}
	static int findIt(int [] arr, int key){
		int a=0, b=arr.length, r=0;
		arr = sort(arr, b);
		while (a <= b){
			r = (a+b)/2;
			if (arr[r] == key) return 1;
			else if (arr[r] > key) b = r-1;
			else if (arr[r] < key) a = r+1;
		}
		return 0;
	}
	static int [] sort(int [] arr, int sizeofArr){
		int temp, gapValue=sizeofArr-2;
		for (int i=gapValue;i>0;i--){
			for (int k=0;k<sizeofArr-i;k++)
				if (arr[k] > arr[k+i]){
					temp = arr[k];
					arr[k] = arr[k+i];
					arr[k+i] = temp;
				}
		}
		return arr;	
	}
}",0,0,0,0,1,0,1,0,0
278,"import java.util.List;
import java.lang.Comparable;
public class BinarySearch<T extends Comparable<T>> implements SearchingAlg<T> {
    @Override
    public int indexOf(List<T> elements, T target) {
        if (elements == null || target == null)
            return NIL;
        return indexOf(elements, target, 0, elements.size() - 1);
    }
    private int indexOf(List<T> elements, T target, int min, int max) {
        if (min <= max) {
            int mid = (max + min) >> 1;
            if (elements.get(mid).equals(target))
                return mid;
            if (isLessThan(elements.get(mid), target))
                return indexOf(elements, target, mid + 1, max);
            return indexOf(elements, target, min, mid - 1);
        }
        return NIL;
    }
    private boolean isLessThan(T first, T second) {
        return (first.compareTo(second) < 0);
    }
    public static void main(String[] args) {
        List<Integer> data = new java.util.ArrayList<Integer>();
        for (int i = 0; i < 100; i++)
            data.add(i);
        SearchingAlg<Integer> alg = new BinarySearch<Integer>();
        for (int i = 0; i < data.size(); i++) {
            int result = alg.indexOf(data, i);
            if (result == NIL)
                throw new java.lang.RuntimeException(""Result shouldn't be NIL"");
            data.remove(new Integer(i));
            result = alg.indexOf(data, i);
            if (result != NIL)
                throw new java.lang.RuntimeException(""Result should be NIL"");
        }
        System.out.println(""All tests passed."");
    }
}",0,0,0,0,0,0,1,0,0
279,"package search;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import static java.lang.String.format;
class BinarySearch implements SearchAlgorithm {
    @Override
    public  <T extends Comparable<T>> int find(T array[], T key) {
        return search(array, key, 0, array.length);
    }
    private <T extends Comparable<T>> int search(T array[], T key, int left, int right){
        if (right < left) return -1;  
        int median = (left + right) >>> 1;
        int comp = key.compareTo(array[median]);
        if (comp < 0) {
            return search(array, key, left, median - 1);
        }
        if (comp > 0) {
            return search(array, key, median + 1, right);
        }
        return median;
    }
    public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);
        Integer shouldBeFound = integers[r.nextInt(size - 1)];
        BinarySearch search = new BinarySearch();
        int atIndex = search.find(integers, shouldBeFound);
        System.out.println(String.format(""Should be found: %d. Found %d at index %d. An array length %d""
                , shouldBeFound, integers[atIndex], atIndex, size));
        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(format(""Found by system method at an index: %d. Is equal: %b"", toCheck, toCheck == atIndex));
    }
}",0,0,0,0,0,0,1,0,0
280,"package searches;
import java.util.Arrays;
public class BinarySearch {
    public static boolean contains(int[] arr, int n) {
        int testIndex = arr.length / 2;
        if(arr[testIndex] == n) {
            return true;
        }
        if (arr.length == 1) {
            return false;
        }
        return n < arr[testIndex] ?
                contains(Arrays.copyOfRange(arr, 0, arr.length / 2), n) :  
                contains(Arrays.copyOfRange(arr, testIndex + 1, arr.length), n);  
    }
}",0,0,0,0,0,0,1,0,0
281,"package rosberglinhares.datastructuresandalgorithms.algorithms.searching;
public class BinarySearch {
    public <T extends Comparable<T>> boolean iterativeBinarySearch(T[] elements, T value) {
        return this.iterativeBinarySearch(elements, 0, elements.length - 1, value);
    }
    public <T extends Comparable<T>> boolean iterativeBinarySearch(T[] elements, int lowerIndex, int upperIndex, T value) {
        while (lowerIndex <= upperIndex) {
            int middleIndex = (lowerIndex + upperIndex) / 2;
            if (value.compareTo(elements[middleIndex]) == 0) {
                return true;
            } else if (value.compareTo(elements[middleIndex]) < 0) {
                upperIndex = middleIndex - 1;
            } else {
                lowerIndex = middleIndex + 1;
            }
        }
        return false;
    }
    public <T extends Comparable<T>> boolean recursiveBinarySearch(T[] elements, T value) {
        return this.recursiveBinarySearch(elements, 0, elements.length - 1, value);
    }
    private <T extends Comparable<T>> boolean recursiveBinarySearch(T[] elements, int lowerIndex, int upperIndex, T value) {
        if (lowerIndex <= upperIndex) {
            int middleIndex = (lowerIndex + upperIndex) / 2;
            if (value.compareTo(elements[middleIndex]) == 0) {
                return true;
            } else if (value.compareTo(elements[middleIndex]) < 0) {
                return this.recursiveBinarySearch(elements, lowerIndex, middleIndex - 1, value);
            } else {
                return this.recursiveBinarySearch(elements, middleIndex + 1, upperIndex, value);
            }
        } else {
            return false;
        }
    }
}",0,0,0,0,0,0,1,0,0
282,"import java.util.Scanner;
public class BinarySearch {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Binary Search Algorithm"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSearchIn = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSearchIn[i] = input.nextInt();
        }
        System.out.println(""Enter number to be searched in an array:"");
        int key = input.nextInt();
        int index = binarySearch(arrayOfIntegersToSearchIn, key);
        if (index == -1) {
            System.out.printf(""Sorry, %d doesn't exist in this array.%n"", key);
        } else {
            System.out.printf(""%d has an index of %d.%n"", key, index);
        }
        input.close();
    }
    public static int binarySearch(int[] input, int target) {
        int[] array = sortArray(input);
        int start = 0;
        int end = array.length - 1;
        while (end >= start) {
            int middle = (start + end) / 2;
            if (array[middle] == target) {
                return middle;
            } else if (array[middle] < target) {
                start = middle + 1;
            } else if (array[middle] > target) {
                end = middle - 1;
            }
        }
        return -1;
    }
    private static int[] sortArray(int[] array) {
        int temp;
        for (int j = 0; j < array.length - 1; j++) {
            for (int i = 0; i < array.length - 1; i++) {
                if (array[i + 1] < array[i]) {
                    temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                }
            }
        }
        return array;
    }
}",0,0,0,0,1,0,1,0,0
283,"package com.jwetherell.algorithms.search;
public class BinarySearch {
    private static final int SWITCH_TO_BRUTE_FORCE = 200;
    private static int[] sorted = null;
    public static final int find(int value, int[] array, boolean optimize) {
        BinarySearch.sorted = array;
        try {
            return recursiveFind(value, 0, BinarySearch.sorted.length - 1, optimize);
        } finally {
            BinarySearch.sorted = null;
        }
    }
    private static int recursiveFind(int value, int start, int end, boolean optimize) {
        if (start == end) {
            int lastValue = sorted[start];  
            if (value == lastValue)
                return start;  
            return Integer.MAX_VALUE;
        }
        final int low = start;
        final int high = end + 1;  
        final int middle = low + ((high - low) / 2);
        final int middleValue = sorted[middle];
        if (value == middleValue)
            return middle;
        if (value > middleValue) {
            if (optimize && (end - middle) <= SWITCH_TO_BRUTE_FORCE)
                return linearSearch(value, middle + 1, end);
            return recursiveFind(value, middle + 1, end, optimize);
        }
        if (optimize && (end - middle) <= SWITCH_TO_BRUTE_FORCE)
            return linearSearch(value, start, middle - 1);
        return recursiveFind(value, start, middle - 1, optimize);
    }
    private static final int linearSearch(int value, int start, int end) {
        for (int i = start; i <= end; i++) {
            int iValue = sorted[i];
            if (value == iValue)
                return i;
        }
        return Integer.MAX_VALUE;
    }
}",0,0,0,0,0,1,1,0,0
284,"import java.io.*;
import java.lang.*;
import java.util.*;
public class Main
{   
    public static void bsearch(int arr[], int start, int end, int num)
    {
        int mid = start + (end-1)/2;
        if(start>end)
         {
        System.out.println(""Number Not Found"");
         }
        else if(arr[mid]==num)
        {
            System.out.println(""Your number found at possition : ""+(mid+1));
        }
        else if(arr[mid]>num)
        {
            end = mid-1;
            bsearch(arr,start,end,num);
        }
        else if(arr[mid]<num)
        {
            start = mid+1;
            bsearch(arr,start,end,num);
        }
    }
	public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(""Enter the size of Array"");
        int n = scanner.nextInt();
        int[] arr = new int[n];
        System.out.println(""Enter an array of "" + n +"" numbers in sorted form to using binary search :"");
        for(int i=0; i<n; i++){
        arr[i] = scanner.nextInt();
    }
        System.out.println(""Enter the number you wants to search \n"");
        int num = scanner.nextInt();
        bsearch(arr, 0, n-1, num);   
	}
}",0,0,0,0,0,0,1,0,0
285,"package Searching;
import java.util.Scanner;
public class BinarySearch {
    private static int binarySearch(int[] array , int target) {
        int n = array.length;
        int low = 0;
        int high = n-1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if(target < array[mid]) {
                high = mid - 1;
            }
            else if(target > array[mid]) {
                low = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i = 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        int target = sc.nextInt();
        int index = binarySearch(array,target);
        System.out.println(index);
    }
}",0,0,0,0,0,0,1,0,0
286,"package com.thecodershub.algorithms;
public class BinarySearch {
	public static <T extends Comparable<T>> int binarySearch(T[] haystack, T needle, int low, int high) {
		if(low > high)
			return -1;
		int mid = (low + high) / 2;
		int comp = haystack[mid].compareTo(needle);
		if(comp < 1)
			return binarySearch(haystack, needle, low, mid - 1);
		if(comp > 1)
			return binarySearch(haystack, needle, mid + 1, high);
		return mid;
	}
	public static int binarySearch(int[] haystack, int needle, int low, int high) {
		if(low > high)
			return -1;
		int mid = (low + high) / 2;
		if(needle < haystack[mid])
			return binarySearch(haystack, needle, low, mid - 1);
		if(needle > haystack[mid])
			return binarySearch(haystack, needle, mid + 1, high);
		return mid;
	}
	public static void testBinarySearch() {
		int[] haystack = {1,2,3,4,5,6,7,8};
		int needle = 3;
		int index = binarySearch(haystack, needle, 0, haystack.length - 1);
		assert index == 2;
		System.out.println(""Index of "" + needle + "" in [1,2,3,4,5,6,7,8]: "" + index);
		needle = 20;
		index = binarySearch(haystack, needle, 0, haystack.length - 1);
		assert index == -1;
		System.out.println(""Index of "" + needle + "" in [1,2,3,4,5,6,7,8]: "" + index);
	}
	public static void main(String... args) {
		testBinarySearch();
	}
}",0,0,0,0,0,0,1,0,0
287,"iterative = function (data, target){
    var start = 0;
    var end = data.length - 1;
    while (start <= end){
        var middle = Math.floor((start + end) / 2);
        if (target < data[middle]){
            end = middle - 1;
        }
        else if (target > data[middle]){
            start = middle + 1;
        }
        else {
            return true;
        }
    }
    return false;
}
recursive = function (data, target, start, end) {
    if (start > end) {
        return false;
    }
    else {
        var middle = Math.floor((start + end) / 2);
        if (target === data[middle]) {
            return true;
        } else if (target < data[middle]) {
            return recursive(data, target, start, middle - 1);
        } else {
            return recursive(data, target, middle + 1, end);
        }
    }
}",0,0,0,0,0,0,1,0,0
288,"def binary(arr, item, l, u):
    if(u>=l):
        mid = u+l//2
        if(arr[mid]==item):
            return(mid+1)
        elif(item<arr[mid]):
            return binary(arr, item, l, mid-1)
        else:
            return binary(arr, item, mid+1, u)
    else:
        return(""-1"")
arr = [1,2,4,5,6,7,8]
it = 8
print(""Found at "", binary(arr, it, 0, len(arr)-1))",0,0,0,0,0,0,1,0,0
289,"package Searching;
import java.util.Arrays;
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {20,35,-15,7,55,1,-22};
        Arrays.sort(arr);
        System.out.println(BinarySearch(arr,-15));
        System.out.println(BinarySearch(arr,22));
        System.out.println(BinarySearch(arr,7));
    }
    public static int BinarySearch(int[] arr,int value){
        int mid = (int) arr.length/2;
        if (value == arr[mid]){
            return mid;
        }
        else if (value>arr[mid]){
            for (int i = mid+1; i < arr.length; i++) {
                if (arr[i] == value){
                    return i;
                }
            }
        }
        else {
            for (int i = 0; i < mid; i++) {
                if (arr[i] == value){
                    return i;
                }
            }
        }
        return -1;
    }
}",0,0,0,0,0,0,1,0,0
290,"package ds.searching;
public class BinarySearch {
    public int binarySearch(int arr[], int l, int r, int x) {
        if (r >= l) {
            int mid = l + (r - l) / 2;
            if (arr[mid] == x)
                return mid;
            if (arr[mid] > x)
                return binarySearch(arr, l, mid - 1, x);
            return binarySearch(arr, mid + 1, r, x);
        }
        return -1;
    }
}",0,0,0,0,0,0,1,0,0
291,"import java.util.Scanner;
public class BinarySearch{
	public int search(int arr[],int item) {
		int N = arr.length;
		int lo=0,hi=N-1;
		while(lo<=hi) {
			int mid = lo + (hi-lo)/2;
			if(arr[mid] == item) {
				return mid;
			}
			else if(item > arr[mid]) {
				lo = mid+1;
			}
			else if(item < arr[mid]) {
				hi = mid-1;
			}
		}
		return -1;	
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		BinarySearch bs = new BinarySearch();
		int[] arr = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38};
		for(int i=0;i<arr.length;i++){
			System.out.print(arr[i] + ""\t"");
		}
		System.out.print(""Enter the item you want to search: "");
		int item = sc.nextInt();
		int result = bs.search(arr, item); 
		if(result==-1) {
			System.out.println(""The item is not present in the array!"");
		}
		else System.out.println(""The item is found at index ""  +result);
	}
}",0,0,0,0,0,0,1,0,0
292,"type num = number;
export default function BinarySearchRecursive(items: num[], element: num): num {
  const middleIndex = Math.floor(items.length / 2);
  if (items.length === 1) return items[0];
  if (items[middleIndex] <= element) {
    return BinarySearchRecursive(
      items.splice(middleIndex, items.length - 1),
      element
    );
  }
  return BinarySearchRecursive(items.splice(0, middleIndex), element);
}
export function BinarySearchIterative(items: num[], element: num): num {
  let low = 0;
  let high = items.length - 1;
  while (low < high) {
    const middle = Math.floor((high + low) / 2);
    const middleElement = items[middle];
    if (middleElement === element) return middle;
    if (middleElement > element) {
      high = middle - 1;
    } else {
      low = middle + 1;
    }
  }
  if (items[low] === element) return low;
  return -1;
}",0,0,0,0,0,0,1,0,0
293,"def binarySearch(inputArray,x):
	if (inputArray[-1] > x):
		mid = len(inputArray)//2 
  if (inputArray[mid] == x): 
			return true    
  if (inputArray[mid] > x): 
			return binarySearch(inputArray[:mid],x)
  return binarySearch(inputArray[mid:],x)
 else:
		return false",0,0,0,0,0,0,1,0,0
294,"public class BinarySearch {
	public static int search(int arr[], int left, int right, int val) {
		if (right >= left) {
			int mid = left + (right - left) / 2;
			if (arr[mid] == val) {
				return mid;
			}
			if (arr[mid] > val) {
				return search(arr, left, mid - 1, val);
			}
			return search(arr, mid + 1, right, val);
		}
		return -1;
	}
}",0,0,0,0,0,0,1,0,0
295,"const binarySearch = (sortedArr, value) => {
  let left = 0;
  let right = sortedArr.length - 1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    const midVal = sortedArr[mid];
    if (midVal === value) {
      return mid;
    } else if (midVal < value) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return -1;
};",0,0,0,0,0,0,1,0,0
296,"package com.aokolnychyi.sorting;
public class BinarySearch {
  public static <T extends Comparable<T>> int findIndexOfElement(T[] array, T targetElement) {
    int lowestElementIndex = 0;
    int highestElementIndex = array.length - 1;
    while (lowestElementIndex <= highestElementIndex) {
      final int middleElementIndex = (lowestElementIndex + highestElementIndex) / 2;
      if (array[middleElementIndex].compareTo(targetElement) < 0) {
        lowestElementIndex = middleElementIndex + 1;
      } else if (array[middleElementIndex].compareTo(targetElement) > 0) {
        highestElementIndex = middleElementIndex - 1;
      } else {
        return middleElementIndex;
      }
    }
    return -1;
  }
  public static void main(String[] args) {
    final Integer[] array1 = new Integer[]{1, 2, 3, 4, 5, 6};
    final Integer[] array2 = new Integer[]{-10, -2, 0, 3, 5};
    final Integer[] array3 = new Integer[]{1};
    final Integer[] array4 = new Integer[]{};
    System.out.println(""Index of 3 in array1: "" + findIndexOfElement(array1, 3));
    System.out.println(""Index of 1 in array1: "" + findIndexOfElement(array1, 1));
    System.out.println(""Index of 6 in array1: "" + findIndexOfElement(array1, 6));
    System.out.println(""Index of 2 in array1: "" + findIndexOfElement(array1, 2));
    System.out.println(""Index of -10 in array2: "" + findIndexOfElement(array2, -10));
    System.out.println(""Index of 0 in array2: "" + findIndexOfElement(array2, 0));
    System.out.println(""Index of 3 in array2: "" + findIndexOfElement(array2, 3));
    System.out.println(""Index of 1 in array3: "" + findIndexOfElement(array3, 1));
    System.out.println(""Index of -2 in array3: "" + findIndexOfElement(array3, -2));
    System.out.println(""Index of 1 in array4: "" + findIndexOfElement(array4, 1));
  }
}",0,0,0,0,0,0,1,0,0
297,"function binarySearch(arr, i) {
    var mid = Math.floor(arr.length / 2);
    if (arr[mid] === i) {
        console.log('match', arr[mid], i);
        return arr[mid];
    } else if (arr[mid] < i && arr.length > 1) {
        binarySearch(arr.splice(mid, Number.MAX_VALUE), i);
    } else if (arr[mid] > i && arr.length > 1) {
        binarySearch(arr.splice(0, mid), i);
    } else {
        console.log('not found', i);
        return -1;
    }
}
var ar=[1,2,3,4,5,6,7,8,9,10];
binarySearch(ar,3);
binarySearch(ar,7);
binarySearch(ar,13);",0,0,0,0,0,0,1,0,0
298,"package com.deepak.algorithms.Searching;
public class BinarySearch {
	public static int performBinarySearch(int[] listOfValues, int targetValue) {
		int index = -1;
		int low = 0;
		int mid;
		int high = listOfValues.length - 1;
		while (high >= low) {
			mid = (high + low)/2;
			if (targetValue < listOfValues[mid]) { 
				high = mid - 1;
			} else if (targetValue > listOfValues[mid]) {
				low = mid + 1;
			} else {
				index = mid;
				break;
			}
		}
		return index;
	}
}",0,0,0,0,0,0,1,0,0
299,"function binarySearch(arr, k) {
  let min = 0
  let max = arr.length - 1
  while (min <= max) {
    const cur = Math.floor((min + max) / 2)
    if (arr[cur] === k) { return cur }
    (arr[cur] > k)
      ? max = cur - 1
      : min = cur + 1
  }
  return -1
}
const arr = [1,2,3,4,5,6,7,8,9,10]
console.log(binarySearch(arr, 6))   
console.log(binarySearch(arr, 9))   
console.log(binarySearch(arr, 2))   
console.log(binarySearch(arr, 7))   
console.log(binarySearch(arr, 11))  
console.log(binarySearch(arr, 3))   
console.log(binarySearch(arr, 3))   
console.log(binarySearch(arr, 3))   ",0,0,0,0,0,0,1,0,0
300,"import java.util.*;
public class Binary {
	int binSearch(int arr[], int target) {
		int low = 0;
		int high = arr.length - 1;
		while (low <= high) {
			int mid = (low + high) / 2;   
			if (arr[mid] == target)
				return mid;
			if (target > arr[mid])       
				low = mid + 1;
			else {
				high = mid - 1;         
			}
		}
		return -1;
	}
	public static void main(String arg[]) {
		Binary b = new Binary();
		int arr[] = { 2, 4, 5, 7, 23, 31, 34, 43, 45 };
		int ans = b.binSearch(arr, 46);
		if (ans == -1)
			System.out.println(""The element is not found"");
		else {
			System.out.println(""Element is found at postion = "" + (ans + 1));
		}
	}
}",0,0,0,0,0,0,1,0,0
301,"def binary_search(l, value):
    low = 0
    high = len(l)-1
    while low <= high: 
        mid = (low+high)//2
        if l[mid] > value: high = mid-1
        elif l[mid] < value: low = mid+1
        else: return mid
    return -1",0,0,0,0,0,0,1,0,0
302,"public class BinarySearch {
    public static int binarySearch(int[] arr, int searchElement) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;  
            if (arr[mid] == searchElement) {  
                return mid;
            }
            if (arr[mid] < searchElement) {  
                left = mid + 1;
            } else {  
                right = mid - 1;
            }
        }
        return -1;         
    }
    public static void main(String[] args) {
        int[] arr = new int[] {1, 5, 35, 112, 258, 324};
        int[] searchArr = new int[] {1, 35, 112, 324, 67};
        int pos;
        for (int i = 0; i < searchArr.length; i++) {
            pos = binarySearch(arr, searchArr[i]);   
            if (pos >= 0) {
                System.out.println(searchArr[i] + ""-> found at index : "" + pos);
            } else {
                System.out.println(searchArr[i] + ""-> not found"");
            }
        }
    }
}",0,0,0,0,0,0,1,0,0
303,"function binarySearchIterative (arr, item) {
	let begin = 0;
	let end = arr.length - 1;
	while (begin <= end) {
		let mid = Math.floor((begin + end) / 2);
		if (arr[mid] === item) {
			return mid;
		} else if (arr[mid] > item) {
			end = mid - 1;
		} else {
			begin = mid + 1;
		}
	}
	return -1;
}
function binarySearchRecursive (arr, item, begin, end) {
	if (begin <= end) {
		let mid = Math.floor((begin + end) / 2);
		if (arr[mid] === item) {
			return mid;
		} else if (arr[mid] > item) {
			return binarySearchRecursive(arr, item, begin, mid - 1);
		} else {
			return binarySearchRecursive(arr, item, mid + 1, end);
		}
	} else {
		return -1;
	}
}
function main () {
	let arr = [2, 5, 6, 7, 8, 9, 10];
	let item = 5;
	if (binarySearchIterative(arr, item) === -1) {
		console.log('Element is not found');
	} else {
		console.log('Element is found');
	}
	if (binarySearchRecursive(arr, item, 0, arr.length - 1) === -1) {
		console.log('Element is not found');
	} else {
		console.log('Element is found');
	}
}
main();",0,0,0,0,0,0,1,0,0
304,"def binarySearch(arr, l, r, x): 
    if r >= l: 
        mid = l + (r - l) // 2
        if arr[mid] == x: 
            return mid 
        elif arr[mid] > x: 
            return binarySearch(arr, l, mid-1, x) 
        else: 
            return binarySearch(arr, mid + 1, r, x) 
    else: 
        return -1
if __name__=='__main__':
    lst = []
    n = int(input(""Enter numbers of elements:""))
    print(""Enter numbers in ascending order"")
    for i in range(0,n):
        ele=int(input())
        lst.append(ele)
    num = int(input(""Enter number to search:"")) 
    result = binarySearch(lst, 0, len(lst)-1, num) 
    if result != -1: 
        print (""Element is present at index % d"" % result) 
    else: 
        print (""Element is not present in array"") ",0,0,0,0,0,0,1,0,0
305,"import unittest
def BinarySearch(arr, key):
    lo, hi = 0, len(arr)-1
    while lo <= hi:
        mi = (lo+hi)>>1  
        if key < arr[mi]:
           hi = mi - 1
        elif key > arr[mi]:
           lo = mi + 1
        else:
           return mi
    return -1  
class BinarySearchTest(unittest.TestCase):
      def test_basic(self):
          arr = [1,2,3,4,5,6,7,8,9]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, n), n - 1) 
      def test_missing(self):
          arr = [1,2,3,4,5,6,7,8,9]
          self.assertEquals(BinarySearch(arr, 19), -1) 
      def test_odd(self):
          arr = [2,4,6,8,10,12,14]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, n), i) 
      def test_even(self):
          arr = [1,3,5,7,9,11,13,17]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, n), i) 
      def test_empty(self):
          arr = []
          self.assertEquals(BinarySearch(arr, 19), -1) 
if __name__ == '__main__':
    unittest.main()  ",0,0,0,0,0,0,1,0,0
306,"import unittest
def BinarySearch(arr, key):
    if len(arr) == 0:
        return False
    else:
        mi = len(arr)//2
        if key == arr[ mi ]:
           return True
        else:
            if key < arr[ mi ]:
               return BinarySearch(arr[:mi], key)
            else:
               return BinarySearch(arr[mi+1:], key)
class BinarySearchTest(unittest.TestCase):
      def test_basic(self):
          arr = [1,2,3,4,5,6,7,8,9]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, n), True) 
      def test_missing(self):
          arr = [1,2,3,4,5,6,7,8,9]
          self.assertEquals(BinarySearch(arr, 19), False) 
      def test_odd(self):
          arr = [2,4,6,8,10,12,14]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, n), True) 
      def test_even(self):
          arr = [1,3,5,7,9,11,13,17]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, n), True) 
      def test_empty(self):
          arr = []
          self.assertEquals(BinarySearch(arr, 19), False) 
if __name__ == '__main__':
   unittest.main()  ",0,0,0,0,0,0,1,0,0
307,"import unittest
def BinarySearch(arr, lo, hi, key):
    if lo > hi:
       return -1
    mi = (lo+hi)>>1  
    if key == arr[ mi ]:
       return mi
    if key < arr[mi]:
       return BinarySearch(arr, lo, mi - 1, key)
    else:
       return BinarySearch(arr, mi + 1, hi, key) 
class BinarySearchTest(unittest.TestCase):
      def test_basic(self):
          arr = [1,2,3,4,5,6,7,8,9]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, 0, len(arr) - 1, n), i) 
      def test_missing(self):
          arr = [1,2,3,4,5,6,7,8,9]
          self.assertEquals(BinarySearch(arr,  0, len(arr) - 1, 19), -1) 
      def test_odd(self):
          arr = [2,4,6,8,10,12,14]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr, 0, len(arr) - 1, n), i) 
      def test_even(self):
          arr = [1,3,5,7,9,11,13,17]
          for i, n in enumerate(arr):
              self.assertEquals(BinarySearch(arr,  0, len(arr) - 1, n), i) 
      def test_empty(self):
          arr = []
          self.assertEquals(BinarySearch(arr,  0, len(arr) - 1, 19), -1) 
if __name__ == '__main__':
   unittest.main()  ",0,0,0,0,0,0,1,0,0
308,"class BinarySearchIterative {
    public int binarySearch(int[] arr, int target) {
        int index = -1;
        int low = 0;
        int high = arr.length - 1;
        while(low <= high) {
            int mid = low + (high - low)/2;
            if( arr[mid] == target ){
                index = mid;
            } else if( arr[mid] < target ) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return index;
    }
    public static void main(String args[]) 
    {  
        BinarySearchIterative object = new BinarySearchIterative();
        int arr[] = { 2, 3, 4, 10, 40 }; 
        int target = 3; 
        int index = object.binarySearch(arr, target);
        if (index == -1) 
            System.out.println(""Element not present""); 
        else
            System.out.println(""Element found at index "" + index); 
    } 
}",0,0,0,0,0,0,1,0,0
309,"import java.util.Arrays;
public class BinarySearchRecursion {
    public int binarySearch(int[] arr, int low, int high, int target) {
        while(low <= high) {
            int mid = low + (high - low)/2;
            if(arr[mid] == target) {
                return mid;
            } else if(arr[mid] < target) {
                return binarySearch(arr, mid + 1, high, target);
            } else {
                return binarySearch(arr, low, mid - 1, target);
            }
        }
        return -1;
    }
    public static void main(String args[]) 
    { 
        BinarySearchRecursion ob = new BinarySearchRecursion(); 
        int arr[] = { 10, 40, 167, 55, 32, 98, 100 }; 
        Arrays.sort(arr);
        int n = arr.length; 
        int x = 100; 
        int result = ob.binarySearch(arr, 0, n - 1, x); 
        if (result == -1) 
            System.out.println(""Element not present""); 
        else
            System.out.println(""Element found at Index "" + result); 
    } 
}",0,0,0,0,0,0,1,0,0
310,"import java.util.Scanner;
public class BinarySearchRecursive {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Binary Search Algorithm with recursion"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSearchIn = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSearchIn[i] = input.nextInt();
        }
        System.out.println(""Enter number to be searched in an array:"");
        int key = input.nextInt();
        int index = recursiveBinarySearch(arrayOfIntegersToSearchIn, key);
        if (index == -1) {
            System.out.printf(""Sorry, %d doesn't exist in this array.%n"", key);
        } else {
            System.out.printf(""%d has an index of %d.%n"", key, index);
        }
        input.close();
    }
    public static int recursiveBinarySearch(int[] input, int key) {
        input = sortArray(input);
        return binarySearch(input, 0, input.length - 1, key);
    }
    private static int[] sortArray(int[] array) {
        int temp;
        for (int j = 0; j < array.length - 1; j++) {
            for (int i = 0; i < array.length - 1; i++) {
                if (array[i + 1] < array[i]) {
                    temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                }
            }
        }
        return array;
    }
    private static int binarySearch(int[] array, int start, int end, int target){
        int middle = (start + end) / 2;
        if (end < start) {
            return -1;
        }
        if (target == array[middle]) {
            return middle;
        } else if (target < array[middle]) {
            return binarySearch(array, start, middle - 1, target);
        } else {
            return binarySearch(array, middle + 1, end, target);
        }
    }
}",0,0,0,0,1,0,1,0,0
311,"public class BinarySearchRecursive {
    public static int binarySearch(int[] arr, int toSearch, int start, int end) {
        if (end < start) {
            return -1;
        }
        int mid = (start + end) / 2;
        if (arr[mid] > toSearch) {
            return binarySearch(arr, toSearch, start, mid - 1);
        } else if (arr[mid] < toSearch) {
            return binarySearch(arr, toSearch, mid + 1, end);
        }
        return mid;
    }
    public static void main(String[] args) {
        int[] arr = {1, 5, 6, 7, 8, 11};
        int toSearch = 8;
        int index = binarySearch(arr, toSearch, 0, arr.length);
        if (index == -1) {
            System.out.println(toSearch + "" not found"");
        } else {
            System.out.println(toSearch + "" found at index "" + index);
        }
    }
}",0,0,0,0,0,0,1,0,0
312,"public class BinarySearchRecursive {
	public static int binarySearch(int[] array, int low, int high, int element) {
		if (low > high) { return -1; } 
		int mid = (high - low) / 2 + low;
		if (element < array[mid]) {
			return binarySearch(array, low, mid - 1, element);
		} else if (element > array[mid]) {
			return binarySearch(array, mid + 1, high, element);
		} else { return mid; }
	}
	public static void main(String[] args) {
		final int[] sortedArray = { -2, -1, 0, 1, 2 };
		for (int i = -5; i <= 5; i++) {
			int pos = binarySearch(sortedArray, 0, sortedArray.length - 1, i);
			System.out.println(
					""Searching for item "" + i + "": "" + (pos == -1 ? ""Item not found"" : (""Item found at position "" + pos)));
		}
	}
}",0,0,0,0,0,0,1,0,0
313,"package Searching;
import java.util.Arrays;
public class BinarySearchRecursively {
    public static void main(String[] args) {
        int[] arr = {20,35,-15,7,55,1,-22};
        Arrays.sort(arr);
        System.out.println(BinarySearch(arr,-15));
        System.out.println(BinarySearch(arr,22));
        System.out.println(BinarySearch(arr,7));
    }
    public static int BinarySearch(int[] arr,int value) {
        return RBinarySearch(arr,0,arr.length,value);
    }
    public static int RBinarySearch(int[] arr,int start,int end,int value){
        if (start>=end){
            return -1;
        }
        int mid = (start+end)/2;
        if (arr[mid] == value){
            return mid;
        }
        else if(arr[mid]<value){
            return RBinarySearch(arr,mid+1,end,value);
        }
        else {
            return RBinarySearch(arr,0,mid,value);
        }
    }
}",0,0,0,0,0,0,1,0,0
314,"package searching;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
import fundamentals.Bag;
public class BinarySearchST<Key extends Comparable<Key>, Value> {
  private Key[] keys;
  private Value[] vals;
  private int N;
  public BinarySearchST(int capacity) { 
    keys = (Key[]) new Comparable[capacity];
    vals = (Value[]) new Object[capacity];
  }
  public int size() { 
    return N; 
  }
  public boolean isEmpty() {
    return N == 0;
  }
  public Value get(Key key) {
    if (isEmpty()) return null;
    int i = rank(key);
    if (i < N && keys[i].compareTo(key) == 0) return vals[i];
    else return null;
  }
  public int rank(Key key) {
    int lo = 0, hi = N-1;
    while (lo <= hi) {
      int mid = lo + (hi - lo) / 2;
      int cmp = key.compareTo(keys[mid]);  
      if (cmp < 0) hi = mid - 1;
      else if (cmp > 0) lo = mid + 1;
      else return mid;
    }
    return lo;
  }
  public void put(Key key, Value val) { 
    int i = rank(key);
    if (i < N && keys[i].compareTo(key) == 0) {  
      vals[i] = val; return; 
    }
    for (int j = N; j > i; j--) { 
      keys[j] = keys[j-1]; vals[j] = vals[j-1];  
    }
    keys[i] = key; vals[i] = val;  
    N++;
  }
  public Iterable<Key> keys() {
    Bag<Key> stkeys = new Bag<Key>();
    int lo = 0, hi = N - 1;
    for (int i = lo; i < hi; i++)
      stkeys.add(keys[i]);;
    return stkeys;
  }
  public static void main(String[] args) {
    BinarySearchST<String, Integer> st = new BinarySearchST<String, Integer>(30);
    for (int i = 0; !StdIn.isEmpty(); i++) {
        String key = StdIn.readString();
        st.put(key, i);
    }
    for (String s : st.keys())
        StdOut.println(s + "" "" + st.get(s));
	}
}",0,0,0,0,0,0,0,0,0
315,"package com.namesny.binarysearchtree;
public interface BinarySearchTree<T extends Comparable<? super T>>{
    public void insert(T value) throws DuplicateValueException;
    public void delete(T key);
    public T find(T key);
    public void clear();
    public boolean isEmpty();
    public T findMin();
    public T findMax();
}",0,0,0,0,0,0,0,0,0
316,"package searching;
import fundamentals.Queue;
public class BinarySearchTree<Key extends Comparable<Key>, Value> {
  private Node root;  
  private class Node {
    private Key key;  
    private Value val;  
    private Node left, right;  
    private int N;  
    public Node(Key key, Value val, int N)  { 
      this.key = key; this.val = val; this.N = N; 
    }
  }
  public int size() { 
    return size(root); 
  }
  private int size(Node x) {
    if (x == null) return 0;
    else return x.N;
  }
  public Value get(Key key) { 
    return get(root, key); 
  }
  private Value get(Node x, Key key) { 
    if (x == null) return null;
    int cmp = key.compareTo(x.key);  
    if (cmp < 0) return get(x.left, key);
    else if (cmp > 0) return get(x.right, key);
    else return x.val;
  }
  public void put(Key key, Value val) { 
    root = put(root, key, val);
  }
  private Node put(Node x, Key key, Value val) {
    if (x == null) return new Node(key, val, 1);
    int cmp = key.compareTo(x.key);  
    if (cmp < 0) x.left = put(x.left, key, val);
    else if (cmp > 0) x.right = put(x.right, key, val);
    else x.val = val;
    x.N = size(x.left) + size(x.right) + 1;
    return x;
  }
  public boolean contains(Key key) {
    return get(key) != null;
  }
  public void delete(Key key) { 
    root = delete(root, key); 
  }
  private Node delete(Node x, Key key) {
    if (x == null) return null;
    int cmp = key.compareTo(x.key);
    if (cmp < 0) x.left = delete(x.left, key);
    else if (cmp > 0) x.right = delete(x.right, key);
    else {
      if (x.right == null) return x.left;
      if (x.left == null) return x.right;
      Node t = x;
      x = min(t.right); 
      x.right = deleteMin(t.right);
      x.left = t.left;
    }
    x.N = size(x.left) + size(x.right) + 1;
    return x;
  }
   public Key min() {
     return min(root).key;
   }
   private Node min(Node root) {
     Node minNode = root;
     for (Node x = root; x != null; x = x.left)
       minNode = x;
     return minNode;
   }
  public void deleteMin() {
    root = deleteMin(root);
  }
  private Node deleteMin(Node x) {
    if (x.left == null) return x.right;
    x.left = deleteMin(x.left);
    x.N = size(x.left) + size(x.right) + 1;
    return x;
  }
  public Key max() {
    return max(root).key;
  }
  private Node max(Node root) {
    Node maxNode = root;
    for (Node x = root; x != null; x = x.right)
      maxNode = x;
    return maxNode;
  }
  public void deleteMax() {
    root = deleteMax(root);
  }
  private Node deleteMax(Node x) {
    if (x.right == null) return x.left;
    x.right = deleteMax(x.right);
    x.N = size(x.left) + size(x.right) + 1;
    return x;
  }
  public Iterable<Key> keys() { 
    return keys(min(), max()); 
  }
  public Iterable<Key> keys(Key lo, Key hi) {
    Queue<Key> queue = new Queue<Key>();
    keys(root, queue, lo, hi);
    return queue;
  }
  private void keys(Node x, Queue<Key> queue, Key lo, Key hi) {
    if (x == null) return;
    int cmplo = lo.compareTo(x.key);
    int cmphi = hi.compareTo(x.key);
    if (cmplo < 0) keys(x.left, queue, lo, hi);
    if (cmplo <= 0 && cmphi >= 0) queue.enqueue(x.key);
    if (cmphi > 0) keys(x.right, queue, lo, hi);
  }
  public void print() {
    print(root);
  }
  private void print(Node x) {
    if (x == null) return;
    print(x.left);
    System.out.print(x.key);
    print(x.right);
  }
  public static void main(String[] args) {
    BinarySearchTree<String, Integer> bst = new BinarySearchTree<String, Integer>();
    String [] keys = {""S"", ""E"", ""A"", ""R"", ""C"", ""H"", ""E"", ""X"", ""A"", ""M"", ""P"", ""L"", ""E""};
    for (int i = 0; i < keys.length; i++) 
      bst.put(keys[i], i);
    for (String x: bst.keys())
      System.out.print(x);
    System.out.println(""\nMinimum key: "" + bst.min());
    bst.deleteMin();
    System.out.println(""Minimum key: "" + bst.min());
    System.out.println(""Maximum key: "" + bst.max());
    bst.deleteMax();;
    System.out.println(""Maximum key: "" + bst.max());
    bst.delete(""M"");
    for (String x: bst.keys())
      System.out.print(x);
  }
}",0,0,0,0,0,0,0,0,0
317,"import java.util.NoSuchElementException;
class Node {	 
    public int data;
    public Node left;
    public Node right;
    public Node(int data) {	 
        this.data = data;
        this.left = null;
        this.right = null;
    }
}
class BST {
    private Node root;	 
    public BST() {	 
        root = null;
    }
    public BST(int data) {	 
        root = new Node(data);
    }
    public void insert(int data) {
        if (root == null) {
            root = new Node(data);	 
            return;
        }
        Node newNode = new Node(data);	 
        Node iterator = root;	 
        Node parent = null;	 
        while (iterator != null) {
            parent = iterator;
            if (data <= iterator.data) {
                iterator = iterator.left;
            }
            else {
                iterator = iterator.right;
            }
        }
        if (data <= parent.data) {
            parent.left = newNode;
        }
        else {
            parent.right = newNode;
        }
    }
    public Node search(int data) {	 
        Node iterator = root;
        while (iterator != null) {
            if (iterator.data == data)
                return iterator;
            else if (data <= iterator.data)
                iterator = iterator.left;
            else
                iterator = iterator.right;
        }
        throw new NoSuchElementException(""Element is not found in BST"");
    }
    public boolean delete(int data) {	 
        if (root == null) {
            throw new NoSuchElementException(""Cannot perform delete operation, BST is empty"");
        }
        Node iterator = root;
        Node parent = null;
        while (iterator != null) {
            if (data == iterator.data) {
                return deleteNode(data, parent);
            } else  {
                parent = iterator;
                if (data <= iterator.data)
                    iterator = iterator.left;
                else
                    iterator = iterator.right;
            }
        }
        throw new NoSuchElementException(""Delete Unsuccessful! Element was not found in BST"");
    }
    private boolean deleteNode(int data, Node parent) {
        Node child = null;
        boolean position = false;	 
        if (data <= parent.data) {
            child = parent.left;
            position = true;
        }
        else
            child = parent.right;
        if (child.left == child.right) {	 
            child = null;
            if (position)
                parent.left = null;
            else
                parent.right = null;
            return true;
        } else if (child.right == null) {	 
            if (position)
                parent.left = child.left;
            else
                parent.right = child.left;
            child.left = null;
            child = null;
            return true;
        } else if (child.left == null) {	 
            if (position)
                parent.left = child.right;
            else
                parent.right = child.right;
            child.right = null;
            child = null;
            return true;
        }
        else {	 
            Node iterator = child.right;
            Node parentOfIterator = null;
            while(iterator.left != null) {	 
                parentOfIterator = iterator;
                iterator = iterator.left;
            }
            child.data = iterator.data;
            parentOfIterator.left = null;
            iterator = null;
            return true;
        }
    }
    public void printInOrder() {	 
        if (root == null)
            throw new NoSuchElementException(""Cannot print! BST is empty"");
        print(root);
        System.out.println("""");
    }
    private void print(Node iterator) {
        if (iterator != null) {
            print(iterator.left);
            System.out.print(iterator.data + "" "");
            print(iterator.right);
        }
    }
}
public class BinarySearchTree {
    public static void main(String[] args) {
        BST tree = new BST();
        tree.insert(10);
        tree.insert(9);
        tree.insert(3);
        tree.insert(12);
        tree.insert(14);
        tree.insert(7);
        tree.insert(6);
        tree.insert(11);
        tree.insert(1);
        tree.insert(2);
        tree.printInOrder();
        tree.delete(9);
        tree.printInOrder();
        try {
            tree.search(4);
            System.out.println(""Node was found successfully."");
        } catch (NoSuchElementException e) {
            System.out.println(""Invalid Search"");
        }
        try {
            tree.delete(9);
        } catch (NoSuchElementException  e) {
            System.out.println(""Cannot delete, Node not present."");
        }
    }
}",0,0,0,0,0,0,0,0,0
318,"function Node(data) {
    this.data = data;
    this.left = null;
    this.right = null;
}
class BinarySearchTree {
    constructor() {
        this.root = null;
    }
    add(data) {
        const node = new Node(data);
        if (!this.root) {
            this.root = node;
        } else {
            this.insertNode(node)
        }
    }
    insertNode(node) {
        let current = this.root;
        while (current) {
            if (node.data < current.data) {
                if (!current.left) {
                    current.left = node;
                    break;
                }
                current = current.left
            } else if (node.data > current.data) {
                if (!current.right) {
                    current.right = node;
                    break;
                }
                current = current.right;
            } else
                break;
        }
    }
    remove(data) {
        this.root = this.removeNode(this.root, data);
    }
    removeNode(node, data) {
        if (!node) {
            return null;
        }
        if (data === node.data) {
            if (!node.left && !node.right) {
                return null
            }
            if (!node.left) {
                return node.right;
            }
            if (!node.right) {
                return node.left;
            }
            const temp = this.getMin(node.right);
            node.data = temp;
            node.right = this.removeNode(node.right, temp);
            return node;
        } else if (data < node.data) {
            node.left = this.removeNode(node.left, data);
            return node;
        } else {
            node.right = this.removeNode(node.right, data);
            return node;
        }
    }
    getMin(node) {
        if (!node) {
            node = this.root;
        }
        while (node.left) {
            node = node.left;
        }
        return node.data;
    }
    preOrder(node, fn) {
        if (node) {
            if (fn) {
                fn(node);
            }
            this.preOrder(node.left, fn);
            this.preOrder(node.right, fn);
        }
    }
    traverseDFS(cb, method) {
        const current = this.root;
        if (method) {
            this[`${method}`](current, cb);
        } else {
            this.preOrder(current, cb);
        }
    }
    printDFS() {
        this.traverseDFS((node) => {
            console.log(
                `Node.data: ${node.data}`,
                `Node.left: ${node.left ? node.left.data : null}`,
                `Node.right: ${node.right ? node.right.data : null}`
            )
        })
    }
}
(function test() {
    let tree = new BinarySearchTree()
    tree.add(5)
    tree.add(3)
    tree.add(1)
    tree.add(4)
    tree.add(7)
    tree.add(6)
    tree.add(9)
    tree.printDFS();
})()",0,0,0,0,0,0,0,0,0
319,"class Node(object):
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
def insert(node, data):
    if node is None:
        node = Node(data)
        return node
    else:
        if data <= node.data:
            node.left = insert(node.left, data)
        else:
            node.right = insert(node.right, data)
    return node
def search(node, data):
    if node is None:
        return None
    if data < node.data:
        node = search(node.left, data)
    elif data > node.data:
        node = search(node.right, data)
    elif data == node.data:
        return node
    return node
def minright(node):
    if node.left is None:
        return node
    else:
        node = minright(node.left)
    return node
def delete(root, data):
    if root is None:
        return root
    if data < root.data:
        root.left = delete(root.left, data)
    elif data > root.data:
        root.right = delete(root.right, data)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        temp = minright(root.right)
        root.data = temp.data
        root.right = delete(root.right, temp.data)
    return root
def inorder(root):
    if root is not None:
        inorder(root.left)
        print(root.data)
        inorder(root.right)
def preorder(root):
    if root is not None:
        print(root.data)
        preorder(root.left)
        preorder(root.right)
def postorder(root):
    if root is not None:
        preorder(root.left)
        preorder(root.right)
        print(root.data)
def main():
    root = None
    root = insert(root, 5)
    root = insert(root, 11)
    root = insert(root, 3)
    root = insert(root, 1)
    root = insert(root, 50)
    root = insert(root, 45)
    root = insert(root, 30)
    root = insert(root, 35)
    print(""****** InOrder ******"")
    inorder(root)
    print(""****** PreOrder ******"")
    preorder(root)
    print(""****** PostOrder ******"")
    postorder(root)
    print(""***** search Node ******"")
    temp = search(root, 28)
    if temp is not None:
        print(""node search==> "", temp.data)
    else:
        print(""node is not present"")
    print(""***** delete Node ******"")
    root = delete(root, 11)
    inorder(root)
if __name__ == '__main__':
    main()",0,0,0,0,0,0,0,0,0
320,"public class binarySearch{
	public static boolean search(int[] inputArray, int x){
		if (x > inputArray[inputArray.length-1] ){
			int mid = inputArray.length/2;
			if (inputArray[mid] == x){
				return true;
			}if (inputArray[mid]>x){
				return search(Arrays.copyOfRange(inputArray,0,mid),x);
			}
			return search(Arrays.copyOfRange(inputArray,mid,inputArray[inputArray.length-1]),x);
		}
	}
}",0,0,0,0,0,0,1,0,0
321,"__author__ = ""streethacker""
def binarySearch(theRef, target):
    low, high = 0, len(theRef) - 1
    while low <= high:
        mid = (low + high) / 2
        if theRef[mid] == target:
            return mid
        elif target < theRef[mid]:
            high = mid - 1
        else:
            low = mid + 1
    return None
if __name__ == ""__main__"":
    case1 = [1, 2, 3, 10, 12, 22, 89, 100]
    case2 = [3, 10, 22, 23, 77, 87, 90, 101]
    case3 = [0, 1, 5, 7, 10, 33, 42, 56]
    case4 = [10, 10, 22, 29, 54, 77, 90, 100]
    print ""The target index of case1 is: %s"" % binarySearch(case1, 10)
    print ""The target index of case2 is: %s"" % binarySearch(case2, 10)
    print ""The target index of case3 is: %s"" % binarySearch(case3, 10)
    print ""The target index of case4 is: %s"" % binarySearch(case4, 10)",0,0,0,0,0,0,1,0,0
322,"function binarySearch (list, value) {
    let start = 0
    let stop = list.length - 1
    let middle = Math.floor((start + stop) / 2)
    while (list[middle] !== value && start < stop) {
      if (value < list[middle]) {
        stop = middle - 1
      } else {
        start = middle + 1
      }
      middle = Math.floor((start + stop) / 2)
    }
    return (list[middle] !== value) ? -1 : middle
  }
  const list = [2, 5, 8, 9, 13, 45, 67, 99]
  console.log(binarySearch(list, 99))  ",0,0,0,0,0,0,1,0,0
323,"def binarySearch(what,arr):
    li = 0
    ls = len(arr)-1
    while li<=ls:
          middle = (li+ls)/2
          if(what == arr[middle]):
             return middle
          elif what > arr[middle]:
             li = middle + 1
          else:
             ls = middle - 1
    return False
def binarySearchRec(what,li,ls,arr):
    if li>ls:
       return False
    middle = (li+ls)/2
    if what == arr[middle]:
       return middle
    elif what > arr[middle]:
       return binarySearchRec(what,middle+1,ls,arr)
    else:
       return binarySearchRec(what,li,middle-1,arr) 
def searchbin(arr, x):
    return _searchbin(arr, x, 0, len(arr)-1)
def _searchbin(arr, x, li, ls):
    if li>ls: 
       return -1
    m = (li+ls)/2
    if x == arr[m]:
       return m 
    if x > arr[m]: 
       return _searchbin(arr,x,m+1,ls)
    if x < arr[m]: 
       return _searchbin(arr,x,li,m-1)    
if __name__ == ""__main__"":
     arr = [1,2,3,4,5,6,7]
     search = 3
     print binarySearch(2,arr)
     print binarySearchRec(22,0,len(arr)-1,arr)
     print arr
     print 'I am searching...:', search
     print 'Position:', searchbin(arr,search)",0,0,0,0,0,0,1,0,0
324,"from TreeNode import *
from BaseTree import *
class BST(Tree):
    def insert_helper(self, node, val):
        if not node:
            node = Node(val)
            return node
        if val < node.val:
            node.left = self.insert_helper(node.left, val)
        elif val > node.val:
            node.right = self.insert_helper(node.right, val)
        return node
    def insert(self, val):
        self.root = self.insert_helper(self.root, val)",0,0,0,0,0,0,0,0,0
325,"import java.util.*;
public class Dijkstra {
    public static Integer[] dijkstra(int[][] adj, int source) {
        int n = adj.length;
        Integer[] dist = new Integer[n];
        boolean[] visited = new boolean[n];
        PriorityQueue<Node> pq = new PriorityQueue<>(n, new NodeComparator());
        for (int i = 0; i < n; i++) {
            dist[i] = Integer.MAX_VALUE;
        }
        dist[source] = 0;
        pq.add(new Node(source, 0));
        while (!pq.isEmpty()) {
            Node min = pq.poll();
            visited[min.node] = true;
            if (dist[min.node] == Integer.MAX_VALUE) break;
            for (int j = 0; j < n; j++) {
                if (adj[min.node][j] != 0) {
                    int possibleDist = dist[min.node] + adj[min.node][j];
                    if (possibleDist < dist[j]) {
                        dist[j] = possibleDist;
                        if (!visited[j])
                            pq.add(new Node(j, possibleDist));
                    }
                }
            }
        }
        return dist;
    }
    private static Integer[] dijkn2(int[][] adj, int source) {
        int n = adj.length;
        boolean[] visited = new boolean[n];
        Integer[] distance = new Integer[n];
        Arrays.fill(distance, Integer.MAX_VALUE);
        distance[source] = 0;
        for (int ia = 0; ia < n; ia++) {
            int curr = Integer.MAX_VALUE; 
            int index = 0;
            for (int i = 0; i < distance.length; i++) {
                if (distance[i] < curr && !visited[i]) {
                    curr = distance[i];
                    index = i;
                }
            }
            int[] adjToCurr = new int[n];  
            for (int j = 0; j < adj[index].length; j++) { 
                if (adj[index][j] != 0) {
                    adjToCurr[j] = adj[index][j];
                }
            }
            for (int b = 0; b < adjToCurr.length; b++) { 
                if (adjToCurr[b] != 0) {
                    int idx = b;
                    int dist = adjToCurr[b];
                    distance[idx] = Math.min(distance[idx], dist + distance[index]);
                }
            }
            visited[index] = true;
        }
        return distance;
    }
    private static class Node {
        public int node;
        public int cost;
        public Node(int node, int cost) {
            this.node = node;
            this.cost = cost;
        }
    }
    private static class NodeComparator implements Comparator<Node> {
        @Override
        public int compare(Node node1, Node node2) {
            return node1.cost - node2.cost;
        }
    }
}",0,0,0,0,0,0,0,0,0
326,"package com.namesny.binarysearchtree;
public class DuplicateValueException extends Exception{
    public DuplicateValueException(String message) {
        super(message);
    }
}",0,0,0,0,0,0,0,0,0
327,"from algorithm_collection.search import binary_search
def exponential_search(arr, key):
    n = len(arr)
    if arr[0] == key:
        return 0
    i = 1
    while i < n and arr[i] <= key:
        i = i * 2
    return binary_search(arr, key, i // 2, min(i, n-1))",0,0,0,0,0,0,0,0,0
328,"public class FenwickTree {
    private int[] values;
    public FenwickTree(int size) {
        this.values = new int[size];
    }
    public void add(int idx, int k) { 
        while (idx < values.length) {
            values[idx] += k;
            idx += _lsb(idx);
        }
    } 
    public int sumTo(int idx) { 
        int sum = 0;
        while (idx > 0) {
            sum += values[idx];
            idx -= _lsb(idx);
        }
        return sum;
    }
    private int _lsb(int i) { 
        return i & -i;
    }
}",0,0,0,0,0,0,0,0,0
329,"def fibonacci_search(arr, key):
    n = len(arr)
    fibMMm2 = 0
    fibMMm1 = 1
    fibM = fibMMm2 + fibMMm1
    while fibM < n:
        fibMMm2 = fibMMm1
        fibMMm1 = fibM
        fibM = fibMMm2 + fibMMm1
    offset = -1
    while fibM > 1:
        i = min(offset+fibMMm2, n-1)
        if (arr[i] < key):
            fibM = fibMMm1
            fibMMm1 = fibMMm2
            fibMMm2 = fibM - fibMMm1
            offset = i
        elif (arr[i] > key):
            fibM = fibMMm2
            fibMMm1 = fibMMm1 - fibMMm2
            fibMMm2 = fibM - fibMMm1
        else:
            return i
    if fibMMm1 and arr[n-1] == key:
        return n-1
    return -1",0,0,0,0,0,0,0,0,0
330,"package Searching;
import java.util.Scanner;
public class FirstOccurrence {
   private static int firstOccurrence(int[] array , int target) {
        int n = array.length;
        int low = 0;
        int high = n-1;
        while (low < high) {
            int mid = (low + high) / 2;
            if(target > array[mid]) {
                low = mid + 1;
            }else {
                high = mid;
            }
        }
        if(array[low] == target) {
            return low;
        }
        else {
            return -1;
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i = 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        int target = sc.nextInt();
        int index = firstOccurrence(array,target);
        System.out.println(index);
    }
}",0,0,0,0,0,0,1,0,0
331,"const binarySearch = (arr, k) => {
  let min = 0;
  let max = arr.length - 1;
  while (min <= max) {
    const cur = Math.floor((min + max) / 2);
    if (arr[cur] === k) {
      return cur;
    }
    (arr[cur] > k) ?
      max = cur - 1 :
      min = cur + 1;
  }
  return -1;
};
module.exports = binarySearch;",0,0,0,0,0,0,1,0,0
332,"package intcoll6;
import java.util.*;
public class Intcoll6 {
    private btNode c;
    private int howmany;
    public Intcoll6() {
        c = null;
        howmany = 0;
    }
    public Intcoll6(int i) {
        c = null;
        howmany = 0;
    }
    public void copy(Intcoll6 obj) {
        if (this != obj) {
            howmany = obj.howmany;
            c = copytree(obj.c);
        }
    }
    private static btNode copytree(btNode t) {
        btNode root = null;
        if (t != null) {
            root = new btNode();
            root.info = t.info;
            root.left = copytree(t.left);
            root.right = copytree(t.right);
        }
        return root;
    }
    public boolean belongs(int i) {
        btNode p = c;
        while ((p != null) && (p.info != i)) {
            if (p.info > i) {
                p = p.left;
            } else {
                p = p.right;
            }
        }
        return (p != null);
    }    
    public void insert(int i) {
        btNode pred = null, p = c;  
        while ((p != null) && (p.info != i)) {  
            pred = p;  
            if (p.info > i) p = p.left;  
            else p = p.right;  
        }
        if (p == null) {  
            howmany++;
            p = new btNode(i, null, null);  
            if (pred != null) {  
                if (pred.info > i) pred.left = p;  
                else pred.right = p;
            } else c = p;  
        }
    }
    public void omit(int i)
    {
        btNode p = c;  
        btNode oneUp = null;  
        while(p!=null && p.info!=i) {
            oneUp = p;
            if(p.info < i)
                p = p.right;
            else
                p = p.left;
        }
        if(p != null) {  
            btNode q = p;  
            if(p.right == null)  
                q = p.left;  
            else if(p.left == null)  
                q = p.right;  
            else {  
                btNode j = p.left;  
                if(j.right == null) {  
                    q = j;  
                    q.right = p.right;  
                } else {  
                    while(j.right.right != null)  
                        j = j.right; 
                    q = j.right;  
                    j.right = q.left;
                    q.right = p.right; 
                    q.left = p.left;
                }
            }
            if(oneUp == null)  
                c = q;  
            else if(oneUp.right == p)  
                oneUp.right = q;  
            else  
                oneUp.left = q;  
            howmany--;  
        }
    }
    public int get_howmany() {
        return howmany;
    }
    public void print() {
        printtree(c);
    }
    private static void printtree(btNode t) {
        if (t != null) {
            printtree(t.left);
            System.out.println(t.info);
            printtree(t.right);
        }
    }
    public boolean equals(Intcoll6 obj) {
        int j = 0; boolean result = (howmany == obj.howmany);
        if (result) {
            int[] a = new int[howmany];
            int[] b = new int[howmany];
            toarray(c, a, 0);
            toarray(obj.c, b, 0);
            j = 0;
            while ((result) && (j < howmany)) {
                result = (a[j] == b[j]); j++;
            }
        }
        return result;
    }
    private static int toarray(btNode t, int[] a, int i) {
        int num_nodes = 0;
        if (t != null) {
            num_nodes = toarray(t.left, a, i);
            a[num_nodes + i] = t.info;
            num_nodes = num_nodes + 1 + toarray(t.right, a, num_nodes + i + 1);
        }
        return num_nodes;
    }
    private static class btNode {
        private int info;
        private btNode left;
        private btNode right;
        private btNode(int s, btNode lt, btNode rt) {
            info = s; left = lt; right = rt;
        }
        private btNode() {
            info = 0; left = null; right = null;
        }
    }
}",0,0,0,0,0,0,0,0,0
333,"from __future__ import print_function
try:
    raw_input          
except NameError:
    raw_input = input  
def interpolation_search(sorted_collection, item):
    left = 0
    right = len(sorted_collection) - 1
    while left <= right:
        if sorted_collection[left]==sorted_collection[right]:
            if sorted_collection[left]==item:
                return left
            else:
                return None
        point = left + ((item - sorted_collection[left]) * (right - left)) // (sorted_collection[right] - sorted_collection[left])
        if point<0 or point>=len(sorted_collection):
            return None
        current_item = sorted_collection[point]
        if current_item == item:
            return point
        else:
            if point<left:
                right = left
                left = point
            elif point>right:
                left = right 
                right = point
            else:    
                if item < current_item:
                    right = point - 1
                else:
                    left = point + 1
    return None
def interpolation_search_by_recursion(sorted_collection, item, left, right):
    if sorted_collection[left]==sorted_collection[right]:
        if sorted_collection[left]==item:
            return left
        else:
            return None
    point = left + ((item - sorted_collection[left]) * (right - left)) // (sorted_collection[right] - sorted_collection[left])
    if point<0 or point>=len(sorted_collection):
        return None
    if sorted_collection[point] == item:
        return point
    elif point<left:
        return interpolation_search_by_recursion(sorted_collection, item, point, left)
    elif point>right:
        return interpolation_search_by_recursion(sorted_collection, item, right, left)
    else:
        if sorted_collection[point] > item:
            return interpolation_search_by_recursion(sorted_collection, item, left, point-1)
        else:
            return interpolation_search_by_recursion(sorted_collection, item, point+1, right)
def __assert_sorted(collection):
    if collection != sorted(collection):
        raise ValueError('Collection must be ascending sorted')
    return True
if __name__ == '__main__':
    import sys
    """"""
	user_input = raw_input('Enter numbers separated by comma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]
    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be ascending sorted to apply interpolation search')
    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
	""""""
    debug = 0
    if debug == 1:
        collection = [10,30,40,45,50,66,77,93]
        try:
            __assert_sorted(collection)
        except ValueError:
            sys.exit('Sequence must be ascending sorted to apply interpolation search')
        target = 67
    result = interpolation_search(collection, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')",0,0,0,0,0,0,0,0,0
334,"from __future__ import print_function
try:
    raw_input          
except NameError:
    raw_input = input  
def interpolation_search(sorted_collection, item):
    left = 0
    right = len(sorted_collection) - 1
    while left <= right:
        point = left + ((item - sorted_collection[left]) * (right - left)) // (sorted_collection[right] - sorted_collection[left])
        if point<0 or point>=len(sorted_collection):
            return None
        current_item = sorted_collection[point]
        if current_item == item:
            return point
        else:
            if item < current_item:
                right = point - 1
            else:
                left = point + 1
    return None
def interpolation_search_by_recursion(sorted_collection, item, left, right):
    point = left + ((item - sorted_collection[left]) * (right - left)) // (sorted_collection[right] - sorted_collection[left])
    if point<0 or point>=len(sorted_collection):
        return None
    if sorted_collection[point] == item:
        return point
    elif sorted_collection[point] > item:
        return interpolation_search_by_recursion(sorted_collection, item, left, point-1)
    else:
        return interpolation_search_by_recursion(sorted_collection, item, point+1, right)
def __assert_sorted(collection):
    if collection != sorted(collection):
        raise ValueError('Collection must be sorted')
    return True
if __name__ == '__main__':
    import sys
    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]
    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be sorted to apply interpolation search')
    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = interpolation_search(collection, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')",0,0,0,0,0,0,0,0,0
335,"def interpolation_search(arr, key, l=0, r=-1):
    if r < 0:
        r = len(arr) - 1
    if (l <= r and key >= arr[l] and key <= arr[r]):
        pos = l + ((r - l) // (arr[r] - arr[l]) * (key - arr[l]))
        if arr[pos] == key:
            return pos
        if arr[pos] < key:
            return interpolation_search(arr, key, pos+1, r)
        if arr[pos] > key:
            return interpolation_search(arr, key, l, pos-1)
    return -1",0,0,0,0,0,0,0,0,0
336,"package search;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.IntStream;
import static java.lang.String.format;
class InterpolationSearch {
	public int find(int array[], int key) {
		int start = 0, end = (array.length - 1);
		while (start <= end && key >= array[start] && key <= array[end])
		{
			int pos = start + (((end-start) / (array[end]-array[start]))*(key - array[start]));
			if (array[pos] == key)
				return pos;
			if (array[pos] < key)
				start = pos + 1;
			else
				end = pos - 1;
		}
		return -1;
	}
	public static void main(String[] args) {
		Random r = new Random();
		int size = 100;
		int maxElement = 100000;
		int[] integers = IntStream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray();
		Integer shouldBeFound = integers[r.nextInt(size - 1)];
		InterpolationSearch search = new InterpolationSearch();
		int atIndex = search.find(integers, shouldBeFound);
		System.out.println(String.format(""Should be found: %d. Found %d at index %d. An array length %d""
				, shouldBeFound, integers[atIndex], atIndex, size));
		int toCheck = Arrays.binarySearch(integers, shouldBeFound);
		System.out.println(format(""Found by system method at an index: %d. Is equal: %b"", toCheck, toCheck == atIndex));
	}
}",0,0,0,0,0,0,0,0,0
337,"package com.jwetherell.algorithms.search;
public class InterpolationSearch {
    private static int[] sorted = null;
    public static final int find(int value, int[] array) {
        InterpolationSearch.sorted = array;
        try {
            return recursiveFind(value, 0, InterpolationSearch.sorted.length - 1);
        } finally {
            InterpolationSearch.sorted = null;
        }
    }
    private static int recursiveFind(int value, int start, int end) {
        if (start == end) {
            int lastValue = sorted[start];  
            if (value == lastValue)
                return start;  
            return Integer.MAX_VALUE;
        }
        final int mid = start + ((value - sorted[start]) * (end - start)) / (sorted[end] - sorted[start]);
        if (mid < 0 || mid > end)
            return Integer.MAX_VALUE;
        int midValue = sorted[mid];
        if (value == midValue)
            return mid;
        if (value > midValue)
            return recursiveFind(value, mid + 1, end);
        return recursiveFind(value, start, mid - 1);
    }
}",0,0,0,0,0,0,0,0,0
338,"class BinarySearch { 
	int binarySearch(int arr[], int x) 
	{ 
		int l = 0, r = arr.length - 1; 
		while (l <= r) { 
			int m = l + (r - l) / 2; 
			if (arr[m] == x) 
				return m; 
			if (arr[m] < x) 
				l = m + 1; 
			else
				r = m - 1; 
		} 
		return -1; 
	} 
	public static void main(String args[]) 
	{ 
		BinarySearch ob = new BinarySearch(); 
		int arr[] = { 2, 3, 4, 10, 40 }; 
		int n = arr.length; 
		int x = 10; 
		int result = ob.binarySearch(arr, x); 
		if (result == -1) 
			System.out.println(""Element not present""); 
		else
			System.out.println(""Element found at ""+ ""index "" + result); 
	} 
} ",0,0,0,0,0,0,1,0,0
339,"package Searches;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import static java.lang.String.format;
public final class IterativeBinarySearch implements SearchAlgorithm {
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int l, r, k, cmp;
        l = 0;
        r = array.length - 1;
        while (l <= r) {
            k = (l + r) / 2;
            cmp = key.compareTo(array[k]);
            if (cmp == 0) {
                return k;
            } else if (cmp < 0) {
                r = --k;
            } else {
                l = ++k;
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);
        Integer shouldBeFound = integers[r.nextInt(size - 1)];
        IterativeBinarySearch search = new IterativeBinarySearch();
        int atIndex = search.find(integers, shouldBeFound);
        System.out.println(String.format(""Should be found: %d. Found %d at index %d. An array length %d""
                , shouldBeFound, integers[atIndex], atIndex, size));
        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(format(""Found by system method at an index: %d. Is equal: %b"", toCheck, toCheck == atIndex));
    }
}",0,0,0,0,0,0,1,0,0
340,"package Searches;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import static java.lang.String.format;
public class IterativeTernarySearch implements SearchAlgorithm {
    @Override
    public <T extends Comparable<T>> int find(T[] array, T key) {
        int left = 0;
        int right = array.length - 1;
         while (right > left) {
            int leftCmp =  array[left].compareTo(key);
            int rightCmp =  array[right].compareTo(key);
            if (leftCmp == 0) return left;
            if (rightCmp == 0) return right;
            int leftThird = left + (right - left) / 3 + 1;
            int rightThird = right - (right - left) / 3 - 1;
            if (array[leftThird].compareTo(key) <= 0) {
                left = leftThird;
            } else {
                right = rightThird;
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement))
                .limit(size)
                .sorted()
                .toArray(Integer[]::new);
        Integer shouldBeFound = integers[r.nextInt(size - 1)];
        IterativeTernarySearch search = new IterativeTernarySearch();
        int atIndex = search.find(integers, shouldBeFound);
        System.out.println(format(""Should be found: %d. Found %d at index %d. An array length %d"",
                shouldBeFound, integers[atIndex], atIndex, size));
        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(format(""Found by system method at an index: %d. Is equal: %b"",
                toCheck, toCheck == atIndex));
    }
}",0,0,0,0,0,0,0,0,0
341,"from __future__ import print_function
import math
def jump_search(arr, x):
    n = len(arr)
    step = int(math.floor(math.sqrt(n)))
    prev = 0
    while arr[min(step, n)-1] < x:
        prev = step
        step += int(math.floor(math.sqrt(n)))
        if prev >= n:
            return -1
    while arr[prev] < x:
        prev = prev + 1
        if prev == min(step, n):
            return -1
    if arr[prev] == x:
        return prev
    return -1
arr = [ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
x = 55
index = jump_search(arr, x)
print(""\nNumber "" + str(x) +"" is at index "" + str(index));",0,0,0,0,0,0,0,0,0
342,"import math
def jump_search(arr, key):
    n = len(arr)
    step = math.sqrt(n)
    prev = 0
    while arr[int(min(step, n) - 1)] < key:
        prev = step
        step += math.sqrt(n)
        if prev >= n:
            return -1
    while arr[int(prev)] < key:
        prev += 1
        if prev == min(step, n):
            return -1
    if arr[int(prev)] == key:
        return int(prev)
    return -1",0,0,0,0,0,0,0,0,0
343,"package com.jwetherell.algorithms.search;
public class LowerBound {
    private LowerBound() { }
    public static int lowerBound(int[] array, int length, int value) {
        int low = 0;
        int high = length;
        while (low < high) {
            final int mid = (low + high) / 2;
            if (value <= array[mid]) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}",0,0,0,0,0,0,1,0,0
344,"import java.awt.Color;
public class Main {
    public static void main(String[] args) {
        GUI f = new GUI();
        f.setLocationRelativeTo(null);
        f.setVisible(true);
        f.getContentPane().setBackground(Color.white);
        f.setResizable(false);
    }
}",0,0,0,0,0,0,0,0,0
345,"package Binarytree;
import java.util.Scanner;
class Node{
int data;
Node left;
Node right;
    Node(int element)
    {
    this.data = element;
    this.left = this.right = null;
    }
}
class BST_mirror{
    Node root;
    BST_mirror()
    {
        root = null;
    }
    void addNode(int element)
    {
        root = add(root,element);
    }
    Node add(Node node, int element)
    {
        if(node == null)
            return new Node(element);
        if(element<=node.data)
            node.left = add(node.left,element);
        else
        if(element>node.data)
            node.right = add(node.right,element);
        return node;
    }
    void inorder(Node root)
    {
        if(root == null)
            return;
        inorder(root.left);
        System.out.print(root.data+"" "");
        inorder(root.right);
    }
    Node mirror()
    {
        return mirrorify(root);
    }
    Node mirrorify(Node node)
    {
        if(node == null)
            return null;
        Node mirror_temp = new Node(node.data);
        mirror_temp.left = mirrorify(node.right);
        mirror_temp.right = mirrorify(node.left);
        return mirror_temp;
    }
}
public class mirror_Tree {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        BST_mirror obj = new BST_mirror();
        obj.addNode(9);
        obj.addNode(6);
        obj.addNode(8);
        obj.addNode(7);
        obj.addNode(13);
        obj.addNode(17);
        obj.addNode(19);
        System.out.println(""Inorder of original Tree"");
        obj.inorder(obj.root);
        System.out.println();
        System.out.println(""Inorder of original Tree"");
        Node mirror_node;
        mirror_node = obj.mirror();
        obj.inorder(mirror_node);
    }
}",0,0,0,0,0,0,0,0,0
346,"import java.util.*;
public class MST {
     public static int prim(int n, int[][] adj) {
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        boolean[] used = new boolean[n];
        int[] parent = new int[n];
        int size = 1;
        int cost = 0;
        used[0] = true;
        int minNode = -1;
        int minDist = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            dist[i] = adj[0][i];
            parent[i] = 0;
            if (dist[i] < minDist && i != 0) {
                minDist = dist[i];
                minNode = i;
            }
        }
        while (size < n) {
            size++;
            cost += dist[minNode];
            used[minNode] = true;
            for (int i = 0; i < n; i++) {
                if (dist[i] > adj[i][minNode]) {
                    dist[i] = adj[i][minNode];
                    parent[i] = minNode;
                }
            }
            minDist = Integer.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                if (dist[i] < minDist && !used[i]) {
                    minDist = dist[i];
                    minNode = i;
                }
            }
        }
        return cost;
    }
}",0,0,0,0,0,0,0,0,0
347,"import java.util.*;
public class NetworkFlow {
  private static final int MAX_V = 40; 
  private static final int INF = 1000000000;
  private static int[][] adj = new int[MAX_V][]; 
  private static int maxFlow, flow, source, sink;
  private static ArrayList<Integer> parent = new ArrayList<>();
  public static int V;
  public static void augmentEdge(int v, int min) {
      if (v == source) {
          flow = min;
      } else if (parent.get(v) != -1) {
          augmentEdge(parent.get(v), Math.min(min, adj[parent.get(v)][v]));
          adj[parent.get(v)][v] -= flow;
          adj[v][parent.get(v)] += flow;
      }
  }
  public static int maxFlow() {
      maxFlow = 0;
    while (true) { 
      flow = 0;
      LinkedList<Integer> queue = new LinkedList<Integer>();
      ArrayList<Integer> distances = new ArrayList <Integer>();
      distances.addAll(Collections.nCopies(V, INF));
      queue.offer(source);
      distances.set(source, 0);
      parent.clear();
      parent.addAll(Collections.nCopies(V, -1));
      while (!queue.isEmpty()) {               
        int curr = queue.poll();
        if (curr == sink)
            break;
        for (int v = 0; v < MAX_V; v++) 
          if (adj[source][v] > 0 && distances.get(v) == INF) { 
            distances.set(v, distances.get(source) + 1);
            queue.offer(v);
            parent.set(v, curr); 
          }
      }
      augmentEdge(sink, INF);
      if (flow == 0)
          break; 
      maxFlow += flow;
    }
    return maxFlow;
  }
  public static HashMap<Integer, ArrayList<Edge>> adjList;
  public static class Edge {
      public int neighbor;
      public int weight;
      public Edge(int n, int w) {
          this.neighbor = n;
          this.weight = w;
      }
  }
  public static int minCostMaxFlow() {
      maxFlow = 0;
    while (true) { 
      flow = 0;
      ArrayList<Integer> distances = new ArrayList <Integer>();
      distances.addAll(Collections.nCopies(V, INF));
      distances.set(source, 0);
      parent.clear();
      parent.addAll(Collections.nCopies(V, -1));
      for (int i = 0; i < V - 1; i++) {
          for (int u = 0; u < V; u++) {
              for (int j = 0; j < adjList.get(u).size(); j++){
                  Edge e = adjList.get(u).get(j);
                  if (distances.get(e.neighbor) > distances.get(u) + e.weight) {
                      distances.set(e.neighbor, distances.get(u) + e.weight);
                      parent.set(e.neighbor, u);
                  }
              }
          }
      }
      augmentEdge(sink, INF);
      if (flow == 0)
          break; 
      maxFlow += flow;
    }
    return maxFlow;
  }
}",0,0,0,0,0,0,0,0,0
348,"package Searching;
import java.util.Scanner;
public class NumberOfOccurrences {
    private static int firstOccurrence(int[] array , int target) {
        int n = array.length;
        int low = 0;
        int high = n-1;
        while (low < high) {
            int mid = (low + high) / 2;
            if(target > array[mid]) {
                low = mid + 1;
            }else {
                high = mid;
            }
        }
        if(array[low] == target) {
            return low;
        }
        else {
            return -1;
        }
    }
    private static int lastOccurrence(int[] array , int target) {
        int n = array.length;
        int low = 0;
        int high = n-1;
        while (low < high) {
            int mid = (low + high + 1) / 2;
            if(target < array[mid]) {
                high =  mid -1 ;
            }else {
                low  = mid;
            }
        }
        if(array[low] == target) {
            return low;
        }
        else {
            return -1;
        }
    }
    private static int numberOfOccurrences(int[] array , int target) {
        int first = firstOccurrence(array, target);
        int last = lastOccurrence(array,target);
        if(first == -1) {
            return -1;
        }
        else {
            return last - first + 1;
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i = 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        int target = sc.nextInt();
        int index = numberOfOccurrences(array,target);
        System.out.println(index);
    }
}",0,0,0,0,0,0,1,0,0
349,"import java.util.Scanner;
import java.lang.Math;
class recursiveBinarySearch{
	public static void main(String [] args){
		Scanner scan = new Scanner(System.in);
		int [] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
		int key = scan.nextInt();
		System.out.println(recBinarySearch(arr, 0, arr.length - 1, key));
	}
	static String recBinarySearch(int [] arr, int a, int b, int key){
		if (a < b){
			int m = (a + b) / 2;
			if (key == arr[m]) return ""I found it."";
			else if (key > arr[m]) return recBinarySearch(arr, m + 1, b, key);
			else return recBinarySearch(arr, a, m - 1, key);
		}
		else return ""I couldnt find it."";
	}
}",0,0,0,0,0,0,1,0,0
350,"package searching;
public class RecursiveBinarySearch {
    private RecursiveBinarySearch() { }
	public static int indexOf(int key, int[] a, int lo, int hi) { 
		if (lo > hi) return -1;
		int mid = lo + (hi - lo) / 2;
		if (key < a[mid]) return indexOf(key, a, lo, mid - 1);
		else if (key > a[mid]) return indexOf(key, a, mid + 1, hi);
		else return mid;
	}
	public static void main(String[] args) {
		int [] a = {1, 2, 4, 0, -3, 7};
		assert a.length == 6 : ""ok"";  
		int key = 4;
		int index = RecursiveBinarySearch.indexOf(key, a, 0, a.length - 1);
		System.out.println(""Key = "" + key + "" Index = "" + index);
	}
}",0,0,0,0,0,0,1,0,0
351,"const binarySearch = (array, searchElement, lowerBound, upperBound) => {
  lowerBound = lowerBound || 0;
  upperBound = upperBound || array.length - 1;
  if (lowerBound > upperBound) {
    return false;
  }
  const midIndex = Math.floor(lowerBound  + (upperBound - lowerBound) / 2);
  const midElement = array[midIndex];
  if (searchElement === midElement) {
    return midIndex;
  } else if (searchElement > midElement) {
    return binarySearch(array, searchElement, midIndex + 1, upperBound);
  } else {
    return binarySearch(array, searchElement, lowerBound, midIndex - 1);
  }
};",0,0,0,0,0,0,1,0,0
352,"import java.util.Arrays;
public class Search {
    int a[];
    void intializeArray(int n)
    {
        a = new int [n];
        for(int i=0;i<n;i++)
        {
            a[i]=i*i;
        }
    }
    String printArray()
    {
        return ""Array : ""+ Arrays.toString(a);
    }
    String Serial_Search(int n)
    {
        int flag=0;
        String str;
        long start=System.nanoTime();
        for(int i=0;a.length-1>i;i++)
        {
            if(n==a[i])
            {
                flag=1;
                break;
            }
        }
        long e=System.nanoTime()-start;
        if(flag==1)
        {
            str=""Number Found"";
        }
        else
        {
            str=""Number not Found"";
        }
        return str+""\n Time taken to complete this function :""+e+""nano seconds"";       
    }
    String binarySearch(int n)
    {
        int flag=0;
        int L,R,M;
        String str;
        L=0;
        R=a.length-1;
        long start = System.nanoTime();
        while(L<=R)
        {
            M=(L+R)/2;
            if(a[M]==n)
            {
                flag=1;
                L=R+1;
            }
            else if(a[M]>n)
                R=M-1;
            else
                L=M+1;           
        }
    long e=System.nanoTime()-start;
    if(flag==1)
    {
        str=""The no. was found"";
    }
    else
    {
        str=""The no. not found"";
    }
        return str+""\n Time taken to complete this function :""+e+""nano seconds"";
  }
}",0,0,0,0,0,1,1,0,0
353,"package leetcode_problems.easy;
public class SearchInsPos_35 {
    public static int searchInsert1(int[] nums, int target) {
        return binarySearch(0, nums.length - 1, nums, target);
    }
    private static int binarySearch(int left, int right, int a[], int target) {
        int mid = (right + left) / 2;
        if (left > right) return left;
        else if (a[mid] == target) return mid;
        else if (a[mid] > target) return binarySearch(0, mid - 1, a, target);
        return binarySearch(mid + 1, right, a, target);
    }
    public static int searchInsert2(int[] nums, int target) {
        int i = 0;
        while (i < nums.length && nums[i] < target) {
            i++;
        }
        return i;
    }
}",0,0,0,0,0,0,1,0,0
354,"package leetcode_problems.medium;
public class SearchRotated_33 {
    public int search(int nums[], int t) {
        int l1 = 0, r1 = findMin(nums) - 1;
        int l2 = r1 + 1, r2 = nums.length - 1;
        int val1 = binarySearch(nums, l1, r1, t);
        int val2 = binarySearch(nums, l2, r2, t);
        return val1 == -1 && val2 == -1 ? -1 : val1 != -1 ? val1 : val2;
    }
    private int findMin(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int m = (r + l) / 2;
            if (nums[m] > nums[r] && nums[m] >= nums[l]) l = m + 1;
            else r = m;
        }
        return l;
    }
    private int binarySearch(int nums[], int l, int r, int t) {
        if (l > r) return -1;
        int m = l + (r - l) / 2;
        if (nums[m] == t) return m;
        if (nums[m] > t) return binarySearch(nums, l, m - 1, t);
        else return binarySearch(nums, m + 1, r, t);
    }
}",0,0,0,0,0,0,1,0,0
355,"class SegmentTree {
    private int[] tree;
    private int[] arr;
    private int n;
    private int leftOf(int p) {
        return p << 1;
    }
    private int rightOf(int p) {
        return (p << 1) + 1;
    }
    public SegmentTree(int[] tempArr) {
        arr = tempArr;
        n = arr.length;
        tree = new int[4 * n];
        for (int i = 0; i < 4 * n; i++) {
            tree[i] = 0;
        }
        build(1, 0, n - 1);
    }
    private void build(int idx, int left, int right) {
        if (left == right) {
            tree[idx] = left;
        } else {
            build(leftOf(idx), left, (left + right) / 2);
            build(rightOf(idx), (left + right) / 2 + 1, right);
            int idxL = tree[leftOf(idx)];
            int idxR = tree[rightOf(idx)];
            if (arr[idxL] <= arr[idxR]) {
                tree[idx] = idxL;
            } else {
                tree[idx] = idxR;
            }
        }
    }
    private int rmq(int idx, int left, int right, int i, int j) {
        if (i > right || j < left) {
            return -1;  
        }
        if (left >= i && right <= j) {
            return tree[idx];  
        }
        int idxL = rmq(leftOf(idx), left, (left + right) / 2, i, j);
        int idxR = rmq(rightOf(idx), (left + right) / 2 + 1, right, i, j);
        if (idxL == -1) {
            return idxR;   
        }
        if (idxR == -1) {
            return idxL;  
        }
        return (arr[idxL] <= arr[idxR]) ? idxL : idxR;
    }
    private int updatePoint(int p, int left, int right, int idx, int newVal) {
        int i = idx, j = idx;
        if (i > right || j < left) {
            return tree[p];
        }
        if (left == i && right == j) {
            arr[i] = newVal; 
            tree[p] = left;
            return tree[p];
        }
        int idxL = updatePoint(leftOf(p), left, (left + right) / 2, idx, newVal);
        int idxR = updatePoint(rightOf(p), (left + right) / 2 + 1, right, idx, newVal);
        tree[p] = arr[idxL] <= arr[idxR] ? idxL : idxR;
        return tree[p];
    }
    public int rmq(int left, int right) {
        return rmq(1, 0, n - 1, left, right);
    }
    public int updatePoint(int idx, int new_value) {
        return updatePoint(1, 0, n - 1, idx, new_value);
    }
}",0,0,0,0,0,0,0,0,0
356,"package sortingandsearch;
public class SparseSearch {
    public static void main(String[] args) {
        String[] array = {""at"", """", """", """", ""ball"", """", """", """", ""cat"", """", """", """", """", ""dog"", """"};
        assert search(array, ""at"") == 0;
        assert search(array, ""dog"") == 13;
        assert search(array, ""cat"") == 8;
        assert search(array, ""ball"") == 4;
        assert search(array, ""zzz"") == -1;
        String[] array2 = {""at"", """", """", """", """", """", ""cat"", """", """", """", """", ""dog""};
        assert search(array2, ""dog"") == 11;
        assert search(array2, ""at"") == 0;
    }
    private static int search(String[] array, String x) {
        return binarySearchIgnoringEmpties(array, x, 0, array.length - 1);
    }
    private static int binarySearchIgnoringEmpties(String[] array, String x, int low, int high) {
        if (low >= high) {
            return -1;
        }
        int mid = (low + high) / 2;
        if (array[mid].length() == 0) {
            int goLeft = mid - 1;
            int goRight = mid + 1;
            while (true) {
                if (goLeft < 0 || goRight >= array.length) {
                    break;
                }
                if (array[goLeft].length() > 0) {
                    mid = goLeft;
                    break;
                } else if (array[goRight].length() > 0) {
                    mid = goRight;
                    break;
                }
                goLeft--;
                goRight++;
            }
        }
        if (array[mid].compareTo(x) > 0) {
            return binarySearchIgnoringEmpties(array, x, low, mid - 1);
        } else if (array[mid].compareTo(x) < 0) {
            return binarySearchIgnoringEmpties(array, x, mid + 1, high);
        } else {
            return mid;
        }
    }
}",0,0,0,0,0,0,1,0,0
357,"import java.util.Arrays;
public class SuffixArray {
    char[] string;
    int n; 
    int[] rankArr;
    int[] tempRA;
    int[] suffixArr;
    int[] tempSA;
    int[] c; 
    int[] phi; 
    int[] pLCP; 
    int[] LCP;
    private static final int MAX_LEN = 100000;
    public SuffixArray(String str) {
        str += ""$"";
        this.string = str.toCharArray();
        this.n = this.string.length;
        System.out.println(str);
        this.rankArr = new int[MAX_LEN];
        this.tempRA = new int[MAX_LEN];
        this.suffixArr = new int[MAX_LEN];
        this.tempSA = new int[MAX_LEN];
        this.c = new int[MAX_LEN];
        phi = new int[MAX_LEN];
        pLCP = new int[MAX_LEN];
        LCP = new int[MAX_LEN];
        constructSA();
    }
    private void countingSort(int k) {
        int maxi = Math.max(300, n); 
        Arrays.fill(c, 0); 
        for (int i = 0; i < n; i++) {
            if (i + k < n)
                c[rankArr[i + k]]++;
            else
                c[0]++;
        }
        int sum = 0;
        for (int i = 0; i < maxi; i++) {
            int t = c[i];
            c[i] = sum;
            sum += t;
        }
        for (int i = 0; i < n; i++) { 
            tempSA[c[suffixArr[i] + k < n ? rankArr[suffixArr[i] + k] : 0]++] = suffixArr[i];
        }
        for (int i = 0; i < n; i++) 
            suffixArr[i] = tempSA[i];
    }
    private void constructSA() {
        for (int i = 0; i < n; i++) 
            rankArr[i] = string[i];
        for (int i = 0; i < n; i++) 
            suffixArr[i] = i;
        for (int k = 1; k < n; k <<= 1) { 
            countingSort(k);
            countingSort(0);
            int r = 0;
            tempRA[suffixArr[0]] = 0; 
            for (int i = 1; i < n; i++) {
                if (rankArr[suffixArr[i]] == rankArr[suffixArr[i - 1]]  
                 && rankArr[suffixArr[i] + k] == rankArr[suffixArr[i - 1] + k]) {
                    tempRA[suffixArr[i]] = r;
                } else {
                    tempRA[suffixArr[i]] = ++r;
                }
            }
            for (int i = 0; i < n; i++) { 
                rankArr[i] = tempRA[i];
            }
        }
    }
    private int compWithSuffix(char[] a, int i, char[] b, int j, int n){
        for (int k=0; i+k < a.length && j+k < b.length; k++){
          if (a[i+k] != b[j+k])
              return a[i+k] - b[j+k];
        }
        return 0;
    }
    public int[] stringMatching(String toM) {
        return stringMatching(toM.toCharArray());
    }
    public int[] stringMatching(char[] P) { 
        int low = 0;
        int high = n - 1;
        int mid = 0;
        while (low < high) {
            mid = (low + high) / 2;
            int cmp = compWithSuffix(string, suffixArr[mid], P, 0, P.length);
            if (cmp >= 0)
                high = mid;
            else
                low = mid + 1;
        }
        if (compWithSuffix(string, suffixArr[low], P, 0, P.length) != 0) 
            return new int[]{-1, -1};
        int[] ans = new int[2];
        ans[0] = low; 
        low = 0;
        high = n - 1;
        mid = 0;
        while (low < high) {
            mid = (low + high) / 2;
            int cmp = compWithSuffix(string, suffixArr[mid], P, 0, P.length);
            if (cmp > 0)
                high = mid;
            else
                low = mid + 1;
        }
        if (compWithSuffix(string, suffixArr[low], P, 0, P.length) != 0) 
            high--;
        ans[1] = high;
        return ans; 
    }
    private void computeLCP() {
        int L = 0;
        phi[suffixArr[0]] = -1;
        for (int i = 1; i < n; i++)
            phi[suffixArr[i]] = suffixArr[i - 1]; 
        for (int i = 0; i < n; i++) {
            if (phi[i] == -1) {
                pLCP[i] = 0;
                continue;
            }
            while (string[i + L] == string[phi[i] + L])
                L++;
            pLCP[i] = L; 
            L = Math.max(L - 1, 0);
        }
        for (int i = 0; i < n; i++) {
            LCP[i] = pLCP[suffixArr[i]]; 
        }
    }
    public String LRS() { 
        int max = 0;
        int idx = 0;
        for (int i = 1; i < n; i++) {
            if (LCP[i] > max) {
                max = LCP[i];
                idx = i;
            }
        }
        return new String(string).substring(suffixArr[idx], suffixArr[idx] + max);
    }
}",0,0,0,0,0,0,0,0,0
358,"import copy
import argparse
import sys
def generate_neighbours(path):
    dict_of_neighbours = {}
    with open(path) as f:
        for line in f:
            if line.split()[0] not in dict_of_neighbours:
                _list = list()
                _list.append([line.split()[1], line.split()[2]])
                dict_of_neighbours[line.split()[0]] = _list
            else:
                dict_of_neighbours[line.split()[0]].append([line.split()[1], line.split()[2]])
            if line.split()[1] not in dict_of_neighbours:
                _list = list()
                _list.append([line.split()[0], line.split()[2]])
                dict_of_neighbours[line.split()[1]] = _list
            else:
                dict_of_neighbours[line.split()[1]].append([line.split()[0], line.split()[2]])
    return dict_of_neighbours
def generate_first_solution(path, dict_of_neighbours):
    with open(path) as f:
        start_node = f.read(1)
    end_node = start_node
    first_solution = []
    visiting = start_node
    distance_of_first_solution = 0
    while visiting not in first_solution:
        minim = 10000
        for k in dict_of_neighbours[visiting]:
            if int(k[1]) < int(minim) and k[0] not in first_solution:
                minim = k[1]
                best_node = k[0]
        first_solution.append(visiting)
        distance_of_first_solution = distance_of_first_solution + int(minim)
        visiting = best_node
    first_solution.append(end_node)
    position = 0
    for k in dict_of_neighbours[first_solution[-2]]:
        if k[0] == start_node:
            break
        position += 1
    distance_of_first_solution = distance_of_first_solution + int(
        dict_of_neighbours[first_solution[-2]][position][1]) - 10000
    return first_solution, distance_of_first_solution
def find_neighborhood(solution, dict_of_neighbours):
    neighborhood_of_solution = []
    for n in solution[1:-1]:
        idx1 = solution.index(n)
        for kn in solution[1:-1]:
            idx2 = solution.index(kn)
            if n == kn:
                continue
            _tmp = copy.deepcopy(solution)
            _tmp[idx1] = kn
            _tmp[idx2] = n
            distance = 0
            for k in _tmp[:-1]:
                next_node = _tmp[_tmp.index(k) + 1]
                for i in dict_of_neighbours[k]:
                    if i[0] == next_node:
                        distance = distance + int(i[1])
            _tmp.append(distance)
            if _tmp not in neighborhood_of_solution:
                neighborhood_of_solution.append(_tmp)
    indexOfLastItemInTheList = len(neighborhood_of_solution[0]) - 1
    neighborhood_of_solution.sort(key=lambda x: x[indexOfLastItemInTheList])
    return neighborhood_of_solution
def tabu_search(first_solution, distance_of_first_solution, dict_of_neighbours, iters, size):
    count = 1
    solution = first_solution
    tabu_list = list()
    best_cost = distance_of_first_solution
    best_solution_ever = solution
    while count <= iters:
        neighborhood = find_neighborhood(solution, dict_of_neighbours)
        index_of_best_solution = 0
        best_solution = neighborhood[index_of_best_solution]
        best_cost_index = len(best_solution) - 1
        found = False
        while found is False:
            i = 0
            while i < len(best_solution):
                if best_solution[i] != solution[i]:
                    first_exchange_node = best_solution[i]
                    second_exchange_node = solution[i]
                    break
                i = i + 1
            if [first_exchange_node, second_exchange_node] not in tabu_list and [second_exchange_node,
                                                                                 first_exchange_node] not in tabu_list:
                tabu_list.append([first_exchange_node, second_exchange_node])
                found = True
                solution = best_solution[:-1]
                cost = neighborhood[index_of_best_solution][best_cost_index]
                if cost < best_cost:
                    best_cost = cost
                    best_solution_ever = solution
            else:
                index_of_best_solution = index_of_best_solution + 1
                best_solution = neighborhood[index_of_best_solution]
        if len(tabu_list) >= size:
            tabu_list.pop(0)
        count = count + 1
    return best_solution_ever, best_cost
def main(args=None):
    dict_of_neighbours = generate_neighbours(args.File)
    first_solution, distance_of_first_solution = generate_first_solution(args.File, dict_of_neighbours)
    best_sol, best_cost = tabu_search(first_solution, distance_of_first_solution, dict_of_neighbours, args.Iterations,
                                      args.Size)
    print(""Best solution: {0}, with total distance: {1}."".format(best_sol, best_cost))
if __name__ == ""__main__"":
    parser = argparse.ArgumentParser(description=""Tabu Search"")
    parser.add_argument(
        ""-f"", ""--File"", type=str, help=""Path to the file containing the data"", required=True)
    parser.add_argument(
        ""-i"", ""--Iterations"", type=int, help=""How many iterations the algorithm should perform"", required=True)
    parser.add_argument(
        ""-s"", ""--Size"", type=int, help=""Size of the tabu list"", required=True)
    sys.exit(main(parser.parse_args()))",0,0,0,0,0,0,0,0,0
359,"from __future__ import print_function
import sys
try:
    raw_input          
except NameError:
    raw_input = input  
precision = 10
def lin_search(left, right, A, target):
    for i in range(left, right+1):
        if(A[i] == target):
            return i
def ite_ternary_search(A, target):
    left = 0
    right = len(A) - 1;
    while(True):
        if(left<right):
            if(right-left < precision):
                return lin_search(left,right,A,target)
            oneThird = (left+right)/3+1;
            twoThird = 2*(left+right)/3+1;
            if(A[oneThird] == target):
                return oneThird
            elif(A[twoThird] == target):
                return twoThird
            elif(target < A[oneThird]):
                right = oneThird-1
            elif(A[twoThird] < target):
                left = twoThird+1
            else:
                left = oneThird+1
                right = twoThird-1
        else:
            return None
def rec_ternary_search(left, right, A, target):
    if(left<right):
        if(right-left < precision):
            return lin_search(left,right,A,target)
        oneThird = (left+right)/3+1;
        twoThird = 2*(left+right)/3+1;
        if(A[oneThird] == target):
            return oneThird
        elif(A[twoThird] == target):
            return twoThird
        elif(target < A[oneThird]):
            return rec_ternary_search(left, oneThird-1, A, target)
        elif(A[twoThird] < target):
            return rec_ternary_search(twoThird+1, right, A, target)
        else:
            return rec_ternary_search(oneThird+1, twoThird-1, A, target)
    else:
        return None
def __assert_sorted(collection):
    if collection != sorted(collection):
        raise ValueError('Collection must be sorted')
    return True
if __name__ == '__main__':
    user_input = raw_input('Enter numbers separated by coma:\n').strip()
    collection = [int(item) for item in user_input.split(',')]
    try:
        __assert_sorted(collection)
    except ValueError:
        sys.exit('Sequence must be sorted to apply the ternary search')
    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result1 = ite_ternary_search(collection, target)
    result2 = rec_ternary_search(0, len(collection)-1, collection, target)
    if result2 is not None:
        print('Iterative search: {} found at positions: {}'.format(target, result1))
        print('Recursive search: {} found at positions: {}'.format(target, result2))
    else:
        print('Not found')",0,0,0,0,0,0,0,0,0
360,"package Searches;
import java.util.Arrays;
import java.util.Random;
import java.util.stream.Stream;
import static java.lang.String.format;
public class TernarySearch implements SearchAlgorithm{
    @Override
    public <T extends Comparable<T>> int find(T[] arr, T value){
        return ternarySearch(arr, value, 0, arr.length - 1);
    }
    private <T extends Comparable<T>> int ternarySearch(T[] arr, T key, int start, int end) {
        if (start > end){
            return -1;
        }
        int mid1 = start + (end - start) / 3;
        int mid2 = start + 2 * (end - start) / 3;
        if (key.compareTo(arr[mid1]) == 0) {
            return mid1;
        }
        else if (key.compareTo(arr[mid2]) == 0) {
            return mid2;
        }
        else if (key.compareTo(arr[mid1]) < 0) {
            return ternarySearch(arr, key, start, --mid1);
        }
        else if (key.compareTo(arr[mid2]) > 0) {
            return ternarySearch(arr, key, ++mid2, end);
        }
        else {
            return ternarySearch(arr, key, mid1, mid2);
        }
    }
    public static void main(String[] args) {
        Random r = new Random();
        int size = 100;
        int maxElement = 100000;
        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);
        Integer shouldBeFound = integers[r.nextInt(size - 1)];
        TernarySearch search = new TernarySearch();
        int atIndex = search.find(integers, shouldBeFound);
        System.out.println(format(""Should be found: %d. Found %d at index %d. An array length %d""
                , shouldBeFound, integers[atIndex], atIndex, size));
        int toCheck = Arrays.binarySearch(integers, shouldBeFound);
        System.out.println(format(""Found by system method at an index: %d. Is equal: %b"", toCheck, toCheck == atIndex));
    }
}",0,0,0,0,0,0,0,0,0
361,"import { insertValue, removeValue, findValue } from ""./node"";
export class Tree {
    constructor() {
        this.root = """";
    }
    insert(value) {
        if (typeof value === ""undefined"") { return; }
        this.root = insertValue(this.root, value);
    }
    remove(value) {
        this.root = removeValue(this.root, value);
    }
    find(value) {
        return findValue(this.root, value);
    }
}",0,0,0,0,0,0,0,0,0
362,"import java.util.*;
public class UnionFindDS {
    private ArrayList<Integer> parent; 
    private ArrayList<Integer> rank; 
    private ArrayList<Integer> setSize; 
    private int numSets; 
    public UnionFindDS(int nSets) { 
        parent = new ArrayList<Integer>(nSets);
        rank = new ArrayList<Integer>(nSets);
        setSize = new ArrayList<Integer>(nSets);
        numSets = nSets;
        for (int i = 0; i < nSets; i++) {
            parent.add(i); 
            rank.add(0); 
            setSize.add(1); 
        }
    }
    public int findSetOf(int elem)  { 
        if (parent.get(elem) == elem) 
            return elem;
        int ret = findSetOf(parent.get(elem)); 
        parent.set(elem, ret); 
        return ret;
    }
    public boolean inSameSet(int elem1, int elem2) { 
        return findSetOf(elem1) == findSetOf(elem2);
    }
    public void unionSets(int elem1, int elem2) { 
        if (!inSameSet(elem1, elem2)) {
            numSets--;
            int p1 = findSetOf(elem1);
            int p2 = findSetOf(elem2);
            if (rank.get(p1) > rank.get(p2)) {
                parent.set(p2, p1); 
                setSize.set(p1, setSize.get(p1) + setSize.get(p2)); 
            } else {
                parent.set(p1, p2); 
                setSize.set(p2, setSize.get(p1) + setSize.get(p2)); 
                if (rank.get(p1) == rank.get(p2)) 
                    rank.set(p1, rank.get(p1) + 1);
            }
        }
    }
    public int getNumDisjointSets() {
        return numSets;
    }
    public int sizeOfSet(int elem) {
        return setSize.get(findSetOf(elem));
    }
}",0,0,0,0,0,0,0,0,0
363,"package com.jwetherell.algorithms.search;
public class UpperBound {
    private UpperBound() { }
    public static int upperBound(int[] array, int length, int value) {
        int low = 0;
        int high = length;
        while (low < high) {
            final int mid = (low + high) / 2;
            if (value >= array[mid]) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
}",0,0,0,0,0,0,1,0,0
364,"import java.util.*;
public class Array{
	static int [] array;   
	static int size;       
	public Array(){
		array=new int[100];  
		size=0;
	}
	static public void getValues(){
		Scanner input = new Scanner(System.in);
		System.out.println(""Enter the number of values to insert:"");
		int numofElem = input.nextInt();  
		for(int i=0;i<numofElem;i++){
			System.out.println(""Enter the num""+i+"":"");
			insert(input.nextInt(),i);
		}
	} 
	static public void insert(int number,int position){
		for(int i=size-1;i>=position;i--){
			array[i+1]=array[i];
		}
		array[position]=number;
		size++;
	}
	static public void delete(int position){
		for(int i=position;i<size-1;i++){
			array[i]=array[i+1];
		}
		size--;
	}
	static public void display(){
		for(int i=0;i<size;i++){
			System.out.print(array[i] + "" "");
		}
		System.out.println();
	}
	static public boolean linearSearch(int number){
		for(int i=0;i<size;i++){
			if(number==array[i]){
				return true;
			}
		}
		return false;
	}
	static public void bubbleSort(){
		for(int i=0;i<size-1;i++){
			for(int j=0;j<size-i-1;j++){
				if(array[j]>array[j+1]){
					int temp=array[j];
					array[j]=array[j+1];
					array[j+1]=temp;
				}
			}
		}
	}
	static public boolean binarySearch(int number,int low, int high){
		if(low>high){
			return false;
		}
		int mid=low + (high-low)/2;
		if(array[mid]==number){
			return true;
		}
		if(array[mid]>number){
			return binarySearch(number,low,mid-1);
		}
		else{
			return binarySearch(number,mid+1,high);
		}
	}
	public static void main(String [] args){
		Array array = new Array();  
		array.getValues();  
		array.display();    
		array.insert(10,4); 
		array.display();    
		array.delete(3);    
		array.display();    
		System.out.println(array.linearSearch(40));  
		array.bubbleSort(); 
		array.display();    
		System.out.println(array.binarySearch(56,0,size));  
	}
}",0,0,0,0,1,1,1,0,0
365,"function ArraySearch() { }
ArraySearch.prototype = (function() {
  function linear(arr, target) {
    for(var i = 0; i < arr.length; i++) {
      if(arr[i] === target) {
        return true;
      }
    }
    return false;
  }
  function binary(arr, target) {
    if(arr.length === 1) {
      return arr[0] === target;
    }
    var index = Math.floor((arr.length - 1) / 2);
    if(arr[index] === target) {
      return true;
    } else if (arr[index] > target) {
      return binary(arr.slice(0, index), target);
    } else {
      return binary(arr.slice(index + 1), target);
    }
  }
  return {
    linear: linear,
    binary: binary
  }
}.call(this))",0,0,0,0,0,1,1,0,0
366,"import java.util.*;
class Solution {
    public int solve(int[] rooms, int target) {
        for (int i = 0; i < rooms.length; i++) {
            if (rooms[i] == target || rooms[i] > target) {
                return rooms[i];
            }
        }
        return -1;
    }
}",0,0,0,0,0,1,0,0,0
367,"package LinearSearch;
import java.util.Scanner;
public class Java_Linear_Search_11 {
    private static final int linearSearch(int numToFind, int[] arrayOfIntegers){
        for (int i = 0; i < arrayOfIntegers.length; i++) {
            if (arrayOfIntegers[i] == numToFind){
                return (i + 1);
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        long endTime, timeElapsed, startTime;
        startTime = System.nanoTime();
        int arrayLength = 0;
        int numToFind = 0;
        Scanner scanner = new Scanner(System.in);
        System.out.println(""Enter the number of Integers in array >"");
        arrayLength = scanner.nextInt();
        int[]  arrayOfIntegers = new int[arrayLength];
        System.out.println(""Enter array of Integers > "");
        for (int i = 0; i < arrayLength; i++){
            System.out.println(""Enter element "" + (i +1));
            arrayOfIntegers[i] = scanner.nextInt();
        }
        System.out.println(""Enter number to find > "");
        numToFind = scanner.nextInt();
        int numPresentInArrayAt = -1;
        numPresentInArrayAt = linearSearch(numToFind, arrayOfIntegers);
        if (numPresentInArrayAt == -1){
            System.out.println(numToFind + "" is not found in the entered array..."");
        }else {
            System.out.println(numToFind + "" is present at position "" + numPresentInArrayAt);
        }
        scanner.close();
        endTime = System.nanoTime();
        timeElapsed = endTime - startTime;
        System.out.println(""Time elapsed in nanoSeconds is "" + timeElapsed);
    }
}",0,0,0,0,0,1,0,0,0
368,"import java.util.*;
public class LinearSearch {
    public static void main(String[] args) {
        int myList[] = {1,2,3,8,9,12};
        int key = 2;
        String output = linearSearch(myList, key) ? ""Successful Search"" : ""Unsuccessful Search"";
        System.out.println(output);
    }
    private static boolean linearSearch(int[] list, int key) {
        for(int i = 0; i < list.length; i++) {
            if(list[i] == key){
                return true;
            }
        }
        return false;
    }
}    
    public static void main(String a[]){
        int[] arr1= {23,45,21,55,234,1,34,90};
        int searchElem = 34;
        System.out.println(""Element ""+searchElem+"" found at index: ""+linearSearch(arr1, searchElem));
    }
} 
import java.util.*;
public class LinearSearch {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		List<Integer> numbers = new ArrayList<>();
		System.out.println(""How many number are you going to enter? "");
		int n = scan.nextInt();
		System.out.println(""Enter the list of numbers: "");
		for (int i = 0; i < n; i++) {
			int num = scan.nextInt();
			numbers.add(num);
		}
		System.out.println(""Enter the target: "");
		int target = scan.nextInt();
		if (numbers.indexOf(target) >= 0) {
			System.out.println(""Successful Search!"");
		} else {
			System.out.println(""Unsuccessful Search!"");
		}
		scan.close();
	}
}",0,0,0,0,0,1,0,0,0
369,"import java.util.ArrayList;
import java.util.Optional;
import java.util.Scanner;
public class JavaLinearSearchUsingStreams {
    public static void main(String[] args) {
        System.out.println(""How many numbers do you want to enter?"");
        Scanner scanner = new Scanner(System.in);
        int numbers = scanner.nextInt();
        ArrayList<Integer> array = new ArrayList<>();
        for (int i = 0; i < numbers; i++) {
            System.out.println(""Please enter the number for index "" + i);
            array.add(scanner.nextInt());
        }
        System.out.println(""Enter the number you want to search for"");
        int numberToFind = scanner.nextInt();
        Optional<Integer> isFound = array.stream().filter(i -> i == numberToFind).findFirst();
        if(isFound.isPresent()) {
            System.out.println(""Found number at index"" + array.indexOf(isFound));
        } else System.out.println(""Number not present"");
    }
}",0,0,0,0,0,0,0,0,0
370,"import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;
public class LinearSearch {
	public static int linearSearch(int[] arr, int target) {
		int n = arr.length;
		for(int i = 0; i < n; i++) {
			if(arr[i] == target) {
				return i;
			}
		}
		return -1;
	}
	public static void main(String[] args) {
		System.out.println(""How many numbers would you like in your list?"");
		Scanner in = new Scanner(System.in);
		Random random = new Random();
		int n = in.nextInt();
		int[] array = new int[n];
		for(int i = 0; i < n; i++) {
			array[i] = random.nextInt(n + 1);
		}
		System.out.println(""An array of size "" + n + "" has been created."");
		System.out.println(""What number should be searched for int the list?"");
		int target = in.nextInt();
		in.close();
		int index = linearSearch(array, target);
		if(index == -1) {
			System.out.println(""Your number is not in the list."");
		} else {
			System.out.println(""Your number was found at index: "" + index);
		}
		System.out.println(""The list was: "" + Arrays.toString(array));
	}
}",0,0,0,0,0,1,0,0,0
371,"import java.util.Scanner;
public class LinearSearch {
  public static void main(String[] args) {
    Scanner input = new Scanner(System.in);
    int n = input.nextInt();
    int value = input.nextInt();
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = input.nextInt();
    }
    linearSearch(n, array, value);
  }
  private static void linearSearch(int n, int[] array, int value) {
    for (int i = 0; i < n; i++) {
      if (array[i] == value) {
        System.out.println(i);
        return;
      }
    }
    System.out.println(""Not Found!"");
  }
}",0,0,0,0,0,1,0,0,0
372,"import java.util.Scanner;
public class LinearSearch {
    public static void main(String[] args) {
        System.out.println(""How many number are you going to enter? "");
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[scanner.nextInt()];
        System.out.println(""Enter the numbers and press enter after each line: "");
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = scanner.nextInt();
        }
        System.out.println(""Enter the target: "");
        int indexOfTarget = linearSearch(numbers, scanner.nextInt());
        if (indexOfTarget >= 0) {
            System.out.println(""Successful Search! The index of your target is: "" + indexOfTarget);
        } else {
            System.out.println(""The array of numbers does not contain your desired number!"");
        }
        scanner.close();
    }
    private static int linearSearch(int[] numbers, int target) {
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == target) {
                return i;
            }
        }
        return -1;
    }
}",0,0,0,0,0,1,0,0,0
373,"import java.util.Arrays;
import java.util.List;
import java.util.Optional;
public class JavaLinearSearch3 {
    public Integer linearSearch(List<Integer> numbers, Integer key ) {
        Integer result = null;
        Optional<Integer> number = numbers.stream().filter(n -> n.equals(key)).findFirst();
        if (number.isPresent()) {
            result = number.get();
        }
        return result;
    }
    public static void main(String[] args) {
        JavaLinearSearch3 javaLinearSearch3 = new JavaLinearSearch3();
        System.out.println(javaLinearSearch3.linearSearch(Arrays.asList(1,2,3,4,5), 3));
    }
}",0,0,0,0,0,1,0,0,0
374,"import java.util.Scanner;
import java.io.*;
import java.lang.*;
public class LinearSearch
{
   public static void main(String args[])
   {
      Scanner in=new Scanner(System.in);
      System.out.println(""Enter the no. of input integers:"");
      int n=in.nextInt();
       int arr[] = new int[n];
       System.out.println(""Enter Array Elements : "");
	    for(int i=0; i<n; i++)
       {
           arr[i] = in.nextInt();
       }
	    System.out.print(""Enter the Number to be Searched..."");
       int num = in.nextInt();
	     int c=0;
       int pos=-1;
       for(int i=0; i<n; i++)
       {
           if(arr[i] == num)
           {
               c = 1;
               pos = i+1;
           }
           if(c==1)
           break;
       }
       if(c == 0)
       {
           System.out.print(""Number Not Found..!!"");
       }
       else
       {
           System.out.print(num+ "" found at position "" + pos);
       }
   }
}",0,0,0,0,0,1,0,0,0
375,"import java.util.*;
import java.lang.*;
import java.io.*; 
class Codechef
{
    static int search(int arr[], int n, int x) 
              { 
        for (int i = 0; i < n; i++)
        { 
            if (arr[i] == x) 
                                       return i; 
                         } 
        return -1; 
    } 
     public static void main (String[] args) throws java.lang.Exception
              {
                         Scanner sc=new Scanner(System.in);
                         System.out.println(""Enter array length"");
                         int n=sc.nextInt();
                         System.out.println(""Enter array Elements"");
                         int i=0;
                         int a[]=new int[n];
  	       for(  ;i<n;i++)
                         a[i]=sc.nextInt();
                         System.out.println(""Enter number to be searched"");
                         int x=sc.nextInt();
                         int d=search(a,n,x);
                         if(d!=-1)
                                      System.out.println(""Found on index ""+d);
                        else
                                      System.out.println(""Not Found"");
                   } 
}",0,0,0,0,0,1,0,0,0
376,"import java.util.*;
import static jdk.nashorn.internal.objects.NativeMath.random;
public class JavaLinearSearch {
    public static void main(String args[]){
        Scanner in=new Scanner(System.in);
        Random random = new Random();
        System.out.println(""Enter the limit of your array (from 1 to 1000): "");
        int size = in.nextInt();
        ArrayList list = new ArrayList(size);
        System.out.println(""Great! Now Java is selecting some random numbers for you..."");
        for(int i=0; i<=size; i++) {
            list.add(i, random.nextInt(size+1));
        }
        System.out.print(""Please, enter the number to be searched, from 0 to 99: "");
        int search = in.nextInt();
        int index = -1;
        index = list.indexOf(search);
        if(index==-1){
            System.out.print(""Number Not Found:"");
            System.out.print("" ""+list);
        } else {
            System.out.print(""Number found at position "" + index + ""!"");
        }
    }
}",0,0,0,0,0,0,0,0,0
377,"import java.util.Scanner;
class LinearSearch{
    int linearSearch(int arr[], int searchNumber){
        int len = arr.length;
        int found = 0;  
        for(int i =0;i<len;i++){
            if(arr[i] == searchNumber){
                found = 1;
                break;
            }
        }
        return found;
    }
    public static void main(String[] args) {
        System.out.println(""Enter Number of elements: "");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter ""+n+"" elements: "");
        for(int i=0;i<n;i++) arr[i] = sc.nextInt();
        System.out.println(""Enter number to be searched: "");
        int searchNumber = sc.nextInt();
        LinearSearch linear = new LinearSearch();
        int found = linear.linearSearch(arr, searchNumber);
        if(found == 1) System.out.println(""Number Found!"");
        else System.out.println(""Number Not Found!"");
    }
}",0,0,0,0,0,1,0,0,0
378,"public class LinearSearch {
    public static void main(String[] args) {
       int [] theArray = {1,2,3,4,5,6};  
       int theNum = 5;  
       System.out.println(""Output is: "" + doLinearSearch(theArray, theNum));
    }
    private static int doLinearSearch(int arr[], int target) { 
        int value = -1;  
        for (int index = 0; index < arr.length; index++) {
          if (arr[index] == target){
            value = index; 
          }
        }
        return value;
     } 
}",0,0,0,0,0,1,0,0,0
379,"import java.util.Scanner;
public class JavaLinearSearch8 {
    private static final Scanner SC = new Scanner(System.in);
    public static void main(String[] args) {
        Integer[] data;
        System.out.print(""Size of data: "");
        data = new Integer[SC.nextInt()];
        for (int i = 0; i < data.length; i++) {
            System.out.print(String.format(""Adding item (%d/%d): "", i+1, data.length));
            data[i] = SC.nextInt();
        }
        for (int i = 0; i < data.length; i++) {
            System.out.print(data[i]);
            if (i < data.length - 1) {
                System.out.print("", "");
            } else {
                System.out.println();
            }
        }
        System.out.print(""Perform sequential search for: "");
        Integer target = SC.nextInt();
        for (int i = 0; i < data.length; i++) {
            if (target.equals(data[i])) {
                System.out.println(""Found item at index: "" + i);
                return;
            }
        }
        System.out.println(""Item not found."");
    }
}",0,0,0,0,0,1,0,0,0
380,"import java.util.Scanner;
import java.util.Random;
import java.util.Arrays;
public class LinearSearch {
    public static void main(String[] args) {
        System.out.println(""How many number are you going to enter? "");
        Random rand = new Random()
        Scanner scanner = new Scanner(System.in);
        int len = scanner.nextInt();
        int[] array = new int[len];
        for(int x=0; x<len; x++){
            array[x] = rand.nextInt();
        }
        System.out.println(Arrays.toString(array));
        System.out.println(""Enter a number to search for"");
        int find = scanner.nextInt();
        boolean found = false;
        for(int x=0; x<len; x++){
            if(array[x]==find){
                found = true;
                System.out.println(""Found at index: ""+x);
            }
        }
        if(!found){
            System.out.println(""Not found"");
        }
        scanner.close();
    }
}",0,0,0,0,0,1,0,0,0
381,"function linear () {
  let n = parseInt(prompt('Enter the size of an array'))
  let t = 0
  const a = new Array(n)
  for (let i = 0; i < a.length; i++) {
    a[i] = parseInt(prompt('Enter array elements'))
  }
  const k = parseInt(prompt('Enter the key element to search: '))
  for (let i = 0; i < a.length; i++) {
    if (k === a[i]) {
      t = 1
      break
    }
  }
  if (t == 1) {
    document.writeln('Element ' + a[i] + ' Found at Position:' + i)
  } else {
    document.writeln('Element Not Found')
  }
}
const nums = [1, 2, 3, 8, 9, 12]
const target = 2
for (const num of nums) {
  if (num === target) {
    console.log('Successful Search!')
    break
  }
}",0,0,0,0,0,1,0,0,0
382,"function linear () {
  let n = parseInt(prompt('Enter the size of an array'))
  let a = []
  for (let i = 0; i < n; i++) {
    a[i] = parseInt(prompt('Current array:\t' + a + '\nEnter array elements'))
  }
  let k = parseInt(prompt('Current array:\t' + a + '\nEnter the key element to search: '))
  for (let i = 0; i < a.length; i++) {
    if (k === a[i]) {
      document.writeln('Element ' + a[i] + ' Found at Position:' + i)
      break
    } else if (i === (a.length - 1) && k !== a[i]) {
      document.writeln('Element Not Found')
    }
  }
}
const nums = [1, 2, 3, 8, 9, 12]
const target = 2
for (const num of nums) {
  if (num === target) {
    console.log('Successful Search!')
    break
  }
}",0,0,0,0,0,1,0,0,0
383,"import java.util.*;
class LinearSearch
{
    public static void main(String args[])
    {
        Scanner sc = new Scanner(System.in);
        System.out.println(""Enter the number of elements : "");
        int n = sc.nextInt();
        int numbers[] = new int [n];
        System.out.println(""Enter "" + n + "" elements"");
        for(int i=0;i<n;i++)
        {
            numbers[i] = sc.nextInt();
        }
        System.out.println(""Enter the number you are searching for : "");
        int num = sc.nextInt();
        boolean result = false;
        for(int i=0;i<n;i++)
        {
            if(numbers[i] == num)
            {
                System.out.println(""Element found at "" + (i+1) + "" position"");
                result = true;
                break;
            }
            else
            {
                result = false;
            }
        }
        if(result == false)
        {
            System.out.println(""Element not found"");
        }
        sc.close();
    }
}",0,0,0,0,0,1,0,0,0
384,"def contains(arr, target):
    for val in arr:
        if val == target:
            return True
    return False",0,0,0,0,0,1,0,0,0
385,"class  A
{ 
	public static int search(int arr[], int x) 
	{ 
		int n = arr.length; 
		for(int i = 0; i < n; i++) 
		{ 
			if(arr[i] == x) 
				return i; 
		} 
		return -1; 
	} 
	public static void main(String args[]) 
	{ 
		int arr[] = { 2, 3, 4, 10, 40 }; 
		int x = 10; 
		int result = search(arr, x); 
		if(result == -1) 
			System.out.print(""Element is not present in array""); 
		else
			System.out.print(""Element is present at index "" + result); 
	} 
} ",0,0,0,0,0,1,0,0,0
386,"def linear_search(arr, key) -> int:
    for i in range(len(arr)):
        if arr[i] == key:
            return i
    return -1",0,0,0,0,0,1,0,0,0
387,"package Searching_Algorithm;
import java.util.Scanner;
public class Linear_Search {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int A[] = new int[10], Search;
        boolean flag = false;
        System.out.println(""Enter Search number:"");
        Search = scanner.nextInt();
        System.out.println(""Enter 10 int number:"");
        for (int i=0; i<A.length; i++){
            A[i] = scanner.nextInt();
        }
        for (int i=0; i<A.length; i++){
            if (A[i] == Search){
                flag = true;
            }
        }
        if (flag){
            System.out.println(""Found"");
        }else {
            System.out.println(""Not Found"");
        }
    }
}",0,0,0,0,0,1,0,0,0
388,"from __future__ import print_function
try:
    raw_input          
except NameError:
    raw_input = input  
def linear_search(sequence, target):
    for index, item in enumerate(sequence):
        if item == target:
            return index
    return None
if __name__ == '__main__':
    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    sequence = [int(item) for item in user_input.split(',')]
    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = linear_search(sequence, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')",0,0,0,0,0,1,0,0,0
389,"def linear_search(array, element):
    for i in range(len(array)):
        if array[i] == element:
            return i
    return -1
def main():
    count = int(input())
    array = []
    find = int(input())
    for i in range(count):
        array.append(int(input()))
    print(linear_search(array, find))
if __name__ == ""__main__"":
    main()",0,0,0,0,0,1,0,0,0
390,"function indexOfItem(collection, target) {
    for (var i = 0; i < collection.length; i++) {
        if (collection[i] === target) {
            return i;
        }
    }
    return null;
}
const names = [""Francina Vigneault"", ""Lucie Hansman"", ""Nancie Rubalcaba"", ""Elida Sleight""];
var index = indexOfItem(names, ""Lucie Hansman"");
console.log(index);",0,0,0,0,0,1,0,0,0
391,"def linear_search(arr, x):
    l = len(arr)
    for i in range(l):
        if arr[i] == x:
            return i
    return None
def main():
    arr = range(100)
    index = linear_search(arr, 55)
    if index is None:
        print('Element not found in array')
    else:
        print('Element found at index %s' % index)
if __name__ == '__main__':
    main()",0,0,0,0,0,1,0,0,0
392,"def linear_search_with_sentinel(arr, key):
    i = 0
    arr.append(key)
    while arr[i] != key:
        i += 1
    if i == len(arr) - 1:
        return -1
    return i",0,0,0,0,0,1,0,0,0
393,"import java.util.Scanner;
public class LinearSearch {
    public static int search(int[] list, int search) {
        int length = list.length;
        for (int index = 0; index < length; index++) {
            if (list[index] == search) {
                return index;
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        System.out.print(""Enter length of list : "");
        Scanner scanner = new Scanner(System.in);
        int length = scanner.nextInt();
        int[] list = new int[length];
        for (int index = 0; index < length; index++) {
            list[index] = scanner.nextInt();
        }
        System.out.print(""Enter element to search : "");
        int search = scanner.nextInt();
        int elementAt = search(list, search);
        String result = elementAt == -1 ? ""Element not found."" : ""Element is at index "" + elementAt;
        System.out.println(result);
    }
}",0,0,0,0,0,1,0,0,0
394,"import java.util.Scanner;
public class LinearSearch {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Linear Search Algorithm"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSearchIn = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSearchIn[i] = input.nextInt();
        }
        System.out.println(""Enter number to be searched in an array:"");
        int key = input.nextInt();
        int index = linearSearch(arrayOfIntegersToSearchIn, key);
        if (index == -1) {
            System.out.printf(""Sorry, %d doesn't exist in this array.%n"", key);
        } else {
            System.out.printf(""%d has an index of %d.%n"", key, index);
        }
        input.close();
    }
    public static int linearSearch(int[] input, int key) {
        for (int i = 0; i < input.length; i++) {
            if (input[i] == key) {
                return i;
            }
        }
        return -1;
    }
}",0,0,0,0,0,1,0,0,0
395,"package com.jwetherell.algorithms.search;
public class LinearSearch {
    public static final int find(int value, int[] array) {
        for (int i = 0; i < array.length; i++) {
            int iValue = array[i];
            if (value == iValue)
                return i;
        }
        return Integer.MAX_VALUE;
    }
}",0,0,0,0,0,1,0,0,0
396,"import java.io.*;
import java.lang.*;
import java.util.*;
public class Main
{
	public static void main(String[] args) {
	    Scanner scanner = new Scanner(System.in);
	    System.out.println(""Enter the size of Array\n"");
	    int n = scanner.nextInt();
	    int[] arr = new int[n];
		System.out.println(""\nEnter Values in array"");
		for(int i=0;i<n;i++)
		{
		   arr[i] = scanner.nextInt();
		}
	    System.out.println(""Enter the Value you want to Search"");
	    int value = scanner.nextInt();
	    for(int j=0;j<n;j++)
	    {
	        if(arr[j]==value)
	        {
	            System.out.println(""Your Value is in ""+ (j+1) +""Position"");
	            break;
	        }
	    }
	}
}",0,0,0,0,0,1,0,0,0
397,"package Searching;
import java.util.Scanner;
public class LinearSearch {
    private static int linearSearch(int[] array , int target) {
        int n = array.length;
        for(int i = 0 ; i < n ; i++) {
            int item = array[i];
            if(item == target) {
                return i;
            }
        }
        return  -1;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i = 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        int target = sc.nextInt();
        int index = linearSearch(array,target);
        System.out.println(index);
    }
}",0,0,0,0,0,1,0,0,0
398,"package Searching;
public class LinearSearch {
    public static void main(String[] args) {
        int[] arr = {20,35,-15,7,55,1,-22};
        System.out.println(LS(arr,-15));
        System.out.println(LS(arr,22));
    }
    public static int LS(int[] arr,int value){
        for (int i = 0; i <arr.length ; i++) {
            if (arr[i] == value){
                return i;
            }
        }
        return -1;
    }
}",0,0,0,0,0,1,0,0,0
399,"class LinearSearch
{
    static int search(int arr[], int n, int x)
    {
        for (int i = 0; i < n; i++)
        {
            if (arr[i] == x)
                return i;
        }
        return -1;
    }
} ",0,0,0,0,0,1,0,0,0
400,"package search;
import java.util.Random;
import java.util.stream.Stream;
public class LinearSearch implements SearchAlgorithm {
    @Override
    public <T extends Comparable<T>> int find(T[] array, T value) {
        for (int i = 0; i < array.length ; i++) {
            if (array[i].compareTo(value) == 0) {
                return i;
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        Random r = new Random();
        int size = 200;
        int maxElement = 100;
        Integer[] integers = Stream.generate(() -> r.nextInt(maxElement)).limit(size).toArray(Integer[]::new);
        Integer shouldBeFound = integers[r.nextInt(size - 1)];
        LinearSearch search = new LinearSearch();
        int atIndex = search.find(integers, shouldBeFound);
        System.out.println(String.format(""Should be found: %d. Found %d at index %d. An array length %d""
                , shouldBeFound, integers[atIndex], atIndex, size));
    }
}",0,0,0,0,0,1,0,0,0
401,"function linearSearch(array, target) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === target) {
      return i;
    }
  }
  return -1;
}
module.exports = {linearSearch};",0,0,0,0,0,1,0,0,0
402,"def linear(array, item):
    for ele in array:
        if item == ele:
            return(""Found"")
arr = [1,2,3,4,5,6,7,8]
it = 4
print(linear(arr, it))",0,0,0,0,0,1,0,0,0
403,"import java.util.Random;
import java.util.Scanner;
class LinearSearch 
{  
public static int search(int arr[], int x) 
{ 
    int n = arr.length; 
    for(int i = 0; i < n; i++) 
    { 
        if(arr[i] == x) 
            return i; 
    } 
    return -1; 
} 
public static void main(String args[]) 
{ 
    Random rd = new Random();
    Scanner sc = new Scanner(System.in);
    int length = sc.nextInt();
    int[] arr = new int[length];
    for(int i = 0; i < length; i++)
    {
        arr[i] = rd.nextInt(51);
        System.out.println(arr[i]);
    }
    int x;
    x = sc.nextInt(); 
    sc.close();
    int result = search(arr, x); 
    if(result == -1) 
        System.out.print(""Element is not present in array""); 
    else
        System.out.print(""Element is present at index "" + result); 
} 
} ",0,0,0,0,0,1,0,0,0
404,"function linearSearchIndexOf(arr, val) {
  for (let i = 0; i < arr.length; i++) {
    if (val === arr[i]) return i;
  }
  return -1;
}
function linearSearchIncludes(arr, val) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === val) {
      return true;
    }
  }
}
function linearSearchFind(arr, func) {
  for (let i = 0; i < arr.length; i++) {
    if (func(arr[i]) === true) {
      return arr[i];
    }
  }
  return undefined;
}",0,0,0,0,0,1,0,0,0
405,"package com.deepak.algorithms.Searching;
public class LinearSearch {
	public static int performLinearSearch(int[] listOfValues, int targetValue) {
		int index = -1;
		for (int i=0; i < listOfValues.length; i++) {
			if (listOfValues[i] == targetValue) {
				index = i;
				break;
			}
		}
		return index;
	}
}",0,0,0,0,0,1,0,0,0
406,"function linearSearch(array, target) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === target) {
      return i;
    }
  }
  return -1;
}",0,0,0,0,0,1,0,0,0
407,"import java.util.Scanner;
class linearSearch{
	public static void main(String [] args){
		Scanner scan = new Scanner(System.in);
		int [] arr = {1, 5, 2, 4, 1, 2, 5, 9, 7, 0, 3};
		int key = scan.nextInt();
		if (findIt(arr, key)) System.out.print(""here"");
		else System.out.print(""It is not here"");
	}
	static int findIt(int [] arr, int key){
		int sizeOfArr = arr.length;
		for (int i=0;i<sizeOfArr;i++) if (key == arr[i]) return 1;
		return 0;
}",0,0,0,0,0,1,0,0,0
408,"import java.util.List;
import java.util.Arrays;
public class LinearSearch<T> implements SearchingAlg<T> {
    @Override
    public int indexOf(List<T> elements, T target) {
        if (elements != null && target != null) {
            for (int i = 0; i < elements.size(); i++) {
                if (target.equals(elements.get(i)))
                    return i;
            }
        }
        return NIL;
    }
    public static void main(String[] args) {
        List<Integer> data = java.util.Arrays.asList(9,4,6,2,4,6,1,6,7,-1);
        int[] expectedIndexes = {0,1,2,3,1,2,6,2,8,9};
        SearchingAlg<Integer> alg = new LinearSearch<Integer>();
        for (int i = 0; i < data.size(); i++) {
            int result = alg.indexOf(data, data.get(i));
            if (result == NIL)
                throw new java.lang.RuntimeException(""Result shouldn't be NIL"");
        }
        System.out.println(""All tests passed."");
    }
}",0,0,0,0,0,1,0,0,0
409,"package searches;
public class LinearSearch {
    public static boolean contains(int[] arr, int n) {
        for(int m : arr)
            if(m == n)
                return true;
        return false;
    }
}",0,0,0,0,0,1,0,0,0
410,"public class LinearSearch {
    public static int linearSearch(int[] arr, int searchElement) {
        for(int i = 0; i < arr.length; i++) {
            if(arr[i] == searchElement)
                return i;	 
        }
        return -1;	 
    }
    public static void main(String[] args) {
        int[] array = new int[100];
        for(int i = 1; i <= 100; i++)
            array[i-1] = i;
        int[] search = {12,55,34,102,78};
        for(int i = 0; i < 5; i++) {
            int index = linearSearch(array, search[i]);
            if(index >= 0)
                System.out.println(search[i] + "" found at index "" + index);
            else
                System.out.println(search[i] + "" not found in the list"");
        }
    }
}",0,0,0,0,0,1,0,0,0
411,"function linearSearch (arr, x) {
	for (let it = 0; it < arr.length; it++) {
		if (x === arr[it]) {
			return it;
		}
	}
	return -1;
}
function main () {
	let data = [];
	for (let i = 1; i <= 100; i++) {
		data.push(i);
	}
	let index = linearSearch(data, 12);
	if (index === -1) {
		console.log('Element was not found');
	} else {
		console.log('Element was found at %dth index', index);
	}
}
main();",0,0,0,0,0,1,0,0,0
412,"try:  
	arr=[]
 def search(arr, x): 
	    for i in range(len(arr)): 
	        if arr[i] == x: 
	            return i 
     return -1
 while True:
		op = int(input(""Press--> 1 to insert integer | 2 to  search element | 3 to exit ""))
  if op==1:                                       
			ele = int(input(""enter elem to insert ""))
   arr.append(ele)
  elif op==2:                                    
			x=int(input(""Enter element to search ""))
   a=search(arr,x)
   if a==-1:
				print(""Element"" ,x,"" is not present in the list"")
   else:
				print(""Element "" ,x, ""is at position "",a)
  else:
			print(""invalid option"")
except ValueError:
	print(""Please enter integer only"")                 
except:
	print(""There's been some issue please check the data you've entered"")",0,0,0,0,0,1,0,0,0
413,"import java.awt.Color;
public class Main {
    public static void main(String[] args) {
        GUI f = new GUI();
        f.setLocationRelativeTo(null);
        f.setVisible(true);
        f.getContentPane().setBackground(Color.white);
        f.setResizable(false);
    }
}",0,0,0,0,0,0,0,0,0
414,"public class MyLinearSearch {
    private int[] arr;
    public MyLinearSearch(int[] arr){
        this.arr=arr;
    }
    public boolean linearSearch(int searchElement){
        boolean found =false;
        for(int i=0;i<arr.length;i++){
            if(searchElement==arr[i]){
                found=true;
                break;
            }
        }
        return found;
    }
    public static void main(String[] args) {
        int[] array={25,8,2,60,60,10,15,5};
        MyLinearSearch obj=new MyLinearSearch(array);
        boolean result=obj.linearSearch(15);
        if(result){
            System.out.println(""element found"");
        }
        else{
            System.out.println(""element not found"");
        }
    }
}",0,0,0,0,0,1,0,0,0
415,"package rosberglinhares.datastructuresandalgorithms.datastructures.arrays;
import rosberglinhares.datastructuresandalgorithms.algorithms.searching.BinarySearch;
public class OrderedArray<T extends Comparable<T>> {
    private T[] elements;
    private int size;
    @SuppressWarnings(""unchecked"")
    public OrderedArray(int maxSize) {
        this.elements = (T[])new Comparable<?>[maxSize];
        this.size = 0;
    }
    public int size() {
        return this.size;
    }
    public void insert(T value) {
        int indexToInsert = 0;
        while (indexToInsert < this.size && value.compareTo(this.elements[indexToInsert]) > 0) {
            indexToInsert++;
        }
        for (int i = this.size - 1; i >= indexToInsert; i--) {
            this.elements[i + 1] = this.elements[i];
        }
        this.elements[indexToInsert] = value;
        this.size++;
    }
    public T get(int index) {
        return this.elements[index];
    }
    public boolean binarySearch(T value) {
        BinarySearch binarySearch = new BinarySearch();
        return binarySearch.iterativeBinarySearch(this.elements, 0, this.size - 1, value);
    }
    public boolean delete(T value) {
        int indexToDelete = 0;
        int comparisonResult = -1;
        while (indexToDelete < this.size && (comparisonResult = value.compareTo(this.elements[indexToDelete])) > 0) {
            indexToDelete++;
        }
        if (comparisonResult == 0) {   
            for (int i = indexToDelete; i < this.size - 1; i++) {
                this.elements[i] = this.elements[i + 1]; 
            }
            this.size--;
            return true;
        } else {
            return false;
        }
    }
}",0,0,0,0,0,0,0,0,0
416,"def linear_search(list, target):
    for i, num in enumerate(list):
        if num == target:
            return i
    return -1",0,0,0,0,0,1,0,0,0
417,"num_array = []
num = int(input(""Enter how many elements you want:""))
print('Enter numbers in array: ')
for i in range(0, num):
    n = int(input(""num :""))
    num_array.append(n)
element_to_find = int(input(""Element to find :""))
element_found = False    
for i in num_array:
    if i==element_to_find:
        element_found = True
        print(""Successful Search!"")
if not element_found:
    print(""Unsuccessful Search!"")",0,0,0,0,0,1,0,0,0
418,"def LinearSearch(l, x):
	length = len(l)
 flag = False
 for i in range(length):
		if l[i] == x:
			print(""Element found at index"", i)
   flag = True
   return flag
 print(""Element not found in array"")
 return flag
array = list(map(int,input(""Enter array as space-separated integers: "").split()))
num = int(input(""Enter element to be found: ""))
LinearSearch(array, num)",0,0,0,0,0,1,0,0,0
419,"data_size = int(input(""Enter size of data: ""))
data = list()
for i in range(0, data_size):
    new_item = int(input(""Adding item (%d/%d): "" % (i+1, data_size)))
    data.append(new_item)
print(data)
target = int(input(""Perform sequential search for: ""))
result = [item for item in data if item == target]
print(result)",0,0,0,0,0,0,0,0,0
420,"num = int(input(""Type the number of elements: ""))
elements = []
for i in range(num):
	elements.append(int(input(""Type the "" + str(i + 1) + "" element: ""))) 
found = False
element = int(input(""Type a element to search: ""))
for e in elements:
	if element == e:
		found = True
  print(""Successful search!"")
  break
if not found:
	print(""Not Found!"")",0,0,0,0,0,1,0,0,0
421,"n=int(input(""Enter size of array : ""))
arr=[]
flag=0
print('Enter array elements : ')
for i in range(n):
    n=arr.append(int(input()))
key=int(input(""Enter element to be searched for : ""))
for x in arr:
    if(x==key):
        print('Found at index : ',arr.index(x))
        flag=1
        break
    else:
        flag=0
if(flag==0):
    print('Not Found!')",0,0,0,0,0,1,0,0,0
422,"ellen = int(input(""Enter number of elements: ""))
def linearSearch():
    myel = [] 
    for num in range(0,ellen): 
        el = input(f""{(num) + 1}. Element: "")
        try: 
            myel.append(int(el))
        except:  
            raise Exception(""Enter only numbers!"")
    print(f""This is your list: {myel}"")
    value = input(""Search a value: "")
    for pos,num in enumerate(myel):
        print(num, myel)
        print(pos)
        if num == int(value): 
            print(f""Value found! It's the {pos+1}. value in your list"")
            break
        if pos+1 == len(myel): 
            print(""Value not found!"")
linearSearch()",0,0,0,0,0,1,0,0,0
423,"num_array = list() 
num = raw_input(""Enter how many elements you want: "")
print ""Enter numbers in array: ""
for i in range(int(num)):
    n = raw_input(""num: "")
    num_array.append(int(n))
element_to_find = raw_input(""Element to find: "")    
for i in num_array: 
    if i == int(element_to_find):
        print ""Successful search!""
        break
else:
    print ""Element not found!""",0,0,0,0,0,1,0,0,0
424,"n = input(""Enter number of elements to search: "")
arr = [0]*n 
some_inp = raw_input(""Enter the space seperated list of numbers to search: "")
f = 0
for i in some_inp.split():
    arr[f] = int(i)
    f = f+1
x = input(""Enter the element to find: "")
count = 0
for i in range(n):
    if(arr[i]==x):
        ans = i 
        count = 1 
        break 
if(count==0):
    print ""Not Found!""
else:
    print ""Location of the element is: "", ans",0,0,0,0,0,1,0,0,0
425,"package com.jwetherell.algorithms.search;
import java.util.Random;
public class QuickSelect {
    private static final Random RANDOM = new Random();
    private static int[] unsorted = null;
    private static int[] temp = null;
    public static final int find(int value, int[] array) {
        unsorted = array;
        temp = new int[unsorted.length];
        try {
            int tempLength = unsorted.length;
            int length = tempLength;
            int pivot = unsorted[0];
            while (length > 0) {
                length = tempLength;
                pivot = unsorted[RANDOM.nextInt(length)];
                tempLength = 0;
                for (int i = 0; i < length; i++) {
                    int iValue = unsorted[i];
                    if (value == iValue)
                        return i;
                    else if (value > pivot && iValue > pivot)
                        temp[tempLength++] = iValue;
                    else if (value < pivot && iValue < pivot)
                        temp[tempLength++] = iValue;
                }
                unsorted = temp;
                length = tempLength;
            }
            return Integer.MAX_VALUE;
        } finally {
            QuickSelect.unsorted = null;
            QuickSelect.temp = null;
        }
    }
}",0,0,0,0,0,0,0,0,0
426,"package Searches;
import java.util.Scanner;
public class SaddlebackSearch {
    private static int[] find(int arr[][], int row, int col, int key) {
        int ans[] = {-1, -1};
        if (row < 0 || col >= arr[row].length) {
            return ans;
        }
        if (arr[row][col] == key) {
            ans[0] = row;
            ans[1] = col;
            return ans;
        }
        else if (arr[row][col] > key) {
            return find(arr, row - 1, col, key);
        }
        return find(arr, row, col + 1, key);
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int arr[][];
        int i, j, rows = sc.nextInt(), col = sc.nextInt();
        arr = new int[rows][col];
        for (i = 0; i < rows; i++) {
            for (j = 0; j < col; j++) {
                arr[i][j] = sc.nextInt();
            }
        }
        int ele = sc.nextInt();
        int ans[] = find(arr, rows - 1, 0, ele);
        System.out.println(ans[0] + "" "" + ans[1]);
        sc.close();
    }
}",0,0,0,0,0,0,0,0,0
427,"import java.util.Arrays;
public class Search {
    int a[];
    void intializeArray(int n)
    {
        a = new int [n];
        for(int i=0;i<n;i++)
        {
            a[i]=i*i;
        }
    }
    String printArray()
    {
        return ""Array : ""+ Arrays.toString(a);
    }
    String Serial_Search(int n)
    {
        int flag=0;
        String str;
        long start=System.nanoTime();
        for(int i=0;a.length-1>i;i++)
        {
            if(n==a[i])
            {
                flag=1;
                break;
            }
        }
        long e=System.nanoTime()-start;
        if(flag==1)
        {
            str=""Number Found"";
        }
        else
        {
            str=""Number not Found"";
        }
        return str+""\n Time taken to complete this function :""+e+""nano seconds"";       
    }
    String binarySearch(int n)
    {
        int flag=0;
        int L,R,M;
        String str;
        L=0;
        R=a.length-1;
        long start = System.nanoTime();
        while(L<=R)
        {
            M=(L+R)/2;
            if(a[M]==n)
            {
                flag=1;
                L=R+1;
            }
            else if(a[M]>n)
                R=M-1;
            else
                L=M+1;           
        }
    long e=System.nanoTime()-start;
    if(flag==1)
    {
        str=""The no. was found"";
    }
    else
    {
        str=""The no. not found"";
    }
        return str+""\n Time taken to complete this function :""+e+""nano seconds"";
  }
}",0,0,0,0,0,1,1,0,0
428,"import java.util.Arrays;
import java.util.Scanner;
import static java.lang.System.exit;
public class Search {
    private static int search_array[];
    private static int size;
    private static Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        while (true) {
            System.out.println(""==============================MENU=============================="");
            System.out.println(""1.Linear Search"");
            System.out.println(""2.Binary Search"");
            System.out.println(""3.Exit"");
            System.out.println(""================================================================"");
            System.out.println(""Please give the choice from the above menu: "");
            int choice = scanner.nextInt();
            switch (choice) {
                case 1:
                    linearSearch();
                    break;
                case 2:
                    binarySearch();
                    break;
                case 3:
                    exit(0);
                    break;
                default:
                    System.out.println(""Please choose the right option, refer the above menu!"");
            }
        }
    }
    private static void linearSearch(){
        int found = 0;
        createArray();
        displayArray();
        System.out.println(""Now give the element to be searched in linear fashion: "");
        int searchItem = scanner.nextInt();
        for (int i = 0; i < size; i++){
            if(search_array[i] == searchItem){
                System.out.println(""The item "" + searchItem + "" found at position "" + (i+1));
                found = 1;
            }
        }
        if(found == 0) {
            System.out.println(""Please give the correct item to be searched! It looks as if there is no such item! Please check again"");
        }
    }
    private static void createArray(){
        System.out.println(""Give the size of the array to insert elements: "");
        size = scanner.nextInt();
        search_array = new int[size];
        System.out.println(""Now give "" + size + "" elements to insert into the array: "");
        for (int i = 0; i < size; i++){
            search_array[i] = scanner.nextInt();
        }
    }
    private static void binarySearch(){
        createArray();
        displayArray();
        System.out.println(""Sorting the array..."");
        Arrays.sort(search_array);
        displayArray();
        System.out.println(""Now give the element to be searched in binary fashion: "");
        int searchItem = scanner.nextInt();
        int head = 0;
        int tail = size;
        int mid;
        while (head < tail){
            mid = (head + tail)/2;
            if(search_array[mid] == searchItem){
                System.out.println(""The item "" + searchItem + "" found at position "" + (mid+1));
                break;
            }else if (search_array[mid] > searchItem){
                tail = mid - 1;
            }else{
                head = mid + 1;
            }
        }
        if(head > tail){
            System.out.println(""Number not found! Please check again!"");
        }
    }
   private static void displayArray(){
        System.out.println(""The elements are as follows: \n"");
        for (int x: search_array){
            System.out.print(x + ""\t"");
        }
        System.out.println();
    }
}",0,0,0,0,0,1,1,0,0
429,"package com.jwetherell.algorithms.search.test;
import static org.junit.Assert.assertTrue;
import com.jwetherell.algorithms.search.*;
import org.junit.Test;
import java.util.ArrayList;
import java.util.Arrays;
public class Search {
    private static final int SIZE = 9999;
    private static final int offset = 123;
    private static int[] sorted = new int[SIZE];
    static {
        for (int i = offset; i < offset + sorted.length; i++) {
            sorted[i - offset] = i;
        }
    }
    private static int valueIndex = SIZE - (SIZE / 4);
    private static int valueInArray = sorted[valueIndex];
    private static int valueNotInArray = sorted[SIZE - 1] + offset;
    @Test
    public void testBruteForceSearch() {
        int index = LinearSearch.find(valueInArray, sorted);
        assertTrue(""Brute force error. expected="" + valueIndex + "" got="" + index, (index == valueIndex));
        index = LinearSearch.find(valueNotInArray, sorted);
        assertTrue(""Brute force error. expected="" + Integer.MAX_VALUE + "" got="" + index, (index == Integer.MAX_VALUE));
    }
    @Test
    public void testBinarySearch() {
        int index = BinarySearch.find(valueInArray, sorted, false);
        assertTrue(""Brute force error. expected="" + valueIndex + "" got="" + index, (index == valueIndex));
        index = BinarySearch.find(valueNotInArray, sorted, false);
        assertTrue(""Brute force error. expected="" + Integer.MAX_VALUE + "" got="" + index, (index == Integer.MAX_VALUE));
    }
    @Test
    public void testOptimizedBinarySearch() {
        int index = BinarySearch.find(valueInArray, sorted, true);
        assertTrue(""Brute force error. expected="" + valueIndex + "" got="" + index, (index == valueIndex));
        index = BinarySearch.find(valueNotInArray, sorted, true);
        assertTrue(""Brute force error. expected="" + Integer.MAX_VALUE + "" got="" + index, (index == Integer.MAX_VALUE));
    }
    @Test
    public void testInterpolationSearch() {
        int index = InterpolationSearch.find(valueInArray, sorted);
        assertTrue(""Brute force error. expected="" + valueIndex + "" got="" + index, (index == valueIndex));
        index = InterpolationSearch.find(valueNotInArray, sorted);
        assertTrue(""Brute force error. expected="" + Integer.MAX_VALUE + "" got="" + index, (index == Integer.MAX_VALUE));
    }
    @Test
    public void testQuickSelect() {
        int index = QuickSelect.find(valueInArray, sorted);
        assertTrue(""Brute force error. expected="" + valueIndex + "" got="" + index, (index == valueIndex));
        index = QuickSelect.find(valueNotInArray, sorted);
        assertTrue(""Brute force error. expected="" + Integer.MAX_VALUE + "" got="" + index, (index == Integer.MAX_VALUE));
    }
    @Test
    public void testLowerBound() {
        ArrayList<int[]> sequences = new ArrayList<int[]>();
        ArrayList<Integer> soughtElements = new ArrayList<Integer>();
        ArrayList<Integer> resultIndexes = new ArrayList<Integer>();
        sequences.add(new int[]{0, 1, 2, 3, 3, 3, 3, 8, 9});
        soughtElements.add(-1);
        resultIndexes.add(0);
        sequences.add(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
        soughtElements.add(4);
        resultIndexes.add(4);
        sequences.add(new int[]{0, 1, 2, 3, 3, 3, 3, 3, 8, 9});
        soughtElements.add(3);
        resultIndexes.add(3);
        sequences.add(new int[]{0, 1, 2, 3, 3, 3, 3, 8, 9});
        soughtElements.add(3);
        resultIndexes.add(3);
        sequences.add(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
        soughtElements.add(44);
        resultIndexes.add(10);
        assertTrue(""Lower bound error. Sequences size="" + sequences.size() + "" sough elements size="" + soughtElements.size() + "" results size:"" + resultIndexes.size(), sequences.size() == resultIndexes.size() && sequences.size() == soughtElements.size());
        for (int i = 0; i < sequences.size(); ++i) {
            int resultIndex = LowerBound.lowerBound(sequences.get(i), sequences.get(i).length, soughtElements.get(i));
            assertTrue(""Lower bound error. Sequence="" + Arrays.toString(sequences.get(i)) + "" sought element="" + soughtElements.get(i) + "" expected result="" + resultIndexes.get(i) + "" got result="" + resultIndex, resultIndex == resultIndexes.get(i));
        }
    }
    @Test
    public void testUpperBound() {
        ArrayList<int[]> sequences = new ArrayList<int[]>();
        ArrayList<Integer> soughtElements = new ArrayList<Integer>();
        ArrayList<Integer> resultIndexes = new ArrayList<Integer>();
        sequences.add(new int[]{0, 1, 2, 3, 3, 3, 3, 8, 9});
        soughtElements.add(-1);
        resultIndexes.add(0);
        sequences.add(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
        soughtElements.add(4);
        resultIndexes.add(5);
        sequences.add(new int[]{0, 1, 2, 3, 3, 3, 3, 3, 8, 9});
        soughtElements.add(3);
        resultIndexes.add(8);
        sequences.add(new int[]{0, 1, 2, 3, 3, 3, 3, 8, 9});
        soughtElements.add(3);
        resultIndexes.add(7);
        sequences.add(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});
        soughtElements.add(44);
        resultIndexes.add(10);
        assertTrue(""Upper bound error. Sequences size="" + sequences.size() + "" sough elements size="" + soughtElements.size() + "" results size:"" + resultIndexes.size(), sequences.size() == resultIndexes.size() && sequences.size() == soughtElements.size());
        for (int i = 0; i < sequences.size(); ++i) {
            int resultIndex = UpperBound.upperBound(sequences.get(i), sequences.get(i).length, soughtElements.get(i));
            assertTrue(""Upper bound error. Sequence="" + Arrays.toString(sequences.get(i)) + "" sought element="" + soughtElements.get(i) + "" expected result="" + resultIndexes.get(i) + "" got result="" + resultIndex, resultIndex == resultIndexes.get(i));
        }
    }
}",0,0,0,0,0,0,0,0,0
430,"import java.io.*;
import java.lang.*;
import java.util.*;
class Search
{
public static void main(String args[])throws IOException
{
	BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	int ch;
	do
	{
	System.out.println(""\n1.Linear Search\n2.Binary Search\n3.Binary Search with recursion\n4.Exit"");
	ch=Integer.parseInt(br.readLine());
	if(ch==4)
		return;
	System.out.println(""Enter the number of terms"");
	int n=Integer.parseInt(br.readLine());
	int a[]=new int[n];
	for(int i=0;i<n;i++)
		{
			System.out.println(""Enter ""+(i+1)+""th term"");
			a[i]=Integer.parseInt(br.readLine());
		}
		System.out.println(""Enter number to be searched"");
		int num=Integer.parseInt(br.readLine());
		switch(ch)
		{
			case 1:
				LinearSearch(a,n,num);
				break;
			case 2:
				BinarySearch(a,n,num);
				break;
			case 3:
				int first=0;
				int last=n;
				BinarySearchRec(a,n,num,first,last);
				break;
		}
	}
	while(ch!=4);
}
public static void LinearSearch(int a[],int n,int num)
{
	for(int i=0;i<n;i++)
	{
		if(a[i]==num)
		{
			System.out.println(num+"" found at ""+(i+1)+""th position"");
			return;
		}
	}
	System.out.println(num+"" not found"");
}
public static void BinarySearch(int a[],int n,int num)
{
	int first=0;
	int last=n;
	int mid=(first+last)/2;
	while(first!=last)
	{
		if(a[mid]==num)
			{
			System.out.println(num+"" found at ""+(mid+1)+""th position"");
			return;
			}
		if(a[mid]<num)
			{
				first=mid+1;
				last=n;
				 mid=(first+last)/2;
			}
		else
			{
				first=0;
				last=mid-1;
				 mid=(first+last)/2;
			}
	}
		System.out.println(num+"" not found"");
}
public static void BinarySearchRec(int a[],int n,int num,int first, int last)
{
	if(first>last)
	{
		System.out.println(num+"" not found"");
		return;
	}
		int mid=(first+last)/2;
		try{
		if(a[mid]==num)
			{
			System.out.println(num+"" found at ""+(mid+1)+""th position"");
			return;
			}
		if(a[mid]<num)
			{
				BinarySearchRec( a, n, num, mid+1, last);
			}
		if(a[mid]>num)
			{
				BinarySearchRec( a, n, num, first,  mid-1);
			}
		}
		catch(ArrayIndexOutOfBoundsException exception) {
				System.out.println(num+"" not found"");
			}
}
}",0,0,0,0,0,1,1,0,0
431,"package Lecture14;
public class searchMatrix {
	public static void main(String[] args) {
		int[][] arr = { { 10, 20, 30, 40 }, 
						{ 11, 21, 31, 41 },
						{ 12, 22, 32, 42 }, 
						{ 13, 23, 33, 43 } };
		System.out.println(searchKeyMatrix(arr, 22));
	}
	public static boolean searchKeyMatrix(int[][] arr, int key) {
		for (int row = 0; row < arr.length; row++) {
			for (int col = 0; col < arr[row].length; col++) {
				if (arr[row][col] == key) {
					System.out.println(""element present at: ("" + row + "",""
							+ col + "")"");
					return true;
				}
			}
		}
		return false;
	}
}",0,0,0,0,0,1,0,0,0
432,"package Lecture14;
public class searchMatrix2 {
	public static void main(String[] args) {
		int[][] arr = { { 10, 20, 30, 40 }, 
						{ 11, 21, 31, 41 },
						{ 12, 22, 32, 42 }, 
						{ 13, 23, 33, 43 } };
		System.out.println(searchKeyMatrix(arr, 22));  
		System.out.println(searchKeyMatrix(arr, 10));  
		System.out.println(searchKeyMatrix(arr, 42));  
		System.out.println(searchKeyMatrix(arr, 23));  
		System.out.println(searchKeyMatrix(arr, 13));  
		System.out.println(searchKeyMatrix(arr, 2));  
	}
	public static boolean searchKeyMatrix(int[][] arr, int key) {
		int start = 0, end = arr.length - 1;
		int mid = (start + end) / 2;
		if (arr[0][mid] == key || arr[mid][0] == key) {
			return true;
		}
		int startcol = 0;
		int endcol = arr.length - 1;
		if (key < arr[0][mid]) {
			endcol = mid;
		} else {
			startcol = mid;
		}
		int startrow = 0;
		int endrow = arr.length - 1;
		if (key < arr[mid][0]) {
			endrow = mid;
		} else {
			startrow = mid;
		}
		for (int row = startrow; row <= endrow; row++) {
			for (int col = startcol; col <= endcol; col++) {
				if (arr[row][col] == key) {
					return true;
				}
			}
		}
		return false;
	}
}",0,0,0,0,0,1,0,0,0
433,"package Lecture14;
public class searchMatrix3 {
	public static void main(String[] args) {
		int[][] arr = { { 10, 20, 30, 40 }, 
						{ 11, 21, 31, 41 },
						{ 12, 22, 32, 42 }, 
						{ 13, 23, 33, 43 } };
		System.out.println(staircase(arr, 22));  
		System.out.println(staircase(arr, 10));  
		System.out.println(staircase(arr, 42));  
		System.out.println(staircase(arr, 23));  
		System.out.println(staircase(arr, 13));  
		System.out.println(staircase(arr, 2));  
	}
	public static boolean staircase(int[][] arr, int key) {
		int row = 0, col = arr.length - 1;
		while (row < arr.length && col >= 0) {
			if (arr[row][col] == key) {
				return true;
			} else if (key > arr[row][col]) {
				row++;
			} else {
				col--;
			}
		}
		return false;
	}
}",0,0,0,0,0,1,0,0,0
434,"def sentinel_linear_search(sequence, target):
    sequence.append(target)
    index = 0
    while sequence[index] != target:
        index += 1
    sequence.pop()
    if index == len(sequence):
        return None
    return index
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by comma:\n').strip()
    sequence = [int(item) for item in user_input.split(',')]
    target_input = raw_input('Enter a single number to be found in the list:\n')
    target = int(target_input)
    result = sentinel_linear_search(sequence, target)
    if result is not None:
        print('{} found at positions: {}'.format(target, result))
    else:
        print('Not found')",0,0,0,0,0,1,0,0,0
435,"package searching;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
import fundamentals.Bag;
public class SequentialSearchST<Key, Value> {
  private Node first;
  private int numItems;
  private class Node {
    private Key key;
    private Value val;
    private Node next;
    public Node(Key key, Value val, Node next) {
      this.key = key;
      this.val = val;
      this.next = next;
    }
  }
  public Value get(Key key) {  
    for (Node x = first; x != null; x = x.next)
      if (key.equals(x.key))
        return x.val;  
    return null;  
  }
  public void put(Key key, Value val) {  
    for (Node x = first; x != null; x = x.next)
      if (key.equals(x.key))
        { x.val = val; return; }  
    first = new Node(key, val, first);  
    numItems++;  
  }
  public boolean contains(Key key) {
    if (key == null) throw new IllegalArgumentException(""argument to contains() is null"");
    return get(key) != null;
  }
  public Iterable<Key> keys() {
    Bag<Key> keys = new Bag<Key>();
    for (Node x = first; x != null; x = x.next)
      keys.add(x.key);
    return keys;
  }
  public int size() {
    return numItems;
  }
  public static void main(String[] args) {
    SequentialSearchST<String, Integer> st = new SequentialSearchST<String, Integer>();
    for (int i = 0; !StdIn.isEmpty(); i++) {
      String key = StdIn.readString();
      st.put(key, i);
    }
    StdOut.println(""Number of items: "" + st.size());
    for (String s : st.keys())
      StdOut.println(s + "" "" + st.get(s));
  }
}",0,0,0,0,0,1,0,1,0
436,"function stringPatternSearch(text, pattern) {
  let count = 0;
  for (let i = 0; i < text.length; i++) {
    for (let j = 0; j < pattern.length; j++) {
      const patternChar = pattern[j];
      if (patternChar !== text[i + j]) {
        break;
      }
      if (j === pattern.length - 1) {
        count++;
      }
    }
  }
  return count;
}",0,0,0,0,0,1,0,0,0
437,"package rosberglinhares.datastructuresandalgorithms.datastructures.arrays;
public class UnorderedArray<T> {
    private static int ELEMENT_NOT_FOUND = -1;
    private T[] elements;
    private int size;
    @SuppressWarnings(""unchecked"")
    public UnorderedArray(int maxSize) {
        this.elements = (T[])new Object[maxSize];
        this.size = 0;
    }
    public int size() {
        return this.size;
    }
    public void insert(T value) {
        this.elements[this.size++] = value;
    }
    public T get(int index) {
        return this.elements[index];
    }
    public int search(T value) {
        for (int i = 0; i < this.size; i++) {
            if (this.elements[i].equals(value)) {
                return i;
            }
        }
        return ELEMENT_NOT_FOUND;
    }
    public boolean delete(T value) {
        int i = this.search(value);
        if (i > ELEMENT_NOT_FOUND) {
            for (; i < this.size - 1; i++) {
                this.elements[i] = this.elements[i + 1]; 
            }
            this.size--;
            return true;
        } else {
            return false;
        }
    }
}",0,0,0,0,0,1,0,0,0
438,"package searching;
import edu.princeton.cs.algs4.ST;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class WordCounter {
	public static void main(String[] args) {
		ST<String, Integer> st = new ST<String, Integer>();
		for (int i = 0; !StdIn.isEmpty(); i++) {
  		String key = StdIn.readString();
  		st.put(key, i);
  	}
		for (String s : st.keys())
		  StdOut.printf(""%s "",s);
		StdOut.println();
		StdOut.printf(""Symbol Table size: %d\n"", st.size());
	}
}",0,0,0,0,0,0,0,0,0
439,"def swap(list , pos1 , pos2):
	list[pos1] , list [pos2] = list[pos2] , list [pos1]
 return list
def bubble_sort(list):
	for i in range(0 , len(list)-1):
		flag = 0
  for j in range(0,len(list)-1 - i):
			if list[j] > list[j+1]:
				flag = 1
    list = swap(list , j , j+1)
  if flag==0:
			break
 return list
a = [2,7,4,1,5,3]
print(a)
bubble_sort(a)
print(a)",0,0,0,0,1,0,0,0,0
440,"package com.ianramzy;
public class BetterBubbleSorter implements Sorter {
    public void sort(int num, int list[]) {
        int i, j = 0, temp;
        boolean swapped;
        do {
            swapped = false;
            for (i = 0; i < num - j - 1; i++) {
                if (list[i] > list[i + 1]) {
                    temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    swapped = true;
                }
            }
            j++;
        }
        while (swapped);
    }
}",0,0,0,0,1,0,0,0,0
441,"package Sorting;
public class Bubble {
	public static <T extends Comparable<T>> void BubbleSort(T arr[])
    {
		int n = arr.length;
        int i, j; 
        T temp;
        boolean swapped;
        for (i = 0; i < n - 1; i++) 
        {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) 
            {
                if (arr[j].compareTo(arr[j+1]) > 0) 
                {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            if (swapped == false)
                break;
        }
    }
    public static <T extends Comparable<T>> void BubbleSortRecursive(T arr[])
    {
    	BubbleSortRecursiveHelper(arr, arr.length);
    }
    private static <T extends Comparable<T>> void BubbleSortRecursiveHelper(T arr[], int n)
    {
        if (n == 1)
            return;
        for (int i=0; i<n-1; i++)
            if (arr[i].compareTo(arr[i+1]) > 0)
            {
                T temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        BubbleSortRecursiveHelper(arr ,n-1);
    }
}",0,0,0,0,1,0,0,0,0
442,"def bubble_sort(l: list):
    arr = l[::]
    is_sorted = True
    end = len(arr)
    while is_sorted:
        is_sorted = False
        for i in range(1, end):
            if arr[i] < arr[i-1]:
                arr[i], arr[i-1] = arr[i-1], arr[i]
                is_sorted = True
        end -= 1
    return arr",0,0,0,0,1,0,0,0,0
443,"from structures.src.util.sort_util import is_sorted, swap
def sort(arr):
    out = list(arr)
    while not is_sorted(out):
        for i in range(0, len(out) - 1):
            if out[i] > out[i + 1]:
                swap(out, i, i + 1)
    return out",0,0,0,0,1,0,0,0,0
444,"def bubblesort(list):
    for iter_num in range(len(list)-1,0,-1):
        for idx in range(iter_num):
            if list[idx]>list[idx+1]:
                temp = list[idx]
                list[idx] = list[idx+1]
                list[idx+1] = temp
list = [19,2,31,45,6,11,121,27]
bubblesort(list)
print(list)
def selection_sort(input_list):
    for idx in range(len(input_list)):
        min_idx = idx
        for j in range( idx +1, len(input_list)):
            if input_list[min_idx] > input_list[j]:
                min_idx = j
        input_list[idx], input_list[min_idx] = input_list[min_idx], input_list[idx]
l = [19,2,31,45,30,11,121,27]
selection_sort(l)
print(l)
def  shaker_sort(alist):
    def swap(i, j):
        alist[i], alist[j] = alist[j], alist[i]
    upper = len(alist) - 1
    lower = 0
    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if alist[j + 1] < alist[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1
        for j in range(upper, lower, -1):
            if alist[j - 1] > alist[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1
alist=[3,9,7,5,3,2,1,8,10]
shaker_sort(alist)
print(alist)",0,0,1,0,1,0,0,0,0
445,"def swap(list , pos1 , pos2):
	list[pos1] , list [pos2] = list[pos2] , list [pos1]
 return list
def bubble_sort(list):
	for i in range(0 , len(list)-1):
		for j in range(0,len(list)-1 - i):
			if list[j] > list[j+1]:
				list = swap(list , j , j+1)
 return list
a = [2,7,4,1,5,3]
print(a)
bubble_sort(a)
print(a)",0,0,0,0,1,0,0,0,0
446,"public class Bubble {
    public static void sort(int[] input) {
        int sorted = input.length;
        for (int i = 0; sorted != 1 && i < input.length - 1; i++) {
            int cache = sorted;
            for (int j = 0; j < cache - 1; j++) {
                if (input[j] > input[j + 1]) {
                    swap(input, j, j + 1);
                    sorted = j + 1;
                }
            }
        }
    }
    private static void swap(int[] input, int a, int b) {
        int cache = input[a];
        input[a] = input[b];
        input[b] = cache;
    }
}",0,0,0,0,1,0,0,0,0
447,"__all__ = (
    ""bubble_sort"",
    ""bubble_sort_imp"",
)
from typing import List, TypeVar
T = TypeVar(""T"")
def bubble_sort(
    data: List[T], *, reverse: bool = False, inplace: bool = False
) -> List[T]:
    if not inplace:
        data = data.copy()
    comparison_op: str = ""__lt__"" if reverse else ""__gt__""
    max_len: int = len(data)
    for i in range(max_len):
        is_compare: bool = False
        for j in range(max_len - i - 1):
            if getattr(data[j], comparison_op)(data[j + 1]):
                data[j], data[j + 1] = data[j + 1], data[j]
                is_compare = True
        if not is_compare:
            break
    return data
def bubble_sort_imp(
    data: List[T], *, reverse: bool = False, inplace: bool = False
) -> List[T]:
    if not inplace:
        data = data.copy()
    comparison_op: str = ""__lt__"" if reverse else ""__gt__""
    unsorted_max_index: int = len(data) - 1
    last_unsorted_max_index: int = -1
    while unsorted_max_index != last_unsorted_max_index:
        last_unsorted_max_index = unsorted_max_index
        for i in range(unsorted_max_index):
            if getattr(data[i], comparison_op)(data[i + 1]):
                data[i], data[i + 1] = data[i + 1], data[i]
                unsorted_max_index = i
    return data",0,0,0,0,1,0,0,0,0
448,"def bubble_sort(num_list):
	for items in range(len(num_list)-1,0,-1):
		for item in range(items):
			if num_list[item] > num_list[item+1]:
				temp = num_list[item]
    num_list[item] = num_list[item+1]
    num_list[item+1] = temp
 return num_list
print bubble_sort([54,26,93,17,77,31,44,55,20])",0,0,0,0,1,0,0,0,0
449,"from __future__ import print_function
def bubble_sort(collection):
    length = len(collection)
    for i in range(length-1):
        swapped = False
        for j in range(length-1-i):
            if collection[j] > collection[j+1]:
                swapped = True
                collection[j], collection[j+1] = collection[j+1], collection[j]
        if not swapped: break  
    return collection
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(*bubble_sort(unsorted), sep=',')",0,0,0,0,1,0,0,0,0
450,"def bubblesort(lst):
    if len(lst) <= 1:
        return lst
    else:
        sorted = False
        while sorted != True:
            sorted = True
            for i in range(len(lst)-1):
                if lst[i] > lst[i+1]:
                    sorted = False
                    lst[i], lst[i+1] = lst[i+1], lst[i]
        return lst
lst = [7, 5, 3, 1, 5, 9, 8, 4, 6, 2, 10]
print(bubblesort(lst))",0,0,0,0,1,0,0,0,0
451,"def bubble_sort(nlist):
    for i in range(len(nlist)-1,0,-1):
        for j in range(i):
            if nlist[j]>nlist[j+1]:
                nlist[j], nlist[j+1] = nlist[j+1], nlist[j]
nlist = [14,46,43,27,57,41,45,21,70]
bubble_sort(nlist)
print(nlist)",0,0,0,0,1,0,0,0,0
452,"def bubble_sort(arr):
    def swap(i, j):
        arr[i], arr[j] = arr[j], arr[i]
    n = len(arr)
    swapped = True
    x = -1
    while swapped:
        swapped = False
        x = x + 1
        for i in range(1, n-x):
            if arr[i - 1] > arr[i]:
                swap(i - 1, i)
                swapped = True
    return arr",0,0,0,0,1,0,0,0,0
453,"def bubble_sort(a):
    b = [*a]
    n = len(b)
    for i in range(n):
        for j in range(n-i-1):
            if b[j] > b[j+1]:
                b[j], b[j+1] = b[j+1], b[j]
    return b
if __name__ == ""__main__"":
    import unittest
    from random import shuffle
    class TestBubbleSort(unittest.TestCase):
        def setUp(self):
            self.ordered = [x for x in range(20)]
            self.shuffled = [*self.ordered]
            while self.ordered == self.shuffled:
                shuffle(self.shuffled)
        def test_bubble_sort(self):
            self.assertEqual(self.ordered, bubble_sort(self.shuffled))
            self.assertNotEqual(self.ordered, self.shuffled)
    unittest.main()",0,0,0,0,1,0,0,0,0
454,"def bubble_sort(array):
    for i in range(0, len(array)-1):
        for j in range(len(array)-1, i, -1):
            if array[i] > array[j]:
                array[i], array[j] = array[j], array[i]
def main():
    count = int(input())
    array = []
    for i in range(count):
        array.append(int(input()))
    bubble_sort(array)
    for i in array:
        print(i, end=' ')
if __name__ == ""__main__"":
    main()",0,0,0,0,1,0,0,0,0
455,"class BubbleSort 
{ 
	void bubbleSort(int arr[]) 
	{ 
		int n = arr.length; 
		for (int i = 0; i < n-1; i++) 
			for (int j = 0; j < n-i-1; j++) 
				if (arr[j] > arr[j+1]) 
				{ 
					int temp = arr[j]; 
					arr[j] = arr[j+1]; 
					arr[j+1] = temp; 
				} 
	}  
	public static void main(String args[]) 
	{ 
		BubbleSort ob = new BubbleSort(); 
		int arr[] = {64, 34, 25, 12, 22, 11, 90}; 
		ob.bubbleSort(arr); 
		System.out.println(""Sorted array:""); 
		int n = arr.length; 
		for (int i=0; i<n; ++i) 
			System.out.print(arr[i] + "" ""); 
		System.out.println();
	} 
} ",0,0,0,0,1,0,0,0,0
456,"from timing import timed_func
import random
@timed_func 
def bubble_sort(items):
    for i in range(len(items)): 
        already_sorted = True 
        for j in range(len(items) - i - 1): 
            if items[j] > items[j + 1]: 
                items[j], items[j + 1] = items[j + 1], items[j]
                already_sorted = False 
        if already_sorted:
            break
    return items
items = [random.randint(1000) for _ in range(1000)]
print(bubble_sort(items))",0,0,0,0,1,0,0,0,0
457,"def Bubble_Sort(A,n):
    for k in range(1,n):
        for i in range(0,n-1):
            if(A[i]>A[i+1]):
                A[i],A[i+1]=A[i+1],A[i]
if __name__==""__main__"":
    print(""Enter the elements in the array: "")
    A=[]
    A=list(map(int,input().split("" "")))
    n=len(A)
    Bubble_Sort(A,n)
    print(""Sorted Array: "",end="""")
    for i in range(0,n):
        print(A[i],end="" "")",0,0,0,0,1,0,0,0,0
458,"public class bubble_sort
{
    static void bubbleSort(int[] arr) {
        boolean swapped = true;
        for(int i=0; i<arr.length-1; i++) {
            swapped = false;
            for(int j=0; j<arr.length-i-1; j++) {
                if(arr[j] > arr[j+1]) {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                    swapped = true;
                }
            }
            if(swapped == false)
                break;
        }
    }
    static void printArray(int[] arr) {
        for(int i=0; i<arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
    }
    public static void main(String[] args) {
        int[] arr = {5, 2, 42, 6, 1, 3, 2};
        bubbleSort(arr);
        printArray(arr);
    }
}",0,0,0,0,1,0,0,0,0
459,"def sort(arr):
    alen = len(arr)
    while True:
        swapped = False
        for i in range(1, alen):
            if arr[i - 1] > arr[i]:
                arr[i - 1], arr[i] = arr[i], arr[i - 1]
                swapped = True
        if not swapped:
            break",0,0,0,0,1,0,0,0,0
460,"package part2;
public class Bubble_Sort{
	public static Comparable[] Bubble_Sort(Comparable[]a) {
		int last = a.length-1;
		boolean sorted = false;
		for(int i=0; i<last && !sorted; i++) {
			sorted = true;
			for(int j=last; j>i; j--) {
				if( less(a[j],a[j-1])) {
					swap(a,j,j-1);
					sorted = false;
				}
			}
		}
		return a;
	}
	private static boolean less(Comparable a, Comparable b) {
		if(a.compareTo(b) < 0) {
			return true;
		}
		return false;
	}
	private static void swap(Comparable[] a, int j, int i) {
		Comparable temp = a[j-1];
		a[j-1] = a[j];
		a[j]=temp;
	}
}",0,0,0,0,1,0,0,0,0
461,"def bubble_sort(lis):
    n = len(lis)
    while n > 0:
        temp_n = 0
        for i in range(1, n):
            if lis[i-1] > lis[i]:
                lis[i-1], lis[i] = lis[i], lis[i-1]
                temp_n = i
        n = temp_n
    return lis
def main():
    lis1 = [4, 1, 2, 3, 9]
    lis2 = [1]
    lis3 = [2, 2, 1, -1, 0, 4, 5, 2]
    lis4 = []
    lis1 = bubble_sort(lis1)
    assert lis1 == [1, 2, 3, 4, 9]
    lis2 = bubble_sort(lis2)
    assert lis2 == [1]
    lis3 = bubble_sort(lis3)
    assert lis3 == [-1, 0, 1, 2, 2, 2, 4, 5]
    lis4 = bubble_sort(lis4)
    assert lis4 == []
if __name__ == '__main__':
    main()",0,0,0,0,1,0,0,0,0
462,"import java.io.*;
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int[] a = new int[n];
        for(int a_i=0; a_i < n; a_i++){
            a[a_i] = in.nextInt();
        }
        int swap =0;
        for(int j = 0; j<n-1;j++)
        {
            for(int i = 0;i<n-1;i++)
            {
                if(a[i]>a[i+1])
                {
                    int temp = a[i];
                    a[i] = a[i+1];
                    a[i+1] = temp;
                    swap++;
                }
            }
        }   
        System.out.println(""Array is sorted in "" + swap +"" swaps. \nFirst Element: ""+ a[0] +""\nLast Element: ""+ a[n-1]);
    }
}",0,0,0,0,1,0,0,0,0
463,"def bubble_sort(arr):
    for i in range(len(arr)):
        for j in reversed(range(i+1, len(arr))):
            if arr[j] < arr[j-1]:
                arr[j], arr[j-1] = arr[j-1], arr[j]
    return arr",0,0,0,0,1,0,0,0,0
464,"def bubble_sort(arr):
    for mark in range(len(arr)-1, 0, -1):
        swapped = False
        for i in range(mark):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                swapped = True
        if not swapped:
            break
    return arr",0,0,0,0,1,0,0,0,0
465,"from strategy import Order, BadOrderError
import sys
__author__ = ""Pablo Acereda""
__copyright__ = ""Copyright 2020""
__credits__ = [ ""Pablo Acereda"" ]
__license__ = ""Apache License 2.0""
__version__ = ""1.0""
__maintainer__ = ""Pablo Acereda""
__email__ = ""p.aceredag@gmail.com""
def sort(array:list, order:Order=Order.ASC) -> list:
    if (order not in [Order.ASC, Order.DESC]):
        raise BadOrderError(""Not Valid Ordering Preference"")
    num_elements:int = len(array)
    for i in range(num_elements):
        swapped:bool = False
        for j in range(num_elements - i - 1):
            if   (order == Order.ASC):  
                if (array[j] > array[j + 1]):
                    array[j], array[j + 1] = array[j + 1], array[j]
                    swapped = True
            elif (order == Order.DESC): 
                if (array[j] < array[j + 1]):
                    array[j], array[j + 1] = array[j + 1], array[j]
                    swapped = True
        if not swapped:
            break
    return array        ",0,0,0,0,1,0,0,0,0
466,"import time
import random
def bubble_sort(data):
	for i in range(len(data) - 1):
		for j in range(len(data) - 1 - i):
			if data[j] > data[j+1]:
				data[j],data[j+1] = data[j+1],data[j]
if __name__ == '__main__':
	lista = [_ for _ in range(1000)]
 random.shuffle(lista)
 start_time = time.time()
 bubble_sort(lista)
 end_time = time.time()
 print(""Time: "", end_time - start_time)
 print(lista)",0,0,0,0,1,0,0,0,0
467,"from timeit import default_timer as timer
def bubble_sort(seq):
    changed = True
    while changed:
        changed = False
        for i in range(len(seq) - 1):
            if seq[i] > seq[i+1]:
                seq[i], seq[i+1] = seq[i+1], seq[i]
                changed = True
    return seq
if __name__ == '__main__':
    time_taken = 0
    x = int(input(""Enter number of trials : ""))
    for n in range(1,x+1):
        with open(""data/reverse.txt"",""r"") as fileobj:
            list_to_sort = list(map(int, fileobj.readlines()))
            start = timer()
            l=bubble_sort(list_to_sort)
            current = timer()-start
            print(f""Running test {n} : {current:.2f} seconds"")
            time_taken += current
    assert sorted(list_to_sort) == l
    time_taken /= 5
    print(f""Bubble sort: average time = {time_taken:.2f} seconds"")       ",0,0,0,0,1,0,0,0,0
468,"import copy
import sort_tools
def bubble_sort(data, low, high):
    for i in range(low, high):
        for j in range(low, high-low-1):
            if data[j] > data[j+1]:
                temp = data[j]
                data[j] =  data[j+1]
                data[j+1] = temp
@sort_tools.timeit('bubble')            
def sort(data):
    bubble_sort(data, 0, len(data))
def main():
    data = sort_tools.build_data_set(5)
    unsorted = copy.deepcopy(data)
    sort(unsorted)
if __name__ == ""__main__"":
    main()",0,0,0,0,1,0,0,0,0
469,"package src.algorithms;
import src.strategy.Order;
public class BubbleSort<T> extends SortingAlgorithm<T> {
	@Override
	@SuppressWarnings(""hiding"")
	public <T extends Comparable<T>> T[] sort(T[] elements, Order order) {		
		int numElements = elements.length;
		boolean swapped;
		for (int i=0; i < numElements - 1; i++) {
			swapped = false;
			for(int j=0; j < numElements-i-1; j++) {
				T current = elements[j];
				T next    = elements[j+1];
				if ((order == Order.ASC  && current.compareTo(next) > 0)  || 
					(order == Order.DESC && current.compareTo(next) < 0)) {
					this.swap(elements, j, j+1);
					swapped = true;
				}
			}
			if(!swapped) break;
		}
		return elements;
	}
}",0,0,0,0,1,0,0,0,0
470,"function bubbleSort (arrData) {
  'use strict'
  function _swap (arrData, numSrc, numTgt) {
    let swap = arrData[numSrc]
    arrData[numSrc] = arrData[numTgt]
    arrData[numTgt] = swap
  }
  let indexA = arrData.length
  console.log('Initial:', arrData.join(), `[Count:${indexA}]`)
  do {
    let indexB = 0
    for (let indexC = 0; indexC < indexA; indexC++) {
      if (arrData[indexC] > arrData[indexC + 1]) {
        _swap(arrData, indexC, indexC + 1)
        indexB = indexC
      }
    }
    indexA = indexB
    console.log('Cycle:', arrData.join())
  } while (indexA > 0)
  console.log('Final:', arrData.join())
  return arrData
}",0,0,0,0,1,0,0,0,0
471,"import numpy as np
def bubbleSort(arr):
    def swap(a, b):
        arr[a], arr[b] = arr[b], arr[a]
    length = len(arr)
    isSwapped = True
    x = -1
    while isSwapped:
        isSwapped = False
        x = x + 1
        for i in range(1, length - x):
            if arr[i-1] > arr[i]:
                swap(i-1, i)
                isSwapped = True
    for i in range(0, length):
        print(arr[i])
if __name__ == ""__main__"":
    arr = np.array([5, 6 , 1, 23, 87, 78, 98, 76])
    bubbleSort(arr)",0,0,0,0,1,0,0,0,0
472,"package javaSorting;
public class BubbleSort {
	public static void sort(int data[]) {
		for (int i = 0; i < data.length - 1; i++) {
			for (int j = 0; j < data.length - 1 - i; j++) {
				if (data[j] > data[j + 1]) {
					int temp = data[j];
					data[j] = data[j + 1];
					data[j + 1] = temp;
				}
			}
		}
	}
	private static void printSortedArray(int data[]) {
		for (int i = 0; i < data.length; i++) {
			System.out.println(data[i]);
		}
	}
	public static void main(String[] args) {
		int SIZE = 1000;
		int[] data = new int[SIZE];
		for (int i = 0; i < SIZE; i++) {
			data[i] = i;
		}
		Shuffle.shuffleData(data);
		long start = System.currentTimeMillis();
		sort(data);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		printSortedArray(data);
		System.out.println(elapsed);
	}
}",0,0,0,0,1,0,0,0,0
473,"export function bubblesort ( compare, a, i, j ) {
	const s = j - 1;
	let swapped ;
	do {
		swapped = false;
		for ( let k = i ; k < s ; ++k ) {
			if ( compare( a[k], a[k + 1] ) > 0 ) {
				const t = a[k];
				a[k] = a[k + 1];
				a[k + 1] = t;
				swapped = true;
			}
		}
	} while ( swapped );
}",0,0,0,0,1,0,0,0,0
474,"def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp
def bubblesort(array):
    n = len(array)-1
    for i in range(0, len(array)):
        for j in range(0, n):
            if array[j] > array[j+1]:
                swap(array, j+1, j)
        n -= 1
if __name__ == ""__main__"":
    array = [17, 9, 13, 8, 7, -5, 6, 11, 3, 4, 1, 2]
    bubblesort(array)
    print array",0,0,0,0,1,0,0,0,0
475,"import java.util.Scanner;
public class BubbleSort {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements : "");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter "" + n + "" elements :"");
        for (int i = 0; i < n; i++)
            arr[i] = sc.nextInt();
        bubbleSort(arr);
        System.out.println(""\nThe sorted array : ;"");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    static void bubbleSort(int arr[]) {
        int len = arr.length, tmp;
        boolean flag;
        for (int i = 0; i < len; i++) {
            flag = false;
            for (int j = 0; j < len - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag)
                break;
        }
    }
}",0,0,0,0,1,0,0,0,0
476,"let bubbleLoop = (first) => {
    if (typeof first !== ""object"") {
        return [""invalid list""];
    }
    var i = 0;
    for (i; i < first.length - 1; i++) {
        var k = i + 1;
        for(k; k < first.length; k++) {
            var compareFirst = first[i];
            var compareSecond = first[k];
            if (compareSecond < compareFirst) {
                first[i] = compareSecond;
                first[k] = compareFirst;
            }
        }
    }
    return first;
}",0,0,0,0,1,0,0,0,0
477,"def bubbleSort(arr):
    length = len(arr) 
    for i in range(length): 
        for j in range(0,length-i-1): 
            if arr[j]>arr[j+1]: 
                arr[j], arr[j+1] = arr[j+1], arr[j] 
    return arr
def bubbleSortOptimized(arr):
    length = len(arr) 
    for i in range(length): 
        for j in range(0,length-i-1): 
            swapped = False 
            if arr[j]>arr[j+1]: 
                arr[j], arr[j+1] = arr[j+1], arr[j] 
                swapped = True
        if swapped==False:
            break 
    return arr
arr = [3,5,2,4,0,1]
sorted_arr = bubbleSort(arr)
print(sorted_arr)
arr = [3,5,2,4,0,1]
sorted_arr = bubbleSortOptimized(arr)
print(sorted_arr)",0,0,0,0,1,0,0,0,0
478,"public class BubbleSort
{
    private int[] A;
    public BubbleSort(int[] data)
    {
        A = data;
    }
    public int[] sort()
    {
        int i, j;
        for(i=0; i<A.length-1; i++)
        {
            for(j=0; j<A.length-1-i; j++)
            {
                if(A[j+1] < A[j])
                {
                    swap(A, j, j+1);
                }
            }
        }
        return A;
    }
    private void swap(int[] A, int u, int v)
    {
        int temp;
        temp = A[u];
        A[u] = A[v];
        A[v] = temp;
    }
}",0,0,0,0,1,0,0,0,0
479,"function swap(A, u, v) {
    var temp = A[u];
    A[u] = A[v];
    A[v] = temp;
    return;
}
function Bubblesort(A) {
    a_len = A.length;
    for(var i = 0; i < a_len-1; i++) {
        for(var j = 0; j < a_len-1-i; j++) {
            if (A[j+1] < A[j]) {
                swap(A, j, j+1);
            }
        } 
    }
    return A;
}
var X = [5,21,40,11,3,1,7,2,4,6,10,18,9,8];
console.log(X);
Bubblesort(X);
console.log(X);",0,0,0,0,1,0,0,0,0
480,"def bubbleSort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if swapped is False:
            break
arr = [64, 34, 25, 12, 22, 11, 90]
bubbleSort(arr)
print(""Sorted array :"")
for i in range(len(arr)):
    print(""%d"" % arr[i], end="" "")",0,0,0,0,1,0,0,0,0
481,"import java.util.Arrays;
public class BubbleSort {
	private int [] input;
	public BubbleSort(int [] input){
		this.input = input.clone();
	}
	public int [] sort(){
		if (this.input == null)  
			return null;
		for (int i = 0; i < this.input.length; i++) {
			for (int j = i + 1; j < this.input.length; j++) {
				if (this.input[i] > this.input[j]){
					swap(i,j);
				}
			}
		}
		return this.input;
	}
	private void swap(int i, int j){  
		int tmp = this.input[i];
		this.input[i] = this.input[j];
		this.input[j] = tmp;
	}
	public static void main(String[] args) {
		int array[] = {9,1,0,4,2,-1,5,2, 200, 99, 45, -100};
		BubbleSort bubblesort = new BubbleSort(array);
		System.out.println(""Unsorted Array -> ""+ Arrays.toString(array));
		System.out.println(""BubbleSort -> ""+ Arrays.toString(bubblesort.sort()));  
	}
}",0,0,0,0,1,0,0,0,0
482,"const bubbleSort = (numArray) => {
    let rotated;
    do {
      rotated = false;
      for (let i = 0; i < numArray.length-1; i++) {
        if (numArray[i] > numArray[i+1]) {
          store = numArray[i];
          numArray[i] = numArray[i+1];
          numArray[i+1] = store;
          rotated = true;
        }
      }
    } while (rotated === true)
    return numArray
  }",0,0,0,0,1,0,0,0,0
483,"class BubbleSort:
    def sort(A):
        def swap(A, u, v):
            temp = A[u]
            A[u] = A[v]
            A[v] = temp
            return
        a_len = len(A)
        for i in range(0, a_len-1):
            for j in range(0, a_len-1-i):
                if (A[j+1] < A[j]):
                    swap(A, j, j+1)
        return A",0,0,0,0,1,0,0,0,0
484,"package org.neeraj.algorithms.sorting;
public class BubbleSort implements Sorter{
	@Override
	public void sort(Comparable[] array)
    {
		int n = array.length;
		int i, j;
		Comparable temp;
		for(i=0;i<n;i++)
			System.out.println(array[i]);
        boolean swapped;
        for (i = 0; i < n - 1; i++) 
        {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) 
            {
                if (compare(array[j],array[j + 1])==1) 
                {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    swapped = true;
                }
            }
            if (swapped == false)
                break;
        }        
    }
	 private int compare(Comparable x, Comparable y)
	    {
		    return x.compareTo(y);
	    }
}",0,0,0,0,1,0,0,0,0
485,"def BubbleSort(list):
    n = len(list)
    for i in range(n):
        swapped = False
        for j in range(0, n-1-i):
            if list[j] > list[j+1]:
                list[j], list[j+1] = list[j+1], list[j]
                swapped = True
        else:
            if not swapped:
                break",0,0,0,0,1,0,0,0,0
486,"package com.aokolnychyi.sorting;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
public class BubbleSort {
  public static <T extends Comparable<? super T>> void sort(List<T> elements) {
    final int numberOfElements = elements.size();
    for (int outerIndex = 0; outerIndex < numberOfElements; outerIndex++) {
      for (int innerIndex = numberOfElements - 1; innerIndex > outerIndex; innerIndex--) {
        final T currentElement = elements.get(innerIndex);
        final T nextElement = elements.get(innerIndex - 1);
        if (currentElement.compareTo(nextElement) < 0) {
          Collections.swap(elements, innerIndex, innerIndex - 1);
        }
      }
    }
  }
  public static <T extends Comparable<T>> void sort(T[] elements) {
    for (int lowestIndex = 0; lowestIndex < elements.length; lowestIndex++) {
      for (int currentIndex = elements.length - 1; currentIndex > lowestIndex; currentIndex--) {
        final T currentElement = elements[currentIndex];
        final T nextElement = elements[currentIndex - 1];
        if (currentElement.compareTo(nextElement) < 0) {
          elements[currentIndex] = nextElement;
          elements[currentIndex - 1] = currentElement;
        }
      }
    }
  }
  public static void main(String[] args) {
    final List<Integer> list = new ArrayList<>();
    list.add(4);
    list.add(1);
    list.add(5);
    list.add(3);
    list.add(9);
    list.add(10);
    list.add(1);
    sort(list);
    System.out.println(list);
    final Integer[] ints = new Integer[]{4, 1, 5, 3, 9, 10, 1};
    sort(ints);
    System.out.println(Arrays.toString(ints));
  }
}",0,0,0,0,1,0,0,0,0
487,"def bubble_sort(nums):
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                swapped = True
random_list_of_nums = [5, 2, 1, 8, 4]
bubble_sort(random_list_of_nums)
print(random_list_of_nums)",0,0,0,0,1,0,0,0,0
488,"package sorting;
import static sorting.Sorting.print;
class bubbleSort {
    static void bubblesort(int a[]){
        boolean swappedElement = false;
        sort:for(int i=0;i<a.length;i++){
                for (int j=0; j < a.length-1; j++) {
                    if(a[j]>a[j+1]){
                        swap(a, j, j+1);
                        swappedElement=true;
                    }
                }
                if(!swappedElement){
                  break sort;
                }
            }
    }
    static void swap(int a[],int p,int q){
                    int temp = a[p];
                    a[p]=a[q];
                    a[q]=temp;
    }
}",0,0,0,0,1,0,0,0,0
489,"def bubbleSort(arr):
	n = len(arr)
 for i in range(n):
		for j in range(0, n-i-1):
			if arr[j] > arr[j+1] :
				arr[j], arr[j+1] = arr[j+1], arr[j]
arr = [64, 34, 25, 12, 22, 11, 90]
bubbleSort(arr)
print (""Sorted array is:"")
for i in range(len(arr)):
	print (""%d"" %arr[i]), ",0,0,0,0,1,0,0,0,0
490,"package me.gilday.revision.sorting.bubble;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class BubbleSort {
	private static Logger logger = LoggerFactory.getLogger(BubbleSort.class);
	private static int passes = 0;
	public static void sort(int[] values) {
		logger.trace(""Sorting: {}"", values);
		boolean swapped = false;
		passes = 0;
		do {
			passes++;
			swapped = false;
			for (int i = 0; i < values.length - 1; i++) {
				if (values[i] > values[i + 1]) {
					int temp = values[i];
					values[i] = values[i + 1];
					values[i + 1] = temp;
					swapped = true;
				}
			}
			logger.trace(""Aftet pass {} : {}"", passes, Arrays.toString(values));
		} while (swapped);
	}
	public static void sortFixedPasses(int[] values) {
		int n = values.length;
		for (int pass = 1; pass < n; pass++) {
			for (int i = 0; i < n - pass; i++) {
				if (values[i] > values[i + 1]) {
					int temp = values[i];
					values[i] = values[i + 1];
					values[i + 1] = temp;
				}
			}
		}
	}
	public static int getPasses() {
		return passes;
	}
}",0,0,0,0,1,0,0,0,0
491,"from time import sleep
from typing import List
from tkinter import Tk
from animated import Animator
class BubbleSort(Animator):
    def sort(self, array: List[int]) -> None:
        for amt in range(len(array)):
            swaps = 0
            for i in range(len(array) - 1 - amt):  
                if array[i] > array[i + 1]:  
                    array[i], array[i + 1] = array[i + 1], array[i]
                    swaps += 1
                    self.render(array, cur=(i, i + 1))
                    sleep(0.01)
            if swaps == 0:
                break  
def main() -> int:
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    shuffledArray = randomSequence(0, 100)
    root = Tk()
    sorter = BubbleSort(
        root,
        background=""black"",
        width=root.winfo_screenwidth(),
        height=root.winfo_screenheight(),
    )
    sorter.pack()
    sorter.sort(shuffledArray)
    sorter.finished()
    return 0",0,0,0,0,1,0,0,0,0
492,"package main;
public class BubbleSort {
    public static void main(String[] args) {
        BubbleSort bubbleSort = new BubbleSort();
        int[] array = {1, 2, 4, 5, 6, 9, 10};
        bubbleSort.sort(array);
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }
    public int[] sort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            boolean sorted = true;
            for (int j = 1; j < array.length - i; j++) {
                if (array[j - 1] > array[j]) {
                    sorted = false;
                    int tmp = array[j - 1];
                    array[j - 1] = array[j];
                    array[j] = tmp;
                }
            }
            if (sorted) break;
        }
        return array;
    }
}",0,0,0,0,1,0,0,0,0
493,"def bubbleSort(arr):
    n = len(arr)
    for i in range(n-1):
        for j in range(0, n-i-1):
            if arr[j] > arr[j + 1] :
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
arr = [64, 34, 25, 12, 22, 11, 90]
bubbleSort(arr)
print (""Sorted array is:"")
for i in range(len(arr)):
    print (""% d"" % arr[i]),",0,0,0,0,1,0,0,0,0
494,"package eu.happycoders.sort.method.bubblesort;
import eu.happycoders.sort.method.*;
public class BubbleSort implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    int numElements = elements.length;
    for (; ; ) {
      boolean swapped = false;
      for (int i = 0; i < numElements - 1; i++) {
        int left = elements[i];
        int right = elements[i + 1];
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          swapped = true;
        }
      }
      if (!swapped) break;
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    int numElements = elements.length;
    for (; ; ) {
      counters.incIterations();
      boolean swapped = false;
      for (int i = 0; i < numElements - 1; i++) {
        counters.incIterations();
        int left = elements[i];
        int right = elements[i + 1];
        counters.addReads(2);
        counters.incComparisons();
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          counters.addWrites(2);
          swapped = true;
        }
      }
      if (!swapped) break;
    }
  }
}",0,0,0,0,1,0,0,0,0
495,"bubbleSort = function(array) {
  var isSorted = true,
      a = array.slice(0);
  for (var i = 0, l = a.length - 1; i < l; i++) {
    if (a[i] > a[i + 1]) {
      a[i] = a[i + 1] + (a[i + 1] = a[i], 0);
      isSorted = false;
    }
  }
  return isSorted ? a : bubbleSort(a);
};",0,0,0,0,1,0,0,0,0
496,"function bubbleSort(array) {
  for (let i = 0; i < array.length; i++) {
    let swaps = 0;
    for (let j = 0; j < array.length - i; j++) {
      if (array[j + 1] < array[j]) {
        const temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
        swaps++;
      }
    }
    if (!swaps) {
      break;
    }
  }
}
let myArray = [3, 7, 5, 6, 4, 2];
bubbleSort(myArray);
console.log(myArray);
myArray = [1, 2, 3, 4, 5];
bubbleSort(myArray);
console.log(myArray);
myArray = [5, 4, 3, 2, 1];
bubbleSort(myArray);
console.log(myArray);",0,0,0,0,1,0,0,0,0
497,"def bubbleSort(arr):
    n = len(arr)
    for i in range(n-1):
        for j in range(0, n-i-1):
            if arr[j] > arr[j + 1] :
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
arr = [64, 34, 25, 12, 22, 11, 90]
print (""Unsorted array is:"")
for i in range(len(arr)):
    print (""% d"" % arr[i]),
bubbleSort(arr)
print (""\nSorted array is:"")
for i in range(len(arr)):
    print (""% d"" % arr[i]),",0,0,0,0,1,0,0,0,0
498,"package Sorts;
import static Sorts.SortUtils.*;
class BubbleSort implements SortAlgorithm {
    @Override
    public  <T extends Comparable<T>> T[] sort(T array[]) {
        int last = array.length;
        boolean swap;
        do {
            swap = false;
            for (int count = 0; count < last-1; count++) {
                if (less(array[count], array[count + 1])) {
                    swap = swap(array, count, count + 1);
                }
            }
            last--;
        } while (swap);
        return array;
    }
    public static void main(String[] args) {
        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        BubbleSort bubbleSort = new BubbleSort();
        bubbleSort.sort(integers);
        print(integers);
        String[] strings = {""c"", ""a"", ""e"", ""b"",""d""};
        print(bubbleSort.sort(strings));
    }
}",0,0,0,0,1,0,0,0,0
499,"import time
numbers = []
def bubble_sort():
     for passesLeft in range(len(numbers)-1, 0, -1):
         for index in range(passesLeft):
             if numbers[index] > numbers[index + 1]:
                numbers[index], numbers[index + 1] = numbers[index + 1], numbers[index]   
def read_from_file(filepath):
    del numbers[:] 
    file = open(filepath, ""r"")
    for i in file:
        numbers.append(int(i))
def print_first_ten_number():
    print numbers[0:9]
def print_last_ten_number():
    print numbers[len(numbers)-10:len(numbers)]
def append_result_to_file(str):
    with open(""results.txt"", ""a"") as result:
        result.write(str+""\n"")
        result.close()
if __name__ == '__main__':
    read_from_file(""../1k.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""1k = "" + str(end-start))
    read_from_file(""../10k.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""10k = "" + str(end-start))
    read_from_file(""../100k.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""100k = "" + str(end-start))
    read_from_file(""../1m.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""1m = "" + str(end-start))
    read_from_file(""../2m.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""2m = "" + str(end-start))     
    read_from_file(""../4m.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""4m = "" + str(end-start))
    read_from_file(""../8m.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""8m = "" + str(end-start))
    read_from_file(""../10m.lst"")
    start = time.clock()
    bubble_sort()
    end = time.clock()
    append_result_to_file(""10m = "" + str(end-start))     ",0,0,0,0,1,0,0,0,0
500,"package com.deepak.algorithms.Sorting;
import com.deepak.algorithms.Library.ArrayUtils;
public class BubbleSort {
	public static Integer[] performBubbleSort(Integer[] list) {
		for (int i = 0; i < list.length; i++) {
			for (int j = 1; j < (list.length - i); j++) {
				if (list[j - 1] > list[j]) {
					ArrayUtils.swap(list, j - 1, j);
				}
			}
		}
		return list;
	}
}",0,0,0,0,1,0,0,0,0
501,"import time 
def BubbleSort(data, drawDataArray, sortSpeedTime):
    for _ in range(len(data)-1):
        for j in range(len(data)-1):
            if data[j] > data[j+1]:
                data[j], data[j+1] = data[j+1], data[j]
                drawDataArray(data, ['purple' if x == j or x == j+1 else 'red' for x in range(len(data))] )
                time.sleep(sortSpeedTime)",0,0,0,0,1,0,0,0,0
502,"package sortvisualiser.algorithms;
import sortvisualiser.SortArray;
public class BubbleSort implements ISortAlgorithm {
    private long stepDelay = 2;
    @Override
    public void runSort(SortArray array) {
        int len = array.arraySize();
        for (int i = 0; i < len - 1; i++) {
            for (int j = 0; j < len - i - 1; j++) {
                if (array.getValue(j) > array.getValue(j + 1)) {
                    array.swap(j, j + 1, getDelay(), true);
                }
            }
        }
    }
    @Override
    public String getName() {
        return ""Bubble Sort"";
    }
    @Override
    public long getDelay() {
        return stepDelay;
    }
    @Override
    public void setDelay(long delay) {
        this.stepDelay = delay;
    }
}",0,0,0,0,1,0,0,0,0
503,"import time
from colors import *
def bubble_sort(data, drawData, timeTick):
    size = len(data)
    for i in range(size-1):
        for j in range(size-i-1):
            if data[j] > data[j+1]:
                data[j], data[j+1] = data[j+1], data[j]
                drawData(data, [YELLOW if x == j or x == j+1 else BLUE for x in range(len(data))] )
                time.sleep(timeTick)
    drawData(data, [BLUE for x in range(len(data))])",0,0,0,0,1,0,0,0,0
504,"package com.calebkoy.sortingalgovisualiser;
import java.util.ArrayList;
public class BubbleSort {
    private static final String NAME = ""Bubblesort"";
    public void sort(ArrayList<Integer> data) {
        if (data == null) {
            throw new IllegalArgumentException(""The data should not be null"");
        }
        for (int i = 0; i < data.size() - 1; i++) {
            for (int j = data.size() - 1; j > i; j--) {
                if (data.get(j) < data.get(j - 1)) {
                    swap(data, j);
                }
            }
        }
    }
    public void swap(ArrayList<Integer> data, int key) {
        if (data == null) {
            throw new IllegalArgumentException(""The data should not be null"");
        }
        if ((key < 0) || (key > data.size() - 1)) {
            throw new IllegalArgumentException(""The key should be a valid index of the array, but key is "" +
                    key + "" and the array has size "" + data.size());
        }
        int temp = data.get(key);
        data.set(key, data.get(key - 1));
        data.set(key - 1, temp);
    }
    public static String getName() {
        return NAME;
    }
}",0,0,0,0,1,0,0,0,0
505,"import time
def sort(bar, layout, num, colors):
    data = list(bar.y)
    count = 0
    for i in range(num):
        for j in range(num-i-1):
            if data[j] > data[j+1]:
                colors[j] = 'crimson'
                colors[j+1] = 'crimson'
                time.sleep(0.1)
                bar.marker.color = colors
                data[j], data[j+1] = data[j+1], data[j]
                bar.y = data
            else:
                colors[j] = 'green'
                colors[j+1] = 'green'
                time.sleep(0.1)
                bar.marker.color = colors
            colors[j] = 'lightslategray'
            colors[j+1] = 'lightslategray'
            bar.marker.color = colors
            count = count + 1
            layout.xaxis.title.text = ""Number of operations: "" + str(count)
        colors[num-i-1] = 'blue'
        bar.marker.color = colors",0,0,0,0,1,0,0,0,0
506,"package bubble_sort;
import java.util.Arrays;
public class BubbleSort {
    public void sort(int[] array) {
        int n = array.length;
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            for (int j = 1; j < n - i; j++) {
                if (array[j - 1] > array[j]) {
                    int temp = array[j - 1];
                    array[j - 1] = array[j];
                    array[j] = temp;
                    swapped = true;
                }
            }
            if (!swapped) {
                break;
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
507,"package Jacob.Sorts;
import Jacob.*;
public class BubbleSort implements Runnable{
	private Integer[] toBeSorted;
	private VisualizerFrame frame;
	private boolean fast;
	public BubbleSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) {
		this.toBeSorted = toBeSorted;
		this.frame = frame;
		this.fast = fast;
	}
	public void run() {
		if (fast) {
			sortFast();
		} else {
			sortSlow();
		}
		SortingVisualizer.isSorting=false;
	}
	public void sortFast() {
		int temp = 0;
		boolean swapped = false;
		for(int i = 0; i<toBeSorted.length-1; i++){
			swapped = false;
			for(int j = 1; j<toBeSorted.length-i; j++){
				if (toBeSorted[j-1]> toBeSorted[j]){
					temp = toBeSorted[j-1];
					toBeSorted[j-1] = toBeSorted[j];
					toBeSorted[j]= temp;
					swapped = true;
				}
			}
			frame.reDrawArray(toBeSorted);
			try {
				Thread.sleep(SortingVisualizer.sleep);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			if (!swapped) break;
		}
	}
	public void sortSlow() {
		int temp = 0;
		boolean swapped = false;
		for(int i = 0; i<toBeSorted.length-1; i++){
			swapped = false;
			for(int j = 1; j<toBeSorted.length-i; j++){
				if (toBeSorted[j-1]> toBeSorted[j]){
					temp = toBeSorted[j-1];
					toBeSorted[j-1] = toBeSorted[j];
					toBeSorted[j]= temp;
					swapped = true;
				}
				frame.reDrawArray(toBeSorted, j, j+1);
				try {
					Thread.sleep(SortingVisualizer.sleep);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			if (!swapped) break;
		}
	}
}",0,0,0,0,1,0,0,0,0
508,"package com.mehmetpekdemir.sort.bubblesort;
import com.mehmetpekdemir.shared.Util;
public final class BubbleSort {
	public static void sort(int[] array) {
		boolean flag = true;
		for (int lastUnsortedIndex = array.length - 1; lastUnsortedIndex > 0; lastUnsortedIndex--) {
			for (int i = 0; i < lastUnsortedIndex; i++) {
				if (array[i] > array[i + 1]) {
					flag = false;
					Util.swap(array, i, i + 1);
				}
			}
			if (flag == true) {
				System.out.println(""Already sorted."");
				break;
			}
		}
	}
}",0,0,0,0,1,0,0,0,0
509,"package sorting;
public class BubbleSort<T extends Comparable<T>> implements Sort<T> {
    @Override
    public void sort(T[] items) {
        boolean sorted = false;
        for (int i = 0; !sorted && i < items.length; i++) {
            sorted = true;
            for (int j = 0; j < items.length; j++) {
                if (items[i].compareTo(items[j]) < 0) {
                    SortUtils.swap(items, i, j);
                    sorted = false;
                }
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
510,"package dev.jeffreybender.sort;
import java.util.Comparator;
public final class BubbleSort {
    private BubbleSort() {
    }
    public static <T> void sort(T[] array, Comparator<? super T> comparator) {
        if (array.length <= 1) {
            return;
        }
        if (comparator == null) {
            comparator = SortUtils.getDefaultComparator();
        }
        boolean didSwap;
        int endIndex = array.length;
        do {
            didSwap = false;
            for (int i = 1; i < endIndex; i++) {
                T o1 = array[i - 1];
                T o2 = array[i];
                if (comparator.compare(o1, o2) > 0) {
                    SortUtils.swap(array, i - 1, i);
                    didSwap = true;
                }
            }
            endIndex--;
        } while (didSwap);
    }
    public static <T extends Comparable<? super T>> void sort(T[] array) {
        sort(array, null);
    }
}",0,0,0,0,1,0,0,0,0
511,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class BubbleSort extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new BubbleSort();
	public void sort(SortArray array) {
		for (int i = array.length(); i >= 1; i--) {
			for (int j = 0; j < i - 1; j++)
				array.compareAndSwap(j, j + 1);
			array.setElement(i - 1, SortArray.ElementState.DONE);
		}
	}
	private BubbleSort() {
		super(""Bubble sort"");
	}
}",0,0,0,0,1,0,0,0,0
512,"package com.dev.namhoai.sort;
public class BubbleSort {
    public static <T extends Comparable> void sort(T[] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 1; j < a.length - i; j++) {
                if (a[j - 1].compareTo(a[j]) > 0) {
                    T temp = a[j - 1];  
                    a[j - 1] = a[j];
                    a[j] = temp;
                }
            }
        }
    }
    public static void sortSimple(int[] a) {
        for (int i = 0; i < a.length; i++) {
            boolean sorted = true;  
            for (int j = 1; j < a.length - i; j++) {
                if (a[j] < a[j - 1]) {  
                    int temp = a[j - 1];
                    a[j - 1] = a[j];
                    a[j] = temp;
                    sorted = false;
                }
            }
            if (sorted) break;
        }
    }
}",0,0,0,0,1,0,0,0,0
513,"require('../../../common/array-extensions');
const { isEmpty, isFunction } = require('../../../common/utils');
const bubbleSort = function(list) {
    if (isEmpty(list)) {
        return list;
    }
    if (list.length < 2) {
        return list;
    }
    const allItemsComparable = list.reduce(
        (acc, item) => (acc &= isFunction(item.compareTo)),
        true
    );
    for (let lastUnsortedIndex = list.length - 1; lastUnsortedIndex > 0; lastUnsortedIndex--) {
        for (let i = 0; i < lastUnsortedIndex; i++) {
            if (allItemsComparable) {
                if (list[i].compareTo(list[i + 1]) > 0) {
                    list.swap(i, i + 1);
                }
            } else {
                if (list[i] > list[i + 1]) {
                    list.swap(i, i + 1);
                }
            }
        }
    }
    return list;
};
module.exports = { bubbleSort };",0,0,0,0,1,0,0,0,0
514,"const swap = (array, i, j) => {
  let temp = array[i];
  array[i] = array[j];
  array[j] = temp;
};
const bubbleSort = array => {
  let swapped = true;
  while (swapped) {
    swapped = false;
    for (let j = 0; j < array.length - 1; j++) {
      if (array[j + 1] < array[j]) {
        swap(array, j, j + 1);
        swapped = true;
      }
    }
  }
};
const array = [4, 5, 1, 3, 2];
bubbleSort(array);
console.log(array);",0,0,0,0,1,0,0,0,0
515,"def bubble_sort(list):
    swaped = True
    while swaped:
        swaped = False
        for j in range(0, len(list) - 1):
            if list[j] > list[j + 1]:
                swap(list, j, j + 1)
                swaped = True
    return list
def swap(list, index_one, index_two):
    temp = list[index_one]
    list[index_one] = list[index_two]
    list[index_two] = temp
array = [1, 5, 65, 23, 57, 1232, -1, -5, -2, 242, 100,
         4, 423, 2, 564, 9, 0, 10, 43, 64, 32, 1, 999]
print(array)
bubble_sort(array)
print(array)",0,0,0,0,1,0,0,0,0
516,"package Sorting;
import java.util.ArrayList;
import java.util.Scanner;
public class BubbleSort {
    public static void main(String[] args) {
        ArrayList<Integer> elements = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            elements.add(sc.nextInt());
        }
        sc.close();
        int elements_array[] = new int[elements.size()];
        for (int i = 0; i < elements.size(); i++) {
            elements_array[i] = elements.get(i);
        }
        elements_array = doBubbleSort(elements_array);
        for (int anElement : elements_array) {
            System.out.println(anElement);
        }
    }
    private static int[] doBubbleSort(int[] elements_array) {
        for (int i = 0; i < elements_array.length; i++) {
            for (int j = 0; j < elements_array.length - 1 - i; j++) {
                if (elements_array[j] > elements_array[j + 1]) {
                    doSwap(elements_array, j, j + 1);
                }
            }
        }
        return elements_array;
    }
    private static void doSwap(int[] elements_array, int i, int j) {
        int temp = elements_array[i];
        elements_array[i] = elements_array[j];
        elements_array[j] = temp;
    }
}",0,0,0,0,1,0,0,0,0
517,"package ie.peternagy.algorithms.sorting;
public class BubbleSort{
    public static void sort(Comparable[] items) {
        sort(items, true);
    }
    public static void sort(Comparable[] items, boolean sortAsc) {
        int arrayLength = items.length;
        for (int i = 0; i < arrayLength; i++) {
            for (int j = 1; j < (arrayLength - i); j++) {
                if ((sortAsc && items[j - 1].compareTo(items[j]) > 0)
                        || (!sortAsc && items[j - 1].compareTo(items[j]) < 0)) {
                    swapItems(items, j - 1, j);
                }
            }
        }
    }
    protected static void swapItems(Comparable[] items, int indexOne, int indexTwo) {
        Comparable tmp = items[indexOne];
        items[indexOne] = items[indexTwo];
        items[indexTwo] = tmp;
    }
}",0,0,0,0,1,0,0,0,0
518,"package com.zhokhov.interview.sorting;
import static com.zhokhov.interview.util.Console.*;
public class BubbleSort {
    private int COMPARISONS_COUNT;
    private int SWAPS_COUNT;
    private int LOOP_COUNT;
    public void sort(int[] array) {
        COMPARISONS_COUNT = 0;
        SWAPS_COUNT = 0;
        LOOP_COUNT = 0;
        for (int reverseIndex = array.length - 1; reverseIndex > 1; reverseIndex--) {
            LOOP_COUNT++;
            ____grey(""------\nreverseIndex: "" + reverseIndex);
            for (int i = 0; i < reverseIndex; i++) {
                LOOP_COUNT++;
                ____grey(""i: "" + i);
                COMPARISONS_COUNT++;
                if (array[i] > array[i + 1]) {
                    SWAPS_COUNT++;
                    ____blue(""Swapping: "" + i + "" and "" + (i + 1));
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                    __red(""==> "");
                    __dump(array);
                    System.out.println("""");
                }
            }
        }
    }
    public static void main(String[] args) {
        int array[] = {7, 1, 8, 2, 0, 12, 10, 6, 5, 3};
        __yellow(""\nNew array: "");
        __dump(array);
        System.out.println(""\nSorting\n"");
        BubbleSort bubbleSort = new BubbleSort();
        bubbleSort.sort(array);
        __green(""\nResult: "");
        __dump(array);
        ____grey(""\nStatistics"");
        __green(""  Comparisons: "");
        System.out.print(bubbleSort.COMPARISONS_COUNT);
        __green(""\n  Swaps: "");
        System.out.print(bubbleSort.SWAPS_COUNT);
        __green(""\n  Loops: "");
        System.out.println(bubbleSort.LOOP_COUNT);
    }
}",0,0,0,0,1,0,0,0,0
519,"package sortlab.algorithm;
import sortlab.algorithm.util.Helper;
import java.util.Comparator;
public final class BubbleSort<T> implements SortAlgorithmInterface<T> {
  public int passes = 0;  
  public long swaps = 0;  
  private final Comparator<T> comparator;
  private Helper<T> helper;
  public BubbleSort(Class<T> of, Comparator<T> comparator) {
    this.comparator = comparator;
    this.helper = new Helper<T>(of);
  }
  public T[] sort(T[] input) {
    int size = input.length;
    T[] sorted = helper.copyOf(input);
    boolean swapped;
    do {
      swapped = false;
      for(int n = 0; n < (size-1); n++) {
        int comparison = comparator.compare(sorted[n], sorted[n+1]);
        if(comparison > 0) {  
          T temp_left = sorted[n];
          T temp_right = sorted[n+1];
          sorted[n] = temp_right;
          sorted[n+1] = temp_left;
          swapped = true;  
          this.swaps += 1;
        }
      }
      this.passes += 1;  
    } while(swapped);
    return sorted;
  }
}",0,0,0,0,1,0,0,0,0
520,"package raymond.com.sorting;
public class BubbleSort extends Sorting
{
	private int [] numberArray;
	public BubbleSort(int [] array)
	{
		numberArray = array;
	}
	public int [] sort()
	{
		int swaps = 0;
		int comps = 0;
		for (int i = 0; i < numberArray.length; i ++)
		{
			for (int j = 0; j < numberArray.length - 1; j ++ )
			{
				comps++;
				if (numberArray[j] > numberArray[j+1])
				{
				swap(numberArray,j,j+1);
				swaps++;
				}
			}
		}
		System.out.println(comps + ""comparisons"");
		System.out.println(swaps + ""swaps"");
		return numberArray;
	}
}",0,0,0,0,1,0,0,0,0
521,"package ec; 
import java.util.ArrayList;
public class BubbleSort<T extends Comparable<T>> implements SortingAlgorithms {
	private ArrayList<T> blist = null;
	private long comparisons = 0;
	private long swaps = 0;
	private long runtime = 0;
	long start;
	long end;
	public BubbleSort() {
		ArrayList<T> b =  new ArrayList<T>();
		blist = b;
		sortingAlgorithms();
	}
	public ArrayList<T> bubbleSort(ArrayList<T> list1) {
		long comp = 0;
		long swap = 0;
		start = System.currentTimeMillis();
		for(int i = 1 ; i <= list1.size() - 1 ; i++) {
			for(int j = 0 ; j <= list1.size() - 2 ; j++) {
				comp++;
				if(list1.get(j).compareTo(list1.get(j + 1)) > 0) {
					swap++;
					T current;
					current = list1.get(j);
					list1.set(j, list1.get(j + 1));
					list1.set(j + 1, current);
				}	
			}
		}
		this.comparisons = comp;
		this.swaps = swap;
		end = System.currentTimeMillis();
		long runtimes = end - start;
		this.runtime = runtimes;
		return list1;
	}
	public void sortingAlgorithms() {
		bubbleSort(blist);
	}
	public ArrayList<T> print(ArrayList<T> bubble) {
		ArrayList<T> bs = new ArrayList<T>();
		for(int i = 0 ; i < bubble.size() ; i++) {
			bs.add(bubble.get(i));
		}
		return bs;
	}
	public void compare() {
		System.out.print(""Comparisons: "" + comparisons + ""\t\t"");
	}
	public void swap() {
		System.out.print(""Swaps: "" + swaps);
	}
	public void runtime() {
		System.out.print(""Runtime: ""  + runtime + "" ms"");
	}
	public long getComparisons() {
		return this.comparisons;
	}
	public long getSwaps() {
		return this.swaps;
	}
	public void setList(ArrayList<T> list) {
		this.blist = list;
	}
	public void setComparisons(long comparisons) {
		this.comparisons = comparisons;
	}
	public void setSwaps(long swaps) {
		this.swaps = swaps;
	}
	public ArrayList<T> getList() {
		return blist;
	}
}",0,0,0,0,1,0,0,0,0
522,"public class BubbleSort {
	public static void sort(int list[]) {
		for (boolean swapped = true; swapped == true;) {
			swapped = false;
			for (int i = 0; i < list.length-1; i++) {
				if (list[i] > list[i+1]) {
					Compare.swap(list, i, i+1);
					swapped = true;
				}
			}
		}
	}
}",0,0,0,0,1,0,0,0,0
523,"package org.manoj.ds.sort;
import java.time.Duration;
import java.time.Instant;
import org.apache.log4j.Logger;
public class BubbleSort implements Sort {
    final static Logger logger = Logger.getLogger(BubbleSort.class);
    private SortingMetadata metadata = null;
    @Override
    public <E extends Comparable<E>> void sort(E[] elements) {
        sort(elements, true);
    }
    @Override
    public <E extends Comparable<E>> void sort(E[] elements, boolean ascending) {
        metadata = new SortingMetadata(elements.length);
        Instant start = Instant.now();
        for (int lastUnsortedIndex = elements.length - 1; lastUnsortedIndex > 0; lastUnsortedIndex--) {
            logger.info(""lastUnsortedIndex="" + lastUnsortedIndex + "":"");
            for (int bubbledIndex = 0; bubbledIndex < lastUnsortedIndex; bubbledIndex++) {
                if (ascending) {
                    if (elements[bubbledIndex].compareTo(elements[bubbledIndex + 1]) > 0) {
                        Sort.swap(elements, bubbledIndex, bubbledIndex + 1);
                        metadata.increamentSwapOperationByOne();
                    }
                } else {
                    if (elements[bubbledIndex].compareTo(elements[bubbledIndex + 1]) < 0) {
                        Sort.swap(elements, bubbledIndex, bubbledIndex + 1);
                        metadata.increamentSwapOperationByOne();
                    }
                }
                logger.info(""\tbubbledIndex="" + bubbledIndex + "":"");
                Sort.logInfo(logger, elements);
                metadata.incrementIterationByOne();
            }
        }
        Instant finish = Instant.now();
        metadata.setTimeTakenToExecute(Duration.between(start, finish).toNanos());
    }
    @Override
    public SortingMetadata getMetadata() {
        return metadata;
    }
}",0,0,0,0,1,0,0,0,0
524,"import java.util.*;
public class BubbleSort {
    public static void printArray(int ar[]){
        for(int g : ar){
           System.out.print(g+"" "");
       }
    }
    public static void  bubbleSort(int ar[]){
       for(int i=0 ; i<ar.length-1 ; i++){
           for(int j=0 ; j<ar.length-(1+i) ;j++){
                System.out.println(""inside for loop"");
                if(ar[j+1]<ar[j]){
                     int temp= ar[j+1];
                     ar[j+1]=ar[j];
                     ar[j]=temp;
                }
            }
       printArray(ar) ;  
       System.out.println();        
       }
       printArray(ar);
    }
    public static void main(String[] args)  {
       Scanner x = new Scanner(System.in);
       int t = x.nextInt();
       int ar [] = new int [t];
       for(int i=0; i<t ;i++){
           ar[i] = x.nextInt();
       }
       bubbleSort(ar);
       x.close();
    }
}",0,0,0,0,1,0,0,0,0
525,"exports.bubbleSort = ({ list }, { shouldSwap, swap }) => {
  let upperIndex = list.length - 1;
  while (upperIndex > 0) {
    let swapIndex = 0;
    for (let i = 0; i < upperIndex; i += 1) {
      if (shouldSwap(i, i + 1)) {
        swap(i, i + 1);
        swapIndex = i;
      }
    }
    upperIndex = swapIndex;
  }
  return list;
};",0,0,0,0,1,0,0,0,0
526,"function bubbleSort(array, low, high){
    for (let i = low; i < high; i++)
        for (let j = low; j < high-i-1; j++)
        {
            if ( array[j] > array[j+1] )
            {
                let temp = array[j];
                array[j] = array[j+1];
                array[j+1] = temp;
            }
        }
}
function sort(array){
    bubbleSort(array, 0, array.length);
}",0,0,0,0,1,0,0,0,0
527,"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
if __name__ == '__main__':
    arr = [64, 34, 25, 12, 22, 11, 90]
    print('Array:', arr)
    bubble_sort(arr)
    print('Sorted array:', arr)",0,0,0,0,1,0,0,0,0
528,"package com.srt.sort;
import java.util.Arrays;
import java.util.function.BiFunction;
@SuppressWarnings({""unused""})
public class BubbleSort<T extends Comparable> extends JSort<T> {
    T[] Sort(T[] arr, BiFunction<T, T, Boolean> compare){
        T[] array = Arrays.copyOf(arr, arr.length);
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = array.length - 1; j > i; j--) {
                if (compare.apply(array[j], array[j - 1])){
                    T temp = array[j];
                    array[j] = array[j - 1];
                    array[j - 1] = temp;
                }
            }
        }
        return array;
    }
}",0,0,0,0,1,0,0,0,0
529,"import java.io.IOException;
import java.util.ArrayList;
public class BubbleSort extends Sorts{
	public ArrayList<Integer> bubbleUp(ArrayList<Integer> unsortedList)
	{
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		boolean swapped = true;
		while(swapped)
		{
			swapped = false;
			for(int i = 1; i < unsortedList.size(); i++)
			{
				if(unsortedList.get(i) < unsortedList.get(i - 1))
				{
					int holder = unsortedList.get(i);
					unsortedList.set(i, unsortedList.get(i - 1));
					unsortedList.set(i - 1, holder);
					swapped = true;
				}
			}
		}
		sortedList = unsortedList;
		return sortedList;
	}
	public void BubbleTime(IOClass ioStream) throws IOException
	{
		ioStream.readFromFile();
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		long timeBefore = System.nanoTime();
		sortedList = bubbleUp(ioStream.getInputArray());
		long timeAfter = System.nanoTime();
		double rawTime = timeAfter - timeBefore;
		double timeInMilli = rawTime/1000000;
		if(isSorted(sortedList))
		{
			ioStream.setInputArray(sortedList);
			System.out.print(""BubbleSort time (in Milli): ""); 
			System.out.println(timeInMilli);
		}
		else
		{
			System.out.println(""Not sorted!"");
		}
	}
}",0,0,0,0,1,0,0,0,0
530,"import java.util.*;
public class BubbleSort {
	int[] bubble(int a[]) {
		for (int i = 0; i < a.length - 1; i++) {
			for (int j = i + 1; j < a.length; j++) {
				if (a[i] > a[j]) {
					int t = a[j];
					a[j] = a[i];
					a[i] = t;
				}
			}
		}
		return a;
	}
	public static void main(String args[]) {
		BubbleSort b = new BubbleSort();
		int a[] = { 5, 1, 4, 2, 8 };
		int ans[] = b.bubble(a);
		System.out.println(""The Final Sorted Array:"");
		for (int i = 0; i < a.length; i++) {
			System.out.print(ans[i] + ""\t"");
		}
	}
}",0,0,0,0,1,0,0,0,0
531,"package ro.geo.sorting.bubblesort;
public class BubbleSort {
	public static void sort(Integer[] unsorted){
		for(int i = 1; i < unsorted.length; i++){
			for(int j = 0; j < unsorted.length - 1; j++){
				if(unsorted[j] > unsorted[j + 1]){
					unsorted[j] = unsorted[j] + unsorted[j + 1];
					unsorted[j + 1] = unsorted[j] - unsorted[j + 1];
					unsorted[j] = unsorted[j] - unsorted[j + 1];
				}
			}
		}
	}
}",0,0,0,0,1,0,0,0,0
532,"package Sorting;
import Comparing.BaseAreaCompare;
import Comparing.VolumeCompare;
import Objects.ThreeDGeoShape;
public class BubbleSort {
	public ThreeDGeoShape[] sort(String sortBy, ThreeDGeoShape[] shapeArray) {
		ThreeDGeoShape temp;
		int result = 0;
		BaseAreaCompare ac = new BaseAreaCompare();
		VolumeCompare vc = new VolumeCompare();
		for (int i = 0; i < shapeArray.length; i++) {
			for (int j = 1; j < shapeArray.length - i; j++) {
				ThreeDGeoShape shape1 = shapeArray[j - 1];
				ThreeDGeoShape shape2 = shapeArray[j];
				if (sortBy.equalsIgnoreCase(""h"")) {
					result = shape2.compareTo(shape1);
				} else if (sortBy.equalsIgnoreCase(""a"")) {
					result = ac.compare(shape2, shape1);
				} else if (sortBy.equalsIgnoreCase(""v"")) {
					result = vc.compare(shape2, shape1);
				}
				if (result == 1) {
					temp = shapeArray[j - 1];
					shapeArray[j - 1] = shapeArray[j];
					shapeArray[j] = temp;
				}
			}
		}
		return shapeArray;
	}
}",0,0,0,0,1,0,0,0,0
533,"public class Sort {
	public static int [] bubbleSort(int[] numArray) {
	    int n = numArray.length;
	    int temp = 0;
	    for (int i = 0; i < n; i++) {
	        for (int j = 1; j < (n - i); j++) {
	            if (numArray[j - 1] > numArray[j]) {
	                temp = numArray[j - 1];
	                numArray[j - 1] = numArray[j];
	                numArray[j] = temp;
	            }
	        }
	    }
	    return numArray;
	}
	public static void main(String[] args) {
		int [] numbers = {453, 114, 214, 328, 311, 64, 575, 117, 877, 393, 596, 911, 236, 982, 23, 469, 733, 223, 600, 440, 74, 839, 727, 162, 530, 707, 208, 376, 330, 42, 170, 986, 442, 930, 482, 662, 291, 757, 615, 985, 275, 785, 151, 735, 239, 863, 55, 247, 343, 176, 855, 297, 316, 794, 505, 620, 737, 739, 483, 831, 793, 141, 695, 875, 444, 570, 419, 232, 904, 116, 140, 690, 776, 6, 635, 191, 745, 957, 181, 454, 687, 961, 668, 768, 120, 199, 893, 493, 915, 205, 568, 755, 638, 671, 517, 513, 919, 648, 24, 644};
		numbers = bubbleSort(numbers);
		System.out.print(numbers[16]);
	}
}",0,0,0,0,1,0,0,0,0
534,"public class BubbleSort {
    static void improvedBubbleSort(int[] arr) {
        int n = arr.length;
        int temp = 0;
        boolean flag = true;
        for (int i = 0; i < n && flag; i++) {
            flag = false;
            for (int j = 1; j < (n - i); j++) {
                if (arr[j - 1] > arr[j]) {
                    temp = arr[j - 1];
                    arr[j - 1] = arr[j];
                    arr[j] = temp;
                    flag = true;
                }
            }
        }
    }
    public static void main(String[] args) {
        int arr[] = {9, 2, 1, 0, 3, 60, 35, 2, 45, 320, 5};
        int arr2[] = {6,1,10,2,50,13,34,2,1,5,7,9};
        System.out.println(""Array 01 Before Improved Bubble Sort"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
        System.out.println();
        improvedBubbleSort(arr);
        System.out.println(""Array After Improved Bubble Sort"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
        System.out.println(""Array 02 Before Improved Bubble Sort"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr2[i] + "" "");
        }
        System.out.println();
        improvedBubbleSort(arr2);
        System.out.println(""Array After Improved Bubble Sort"");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr2[i] + "" "");
        }
    }
}",0,0,0,0,1,0,0,0,0
535,"package sortAlgorithms;
import helperUtils.Utility;
public class BubbleSort {
  public static void main(String args[]) {
    int[] inputArr = { 10, -80, 5, 76, 92, 100, 52, 1, -10 };
    Utility.printArray(inputArr, true, ""Bubble Sort"");
    for (int sortedBoundary = inputArr.length - 1; sortedBoundary > 0; sortedBoundary--) {
      for (int i = 0; i < sortedBoundary; i++) {
        if (inputArr[i] > inputArr[i + 1]) {
          Utility.swap(inputArr, i, i + 1);
        }
      }
    }
    Utility.printArray(inputArr, false, null);
  }
}",0,0,0,0,1,0,0,0,0
536,"""use strict"";
Array.prototype.bubblesort = function(compare) {
    if (""function"" != typeof compare) {
        var desc = compare || false;
        compare = function(a, b) {
            return desc ? a < b : a > b;
        }
    }
    var that = this;
    var max = that.length;
    function swap(i, j) {
        var temp = that[i];
        that[i] = that[j];
        that[j] = temp;
    }
    function sort(max) {
        var sorted = false;
        for (var i = 1; i <= max; i += 1) {
            if (compare(that[i - 1], that[i])) {
                swap(i - 1, i);
                sorted = true;
            }
        }
        return sorted;
    }
    while (sort(max -= 1))
        ;
    return this;
};",0,0,0,0,1,0,0,0,0
537,"import random
def bubble_sort(alist):
    swaps = 1
    while swaps:
        swaps = 0
        for index in range(len(alist) - 1):
            if alist[index] > alist[index + 1]:
                alist[index], alist[index + 1] = alist[index + 1], alist[index]
                swaps += 1
unordered_list = []
for i in range(100):
    unordered_list.append(i)
random.shuffle(unordered_list)
bubble_sort(unordered_list)
print(unordered_list)
success = True
for index in range(len(unordered_list) - 1):
    if unordered_list[index] > unordered_list[index + 1]:
        success = False
if success:
    print(""Bubble Sort successful!"")",0,0,0,0,1,0,0,0,0
538,"class bubbleSort
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		int [] sortedArr = new int [sizeofArr];
		sortedArr = bubleSort(arr, sizeofArr);
		print(sortedArr);
	}
	static int [] bubbleSort(int [] arr, int sizeofArr){
		int temp, check;
		for (int i=0;i<sizeofArr;i++ ){
			check=1;
			for (int k=0;k<sizeofArr-i-1 && arr[k] > arr[k+1];k++ ){
				temp = arr[k];
				arr[k] = arr[k+1];
				arr[k+1] = temp;
				check = 0;
			}
			if (check) break;
		}
		return arr;
	}
	static void print (int [] arr){
		for (int a : arr)
		System.out.print("" ""+a);
	}
}",0,0,0,0,1,0,0,0,0
539,"import java.util.Arrays;
public class BubbleSort{
	private boolean optimized = false;
	public BubbleSort(){}
	public BubbleSort(boolean optimized){
		this.optimized = optimized;
	}
	public void bubbleSort(int[] A) {
		if (optimized) {
			optimizedBubbleSort(A);
		} else {
			basicBubbleSort(A);
		}
	}
	private void basicBubbleSort(int[] A) {
		int len = A.length;
		for (int i = 0; i < len - 1; i ++) {
			for (int j = 0; j < len - 1; j ++) {
				if (A[j] > A[j + 1]) {
					swap(A, j, j + 1);
				}
			}
		}
	}
	private void optimizedBubbleSort(int[] A) {
		int len = A.length;
		int unsortedBorder = len - 1, lastExchange = 0;
		for (int i = 0; i < len - 1; i ++) {
			int flag = 0;
			for (int j = 0; j < unsortedBorder; j ++) {
				if (A[j] > A[j + 1]) {
					swap(A, j, j + 1);
					flag = 1;
					lastExchange = j;
				}
			}
			unsortedBorder = lastExchange;
			if (0 == flag) {
				return;
			}
		}
	}
	private void swap(int[] A, int idx1, int idx2) {
		int tmp = A[idx1];
		A[idx1] = A[idx2];
		A[idx2] = tmp;
	}
	public static void main(String[] args) {
		int[] A1 = {4, 5, 9, 2, 0, 1, 6, 8, 3, 7};
		int[] A2 = {4, 5, 9, 2, 0, 1, 6, 8, 3, 7};
		BubbleSort bs1 = new BubbleSort();
		BubbleSort bs2 = new BubbleSort(true);
		System.out.println(""A1 unsorted: "" + Arrays.toString(A1));
		System.out.println(""A2 unsorted: "" + Arrays.toString(A2));
		long basicStartTime = System.currentTimeMillis();
		bs1.bubbleSort(A1);
		long basicEndTime = System.currentTimeMillis();
		long optimizedStartTime = System.currentTimeMillis();
		bs2.bubbleSort(A2);
		long optimizedEndTime = System.currentTimeMillis();
		System.out.println(""A1 sorted via basic: "" + Arrays.toString(A1) 
						+ "", time eclipsed: "" + (basicEndTime - basicStartTime) + ""ms"");
		System.out.println(""A2 sorted via optimized: "" + Arrays.toString(A2)
						+ "", time eclipsed: "" + (optimizedEndTime - optimizedStartTime) + ""ms"");
	}
}",0,0,0,0,1,0,0,0,0
540,"package sorting.algorithms;
public class BubbleSort {
    public int[] sort(int[] inputArray) {
        int arrayLength = inputArray.length;
        int j = 0;
        int temp;
        boolean swapped = true;
        while (swapped) {
            swapped = false;
            j++;
            for (int i = 0; i < arrayLength - j; i++) {
                if (inputArray[i] > inputArray[i + 1]) {
                    temp = inputArray[i];
                    inputArray[i] = inputArray[i + 1];
                    inputArray[i + 1] = temp;
                    swapped = true;
                }
            }
        }
        return inputArray;
    }
}",0,0,0,0,1,0,0,0,0
541,"package com.intrafoundation;
import java.util.Arrays;
public class BubbleSort extends BaseSort {
    public void sort(int[] arr) {
        swaps = 0;
        final int end = arr.length - 1;
        boolean swapped;
        do {
            swapped = false;
            for (int inner = 0; inner < end; inner++) {
                final int a = arr[inner];
                final int b = arr[inner + 1];
                if (a > b) {
                    arr[inner] = b;
                    arr[inner + 1] = a;
                    swaps++;
                    swapped = true;
                }
            }
        } while (swapped);
    }
}",0,0,0,0,1,0,0,0,0
542,"package ie.gmit.dip;
import java.util.Random;
import java.util.*; 
public class BubbleSort {
    public static void main(String[] args) {
        Random g = new Random();
       int [] number = new int [10000];  
        System.out.print(""Random Numbers:"");
        for (int d = 0 ; d<number.length ; d++){
            int RandomG = g.nextInt(1000)+1;
            number[d] = RandomG;
            System.out.print("" "" +RandomG);
            }
       System.out.print(""\nSorted Numbers:""+(Arrays.toString(BubbleSortMethod(number))));
    }
    public static int [] BubbleSortMethod(int[] number){
        int temp;
        long startTime= System.nanoTime();
        for(int i = 0 ; i < number.length-1 ; i++){
            for ( int j = 1 ; j < number.length-i-1 ; j++){
                if ( number[j-1] > number[j]){
                    temp = number[j-1];
                    number[j-1] = number[j];
                    number[j] = temp;
                }
            }
        }
        long endTime= System.nanoTime();
        long elapsed = endTime-startTime;
        double timeMillis= elapsed/1000000.0;
        System.out.print(""\nSorted In: ""+ timeMillis );
        return number;  
    }
}",0,0,0,0,1,0,0,0,0
543,"import java.util.Arrays;
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {5, 4, 3, 2, 1};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    static void bubbleSort(int[] arr){
        boolean swapped = false;
        for(int i = 0; i < arr.length; i++){
            for(int j = 1; j < arr.length - i; j++){
                if(arr[j] < arr[j - 1]){
                    int temp = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = temp;
                    swapped = true;
                }
            }
            if(!swapped){
                break;
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
544,"package io.lenur.sort;
public class BubbleSort implements Sortable {
    @Override
    public void sort(int[] data) {
        for (int i = 0; i < data.length; i++) {
            for (int j = 0; j < data.length - i - 1; j++) {
                if (data[j] > data[j + 1]) {
                    int temp = data[j + 1];
                    data[j + 1] = data[j];
                    data[j] = temp;
                }
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
545,"package sortingalgorithms;
import cnode.CNode;
import java.util.ArrayList;
import java.util.Arrays;
import javafx.animation.FillTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.Transition;
import javafx.scene.paint.Color;
public class BubbleSort extends AbstractSort {
  private boolean swapped;
  private ArrayList<Transition> transitions;
  public BubbleSort() {
    this.transitions = new ArrayList<>();
  }
  private ArrayList<Transition> compareCNode(CNode[] arr, int a, int b) {
    ArrayList<Transition> transitions = new ArrayList<>();
    transitions.add(colorCNode(arr, SELECT_COLOR, a, b));
    if (arr[a].getValue() > arr[b].getValue()) {
      transitions.add(swap(arr, a, b));
      swapped = true;
    } 
    transitions.add(colorCNode(arr, START_COLOR, a, b));
    return transitions;
  }
  private void bubbleSort(CNode[] arr) {
    for (int i = 0; i < arr.length; i++) {
      swapped = false;
      for (int j = 0; j < arr.length - 1 - i; j++) {
        this.transitions.addAll(compareCNode(arr, j, j + 1));
      }
      if (!swapped) {
        break;
      }
    }
  }
  @Override
  public ArrayList<Transition> startSort(CNode[] arr) {
    bubbleSort(arr);
    this.transitions.add(colorCNode(Arrays.asList(arr), SORTED_COLOR));
    return this.transitions;
  }
}",0,0,0,0,1,0,0,0,0
546,"package Java;
public class BubbleSort extends Sort{
	public static void main(String[] args){
		int[] data = {5, 3, 2, 4, 1};
		timeSort(new BubbleSort(), data);
	}
	public BubbleSort(){ super(""Bubble""); }
	private void bubbleSort(int[] data, int low, int high){
		for (int i = low; i < high; i++)
			for (int j = low; j < high - i - 1; j++)
			{	 
				if ( data[j] > data[j+1] )
				{
					int temp = data[j];
					data[j] =  data[j+1];
					data[j+1] = temp;
				}
			}
	}
	@Override
	public void sort(int[] data){
		bubbleSort(data, 0, data.length);
	}
}",0,0,0,0,1,0,0,0,0
547,"function bubble_Sort(a)
{
    var swapp;
    var n = a.length-1;
    var x=a;
    do {
        swapp = false;
        for (var i=0; i < n; i++)
        {
            if (x[i] < x[i+1])
            {
               var temp = x[i];
               x[i] = x[i+1];
               x[i+1] = temp;
               swapp = true;
            }
        }
        n--;
    } while (swapp);
 return x; 
}
console.log(bubble_Sort([12, 345, 4, 546, 122, 84, 98, 64, 9, 1, 3223, 455, 23, 234, 213]));",0,0,0,0,1,0,0,0,0
548,"var array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function swap(array, i, j) {
  var temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
function bubbleSortBasic(array) {
  for(var i = 0; i < array.length; i++) {
    for(var j = 1; j < array.length; j++) {
      if(array[j - 1] > array[j]) {
        swap(array, j - 1, j);
      }
    }
  }
  return array;
}
console.log(bubbleSortBasic(array.slice()));  
function bubbleSort(array) {
  var swapped;
  do {
    swapped = false;
    for(var i = 0; i < array.length; i++) {
      if(array[i] && array[i + 1] && array[i] > array[i + 1]) {
        swap(array, i, i + 1);
        swapped = true;
      }
    }
  } while(swapped);
  return array;
}
console.log(bubbleSort(array.slice()));  ",0,0,0,0,1,0,0,0,0
549,"def bubbleSort(alist):
   for i in range(len(alist)-1,0,-1):
       for j in range(i):
           if alist[j] > alist[j+1]:
               temp = alist[j]
               alist[j] = alist[j+1]
               alist[j+1] = temp
   return alist
print(bubbleSort([5,1,2,3,9,8,0]))",0,0,0,0,1,0,0,0,0
550,"package sorts;
import util.SortUtil;
public class BubbleSort {
    public static int[] sort(int[] arr) {
        while(!SortUtil.isSorted(arr)) {
            for(int i = 0; i < arr.length - 1; i++) {
                if(arr[i] > arr[i + 1]) {
                    SortUtil.swap(arr, i, i + 1);
                }
            }
        }
        return arr;
    }
}",0,0,0,0,1,0,0,0,0
551,"package rosberglinhares.datastructuresandalgorithms.algorithms.sorting;
public class BubbleSort {
    public <T extends Comparable<T>> void iterativeBubbleSort(T[] items) {
        for (int n = 1; n <= items.length - 1; n++) {
            for (int i = 0; i < items.length - n; i++) {
                if (items[i].compareTo(items[i + 1]) > 0) {
                    T temp = items[i];
                    items[i] = items[i + 1];
                    items[i + 1] = temp;
                }
            }
        }
    }
    public <T extends Comparable<T>> void recursiveBubbleSort(T[] items) {
        this.recursiveBubbleSort(items, items.length - 1);
    }
    private <T extends Comparable<T>> void recursiveBubbleSort(T[] items, int upperIndex) {
        if (upperIndex > 0) {
            for (int i = 0; i <= upperIndex - 1; i++) {
                if (items[i].compareTo(items[i + 1]) > 0) {
                    T temp = items[i];
                    items[i] = items[i + 1];
                    items[i + 1] = temp;
                }
            }
            recursiveBubbleSort(items, upperIndex - 1);
        }
    }
}",0,0,0,0,1,0,0,0,0
552,"import java.util.Arrays;
import java.util.Scanner;
public class BubbleSort {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Bubble Sort Algorithm"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSort = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSort[i] = input.nextInt();
        }
        int[] sortedArray = bubbleSort(arrayOfIntegersToSort);
        System.out.printf(""Sorted array using Bubble Sort Algorithm: %s%n"",
                Arrays.toString(sortedArray));
        input.close();
    }
    private static int[] bubbleSort(int[] arrayToSort) {
        for (int i = 0; i < arrayToSort.length; i++) {
            for (int j = arrayToSort.length - 1; j > i; j--) {
                if (arrayToSort[j] < arrayToSort [j - 1]) {
                    swap(arrayToSort, j, j - 1);
                }
            }
        }
        return arrayToSort;
    }
    private static void swap(int[] array, int from, int to){
        int temp = array[from];
        array[from] = array[to];
        array[to] = temp;
    }
}",0,0,0,0,1,0,0,0,0
553,"package com.jwetherell.algorithms.sorts;
public class BubbleSort<T extends Comparable<T>> {
    private BubbleSort() { }
    public static <T extends Comparable<T>> T[] sort(T[] unsorted) {
        boolean swapped = true;
        int length = unsorted.length;
        while (swapped) {
            swapped = false;
            for (int i = 1; i < length; i++) {
                if (unsorted[i].compareTo(unsorted[i - 1]) < 0) {
                    swap(i, i - 1, unsorted);
                    swapped = true;
                }
            }
            length--;
        }
        return unsorted;
    }
    private static <T extends Comparable<T>> void swap(int index1, int index2, T[] unsorted) {
        T value = unsorted[index1];
        unsorted[index1] = unsorted[index2];
        unsorted[index2] = value;
    }
}",0,0,0,0,1,0,0,0,0
554,"package Sorting;
import java.util.Scanner;
public class BubbleSort {
    private static void bubbleSort(int[] array) {
        int n = array.length;
        boolean isSwapped ;
        for(int i = 0 ; i < n-1 ; i++) {
            isSwapped = false;
            for(int j = 0 ; j < n - 1 - i ; j++) {
                if(array[j] > array[j+1]) {
                    swap(array,j,j+1);
                    isSwapped = true;
                }
            }
            if(!isSwapped) {
                break;
            }
        }
    }
    private static void swap(int[] array , int i , int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    private static void print(int[] array) {
        for(int i : array) {
            System.out.print(i + "" "");
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i= 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        System.out.print(""Before Sorting : "");
        print(array);
        long startTime = System.nanoTime();
        bubbleSort(array);
        long endTime = System.nanoTime();
        System.out.print(""\nAfter Sorting : "");
        print(array);
        long totalTime = endTime - startTime;
        System.out.printf(""\nTime in seconds : %.6fs"",(totalTime/ 1000000000.0));
        sc.close();
    }
}",0,0,0,0,1,0,0,0,0
555,"package Sorting;
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr={20,35,-15,7,55,1,-22};
        BS(arr);
    }
    public static void BS(int[] arr){
        for (int lui = arr.length-1; lui>0; lui--){
            for(int i=0;i<lui;i++){
                if (arr[i]>arr[i+1]){
                    swap(arr,i,i+1);
                }
            }
        }
        for(int j=0;j<arr.length;j++){
            System.out.print(arr[j]+"" "");
        }
    }
    public static void swap(int[] arr,int i,int j){
        if (i==j){
            return;
        }
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}",0,0,0,0,1,0,0,0,0
556,"import java.util.Arrays;
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {9,8,7,6,5,4,3,2,1,0};
        System.out.println(""Array before sorting : ""+Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println(""Array after sorting : ""+Arrays.toString(arr));
    }
    public static void bubbleSort(int[] arr) {
        for(int i = 0;i<arr.length;i++){
            for(int j = 0;j<arr.length-1-i;j++){
                if(arr[j] > arr[j+1]) {
                    swap(arr,j,j+1);
                }
            }
        }
    }
    public static void swap(int[] arr, int a, int b){
        arr[a] = arr[a]+arr[b];
        arr[b] = arr[a]-arr[b];
        arr[a] = arr[a]-arr[b];
    }
}",0,0,0,0,1,0,0,0,0
557,"package com.growingwiththeweb.sorting;
public class BubbleSort {
    public static void sort(Integer[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = 1; j < array.length - i; j++) {
                if (array[j - 1] > array[j]) {
                    swap(array, j, j - 1);
                }
            }
        }
    }
    private static void swap(Integer[] array, int a, int b) {
        Integer temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}",0,0,0,0,1,0,0,0,0
558,"export default function BubbleSort(numberArray: number[]): number[] {
  let { length } = numberArray;
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i < length - 1; i++) {
      if (numberArray[i] > numberArray[i + 1]) {
        const temp = numberArray[i];
        numberArray[i] = numberArray[i + 1];
        numberArray[i + 1] = temp;
        swapped = true;
      }
    }
    length -= 1;
  } while (swapped);
  return numberArray;
}",0,0,0,0,1,0,0,0,0
559,"aij.bubbleSort = function(items) {
    var sort = function(arr) {
      var swapped,
          endIndex = arr.length;
      do {
        swapped = false;
        for (var i = 0; i < endIndex - 1; i++) {
          if (arr[i+1] < arr[i]) {
            aij.swap(arr, i, i + 1);
            swapped = true;
          }
        };
        endIndex--;
      } while(swapped);
      return arr;
    };
    return aij.isSortable(items) ? sort(items) : items;
};",0,0,0,0,1,0,0,0,0
560,"from random import shuffle
def bubblesort(arr):
    swapped = True
    n = len(arr)-1
    while swapped:
          swapped = False
          for i in xrange(n):
              if arr[i] > arr[i+1]:
                 arr[i], arr[i+1] = arr[i+1], arr[i]  
                 swapped = True          
    return None
def bubblesort2(arr):
    n = len(arr)-1;
    for i in range(0,n):
        for j in range(n,i,-1):
            if arr[j] < arr[j-1]:
               arr[j],arr[j-1] = arr[j-1], arr[j]    
    return None
def bubblesort3(arr):
    n = len(arr)-1;   
    for i in range(n,0,-1):
        for j in range(0,i):
            if arr[j] > arr[j+1]:
               arr[j],arr[j+1] = arr[j+1], arr[j]    
    return None
if __name__ == ""__main__"":
    vec = range(10)
    arr = vec[:]
    shuffle(arr)
    print 'Input array'
    print arr
    print 'sorted array'
    bubblesort3(arr)
    print arr",0,0,0,0,1,0,0,0,0
561,"public class BubbleSort {
    public static int[] sort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        return array;
    }
}",0,0,0,0,1,0,0,0,0
562,"const swap = (arr, i, j) => {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
};
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1);
      }
    }
  }
  return arr;
}
bubbleSort([37, 45, 29, 8]);",0,0,0,0,1,0,0,0,0
563,"function bubbleSort(items) {
    var len = items.length
    for (var a = 0; a < len; a++) {
        for (var b = 0; b < len - a; b++) {
            if (items[b] > items[b + 1]){
                swap(items, b, b + 1);
            }
        }
    }
    return items;
}",0,0,0,0,1,0,0,0,0
564,"def bubblesort(numlist):       
    for i in range(len(numlist)-1):
        for j in range(0, len(numlist)-i-1):
            if numlist[j]> numlist[j+1]:
                temp = numlist[j]
                numlist[j]= numlist[j+1]
                numlist[j+1]= temp
    return (numlist)",0,0,0,0,1,0,0,0,0
565,"public class BubbleSort
{
    void bubbleSort(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
            for (int j = 0; j < n-i-1; j++)
                if (arr[j] > arr[j+1])
                {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
    }
    void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    public static void main(String args[])
    {
        BubbleSort ob = new BubbleSort();
        int arr[] = {64, 34, 25, 12, 22, 11, 90};
        ob.bubbleSort(arr);
        System.out.println(""Sorted array"");
        ob.printArray(arr);
    }
}",0,0,0,0,1,0,0,0,0
566,"'use strict';
const bubbleSort = (arr = []) => {
  let sortedArray = [...arr];
  let n = sortedArray.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (sortedArray[j] > sortedArray[j + 1]) {
        let temp = sortedArray[j];
        sortedArray[j] = sortedArray[j + 1];
        sortedArray[j + 1] = temp;
      }
    }
  }
  return sortedArray;
};
module.exports = bubbleSort;",0,0,0,0,1,0,0,0,0
567,"def bubbleSort(listofnumbers):
    for allnumbers in range(len(listofnumbers)-1,0,-1):
        for i in range(allnumbers):
            if listofnumbers[i]>listofnumbers[i+1]:
                a = listofnumbers[i]
                listofnumbers[i] = listofnumbers[i+1]
                listofnumbers[i+1] = a
listofnumbers = [20,10,32,45,99,17,77,31,44,55,20]
print(f""Original list: {listofnumbers}"")
bubbleSort(listofnumbers)
print(f""Organized list: {listofnumbers}"")",0,0,0,0,1,0,0,0,0
568,"const array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function bubbleSortBasic(array) {
  for(let i = 0; i < array.length; i++) {
    for(let j = 1; j < array.length; j++) {
      if(array[j - 1] > array[j]) {
        [array[j - 1], array[j]] = [array[j], array[j - 1]];
      }
    }
  }
  return array;
}
console.log(bubbleSortBasic(array.slice()));  
function bubbleSort(array) {
  let swapped;
  do {
    swapped = false;
    for(let i = 0; i < array.length; i++) {
      if(array[i] && array[i + 1] && array[i] > array[i + 1]) {
        [array[i], array[i + 1]] = [array[i + 1], array[i]];
        swapped = true;
      }
    }
  } while(swapped);
  return array;
}
console.log(bubbleSort(array.slice()));  ",0,0,0,0,1,0,0,0,0
569,"public class BubbleSort {
    public static void main(String[] args) {
        int[] input = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                if (input[i] < input[j]) {
                    int temp = input[i];
                    input[i] = input[j];
                    input[j] = temp;
                }
            }
        }
        System.out.println(""Bubble Sort : Sorted List"");
        for (int i = 0; i < 10; i++) {
            System.out.println(input[i]);
        }
    }
}",0,0,0,0,1,0,0,0,0
570,"export function bubbbleSort(array) {
  let times = 0;
  while(times < input.length - 1) {
    for(let i = 0; i < array.length - 1 - times; i++) {
      const a = array[i];
      const b = array[i + 1];
      if (a > b) {
        swap(array, i, i + 1)
      }
    }
    times++;
  }
  return array;
}
function swap(array, index1, index2) {
  const val1 = array[index1];
  array[index1] = array[index2];
  array[index2] = val1;
}",0,0,0,0,1,0,0,0,0
571,"function bubbleSort(array) {
    let swapped;
    do {
        swapped = false;
        for(let i = 0; i < array.length; i++) {
            if(
                array[i + 1] &&          
                array[i] > array[i + 1]  
            ) {
                [array[i], array[i + 1]] = [array[i + 1], array[i]];
                swapped = true;  
            }
        }
    } while(swapped);
    return array;
}
(function test() {
    const testArray1 = [4, 5, 2, 1, 3, 8]
    const testArray2 = [5, 5, 6, 100, 3, 5, 2, 1, 5, 7, 8888, 4]
    const testArray3 = [2, 1]
    console.log(bubbleSort(testArray1))
    console.log(bubbleSort(testArray2))
    console.log(bubbleSort(testArray3))
})()",0,0,0,0,1,0,0,0,0
572,"def bubble_sort(lista, n):
    i = 0
    while(i < n-1):
        j = n-1
        while(j>i):
            if(lista[j] < lista[j - 1]):
                lista[j - 1], lista[j] = lista[j], lista[j - 1]
            j-=1
        i+=1",0,0,0,0,1,0,0,0,0
573,"def bubbleSort(list):
    notSorted = len(list)
    swapped = True
    while swapped:
        swapped = False
        for i in range(0, notSorted - 1):
            if list[i] > list[i + 1]:
                list[i], list[i + 1] = list[i + 1], list[i]
                swapped = True
        notSorted -= 1
    return list
myList = [43,54,15,13,87,545,435,63,245,753,45,2,534,15]
print(myList)
print(bubbleSort(myList))",0,0,0,0,1,0,0,0,0
574,"def bubbleSort(list, notSorted):
    swapped = False
    for i in range(0, notSorted - 1):
        if list[i] > list[i + 1]:
            list[i], list[i + 1] = list[i + 1], list[i]
            swapped = True
    if swapped == False:
        return list
    else:
        return bubbleSort(list, notSorted - 1)
myList = [43,54,15,13,87,545,435,63,245,753,45,2,534,15]
print(myList)
print(bubbleSort(myList, len(myList)))",0,0,0,0,1,0,0,0,0
575,"var arrayRandom = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
var arrayOrdered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arrayReversed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
function swap(array, i, j) {
  var temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
function bubbleSortBasic(array) {
  var countOuter = 0;
  var countInner = 0;
  var countSwap = 0;
  for(var i = 0; i < array.length; i++) {
    countOuter++;
    for(var j = 1; j < array.length; j++) {
      countInner++;
      if(array[j - 1] > array[j]) {
        countSwap++;
        swap(array, j - 1, j);
      }
    }
  }
  console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
  return array;
}
bubbleSortBasic(arrayRandom.slice());  
bubbleSortBasic(arrayOrdered.slice());  
bubbleSortBasic(arrayReversed.slice());  
function bubbleSort(array) {
  var countOuter = 0;
  var countInner = 0;
  var countSwap = 0;
  var swapped;
  do {
    countOuter++;
    swapped = false;
    for(var i = 0; i < array.length; i++) {
      countInner++;
      if(array[i] && array[i + 1] && array[i] > array[i + 1]) {
        countSwap++;
        swap(array, i, i + 1);
        swapped = true;
      }
    }
  } while(swapped);
  console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
  return array;
}
bubbleSort(arrayRandom.slice());  
bubbleSort(arrayOrdered.slice());  
bubbleSort(arrayReversed.slice());  ",0,0,0,0,1,0,0,0,0
576,"package com.ianramzy;
public class BubbleSorter implements Sorter {
    public void sort(int num, int list[]) {
        int i, j, temp;
        for (j = 0; j < num - 1; j++) {
            for (i = 0; i < num - j - 1; i++) {
                if (list[i] > list[i + 1]) {
                    temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                }
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
577,"package sorters;
import java.util.Comparator;
import java.util.List;
public class BubbleSorter<E> extends AbstractSorter<E> {
	public void sort(List<E> list, Comparator<E> comp) {
		for (int i = 0; i < list.size(); i++) {
			for (int k = 0; k < list.size() - i - 1; k++) {
				if (comp.compare(list.get(k), list.get(k + 1)) > 0) {
					swap(list, k, k + 1);
				}
			}
		}
	}
	public String getName() {
		return ""Bubble Sort"";
	}
}",0,0,0,0,1,0,0,0,0
578,"let numbers = [5, 7, 10, 4, 1, 8, 11, 14, 6, 2, 17, 14, 3, 9, 20, 13, 18];  
let countSwap = 0;
const BubbleSortArray = (numbers) => {
   countSwap = 0;
   numbers.forEach((num, index) => {
      if (numbers[index] > numbers[index + 1]) {
        countSwap += 1;
        let temp = numbers[index];
        numbers[index] = numbers[index + 1];
        numbers[index + 1] = temp;
      }
   });
}
do {
   BubbleSortArray(numbers);
} while (countSwap > 0);
console.log(numbers);",0,0,0,0,1,0,0,0,0
579,"package eu.happycoders.sort.method.bubblesort;
import eu.happycoders.sort.method.*;
public class BubbleSortOpt1 implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    for (int max = elements.length - 1; max > 0; max--) {
      boolean swapped = false;
      for (int i = 0; i < max; i++) {
        int left = elements[i];
        int right = elements[i + 1];
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          swapped = true;
        }
      }
      if (!swapped) break;
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    for (int max = elements.length - 1; max > 0; max--) {
      counters.incIterations();
      boolean swapped = false;
      for (int i = 0; i < max; i++) {
        counters.incIterations();
        int left = elements[i];
        int right = elements[i + 1];
        counters.addReads(2);
        counters.incComparisons();
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          counters.addWrites(2);
          swapped = true;
        }
      }
      if (!swapped) break;
    }
  }
}",0,0,0,0,1,0,0,0,0
580,"package eu.happycoders.sort.method.bubblesort;
import eu.happycoders.sort.method.*;
public class BubbleSortOpt2 implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    int max = elements.length - 1;
    for (; ; ) {
      int lastSwapped = 0;
      for (int i = 0; i < max; i++) {
        int left = elements[i];
        int right = elements[i + 1];
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          lastSwapped = i;
        }
      }
      if (lastSwapped == 0) break;
      max = lastSwapped;
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    int max = elements.length - 1;
    for (; ; ) {
      counters.incIterations();
      int lastSwapped = 0;
      for (int i = 0; i < max; i++) {
        counters.incIterations();
        int left = elements[i];
        int right = elements[i + 1];
        counters.addReads(2);
        counters.incComparisons();
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          counters.addWrites(2);
          lastSwapped = i;
        }
      }
      if (lastSwapped == 0) break;
      max = lastSwapped;
    }
  }
}",0,0,0,0,1,0,0,0,0
581,"package com.growingwiththeweb.sorting;
public class BubbleSortOptimised {
    public static void sort(Integer[] array) {
        int unsortedBelow = array.length;
        while (unsortedBelow != 0) {
            int lastSwap = 0;
            for (int i = 1; i < unsortedBelow; i++) {
                if (array[i - 1] > array[i]) {
                    swap(array, i, i - 1);
                    lastSwap = i;
                }
            }
            unsortedBelow = lastSwap;
        }
    }
    private static void swap(Integer[] array, int a, int b) {
        Integer temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}",0,0,0,0,1,0,0,0,0
582,"public class BubbleSortOptimized {
	public static void sort(int list[]) {
		int n = list.length;
		for (boolean swapped = true; swapped == true;) {
			swapped = false;
			for (int i = 0; i < n-1; i++) {
				if (list[i] > list[i+1]) {
					Compare.swap(list, i, i+1);
					swapped = true;
				}
			}
			n--;
		}
	}
}",0,0,0,0,1,0,0,0,0
583,"public class BubbleSort
{
  void bubbleSort(int arr[])
    {
        int n = arr.length;
        boolean swapped;
        for (int i = 0; i < n-1; i++){
            swapped=false;
            for (int j = 0; j < n-i-1; j++)
                if (arr[j] > arr[j+1])
                {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                    swapped=true;
                }
            if(!swapped){
		    break;
		    }
        }
    }
    void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    public static void main(String args[])
    {
        BubbleSort ob = new BubbleSort();
        int arr[] = {5, 2, 9, 1, 7, 3, 4, 505, 200};
        ob.bubbleSort(arr);
        System.out.println(""Sorted array"");
        ob.printArray(arr);
    }
}",0,0,0,0,1,0,0,0,0
584,"package eu.happycoders.sort.method.bubblesort;
import eu.happycoders.sort.method.*;
import java.util.concurrent.Phaser;
import java.util.concurrent.atomic.AtomicInteger;
public abstract class BubbleSortParallel implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    AtomicInteger lastSwappedInRound = new AtomicInteger();
    int[] startPositions = partition(elements);
    int numThreads = startPositions.length - 1;
    Phaser phaser = new Phaser(numThreads);
    Thread[] threads = new Thread[numThreads];
    for (int i = 0; i < numThreads; i++) {
      final int threadNo = i;
      threads[threadNo] = new Thread(() -> {
        int startPos = startPositions[threadNo];
        int endPos = startPositions[threadNo + 1];
        for (int round = 1; ; round++) {
          phaser.arriveAndAwaitAdvance();
          boolean swapped = sortPartition(elements, startPos, endPos, false);
          phaser.arriveAndAwaitAdvance();
          swapped |= sortPartition(elements, startPos, endPos, true);
          if (swapped) lastSwappedInRound.set(round);
          phaser.arriveAndAwaitAdvance();
          if (lastSwappedInRound.get() < round) break;
        }
      });
    }
    for (int i = 0; i < numThreads; i++) {
      threads[i].start();
    }
    for (int i = 0; i < numThreads; i++) {
      try {
        threads[i].join();
      } catch (InterruptedException e) {
        throw new Error(e);
      }
    }
  }
  private int[] partition(int[] elements) {
    int numPartitions = Math.min(Runtime.getRuntime().availableProcessors(),
          elements.length / 2);
    int remainingElements = elements.length;
    int remainingPartitions = numPartitions;
    int[] startPositions = new int[numPartitions + 1];
    for (int i = 0; i < numPartitions; i++) {
      int partitionSize = remainingElements / remainingPartitions;
      if (partitionSize % 2 == 1 && startPositions[i] + partitionSize < elements.length) {
        partitionSize++;
      }
      remainingElements -= partitionSize;
      remainingPartitions--;
      startPositions[i + 1] = startPositions[i] + partitionSize;
    }
    return startPositions;
  }
  abstract boolean sortPartition(int[] elements, int startPos, int endPos,
                                 boolean even);
  @Override
  public void sort(int[] elements, Counters counters) {
  }
}",0,0,0,0,1,0,0,0,0
585,"package eu.happycoders.sort.method.bubblesort;
public class BubbleSortParallelDivideAndConquer extends BubbleSortParallel {
  @Override
  boolean sortPartition(int[] elements, int startPos, int endPos,
                        boolean even) {
    boolean swapped = false;
    if (!even) {
      for (int i = startPos; i < endPos - 1; i++) {
        int left = elements[i];
        int right = elements[i + 1];
        if (left > right) {
          elements[i + 1] = left;
          elements[i] = right;
          swapped = true;
        }
      }
    }
    else if (endPos < elements.length - 1) {
      int left = elements[endPos - 1];
      int right = elements[endPos];
      if (left > right) {
        elements[endPos] = left;
        elements[endPos - 1] = right;
        swapped = true;
      }
    }
    return swapped;
  }
}",0,0,0,0,1,0,0,0,0
586,"package eu.happycoders.sort.method.bubblesort;
public class BubbleSortParallelOddEven extends BubbleSortParallel {
  @Override
  boolean sortPartition(int[] elements, int startPos, int endPos,
                        boolean even) {
    boolean swapped = false;
    if (even) startPos++;
    for (int i = startPos; i < endPos && i < elements.length - 1; i += 2) {
      int left = elements[i];
      int right = elements[i + 1];
      if (left > right) {
        elements[i + 1] = left;
        elements[i] = right;
        swapped = true;
      }
    }
    return swapped;
  }
}",0,0,0,0,1,0,0,0,0
587,"def bubble_sort(number_list): 
	for i, num in enumerate(number_list): 
		try: 
			if number_list[i+1] < num: 
				number_list[i] = number_list[i+1] 
    number_list[i+1] = num 
    bubble_sort(number_list) 
  except IndexError: 
			pass
 return number_list 
number_list = [64, 34, 25, 12, 22, 11, 90] 
bubble_sort(number_list) 
print(""Sorted array:""); 
for i in range(len(number_list)): 
	print(number_list[i], end=' ') ",0,0,0,0,1,0,0,0,0
588,"function bubbleSort(array) {
  for (let i = 0; i < array.length; i++) {
    for (let j = i + 1; j < array.length; j++) {
      if (array[i] > array[j]) {
        swap(array, i, j);
      }
    }
  }
  return array;
}
function swap(array, firstIndex, secondIndex) {
  array[firstIndex] = array[firstIndex] ^ array[secondIndex];
  array[secondIndex] = array[firstIndex] ^ array[secondIndex];
  array[firstIndex] = array[firstIndex] ^ array[secondIndex];
}
module.exports = bubbleSort;",0,0,0,0,1,0,0,0,0
589,"import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;
class Sort
{
    void BubbleSort(int arr[])
    {
        int temp;
        boolean check;
        for (int i = 0; i < arr.length - 1; ++i)
        {
            check = false;
            for (int j = 0; j < arr.length - i - 1; ++j)
            {
                if (arr[j] > arr[j + 1])
                {
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    check = true;
                }
            }
            if (!check)
            {
                break;
            }
        }
    }
    void Display(int arr[])
    {
        for(int i : arr)
        {
            System.out.print(i + ""  "");
        }
    }
}
class Main
{
    public static void main(String[] args)throws IOException
    {
        Sort obj = new Sort();
        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""\n\t---BUBBLE SORT---"");
        System.out.print(""Enter the size of array = "");
        int n = Integer.parseInt(buf.readLine());
        int[] arr = new int[n];
        System.out.println(""Enter elements -"");
        for(int i = 0; i < n ; ++i)
        {
            System.out.print((i + 1) +"" : "");
            arr[i] = Integer.parseInt(buf.readLine());
        }
        System.out.println(""Elements in the array : "");
        obj.Display(arr);
        obj.BubbleSort(arr);
        System.out.println(""\nElements in ascending order : "");
        obj.Display(arr);
    }
}",0,0,0,0,1,0,0,0,0
590,"from typing import List
def bubbleSort(array: List[int]) -> None:
    for amt in range(len(array)):
        swaps = 0
        for i in range(len(array) - 1 - amt):  
            if array[i] > array[i + 1]:  
                array[i], array[i + 1] = array[i + 1], array[i]
                swaps += 1
        if swaps == 0:
            break  
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""BUBBLE SORT"")
    shuffledArray = randomSequence(0, 1000)
    print(shuffledArray, ""\n"")
    bubbleSort(shuffledArray)
    print(shuffledArray)",0,0,0,0,1,0,0,0,0
591,"import java.io.IOException;
import java.util.ArrayList;
public class MergeSort extends Sorts{
	public ArrayList<Integer> mergeSort(ArrayList<Integer> unsortedList)
	{
		if(unsortedList.size() <= 1)
		{
			return unsortedList;
		}
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		ArrayList<Integer> left = new ArrayList<Integer>();
		ArrayList<Integer> right = new ArrayList<Integer>();
		int middle = unsortedList.size()/2;
		for(int i = 0; i < unsortedList.size(); i++)
		{
			if(i < middle)
			{
				left.add(unsortedList.get(i));
			}
			else
			{
				right.add(unsortedList.get(i));
			}
		}
		left = mergeSort(left); 
		right = mergeSort(right);
		sortedList = merge(left, right);
		return sortedList;
	}
	public ArrayList<Integer> merge(ArrayList<Integer> left, ArrayList<Integer> right)
	{
		ArrayList<Integer> mergedList = new ArrayList<Integer>();
		while(left.size() > 0 || right.size() > 0)
		{
			if(left.size() > 0 && right.size() > 0)
			{
				if(left.get(0) < right.get(0))
				{
					mergedList.add(left.get(0));
					left.remove(0);
				}
				else
				{
					mergedList.add(right.get(0));
					right.remove(0);
				}
			}
			else if(left.size() > 0)
			{
				mergedList.add(left.get(0));
				left.remove(0);
			}
			else if(right.size() > 0)
			{
				mergedList.add(right.get(0));
				right.remove(0);
			}
		}
		return mergedList;
	}
	public void MergeTime(IOClass ioStream) throws IOException
	{
		ioStream.readFromFile();
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		long timeBefore = System.nanoTime();
		sortedList = mergeSort(ioStream.getInputArray());
		long timeAfter = System.nanoTime();
		double rawTime = timeAfter - timeBefore;
		double timeInMilli = rawTime/1000000;
		if(isSorted(sortedList))
		{
			ioStream.setInputArray(sortedList);
			System.out.print(""MergeSort time (in Milli): ""); 
			System.out.println(timeInMilli);
		}
		else
		{
			System.out.println(""Not sorted!"");
		}
	}
}",0,1,0,0,0,0,0,0,0
592,"import java.io.*; 
class BubbleSort 
{ 
	static void bubbleSort(int arr[], int n) 
	{ 
		int i, j, temp; 
		boolean swapped; 
		for (i = 0; i < n - 1; i++) 
		{ 
			swapped = false; 
			for (j = 0; j < n - i - 1; j++) 
			{ 
				if (arr[j] > arr[j + 1]) 
				{ 
					temp = arr[j]; 
					arr[j] = arr[j + 1]; 
					arr[j + 1] = temp; 
					swapped = true; 
				} 
			} 
			if (swapped == false) 
				break; 
		} 
	} 
	public static void main(String args[]) 
	{ 
		int arr[] = { 64, 34, 25, 12, 22, 11, 90 }; 
		int n = arr.length; 
		bubbleSort(arr, n); 
		System.out.println(""Sorted array: ""); 
		printArray(arr, n);int i; 
		for (i = 0; i < size; i++) 
			System.out.print(arr[i] + "" ""); 
		System.out.println(); 
	} 
} ",0,0,0,0,1,0,0,0,0
593,"def Optimized_BubbleSort(A,n):
    for k in range(1,n):
        flag=0
        for i in range(0,n-k):
            if(A[i]>A[i+1]):
                A[i],A[i+1]=A[i+1],A[i]
                flag=1
        if(flag==0):
            break
if __name__==""__main__"":
    print(""Enter elements in the array: "")
    A=list(map(int,input().split("" "")))
    n=len(A)
    Optimized_BubbleSort(A,n)
    for i in range(0,n):
        print(A[i],end="" "")",0,0,0,0,1,0,0,0,0
594,"public class OptimzedBubbleSort {
      public static BubbleSort(int *arr, int n)
      {
          for(int i=0; i<n; i++)
          {  
            bool flag = false;
             for(int j=0; j<n-i-1; j++)
             {
                if(array[j]>array[j+1])
                {
                  flag = true;
                   int temp = array[j+1];
                   array[j+1] = array[j];
                   array[j] = temp;
                }
             }
            if(!flag){ 
               return; 
            } 
         }
      }
}",0,0,0,0,1,0,0,0,0
595,"import java.util.Arrays;
public class RecursiveBubbleSort
{ 
    private static void bubbleSort(int arr[], int n)
    { 
        if (n == 1) 
            return; 
        for (int i=0; i<n-1; i++) 
            if (arr[i] > arr[i+1]) 
            { 
                int temp = arr[i]; 
                arr[i] = arr[i+1]; 
                arr[i+1] = temp; 
            } 
        bubbleSort(arr, n-1); 
    } 
    public static void main(String[] args) 
    { 
        int arr[] = {64, 34, 25, 12, 22, 11, 90}; 
        bubbleSort(arr, arr.length); 
        System.out.println(""Sorted array : ""); 
        System.out.println(Arrays.toString(arr)); 
    } 
} ",0,0,0,0,1,0,0,0,0
596,"import java.util.*;
public class RecursiveBubbleSort {
	public static void main(String[] args) {
		Scanner scn=new Scanner(System.in);
		int[] arr=  {5,1,4,2,8};
		bubbleSort(arr,arr.length);
		System.out.println(""Sorted Array Elements: "");
		System.out.println(Arrays.toString(arr));
	}
	private static void bubbleSort(int[] arr, int n) {
		if(n==1) return;
		for(int i=0;i<n-1;i++) {
			if(arr[i]>arr[i+1]) {		
				int temp=arr[i];				 
				arr[i]=arr[i+1];
				arr[i+1]=temp;
			}
		}
		bubbleSort(arr,n-1);					 
	}
}",0,0,0,0,1,0,0,0,0
597,"function bubbleSort(array) {
  const len = array.length;
  let stop;
  for (let i = 0; i < len; i++){
      for (let j = 0, stop = len - i; j < stop; j++){
          if (array[j] > array[j + 1]){
              swap(array, j, j + 1);
          }
      }
  }
  function swap(array, firstIdx, secondIdx){
    let temp = array[firstIdx];
    array[firstIdx] = array[secondIdx];
    array[secondIdx] = temp;
  }
  return array;
}",0,0,0,0,1,0,0,0,0
598,"package bubblesort;
import java.util.*;
public class Sort <T extends Comparable<T>> implements Comparator<T> {
	public ArrayList<T> list;
	public int compare(T a, T b) {
		return a.compareTo(b);
	}
	public Sort(){
		this.list = new ArrayList<T>();
	}
	@Override
	public String toString(){
		String listOut = """";
		listOut += ""-->"";
		for (int i = 0; i < list.size(); i++) {
			listOut += list.get(i) + "" "";
		}
		return listOut;
	}
	public void MainSort() {
		int length = list.size();
		boolean swapped = true;;
		T holder;
		while(swapped) {
			swapped = false;
			for (int i = 0; i < length - 1; i++) {
				if (this.compare(list.get(i), list.get(i+1)) < 0) {
					holder = list.get(i);
					list.set(i, list.get(i+1));
					list.set(i + 1, holder);
					swapped = true;
				}
			}
		}
	}
}",0,0,0,0,1,0,0,0,0
599,"public class SortingAnArray {
    public static void main(String[] args) {
        int[] array = {6,4,2,5,0,1,3};
        System.out.print(""Current Array: "");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "" "");
        }
        System.out.print(""\n"");
        for (int i = 0; i < array.length; i++) {
            for (int j = i + 1; j < array.length; j++) {
                if(array[i] > array[j]){
                    int tempVar = array[i];
                    array[i] = array[j];
                    array[j] = tempVar;
                }
            }
        }
        System.out.print(""Sorted Array: "");
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "" "");
        }
        System.out.print(""\n"");
    }
}",0,0,0,0,1,0,0,0,0
600,"from ..utils.functions import swap, partition
def selection(array, inplace=True):
    if not inplace:
        cp_array = array.copy()
        return selection(cp_array, inplace=True)
    for pivot in range(len(array)):
        for index in range(pivot, len(array)):
            if array[index] < array[pivot]:
                swap(array, pivot, index)
    return array
def bubble(array, inplace=True):
    if not inplace:
        cp_array = array.copy()
        return bubble(cp_array, inplace=True)
    if len(array) <= 1:
        return array
    for limit in range(len(array)):
        for index in range(1, len(array)-limit):
            if array[index] < array[index-1]:
                swap(array, index, index-1)
    return array
def insertion(array, inplace=True):
    if not inplace:
        cp_array = array.copy()
        return insertion(cp_array, inplace=True)
    if len(array) <= 1:
        return array
    for pivot in range(1, len(array)):
        for index in range(len(array[:pivot])-1, -1, -1):
            if array[pivot] < array[index]:
                swap(array, pivot, index)
                pivot = index
            else:
                break
    return array
def quicksort(array, inplace=True):
    def sort(array, start, end):   
        if start < end:
            index = partition(array, start, end)
            sort(array, start, index - 1)
            sort(array, index + 1, end)
        return
    if not inplace:
        array = array.copy()
    sort(array, 0, len(array)-1)
    return array",1,0,1,1,1,0,0,0,0
601,"public class BinaryInsertion {
    private BinaryInsertion() { }
    public static void sort(final Comparable[] a) {
        int n = a.length;
        for (int i = 1; i < n; i++) {
            Comparable v = a[i];
            int lo = 0, hi = i;
            while (lo < hi) {
                int mid = lo + (hi - lo) / 2; 
                if (less(v, a[mid])) hi = mid;
                else                 lo = mid + 1;
            }
            for (int j = i; j > lo; --j)
                a[j] = a[j-1];
            a[lo] = v;
        }
    }
    private static boolean less(final Comparable v, final Comparable w) {
        return v.compareTo(w) < 0;
    }
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            System.out.println(a[i]);
        }
    }
}",0,0,0,1,0,0,1,0,0
602,"def binary_search(arr, val, start, end):
    if start == end:
        if arr[start] > val:
            return start
        else:
            return start+1
    if start > end:
        return start
    mid = (start+end)/2
    if arr[mid] < val:
        return binary_search(arr, val, mid+1, end)
    elif arr[mid] > val:
        return binary_search(arr, val, start, mid-1)
    else:
        return mid
def insertion_sort(arr):
    for i in xrange(1, len(arr)):
        val = arr[i]
        j = binary_search(arr, val, 0, i-1)
        arr = arr[:j] + [val] + arr[j:i] + arr[i+1:]
    return arr
print(""Sorted array:"")
print insertion_sort([37, 23, 0, 17, 12, 72, 31, 46, 100, 88, 54])",0,0,0,1,0,0,1,0,0
603,"import java.util.Arrays; 
class GFG 
{ 
	public static void main(String[] args) 
	{ 
		final int[] arr = {37, 23, 0, 17, 12, 72, 31, 
							46, 100, 88, 54 }; 
		new GFG().sort(arr); 
		for(int i=0; i<arr.length; i++) 
			System.out.print(arr[i]+"" ""); 
	} 
	public void sort(int array[]) 
	{ 
		for (int i = 1; i < array.length; i++) 
		{ 
			int x = array[i]; 
			int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1); 
			System.arraycopy(array, j, array, j+1, i-j); 
			array[j] = x; 
		} 
	} 
} ",0,0,0,1,0,0,1,0,0
604,"def binary_search(arr, val, start, end): 
	if start == end: 
		if arr[start] > val: 
			return start 
  else: 
			return start+1
 if start > end: 
		return start 
 mid = (start+end)/2
 if arr[mid] < val: 
		return binary_search(arr, val, mid+1, end) 
 elif arr[mid] > val: 
		return binary_search(arr, val, start, mid-1) 
 else: 
		return mid 
def insertion_sort(arr): 
	for i in xrange(1, len(arr)): 
		val = arr[i] 
  j = binary_search(arr, val, 0, i-1) 
  arr = arr[:j] + [val] + arr[j:i] + arr[i+1:] 
 return arr 
print(""Sorted array:"") 
print insertion_sort([37, 23, 0, 17, 12, 72, 31, 
      46, 100, 88, 54]) ",0,0,0,1,0,0,1,0,0
605,"class Sort:
    def __init__(self, array):
        self.array = array
    def binary_insertion_sort(self):
        for i in range(1, len(self.array)):
            key = self.array[i]
            pos = self.binary_search(key, 0, i) + 1
            for k in range(i, pos, -1):
                self.array[k] = self.array[k - 1]
            self.array[pos] = key
        return self.array
    def binary_search(self, element, first, last):
        if last - first <= 1:
            if element < self.array[first]:
                return first - 1
            else:
                return first
        mid = (first + last)//2
        if self.array[mid] < element:
            return self.binary_search(element, mid, last)
        elif self.array[mid] > element:
            return self.binary_search(element, first, mid)
        else:
            return mid
def main():
    array = list(map(int, input(""Enter unsorted array: "").split(' ')))
    obj = Sort(array)
    sorted_array = obj.binary_insertion_sort()
    print(""Sorted Array: "", end = '')
    print(*sorted_array)
if __name__ == ""__main__"":
    main()     ",0,0,0,1,0,0,1,0,0
606,"import java.util.Arrays;
class binaryinsertionsort
{
    public static void main(String[] args)
    {
        final int[] arr = { 37, 23, 0, 17, 12, 72, 31, 46, 100, 88, 54 };
        new binaryinsertionsort().sort(arr);
        for (int i = 0; i < arr.length; i++)
            System.out.print(arr[i] + "" "");
    }
    public void sort(int array[])
    {
        for (int i = 1; i < array.length; i++)
        {
            int x = array[i];
            int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1);
            System.arraycopy(array, j, array, j + 1, i - j);
            array[j] = x;
        }
    }
}",0,0,0,1,0,0,1,0,0
607,"def binary_search(arr, val, start, end):
    if start == end:
        if arr[start] > val:
            return start
        return start + 1
    if start > end:
        return start
    mid = (start + end) // 2
    if arr[mid] < val:
        return binary_search(arr, val, mid + 1, end)
    elif arr[mid] > val:
        return binary_search(arr, val, start, mid - 1)
    else:
        return mid
def insertion_sort(arr):
    for i in range(1, len(arr)):
        val = arr[i]
        j = binary_search(arr, val, 0, i - 1)
        arr = arr[:j] + [val] + arr[j:i] + arr[i + 1:]
    return arr
if __name__ == '__main__':
    arr = [37, 23, 0, 17, 12, 72, 31, 46, 100, 88, 54]
    print(f'List: {arr}')
    print('Sorting...')
    sorted_arr = insertion_sort(arr)
    print(f'List: {sorted_arr}')",0,0,0,1,0,0,1,0,0
608,"package Sorting.Challenges;
public class Challenge2 {
    public static void main(String[] args) {
        int[] arr={20,35,-15,7,55,1,-22};
        iS(arr,7);
        for(int j=0;j<arr.length;j++){
            System.out.print(arr[j]+"" "");
        }
    }
    public static void iS(int[] arr,int numItems){
        if (numItems<2){
            return;
        }
        iS(arr,numItems-1);
        int newElement = arr[numItems-1];
        int i;
        for (i = numItems-1; i > 0 && arr[i-1] > newElement; i--) {
            arr[i] = arr[i-1];
        }
        arr[i] = newElement;
    }
}",0,0,0,1,0,0,0,0,0
609,"exports.heapSort = ({ list }, { compare, swap }) => {
  const getParentIndex = (childIndex) => (
    Math.floor((childIndex - 1) / 2)
  );
  const getLeftChildIndex = (parentIndex) => (
    (parentIndex * 2) + 1
  );
  const getRightChildIndex = (parentIndex) => (
    (parentIndex * 2) + 2
  );
  const shouldSwap = (i, j) => (
    i >= 0 && j >= 0
    && i < list.length
    && j < list.length
    && compare(list[j], list[i]) > 0
  );
  const heapifyUp = (i) => {
    let childIndex = i;
    let parentIndex = getParentIndex(childIndex);
    while (shouldSwap(parentIndex, childIndex)) {
      swap(parentIndex, childIndex);
      childIndex = parentIndex;
      parentIndex = getParentIndex(childIndex);
    }
  };
  const heapify = () => {
    for (let i = 0; i < list.length; i += 1) {
      heapifyUp(i);
    }
    return list;
  };
  const compareChildrenBefore = (i, leftIndex, rightIndex) => {
    if (shouldSwap(leftIndex, rightIndex) && rightIndex < i) {
      return rightIndex;
    }
    return leftIndex;
  };
  const heapifyDownUntil = (i) => {
    let parentIndex = 0;
    let leftIndex = 1;
    let rightIndex = 2;
    let childIndex;
    while (leftIndex < i) {
      childIndex = compareChildrenBefore(i, leftIndex, rightIndex);
      if (shouldSwap(parentIndex, childIndex)) {
        swap(parentIndex, childIndex);
      }
      parentIndex = childIndex;
      leftIndex = getLeftChildIndex(parentIndex);
      rightIndex = getRightChildIndex(parentIndex);
    }
  };
  heapify();
  for (let i = list.length - 1; i > 0; i -= 1) {
    swap(0, i);
    heapifyDownUntil(i);
  }
  return list;
};",0,0,0,0,0,0,0,0,0
610,"import random
from time import time
def CreatList(n):
    alist = []
    for i in range(n, 0, -1):
        alist.append(random.randint(0, n))
    return alist
def Inplace_InsertionSort(L):
    for i in range(1, len(L)):
        currentvalue = L[i]
        while i > 0 and L[i - 1] > currentvalue:
            L[i] = L[i - 1]
            i -= 1
        L[i] = currentvalue
def performace(lenList):
    seqOri = CreatList(lenList)
    seq1 = list(seqOri)
    begin = time()
    Inplace_InsertionSort(seq1)
    end = time()
    diff = (end - begin) * 1000
    print(""Inplace_InsertionSort: "" + str(diff))
    print(""seq1: "" + str(seq1))
    print(""--------------------------------------------------------------------------------------------------------"")
if __name__ == '__main__':
    performace(50)
    performace(100)",0,0,0,1,0,0,0,0,0
611,"public class Insertion {
    public static void sort(int[] input) {
        for (int i = 1; i < input.length; ++i) {
            for (int j = i; j > 0 && input[j - 1] > input[j]; --j) {
                swap(input, j, j - 1);
            }
        }
    }
    private static void swap(int[] input, int a, int b) {
        int cache = input[a];
        input[a] = input[b];
        input[b] = cache;
    }
}",0,0,0,1,0,0,0,0,0
612,"from burstSettings import EOS
def sort(data, array, depth, L, R):
    def less(a, b):
        d = depth
        while True:
            c1 = data[a + d]
            c2 = data[b + d]
            if c1 < c2:
                return True
            if c2 < c1:
                return False
            if c1 == EOS == c2:
                return False
            d += 1
    if len(array) < 2:
        return
    for i in xrange(L + 1, R):
        j = i
        temp = array[i]
        while j > L and less(temp, array[j - 1]):
            array[j] = array[j - 1]
            j -= 1
        array[j] = temp",0,0,0,1,0,0,0,0,0
613,"package piratezpdx.sortathon;
public class Insertion extends ArrayBased {
    Insertion(){
        super();
    }
    public int sort() throws ArrayIndexOutOfBoundsException{
        int count = 0;
        int comparison = 0;
        int focus_element = 0;
        int current_element = 0;
        int array_length = sortingArray.length;
        boolean inserted;
        if (array_length < 1){
            throw new ArrayIndexOutOfBoundsException();
        }
        for (focus_element = 1; focus_element < array_length; focus_element++){
            inserted = false;
            comparison = sortingArray[focus_element];
            for (current_element = 0; (current_element < focus_element) && !inserted; current_element++){
                if (comparison < sortingArray[current_element]){
                    System.arraycopy(sortingArray,current_element,sortingArray,current_element+1,(focus_element-current_element));
                    inserted = true;
                    sortingArray[current_element] = comparison;
                }
                count++;
            }
        }
        return count;
    }
}",0,0,0,1,0,0,0,0,0
614,"def insertion(l: list):
    arr = l[::]
    for i in range(len(arr)):
        for j in range(i, 0, -1):
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
    return arr",0,0,0,1,0,0,0,0,0
615,"package Sorting;
public class Insertion {
	public static <T extends Comparable<T>> void InsertionSort(T arr[])
	{
		int n = arr.length;
        for (int i=1; i<n; ++i)
        {
            T key = arr[i];
            int j = i-1;
            while (j>=0 && arr[j].compareTo(key) > 0)
            {
                arr[j+1] = arr[j];
                j = j-1;
            }
            arr[j+1] = key;
        }
	}
	    public static <T extends Comparable<T>> void InsertionSortRecursive(T arr[])
	    {
	    	InsertionSortRecursiveHelper(arr, arr.length);
	    }
	    private static <T extends Comparable<T>> void InsertionSortRecursiveHelper(T arr[], int n)
	    {
	        if (n <= 1)
	            return;
	        InsertionSortRecursiveHelper( arr, n-1 );
	        T last = arr[n-1];
	        int j = n-2;
	        while (j >= 0 && arr[j].compareTo(last) > 0)
	        {
	            arr[j+1] = arr[j];
	            j--;
	        }
	        arr[j+1] = last;
	    }
}",0,0,0,1,0,0,0,0,0
616,"import structures.src.util.sort_util as util
def sort(arr):
    out = list(arr)
    for i in range(1, len(out)):
        j = i
        while j > 0 and out[j - 1] > out[j]:
            util.swap(out, j, j - 1)
            j -= 1
    return out",0,0,0,1,0,0,0,0,0
617,"def insertion_sort(list):
	for i in range(1,len(list)):
		x = list[i]
  j = i-1
  while (j != -1 and list[j] > x):
			list[j+1] = list[j]
   j-=1
  list[j+1] = x
 return list
a = [2,7,4,1,5,3]
print(a)
insertion_sort(a)
print(a)",0,0,0,1,0,0,0,0,0
618,"package com.sorting;
import java.util.Comparator;
public class Insertion {
	private Insertion() {
	}
	public static void sort(Comparable[] array) {
		if(array == null)
			throw new NullPointerException();
		int N = array.length;
		for (int i = 0; i < N; i++) {
			for (int j = i; j > 0 && less(array[j], array[j - 1]); j--) {
				exch(array, j - 1, j);
			}
		}
	}
	public static void sort(Object[] array, Comparator com) {
		if(array == null)
			throw new NullPointerException();
		int n = array.length;
		for (int i = 0; i < n; i++) {
			for (int j = i; j > 0 && less(array[j], array[j - 1], com); j--) {
				exch(array, j, j - 1);
			}
		}
	}
	private static boolean less(Comparable v, Comparable w) {
		return v.compareTo(w) < 0;
	}
	private static boolean less(Object v, Object w, Comparator c) {
		return c.compare(v, w) < 0;
	}
	private static void exch(Object[] a, int i, int j) {
		Object swap = a[i];
		a[i] = a[j];
		a[j] = swap;
	}
	public static void show(Object[] array) {
		int len = array.length;
		for (int i = 0; i < len; i++)
			System.out.print(array[i] + "","");
	}
}",0,0,0,1,0,0,0,0,0
619,"__all__ = (""insertion_sort"",)
from typing import List, TypeVar
T = TypeVar(""T"")
def insertion_sort(
    data: List[T], *, reverse: bool = False, inplace: bool = False
) -> List[T]:
    if not inplace:
        data = data.copy()
    comparison_op: str = ""__lt__"" if reverse else ""__gt__""
    max_len: int = len(data)
    for i in range(1, max_len):
        selected: T = data[i]
        j: int = i
        while j > 0 and getattr(data[j - 1], comparison_op)(selected):
            data[j] = data[j - 1]  
            j -= 1
        data[j] = selected
    return data",0,0,0,1,0,0,0,0,0
620,"def insertionSort(arr): 
    for i in range(1, len(arr)): 
        key = arr[i] 
        j = i - 1
        while j >=0 and key < arr[j] : 
                arr[j+1] = arr[j] 
                j -= 1
        arr[j+1] = key 
arr = [12, 11, 13, 5, 6, 9, 8] 
print (""Original array is: {}"".format(arr)) 
insertionSort(arr) 
print (""Sorted array is: {}"".format(arr)) ",0,0,0,1,0,0,0,0,0
621,"from timeit import default_timer as timer
def insertion_sort(seq):
    for i in range(1, len(seq)):
        key = seq[i]
        low, up = 0, i
        while up > low:
            middle = (low + up) // 2
            if seq[middle] < key:
                low = middle + 1              
            else:
                up = middle
        seq[:] = seq[:low] + [key] + seq[low:i] + seq[i + 1:]
if __name__ == '__main__':
    time_taken = 0
    x = int(input(""Enter number of trials : ""))
    for n in range(1,x+1):
        with open(""data/random.txt"",""r"") as fileobj:
            list_to_sort = list(map(int, fileobj.readlines()))
            start = timer()
            insertion_sort(list_to_sort)
            current = timer()-start
            print(f""Running test {n} : {current:.2f} seconds"")
            time_taken += current
    assert sorted(list_to_sort) == list_to_sort
    time_taken /= x
    print(f""Insertion sort: average time = {time_taken:.2f} seconds"")",0,0,0,1,0,0,0,0,0
622,"def insertion_sort(num_list):
	for num in range(1,len(num_list)):
		cur_val = num_list[num]
  pos = num  
  while pos > 0 and num_list[pos-1] > cur_val :
			num_list[pos] = num_list[pos-1]
   pos = pos -1
  num_list[pos]= cur_val
 return num_list
print insertion_sort([54,26,93,17,77,31,44,55,20])",0,0,0,1,0,0,0,0,0
623,"from __future__ import print_function
def insertion_sort(collection):
    for index in range(1, len(collection)):
        while index > 0 and collection[index - 1] > collection[index]:
            collection[index], collection[index - 1] = collection[index - 1], collection[index]
            index -= 1
    return collection
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(insertion_sort(unsorted))",0,0,0,1,0,0,0,0,0
624,"def insertionsort(lst):
    if len(lst) <= 1:
        return lst
    else:
        for i in range(1, len(lst)):
            while lst[i] < lst[i-1] and i > 0:
                lst[i], lst[i-1] = lst[i-1], lst[i]
                i -= 1
        return lst
lst = [7, 5, 3, 1, 5, 9, 8, 4, 6, 2, 10]
print(insertionsort(lst))",0,0,0,1,0,0,0,0,0
625,"def insertion_sort(arr):
    for k in range(1, len(arr)):
        key = arr[k]
        j = k
        while j > 0 and arr[j-1] > arr[j]:
            arr[j], arr[j-1] = arr[j-1], arr[j]
            j = j - 1
my_list = [24, 81, 13, 57, 16]
insertion_sort(my_list)
print(my_list)",0,0,0,1,0,0,0,0,0
626,"def insertion_sort(arr, simulation=False):
    for i in range(len(arr)):
        cursor = arr[i]
        pos = i
        while pos > 0 and arr[pos - 1] > cursor:
            arr[pos] = arr[pos - 1]
            pos = pos - 1
        arr[pos] = cursor
    return arr",0,0,0,1,0,0,0,0,0
627,"def insertion_sort(a):
    b = [*a]
    for i in range(len(b)):
        temp = b[i]
        j = i - 1
        while j >= 0 and b[j] > temp:
            b[j+1] = b[j]
            j -= 1
        b[j+1] = temp
    return b
if __name__ == ""__main__"":
    import unittest
    from random import shuffle
    class TestInsertionSort(unittest.TestCase):
        def setUp(self):
            self.ordered = [x for x in range(20)]
            self.shuffled = [*self.ordered]
            while self.ordered == self.shuffled:
                shuffle(self.shuffled)
        def test_insertion_sort(self):
            self.assertEqual(self.ordered, insertion_sort(self.shuffled))
            self.assertNotEqual(self.ordered, self.shuffled)
    unittest.main()",0,0,0,1,0,0,0,0,0
628,"public class insertion_sort 
{
    static void InsertionSort(int arr[]) {
        int j;
        for(int i=1; i<arr.length; i++) {
            j = i;
            while(j>0 && arr[j-1] > arr[j]) {
                int temp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = temp;
                j = j-1;
            }
        }
    }
    static void printarray(int arr[]){
        for(int i=0; i<arr.length; i++)
            System.out.print(arr[i] + "" "");
    } 
    public static void main(String args[]) { 
        int arr[] = {15, 32, 4, 6, 21, 23, 12};
        InsertionSort(arr);
        printarray(arr);
    }
}",0,0,0,1,0,0,0,0,0
629,"def insertion_Sort(arr):
	for i in range(1, len(arr)):
		key = arr[i]
  j = i-1
  while j >= 0 and key < arr[j] :
				arr[j + 1] = arr[j]
    j -= 1
  arr[j + 1] = key
arr = [12, 11, 13, 5, 6]
insertion_Sort(arr)
for i in range(len(arr)):
	print (""% d"" % arr[i])",0,0,0,1,0,0,0,0,0
630,"def InsertionSort(A,n):
    for i in range(1,n):
        value=A[i]
        hole=i
        while(hole>0 and A[hole-1]>value):
            A[hole]=A[hole-1]
            hole=hole-1
        A[hole]=value
if __name__==""__main__"":
    print(""Enter the elements in the array"")
    A=list(map(int,input().split("" "")))
    n=len(A)
    InsertionSort(A,n)
    print(""Sorted Array: "",end="""")
    for i in range(0,n):
        print(A[i],end="" "")",0,0,0,1,0,0,0,0,0
631,"package part2;
public class Insertion_Sort {
	public static Comparable[] Insertion_Sort(Comparable[]a) {
		for(int i=1; i<a.length; i++) {
			for(int j=i; j>0 && a[j].compareTo(a[j-1]) < 0; j--) {
				swap(a,j,j-1);
			}
		}
		return a;
	}
	private static boolean less(Comparable a, Comparable b) {
		if(a.compareTo(b) < 0) {
			return true;
		}
		return false;
	}
	public static void swap(Comparable[] a, int j, int b) {
		Comparable temp = a[j-1];
		a[j-1] = a[j];
		a[j]=temp;
	}
}",0,0,0,1,0,0,0,0,0
632,"import copy
import sort_tools
def insertion_sort(data, n):
    for i in range(1, n):
        temp = data[i]; 
        j = i
        while j > 0 and data[j-1] > temp:
            data[j] = data[j-1]
            j -= 1
        data[j] = temp
@sort_tools.timeit('insertion')
def sort(data):
    insertion_sort(data, len(data))
def main():
    data = sort_tools.build_data_set(5)
    unsorted = copy.deepcopy(data)
    sort(unsorted)
if __name__ == ""__main__"":
    main()",0,0,0,1,0,0,0,0,0
633,"def sort(arr):
    alen = len(arr)
    for i in range(1, alen):
        item = arr[i]
        j = i - 1
        while j >= 0 and item < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = item",0,0,0,1,0,0,0,0,0
634,"def insertion_sort(lis):
    for i in range(len(lis)):
        j = i
        while j > 0 and lis[j-1] > lis[j]:
            lis[j], lis[j-1] = lis[j-1], lis[j]
            j -= 1
    return lis
def main():
    lis1 = [4, 1, 2, 3, 9]
    lis2 = [1]
    lis3 = [2, 2, 1, -1, 0, 4, 5, 2]
    lis4 = []
    lis1 = insertion_sort(lis1)
    assert lis1 == [1, 2, 3, 4, 9]
    lis2 = insertion_sort(lis2)
    assert lis2 == [1]
    lis3 = insertion_sort(lis3)
    assert lis3 == [-1, 0, 1, 2, 2, 2, 4, 5]
    lis4 = insertion_sort(lis4)
    assert lis4 == []
if __name__ == '__main__':
    main()",0,0,0,1,0,0,0,0,0
635,"def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        v = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > v:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = v
    return arr",0,0,0,1,0,0,0,0,0
636,"def insertion_sort(arr):
    for i in range(1,len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr",0,0,0,1,0,0,0,0,0
637,"from strategy import Order, BadOrderError
import sys
__author__ = ""Pablo Acereda""
__copyright__ = ""Copyright 2020""
__credits__ = [ ""Pablo Acereda"" ]
__license__ = ""Apache License 2.0""
__version__ = ""1.0""
__maintainer__ = ""Pablo Acereda""
__email__ = ""p.aceredag@gmail.com""
def sort(array:list, order:Order=Order.ASC) -> list:
    if (order not in [Order.ASC, Order.DESC]):
        raise BadOrderError(""Not Valid Ordering Preference"")
    for i in range(1, len(array)):
        key = array[i]
        j = i - 1
        while (j >= 0 and 
               order == Order.ASC  and key < array[j] or 
               order == Order.DESC and key > array[j]):  
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = key
    return array",0,0,0,1,0,0,0,0,0
638,"import time
import random
def insertion_sort(data):
	for i in range(1, len(data)):
		j = i - 1
  while j >= 0:
			if data[i] >=data[j]:
				break
   else:
				data[i],data[j] = data[j], data[i]
    i = j
    j -= 1
if __name__ == '__main__':
	lista = [_ for _ in range(1000)]
 random.shuffle(lista)
 start_time = time.time()
 insertion_sort(lista)
 end_time = time.time()
 print(""Time: "", end_time - start_time)
 print(lista)",0,0,0,1,0,0,0,0,0
639,"package Sorting;
public class Insertion_Sort {
    void Insertion_Sort(int[] givenArr){
        for(int i=1;i<givenArr.length;i++){
            int tmp = givenArr[i];
            for(int j=i-1;j>=0;j--){
                if(tmp<givenArr[j]){
                    swap(givenArr,j+1,j);
                }
                else{
                    break;
                }
            }
        }
    }
    void swap(int[] arr,int a,int b){
        int tmp = arr[b];
        arr[b] = arr[a];
        arr[a] = tmp;
    }
    public static void main(String[] args) {
        int[] given_arr = new int[]{10,2,8,1,4,6,5,7,9};
        Insertion_Sort insertion_sort = new Insertion_Sort();
        insertion_sort.Insertion_Sort(given_arr);
        insertion_sort.printArr(given_arr);
    }
    private void printArr(int[] given_arr) {
        for(int i=0;i<given_arr.length;i++){
            System.out.print(given_arr[i]+"" "");
        }
    }
}",0,0,0,1,0,0,0,0,0
640,"const insertionSort = arr => {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    let el = arr[i];
    let j;
    for (j = i - 1; j >= 0 && arr[j] > el; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = el;
  }
  return arr;
};
console.log(insertionSort([3, 0, 2, 5, -1, 4, 1]));",0,0,0,1,0,0,0,0,0
641,"def insertionSort(alist):
    for index in range(1, len(alist)):
        current_value = alist[index]
        position = index
        while position > 0 and alist[position - 1] > current_value:
            alist[position] = alist[position - 1]
            position -= 1
            alist[position] = current_value
def main():
    alist = [54, 26, 93, 17, 77, 31, 44, 55, 20]
    insertionSort(alist)
    print(alist)
if __name__ == '__main__':
    main()",0,0,0,1,0,0,0,0,0
642,"def insertionSort(arr): 
	for i in range(1, len(arr)): 
		key = arr[i] 
  j = i-1
  while j >=0 and key < arr[j] : 
				arr[j+1] = arr[j] 
    j -= 1
  arr[j+1] = key 
arr = [12, 11, 13, 5, 6] 
insertionSort(arr) 
print (""Sorted array is:"") 
for i in range(len(arr)): 
	print (""%d"" %arr[i]) ",0,0,0,1,0,0,0,0,0
643,"import java.util.Scanner;
public class InsertionOpt {
    private InsertionOpt() {
    }
    public static void sort(Comparable[] a) {
        int n = a.length;
        int exchanges = 0;
        for (int i = n - 1; i > 0; i--) {
            if (less(a[i], a[i - 1])) {
                swap(a, i, i - 1);
                exchanges++;
            }
        }
        if (exchanges == 0) return;
        for (int i = 2; i < n; i++) {
            Comparable v = a[i];
            int j = i;
            while (less(v, a[j - 1])) {
                a[j] = a[j - 1];
                j--;
            }
            a[j] = v;
        }
        assert isSorted(a);
    }
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }
    private static void swap(Object[] a, int i, int j) {
        Object swp = a[i];
        a[i] = a[j];
        a[j] = swp;
    }
    private static boolean isSorted(Comparable[] a) {
        for (int i = 1; i < a.length; i++)
            if (less(a[i], a[i - 1])) return false;
        return true;
    }
    private static void show(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + "" "");
        }
    }
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        String[] a = scan.nextLine().split("" "");
        InsertionOpt.sort(a);
        show(a);
    }
}",0,0,0,1,0,0,0,0,0
644,"package sort.primary;
import sort.Sort;
public class InsertionSort extends Sort {
    @Override
    public void sortMethod(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = i; j > 0; j--) {
                if (less(a[j], a[j - 1]))
                    exch(a, j, j - 1);
            }
        }
    }
    public static void sort(Comparable[] a) {
        new InsertionSort().sortMethod(a);
    }
}",0,0,0,1,0,0,0,0,0
645,"function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let currentVal = arr[i];
    for (var j = i - 1; j >= 0 && arr[j] > currentVal; j--) {
      arr[j + 1] = arr[j];
    }
    arr[j + 1] = currentVal;
  }
  return arr;
}
insertionSort([2, 1, 9, 76, 4]);",0,0,0,1,0,0,0,0,0
646,"def insertion_sort(A, comp):
    for k in range(1,len(A)):
        current = A[k]
        j = k
        while j > 0 and (comp (A[j - 1], current) < 0):
            A[j] = A[j - 1]
            j -= 1
        A[j] = current
        print(k, A)
def int_comparator(i,j):
    return j-i
if __name__ == '__main__':
    list = [5, 10, 58, 23, 1, 2]
    insertion_sort(list, int_comparator)",0,0,0,1,0,0,0,0,0
647,"package src.algorithms;
import src.strategy.Order;
public class InsertionSort<T> extends SortingAlgorithm<T> {
	@Override
	@SuppressWarnings(""hiding"")
	public<T extends Comparable<T>> T[] sort(T[] elements, Order order) {
		int numElements = elements.length;
		for (int i=1; i<numElements; i++) {
			T edgeElement = elements[i];
			int j = i - 1;
			while (j >= 0 && (
				   order == Order.ASC  && edgeElement.compareTo(elements[j]) < 0   ||
			       order == Order.DESC && edgeElement.compareTo(elements[j]) > 0)) {
				elements[j + 1] = elements[j];
				j -= 1;
			}
			elements[j + 1] = edgeElement;
		}
		return elements;
	}
}",0,0,0,1,0,0,0,0,0
648,"function insertionSort (arrData) {
  'use strict'
  let dataMax = arrData.length
  console.log('Initial:', arrData.join(), `[Count:${dataMax}]`)
  for (let indexA = 1; indexA < dataMax; indexA++) {
    console.log(arrData.join())
    const indexB = arrData[indexA]
    let indexC = indexA
    while (indexC > 0 && arrData[indexC - 1] > indexB) {
      arrData[indexC] = arrData[--indexC]
    }
    arrData[indexC] = indexB
    console.log('Cycle:', arrData.join())
  }
  console.log('Final:', arrData.join())
  return arrData
}",0,0,0,1,0,0,0,0,0
649,"class InsertionSort:
    def sort(A):
        a_len = len(A)
        for i in range(1, a_len):
            v = A[i]
            j = i - 1
            while((j >= 0) and A[j] > v):
                A[j+1] = A[j]
                j = j - 1
            A[j+1] = v
        return A",0,0,0,1,0,0,0,0,0
650,"package javaSorting;
public class InsertionSort {
	public static void sort(int data[]) {
		for (int i = 1; i < data.length; i++) {
			int j = i - 1;
			while (j >= 0) {
				if (data[i] >= data[j]) {
					break;
				} else {
					int temp = data[j];
					data[j] = data[i];
					data[i] = temp;
					i = j;
					j -= 1;
				}
			}
		}
	}
	private static void printSortedArray(int data[]) {
		for (int i = 0; i < data.length; i++) {
			System.out.println(data[i]);
		}
	}
	public static void main(String[] args) {
		int SIZE = 1000;
		int[] data = new int[SIZE];
		for (int i = 0; i < SIZE; i++) {
			data[i] = i;
		}
		Shuffle.shuffleData(data);
		long start = System.currentTimeMillis();
		sort(data);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		printSortedArray(data);
		System.out.println(elapsed);
	}
}",0,0,0,1,0,0,0,0,0
651,"function Insertionsort(A) {
    var i, v, j, a_len;
    a_len = A.length;
    for (i=1; i < a_len; i++) {
        v = A[i];
        j = i - 1;
        while ((j >= 0) && (A[j] > v)) {
            A[j+1] = A[j];
            j = j -1;
        }
        A[j+1] = v;
    }
    return A;
}
var X = [5,21,40,11,3,1,7,2,4,6,10,18,9,8];
console.log(X);
Insertionsort(X);
console.log(X);",0,0,0,1,0,0,0,0,0
652,"def insertionSort(list):
    length = len(list)
    for i in range(1, length):
        currentElement = list[i]
        currentPosition = i
        while list[currentPosition - 1] > currentElement and currentPosition > 0:
            list[currentPosition] = list[currentPosition - 1]
            currentPosition -= 1
        list[currentPosition] = currentElement
    return list
myList = [343,12,45,13,87,45,25,665,5,234,6,23,5]
print(myList)
print(insertionSort(myList))",0,0,0,1,0,0,0,0,0
653,"import java.util.Scanner;
public class InsertionSort {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements : "");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter "" + n + "" elements :"");
        for (int i = 0; i < n; i++)
            arr[i] = sc.nextInt();
        insertionSort(arr);
        System.out.println(""\nThe sorted array : ;"");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    static void insertionSort(int arr[]) {
        int len = arr.length, tmp, j;
        for (int i = 1; i < len; i++) {
            tmp = arr[i];
            for (j = i; j > 0; j--) {
                if (arr[j - 1] > tmp)
                    arr[j] = arr[j - 1];
                else
                    break;
            }
            arr[j] = tmp;
        }
    }
}",0,0,0,1,0,0,0,0,0
654,"const insertionSort = arr => {
    const len = arr.length;
    for (let i = 0; i < len; i++) {
      let el = arr[i];
      let j;
      for (j = i - 1; j >= 0 && arr[j] > el; j--) {
        arr[j + 1] = arr[j];
      }
      arr[j + 1] = el;
    }
    return arr;
  };",0,0,0,1,0,0,0,0,0
655,"def insertion_sort(nums):
    for i in range(1, len(nums)):
        item_to_insert = nums[i]
        j = i - 1
        while j >= 0 and nums[j] > item_to_insert:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = item_to_insert
random_list_of_nums = [9, 1, 15, 28, 6]
insertion_sort(random_list_of_nums)
print(random_list_of_nums)",0,0,0,1,0,0,0,0,0
656,"public class InsertionSort
{
    private int[] A;
    public InsertionSort(int[] data)
    {
        A = data;
    }
    public int[] sort()
    {
        int i, j, v;
        int a_len = A.length;
        for(i=0; i<a_len; i++)
        {
            v = A[i];
            j = i - 1;
            while((j >= 0) && (A[j] > v))
            {
                A[j+1] = A[j];
                j = j - 1;
            }
            A[j+1] = v;
        }
        return A;
    }
}",0,0,0,1,0,0,0,0,0
657,"def InsertionSort(List):
    for i in range(1, len(List)):
        key = List[i]
        j = i - 1
        while j >= 0 and key < List[j]:
            List[j + 1] = List[j]
            j -= 1
        List[j + 1] = key
    print('The sorted list: \t', List)
if __name__ == ""__main__"":
    lst = []
    size = int(input(""\nEnter size of the list: \t""))
    for i in range(size):
        elements = int(input(""Enter the element: \t""))
        lst.append(elements)
    InsertionSort(lst)",0,0,0,1,0,0,0,0,0
658,"import java.util.Arrays;
public class InsertionSort {
	private int [] input;
	public InsertionSort(int [] input) {
		this.input = input.clone();
	}
	public int [] sort(){
		for (int i = 1; i < this.input.length; i++) {
			int j = i;
			while (j > 0 && this.input[j] < this.input[j - 1]){
				swap(j - 1,j);
				j--;
			}
		}
		return this.input;
	}
	private void swap(int i, int j){  
		int tmp = this.input[i];
		this.input[i] = this.input[j];
		this.input[j] = tmp;
	}
	public static void main(String[] args) {
		int array[] = {9,1,0,4,2,-1,5,2, 200, 99, 45, -100};
		InsertionSort insertionsort = new InsertionSort(array);
		System.out.println(""Unsorted Array -> ""+ Arrays.toString(array));
		System.out.println(""InsertionSort -> ""+ Arrays.toString(insertionsort.sort()));  
	}
}",0,0,0,1,0,0,0,0,0
659,"def insertionSort(arr):
	for i in range(1, len(arr)):
		key = arr[i]
  j = i-1
  while j >= 0 and key < arr[j] :
				arr[j + 1] = arr[j]
    j -= 1
  arr[j + 1] = key
arr = [12, 11, 13, 5, 6]
insertionSort(arr)
for i in range(len(arr)):
	print (""% d"" % arr[i])",0,0,0,1,0,0,0,0,0
660,"package org.neeraj.algorithms.sorting;
public class InsertionSort implements Sorter
{
    public void sort(Comparable[] array)
    {
	int n = array.length;
	for (int j = 1; j < n; j++) {
	    Comparable k = array[j];
	    int i = j-1;
	    while (i >= 0 && array[i].compareTo(k) > 0) {
		array[i+1] = array[i];
		i--;
	    }
	    array[i+1] = k;
	}
    }
}",0,0,0,1,0,0,0,0,0
661,"def insertionsort(lst):
    for j in range(1, len(lst)):
        key = lst[j]
        i = j - 1
        while i >= 0 and lst[i] > key:
            lst[i + 1] = lst[i]
            i -= 1
        lst[i + 1] = key
    return lst
if __name__ in ""__main__"":
    a = [1, 0, 2, 4, 5, 6, 2, 7, 9, 1, 3, 8, -1]
    print('list          :', a)
    print('insertion sort:', insertionsort(a), insertionsort(a) == sorted(a))",0,0,0,1,0,0,0,0,0
662,"public class InsertionSort {
	public static void sort(int arr[]) {
		int arrLen = arr.length;
		for (int i = 1; i < arrLen; ++i) {
			int key = arr[i];
			int j = i - 1;
			while(j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j -= 1;
			}
			arr[j + 1] = key;
		}
	}
}",0,0,0,1,0,0,0,0,0
663,"import time
numbers = []
def insertion_sort(list):
    i = 0
    j = 0
    for index in range(len(list)):
        j = index
        while (j > 0) and (list[j-1] > list[j]):
            list[j-1] , list[j] = list [j] , list[j-1]
            j -= 1
def read_from_file(filepath):
    del numbers[:]
    file = open(filepath,'r')
    for i in file:
        numbers.append(int(i))
    file.close()
def print_first_ten_number():
    print numbers[0:9]
def print_last_ten_number():
    print numbers[len(numbers)-10:len(numbers)]
def append_result_to_file(str):
    with open(""results.txt"", ""a"") as result:
        result.write(str+""\n"")
        result.close()
if __name__ == '__main__':
    read_from_file(""../1k.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""1k = "" + str(end-start))
    read_from_file(""../10k.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""10k = "" + str(end-start))
    read_from_file(""../100k.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""100k = "" + str(end-start))
    read_from_file(""../1m.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""1m = "" + str(end-start))
    read_from_file(""../2m.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""2m = "" + str(end-start))     
    read_from_file(""../4m.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""4m = "" + str(end-start))
    read_from_file(""../8m.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""8m = "" + str(end-start))
    read_from_file(""../10m.lst"")
    start = time.clock()
    insertion_sort(numbers)
    end = time.clock()
    append_result_to_file(""10m = "" + str(end-start))",0,0,0,1,0,0,0,0,0
664,"package com.aokolnychyi.sorting;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class InsertionSort {
  public static <T extends Comparable<? super T>> void sort(final List<T> elements) {
    for (int index = 1; index < elements.size(); index++) {
      final T currentElement = elements.get(index);
      int previousIndex = index - 1;
      while (previousIndex >= 0 && currentElement.compareTo(elements.get(previousIndex)) < 0) {
        elements.set(previousIndex + 1, elements.get(previousIndex));
        previousIndex--;
      }
      elements.set(previousIndex + 1, currentElement);
    }
  }
  public static <T extends Comparable<T>> void sort(T[] elements) {
    for (int index = 1; index < elements.length; index++) {
      final T currentElement = elements[index];
      int previousIndex = index - 1;
      while (previousIndex >= 0 && currentElement.compareTo(elements[previousIndex]) < 0) {
        elements[previousIndex + 1] = elements[previousIndex];
        previousIndex--;
      }
      elements[previousIndex + 1] = currentElement;
    }
  }
  public static void main(String[] args) {
    final Integer[] ints = new Integer[]{4, 1, 5, 3, 9, 10, 1};
    sort(ints);
    System.out.println(Arrays.toString(ints));
    final List<Integer> list = new ArrayList<>();
    list.add(4);
    list.add(1);
    list.add(5);
    list.add(3);
    list.add(9);
    list.add(10);
    list.add(1);
    sort(list);
    System.out.println(list);
    sort(new ArrayList<Integer>());
  }
}",0,0,0,1,0,0,0,0,0
665,"import time 
def InsertionSort(data, drawDataArray, sortSpeedTime):
    for i in range (1, len(data)): 
        key = data[i]
        j = i-1
        while j >= 0 and key < data[j]: 
            data[j + 1] = data[j] 
            j -= 1
            drawDataArray(data, ['purple' if x == j or x == j + 1 else 'red' for x in range(len(data))])
            time.sleep(sortSpeedTime)
        data[j + 1] = key ",0,0,0,1,0,0,0,0,0
666,"package sorting;
class insertionSort {
    static void insertionsort(int a[]){
        for(int i=1;i<a.length;i++){
            for(int j=i;j>0;j--){
                if(a[j]<a[j-1]){
                    swap(a,j,j-1);
                }
            }
        }
    }
    static void swap(int a[],int p,int q){
                    int temp = a[p];
                    a[p]=a[q];
                    a[q]=temp;
    }
}",0,0,0,1,0,0,0,0,0
667,"import time
from colors import *
def insertion_sort(data, drawData, timeTick):
    for i in range(len(data)):
        temp = data[i]
        k = i
        while k > 0 and temp < data[k-1]:
            data[k] = data[k-1]
            k -= 1
        data[k] = temp
        drawData(data, [YELLOW if x == k or x == i else BLUE for x in range(len(data))])
        time.sleep(timeTick)
    drawData(data, [BLUE for x in range(len(data))])",0,0,0,1,0,0,0,0,0
668,"public class InsertionSort {
    public static void main(String[] args) {
        int[] input = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};
        for (int i = 1; i < 10; i++) {
            int tmp = input[i];
            int x = i - 1;
            while (x >= 0 && tmp <= input[x]) {
                input[x + 1] = input[x];
                x = x - 1;
            }
            input[x + 1] = tmp;
        }
        System.out.println(""Insertion Sort : Sorted List"");
        for (int i = 0; i < 10; i++) {
            System.out.println(input[i]);
        }
    }
}",0,0,0,1,0,0,0,0,0
669,"insertionSort = function(array) {
  var i, j,
      a = array.slice(0);
  for (i = 0, l = a.length; i < l; i++) {
    j = i;
    while (j > 0 && a[j - 1] > a[j]) {
      a[j] = a[j - 1] + (a[j - 1] = a[j], 0);
      j--;
    }
  }
  return a;
};",0,0,0,1,0,0,0,0,0
670,"function insertionSort(array){
    for (let p = 1; p < array.length; p++)
    {
        let temp = array[p];  
        var j;
        for (j = p; j > 0 && array[j-1] > temp; j--)
            array[j] = array[j-1];
        array[j] = temp;
    }
}
function sort(array){
    insertionSort(array);
}",0,0,0,1,0,0,0,0,0
671,"def insertionSort(inputArray):
	n = len(inputArray)
 for i in range(1,n):
		key = inputArray[i]
  j = i-1
  while (j >= 0 and inputArray[j]>key):
			inputArray[j+1] = inputArray[j]
   j = j - 1
  inputArray[j+1] = key
 return inputArray",0,0,0,1,0,0,0,0,0
672,"package com.satishkumarprasad.algo.sortingalgos;
public class InsertionSort implements SortingAlgorithm {
	@Override
	public void sort(int[] array) {
		for (int i = 1; i < array.length; i++) {
			int key = array[i];
			int j = i - 1;
			while (j >= 0 && array[j] > key) {
				array[j + 1] = array[j];
				j--;
			}
			array[j + 1] = key;
		}
	}
}",0,0,0,1,0,0,0,0,0
673,"import time
def sort(bar, layout, num, colors):
    data = list(bar.y)
    count = 0
    for i in range(1, num):
        key = data[i]
        j = i-1
        count += 1
        layout.xaxis.title.text = ""Number of operations: "" + str(count)
        while j>=0 and key < data[j]:
            data[j+1] = data[j]
            colors[j+1] = 'blue'
            colors[j] = 'yellow'
            bar.marker.color = colors
            bar.y = data
            time.sleep(0.1)
            colors[j] = 'blue'
            bar.marker.color = colors
            j -= 1
            count += 1
            layout.xaxis.title.text = ""Number of operations: "" + str(count)
        data[j+1] = key
        bar.y = data
        colors[i] = 'blue'
        bar.marker.color = colors",0,0,0,1,0,0,0,0,0
674,"package me.gilday.revision.sorting.insertion;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class InsertionSort {
	private static Logger logger = LoggerFactory.getLogger(InsertionSort.class);
	public static void sort(int[] values) {
		logger.trace(""==Sorting=="");
		logger.trace(Arrays.toString(values));
		for (int j = 1; j < values.length; j++) {	
			int insert = values[j];
			int i = j - 1;
			while (i >= 0 && values[i] > insert) {
				values[i+1] = values[i];
				i = i - 1;
				logger.trace(Arrays.toString(values));
			}
			values[i + 1] = insert;
			logger.trace(Arrays.toString(values));
		}	
	}	
	public static void sortAlternative(int[] values) {
		logger.trace(""==Sorting=="");
		logger.trace(Arrays.toString(values));
		for (int i = 1; i < values.length; i++) {
			int insert = values[i];
			int j = i - 1;
			boolean done = false;
			do {
				if (values[j] > insert) {
					values[j+1] = values[j];
					j = j - 1;					
				} else {
					done = true;
				}
				logger.trace(Arrays.toString(values));
			} while (!done && j >= 0);
			values[j + 1] = insert;
			logger.trace(Arrays.toString(values));
		}		
	}
}",0,0,0,1,0,0,0,0,0
675,"package main;
public class InsertionSort {
    public static void main(String a[]) {
        int[] arr1 = {10, 34, 2, 56, 7, 67, 88, 42};
        doInsertionSort(arr1);
        for (int num : arr1) {
            System.out.print(num);
            System.out.print("", "");
        }
    }
    public static void doInsertionSort(int[] input) {
        for (int i = 1; i < input.length; i++) {
            for (int j = i; j > 0; j--) {
                if (input[j] < input[j - 1]) {
                    int temp = input[j];
                    input[j] = input[j - 1];
                    input[j - 1] = temp;
                }
            }
        }
    }
}",0,0,0,1,0,0,0,0,0
676,"package Sorts;
import static Sorts.SortUtils.less;
import static Sorts.SortUtils.print;
class InsertionSort implements SortAlgorithm {
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        for (int j = 1; j < array.length; j++) {
            T key = array[j];
            int i = j - 1;
            while (i >= 0 && less(key, array[i])) {
                array[i + 1] = array[i];
                i--;
            }
            array[i + 1] = key;
        }
        return array;
    }
    public static void main(String[] args) {
        Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        InsertionSort sort = new InsertionSort();
        sort.sort(integers);
        print(integers);
        String[] strings = {""c"", ""a"", ""e"", ""b"",""d""};
        sort.sort(strings);
        print(strings);
    }
}",0,0,0,1,0,0,0,0,0
677,"package com.deepak.algorithms.Sorting;
import com.deepak.algorithms.Library.ArrayUtils;
public class InsertionSort {
	public static Integer[] performInsertionSort(Integer[] list) {
		for (int i = 1; i < list.length; i++) {
			for (int j = i; j > 0; j--) {
				if (list[j] < list[j - 1]) {
					ArrayUtils.swap(list, j, j - 1);
				}
			}
		}
		return list;
	}
}",0,0,0,1,0,0,0,0,0
678,"package sortvisualiser.algorithms;
import sortvisualiser.SortArray;
public class InsertionSort implements ISortAlgorithm {
    private long stepDelay = 1;
    @Override
    public void runSort(SortArray array) {
        for (int i = 0; i < array.arraySize(); i++) {
            int key = array.getValue(i);
            int j = i - 1;
            while (j >= 0 && array.getValue(j) > key) {
                array.updateSingle(j + 1, array.getValue(j), 5, true);
                j--;
            }
            array.updateSingle(j + 1, key, getDelay(), true);
        }
    }
    @Override
    public String getName() {
        return ""Insertion Sort"";
    }
    @Override
    public long getDelay() {
        return stepDelay;
    }
    @Override
    public void setDelay(long delay) {
        this.stepDelay = delay;
    }
}",0,0,0,1,0,0,0,0,0
679,"package com.calebkoy.sortingalgovisualiser;
import java.util.ArrayList;
public class InsertionSort {
    private static final String NAME = ""Insertion sort"";
    public void sort(ArrayList<Integer> data) {
        if (data == null) {
            throw new IllegalArgumentException(""The data should not be null"");
        }
        if ((data.isEmpty()) || (data.size() == 1)) {
            return;
        }
        sort(data, 0, data.size() - 1);
    }
    public void sort(ArrayList<Integer> data, int left, int right) {
        if (data == null) {
            throw new IllegalArgumentException(""The data should not be null"");
        }
        if ((data.isEmpty()) || (data.size() == 1)) {
            return;
        }
        validateIndices(data, left, right);
        for (int i = left + 1; i < right + 1; i++) {
            int key = data.get(i);
            int j = i - 1;
            while (j >= left && data.get(j) > key) {
                data.set(j + 1, data.get(j));
                j -= 1;
            }
            data.set(j + 1, key);
        }
    }
    private void validateIndices(ArrayList<Integer> data, int left, int right) {
        if ((left < 0) || (right < 0)) {
            throw new IllegalArgumentException(""Indices left and right should be >= 0, but left is "" + left +
                    "" and right is "" + right);
        }
        if ((left >= data.size() - 1) && (left != right)) {
            throw new IllegalArgumentException(""Index left must be < data.size() - 1, but left is "" + left +
                    "", (data.size() - 1) equals "" + (data.size() - 1) + "" and right is "" + right);
        }
        if (right > data.size() - 1) {
            throw new IllegalArgumentException(""Index right must be <= data.size() - 1, but right is "" + right +
                    "" and (data.size() - 1) equals "" + (data.size() - 1));
        }
    }
    public static String getName() {
        return NAME;
    }
}",0,0,0,1,0,0,0,0,0
680,"package sorting;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class InsertionSort {
  public static void sort(Comparable[] a) {  
    int N = a.length;
    for (int i = 1; i < N; i++) {  
      for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
        exch(a, j, j-1);
    }
  }
  private static boolean less(Comparable v, Comparable w) { 
    return v.compareTo(w) < 0;  
  }
  private static void exch(Comparable[] a, int i, int j) { 
    Comparable t = a[i]; 
    a[i] = a[j]; 
    a[j] = t; 
  }
  private static void show(Comparable[] a) {  
    for (int i = 0; i < a.length; i++)
      StdOut.printf(""%s\n"", a[i]);
  }
  public static boolean isSorted(Comparable[] a) {  
    for (int i = 1; i < a.length; i++)
      if (less(a[i], a[i-1])) return false;
    return true;
  }
  public static void main(String[] args) {  
    String[] a = StdIn.readAllStrings();
    sort(a);
    assert isSorted(a);
    show(a);
  }
}",0,0,0,1,0,0,0,0,0
681,"package insertion_sort;
public class InsertionSort {
    public void sort(int[] array) {
        for (int i = 1; i < array.length; i++) {
            int key = array[i];
            int j = i;
            while (j > 0 && array[j - 1] > key) {
                array[j] = array[j - 1];
                j--;
            }
            array[j] = key;
        }
    }
}",0,0,0,1,0,0,0,0,0
682,"package Jacob.Sorts;
import Jacob.*;
public class InsertionSort implements Runnable{
	private Integer[] toBeSorted;
	private VisualizerFrame frame;
	private boolean fast;
	public InsertionSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) {
		this.toBeSorted = toBeSorted;
		this.frame = frame;
		this.fast = fast;
	}
	public void run() {
		if (fast) {
			sortFast();
		} else {
			sortSlow();
		}
		SortingVisualizer.isSorting=false;
	}
	public void sortFast() {
		int temp = 0;
		int insert = 0;
		for(int i = 1; i<toBeSorted.length; i++){
			insert = i;
			for(int j = i-1; j>=0; j--){
				if (toBeSorted[i] < toBeSorted[j]){
					insert = j;
					if (j == 0){
						break;
					}
				}else{
					break;
				}
			}
			temp = toBeSorted[i];
			for (int j = i; j>insert; j--){
				toBeSorted[j] = toBeSorted[j-1];
			}
			toBeSorted[insert] = temp;
			frame.reDrawArray(toBeSorted, i);
			try {
				Thread.sleep(SortingVisualizer.sleep);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	public void sortSlow() {
		int temp = 0;
		int insert = 0;
		for(int i = 1; i<toBeSorted.length; i++){
			insert = i;
			for(int j = i-1; j>=0; j--){
				if (toBeSorted[i] < toBeSorted[j]){
					insert = j;
					if (j == 0){
						break;
					}
				}else{
					break;
				}
				frame.reDrawArray(toBeSorted, i, insert);
				try {
					Thread.sleep(SortingVisualizer.sleep);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			temp = toBeSorted[i];
			for (int j = i; j>insert; j--){
				toBeSorted[j] = toBeSorted[j-1];
			}
			toBeSorted[insert] = temp;
		}
		frame.reDrawArray(toBeSorted);
	}
}",0,0,0,1,0,0,0,0,0
683,"package eu.happycoders.sort.method;
public class InsertionSort implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    sort(elements, 0, elements.length);
  }
  public void sort(int[] elements, int fromIndex, int toIndex) {
    for (int i = fromIndex + 1; i < toIndex; i++) {
      int elementToSort = elements[i];
      int j = i;
      while (j > fromIndex && elementToSort < elements[j - 1]) {
        elements[j] = elements[j - 1];
        j--;
      }
      elements[j] = elementToSort;
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    sort(elements, 0, elements.length, counters);
  }
  public void sort(int[] elements, int fromIndex, int toIndex,
                   Counters counters) {
    for (int i = fromIndex + 1; i < toIndex; i++) {
      counters.incIterations();
      int number = elements[i];
      counters.incReads();
      int j = i;
      while (j > fromIndex) {
        counters.incIterations();
        counters.incComparisons();
        if (!(number < elements[j - 1])) break;
        elements[j] = elements[j - 1];
        counters.incReads();
        counters.incWrites();
        j--;
      }
      elements[j] = number;
      counters.incWrites();
    }
  }
}",0,0,0,1,0,0,0,0,0
684,"require('../../../common/array-extensions');
const { isEmpty, isFunction } = require('../../../common/utils');
const insertionSort = function(list) {
    if (isEmpty(list)) {
        return list;
    }
    if (list.length < 2) {
        return list;
    }
    const allItemsComparable = list.reduce(
        (acc, item) => (acc &= isFunction(item.compareTo)),
        true
    );
    let key = 0;
    let i = 0;
    for (let firstUnsortedIndex = 1; firstUnsortedIndex < list.length; firstUnsortedIndex++) {
        key = list[firstUnsortedIndex];
        i = firstUnsortedIndex - 1;
        if (allItemsComparable) {
            while (i >= 0 && key.compareTo(list[i]) < 0) {
                list.swap(i, i + 1);
                i--;
            }
        } else {
            while (i >= 0 && key < list[i]) {
                list.swap(i, i + 1);
                i--;
            }
        }
    }
    return list;
};
module.exports = { insertionSort };",0,0,0,1,0,0,0,0,0
685,"""use strict"";
Array.prototype.insertionsort = function(compare) {
    if (""function"" != typeof compare) {
        var desc = compare || false;
        compare = function(a, b) {
            return desc ? a < b : a > b;
        }
    }
    var that = this;
    function swap(i, j) {
        var temp = that[i];
        that[i] = that[j];
        that[j] = temp;
    }
    for (var i = 1; i < this.length; i += 1) {
        var j = i;
        while (j > 0 && compare(this[j - 1], this[j])) {
            swap(j - 1, j);
            j -= 1;
        }
    }
    return this;
}",0,0,0,1,0,0,0,0,0
686,"def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
if __name__ == '__main__':
    nums = [12, 11, 13, 5, 6]
    insertion_sort(nums)
    print(nums)",0,0,0,1,0,0,0,0,0
687,"package com.mehmetpekdemir.sort.insertionsort;
public final class InsertionSort {
	public static void sort(int[] array) {
		for (int firstUnsortedIndex = 1; firstUnsortedIndex < array.length; firstUnsortedIndex++) {
			int newElement = array[firstUnsortedIndex];
			int i;
			for (i = firstUnsortedIndex; i > 0 && array[i - 1] > newElement; i--) {
				array[i] = array[i - 1];
			}
			array[i] = newElement;
		}
	}
}",0,0,0,1,0,0,0,0,0
688,"package sorting;
public class InsertionSort<T extends Comparable<T>> implements Sort<T>, PartialSort<T> {
    @Override
    public void sort(T[] items) {
        for (int s = 1; s < items.length; s++) {
            for (int i = s; i > 0 && items[i].compareTo(items[i - 1]) < 0; i--) {
                SortUtils.swap(items, i, i - 1);
            }
        }
    }
    @Override
    public void sortPartially(T[] items, int fromIn, int toEx) {
        for (int s = fromIn + 1; s < toEx; s++) {
            for (int i = s; i > fromIn && items[i].compareTo(items[i - 1]) < 0; i--) {
                SortUtils.swap(items, i, i - 1);
            }
        }
    }
}",0,0,0,1,0,0,0,0,0
689,"package dev.jeffreybender.sort;
import java.util.Comparator;
public final class InsertionSort {
    private InsertionSort() {
    }
    public static <T> void sort(T[] array, Comparator<? super T> comparator) {
        if (array.length <= 1) {
            return;
        }
        if (comparator == null) {
            comparator = SortUtils.getDefaultComparator();
        }
        for (int index = 1; index < array.length; index++) {
            T objectAtIndex = array[index];
            int compareToIndex = index - 1;
            while (compareToIndex >= 0 && comparator.compare(array[compareToIndex], objectAtIndex) > 0) {
                array[compareToIndex + 1] = array[compareToIndex];
                compareToIndex--;
            }
            array[compareToIndex + 1] = objectAtIndex;
        }
    }
    public static <T extends Comparable<? super T>> void sort(T[] array) {
        sort(array, null);
    }
}",0,0,0,1,0,0,0,0,0
690,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class InsertionSort extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new InsertionSort();
	public void sort(SortArray array) {
		int length = array.length();
		array.setRange(0, length, SortArray.ElementState.INACTIVE);
		for (int i = 0; i < length; i++) {
			for (int j = i; j >= 1 && array.compareAndSwap(j - 1, j); j--);
		}
		array.setRange(0, length, SortArray.ElementState.DONE);
	}
	private InsertionSort() {
		super(""Insertion sort"");
	}
}",0,0,0,1,0,0,0,0,0
691,"package Sorting;
import java.util.ArrayList;
import java.util.Scanner;
public class InsertionSort {
    public static void main(String[] args) {
        ArrayList<Integer> elements = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            elements.add(sc.nextInt());
        }
        sc.close();
        int elements_array[] = new int[elements.size()];
        for (int i = 0; i < elements.size(); i++) {
            elements_array[i] = elements.get(i);
        }
        elements_array = doInsertionSort(elements_array);
        for (int anElement : elements_array) {
            System.out.println(anElement);
        }
    }
    private static int[] doInsertionSort(int[] elementsArray) {
        for (int i = 1; i < elementsArray.length; i++) {
            for (int j = i; j > 0; j--) {
                if (elementsArray[j] < elementsArray[j - 1]) {
                    doSwap(elementsArray, j, j - 1);
                }
            }
        }
        return elementsArray;
    }
    private static void doSwap(int[] elements_array, int i, int j) {
        int temp = elements_array[i];
        elements_array[i] = elements_array[j];
        elements_array[j] = temp;
    }
}",0,0,0,1,0,0,0,0,0
692,"package ie.peternagy.algorithms.sorting;
public class InsertionSort {
    public static void sort(Comparable[] items) {
        sort(items, true);
    }
    public static void sort(Comparable[] items, boolean isAsc) {
        Comparable key;
        int lowIndex;
        for (int i = 1; i < items.length; i++) {
            key = items[i];
            lowIndex = i;
            while(--lowIndex >= 0){
                if((isAsc && items[lowIndex].compareTo(key) > 0)
                        || (!isAsc && items[lowIndex].compareTo(key) < 0))
                    items[lowIndex + 1] = items[lowIndex];
                else
                    break;
            }
            items[lowIndex + 1] = key;
        }
    }
}",0,0,0,1,0,0,0,0,0
693,"package com.zhokhov.interview.sorting;
import static com.zhokhov.interview.util.Console.*;
public class InsertionSort {
    private int COMPARISONS_COUNT;
    private int LOOP_COUNT;
    public void sort(int array[]) {
        COMPARISONS_COUNT = 0;
        LOOP_COUNT = 0;
        for (int index = 1; index < array.length; index++) {
            LOOP_COUNT++;
            ____cyan(""\n--------\nindex: "" + index);
            insert(array, index);
        }
    }
    private void insert(int array[], int currentIndex) {
        int value = array[currentIndex];
        ____grey(""value: "" + value);
        ____grey(""currentIndex: "" + currentIndex);
        int reverseIndex = currentIndex;
        ____grey(""reverseIndex: "" + reverseIndex);
        for (int i = currentIndex - 1; i >= 0; i--) {
            LOOP_COUNT++;
            ____grey(""\ni: "" + i);
            COMPARISONS_COUNT++;
            if (array[i] >= value) {
                ____blue(""Move element "" + array[i] + "" to position "" + (i + 1));
                ____blue(""new reverseIndex: "" + i);
                array[i + 1] = array[i];
                reverseIndex = i;
                System.out.print(""["" + value + ""]"");
                __red("" ==> "");
                __dump(array);
            } else {
                ____grey(""breaking"");
                break;
            }
        }
        ____grey(""\nreverseIndex (after loop): "" + reverseIndex + "", put value here"");
        array[reverseIndex] = value;
        __red(""==> "");
        __dump(array);
    }
    private void sampleInsert(int array[], int value) {
        ____grey(""value: "" + value);
        int reverseIndex = array.length - 1;
        ____grey(""reverseIndex: "" + reverseIndex);
        for (int i = array.length - 2; i >= 0; i--) {
            ____grey(""\ni: "" + i);
            if (array[i] >= value) {
                ____blue(""Move element to: "" + (i + 1));
                ____blue(""new reverseIndex: "" + i);
                array[i + 1] = array[i];
                reverseIndex = i;
            } else {
                ____grey(""breaking"");
                break;
            }
        }
        ____grey(""\nreverseIndex (after loop): "" + reverseIndex + "", put value here"");
        array[reverseIndex] = value;
    }
    public static void main(String[] args) {
        int array[] = {7, 1, 8, 2, 0, 12, 10, 7, 5, 3};
        __yellow(""\nNew array: "");
        __dump(array);
        System.out.println(""\nSorting"");
        InsertionSort insertionSort = new InsertionSort();
        insertionSort.sort(array);
        __green(""\nResult: "");
        __dump(array);
        ____grey(""\nStatistics"");
        __green(""  Comparisons: "");
        System.out.print(insertionSort.COMPARISONS_COUNT);
        __green(""\n  Loops: "");
        System.out.println(insertionSort.LOOP_COUNT);
        System.out.print(""\n"");
        System.out.println(""***********************\n"");
        System.out.println(""Insert item to sorted array."");
        int sortedArray[] = {1, 2, 3, 4, 5, 6, Integer.MAX_VALUE};
        __yellow(""\nNew array: "");
        __dump(array);
        System.out.println(""\nInserting"");
        insertionSort.sampleInsert(sortedArray, 4);
        __green(""\nResult: "");
        __dump(sortedArray);
    }
}",0,0,0,1,0,0,0,0,0
694,"package raymond.com.sorting;
public class InsertionSort extends Sorting
{
	int [] numberArray;
	public InsertionSort(int [] array)
	{
		numberArray = array;
	}
	public int [] sort()
	{
		for (int i = 0; i < numberArray.length; i ++)
		{
			int smallestIndex = i;
			for (int j = i; j < numberArray.length; j ++)
			{
				if (numberArray[j] < numberArray[smallestIndex])
				{
					smallestIndex = j;
				}
			}
			swap(numberArray, i, smallestIndex);
		}
		printArray(numberArray);
		return null;
	}
}",0,0,0,1,0,0,0,0,0
695,"package ec;
import java.util.ArrayList;
public class InsertionSort<T extends Comparable<T>> implements SortingAlgorithms{
	 ArrayList<T> list = new ArrayList<T>();
	public InsertionSort() {
		sortingAlgorithms();
	}
	private long comparisons = 0;
	private long swaps = 0;
	static long runtime;
	static long start;
	static long end;
	public ArrayList<T> insertionSort(ArrayList<T> list) {
		long comparisons = 0;
		long swaps = 1;
		T now;
		start = System.currentTimeMillis();
		for(int i = 1 ; i <= list.size() - 1 ; i++) {
			now = list.get(i);
			int j;
			j = i;
			while(j > 0 && now.compareTo(list.get(j - 1)) < 0) {
				comparisons++;
				list.set(j, list.get(j - 1));
				j--;
				list.set(j, now);
			}
			swaps++;
		}
		this.comparisons = comparisons;
		this.swaps = swaps;
		end = System.currentTimeMillis();
		long runtimes = end - start;
		InsertionSort.runtime = runtimes;
		runtime = end - start;
		return list;
	}
	public ArrayList<T> print(ArrayList<T> bubble) {
		ArrayList<T> bs = new ArrayList<T>();
		for(int i = 0 ; i < bubble.size() ; i++) {
			bs.add(bubble.get(i));
		}
		return bs;
	}
	public void compare() {
		System.out.print(""Comparisons: "" + comparisons);
	}
	public void swap() {
		System.out.print(""Swaps: "" + swaps);
	}
	public void runtime() {
		System.out.print(""Runtime: ""  + runtime + "" ms"");
	}
	@Override
	public void sortingAlgorithms() {
		insertionSort(list);
	}
}",0,0,0,1,0,0,0,0,0
696,"import java.util.Arrays;
public class InsertionSort {
    private static void insertionSort(int[] inputArray) {
        int n = inputArray.length;
        for (int i = 1; i < n; i++) {
            int key = inputArray[i];
            int j = i - 1;
            while (j >= 0 && inputArray[j] > key) {
                inputArray[j + 1] = inputArray[j];
                j = j - 1;
            }
            inputArray[j + 1] = key;
        }
    }
    public static void main(String[] args) {
        int[] arr = {80, 12, 11, -5, 1, 0, 23, 2, 3, 4, 9};
        System.out.println(Arrays.toString(arr));
        insertionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}",0,0,0,1,0,0,0,0,0
697,"function insertionSort (arr) {
	for (let i = 1; i < arr.length; i++) {
		let j = i - 1;
		let temp = arr[i];
		while (j >= 0 && arr[j] > temp) {
			arr[j + 1] = arr[j];
			j--;
		}
		arr[j + 1] = temp;
	}
	return arr;
}
function main () {
	let arr = [5, 9, 3, 1, 99];
	arr = insertionSort(arr);
	console.log(arr);
}
main();",0,0,0,1,0,0,0,0,0
698,"var array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function insertionSort(array) {
  for(var i = 0; i < array.length; i++) {
    var temp = array[i];
    var j = i - 1;
    while (j >= 0 && array[j] > temp) {
      array[j + 1] = array[j];
      j--;
    }
    array[j + 1] = temp;
  }
  return array;
}
console.log(insertionSort(array));  ",0,0,0,1,0,0,0,0,0
699,"import random
def insertion_sort(alist):
    for index in range(len(alist)):
        currentvalue = alist[index]
        position = index
        while position > 0 and alist[position - 1] > currentvalue:
            alist[position] = alist[position - 1]
            position = position - 1
        alist[position] = currentvalue
rand_list = []
for i in range(100):
    rand_list.append(i)
random.shuffle(rand_list)
print(rand_list)
insertion_sort(rand_list)
print(rand_list)
success = True
for index in range(len(rand_list) - 1):
    if rand_list[index] > rand_list[index + 1]:
        success = False
if success:
    print(""Insertion Sort successful!"")",0,0,0,1,0,0,0,0,0
700,"public class InsertionSort {
	public static void sort(int[] list) {
		for (int i = 1; i < list.length; i++) {
			for (int c = i; c > 0 && list[c] < list[c-1]; c--) {
				Compare.swap(list, c, c-1);
			}
		}
	}
}",0,0,0,1,0,0,0,0,0
701,"package org.manoj.ds.sort;
import java.time.Duration;
import java.time.Instant;
import org.apache.log4j.Logger;
public class InsertionSort implements Sort {
    final static Logger logger = Logger.getLogger(BubbleSort.class);
    private SortingMetadata metadata = null;
    @Override
    public <E extends Comparable<E>> void sort(final E[] elements) {
        sort(elements, true);
    }
    @Override
    public <E extends Comparable<E>> void sort(final E[] elements, final boolean ascending) {
        metadata = new SortingMetadata(elements.length);
        final Instant start = Instant.now();
        for (int firstUnsortedIndex = 1; firstUnsortedIndex < metadata.getNumberOfElement(); firstUnsortedIndex++) {
            E newElement = elements[firstUnsortedIndex];
            int index = firstUnsortedIndex;
            logger.info(""firstUnsortedIndex="" + firstUnsortedIndex + "" | newElement="" + newElement + "" :"");
            if (ascending) {
                while (index > 0 && elements[index - 1].compareTo(newElement) > 0) {
                    elements[index] = elements[index - 1];
                    metadata.increamentSwapOperationByOne();
                    index--;
                }
            } else {
                while (index > 0 && elements[index - 1].compareTo(newElement) < 0) {
                    elements[index] = elements[index - 1];
                    metadata.increamentSwapOperationByOne();
                    index--;
                }
            }
            elements[index] = newElement;
            logger.info(""\tsortIndex="" + index + "":"");
            Sort.logInfo(logger, elements);
            metadata.incrementIterationByOne();
        }
        final Instant finish = Instant.now();
        metadata.setTimeTakenToExecute(Duration.between(start, finish).toNanos());
    }
    @Override
    public SortingMetadata getMetadata() {
        return metadata;
    }
}",0,0,0,1,0,0,0,0,0
702,"import java.util.*;
public class InsertionSort {
    public static void main (String[] args){
       Scanner x = new Scanner(System.in);
       System.out.println(""Please enter the length of Numbers:"");
       int t = x.nextInt();
       int [] arr= new int [t];
       System.out.println(""Please enter the Numbers:"");
       for(int i=0; i<t ;i++){
           arr[i] = x.nextInt();
       }
       Sort(arr );
       x.close();
    }
    public static void printArray(int[] ar){
        for(int g : ar){
           System.out.print(g+"" "");
       }
    }
    public static void Sort(int[] ar){
        for(int i=1 ; i<ar.length ; i++){
           int key= ar[i];
            int j= i-1;  
                 while(j>-1 && ar[j]>key){
                     ar[j+1] =ar[j];
                     j--;
                 }
            ar[j+1]=key;
        System.out.println(""\n After the iteration ""+ i );     
        printArray(ar);         
        }
        System.out.println(""\nAfter  all the iteration -Sorted Array-""); 
        printArray(ar);
     }
}",0,0,0,1,0,0,0,0,0
703,"package com.srt.sort;
import java.util.Arrays;
import java.util.function.BiFunction;
@SuppressWarnings({""unchecked"", ""unused""})
public class InsertionSort<T extends Comparable> extends JSort<T> {
    T[] Sort(T[] arr, BiFunction<T, T, Boolean> compare){
        T[] array = Arrays.copyOf(arr, arr.length);
        for (int i = 1; i < array.length; i++) {
            T key = array[i];
            int index = i;
            while(index  > 0 && compare.apply(key, array[index -1])){
                array[index] = array[index - 1];
                index--;
            }
            array[index] = key;
        }
        return array;
    }
}",0,0,0,1,0,0,0,0,0
704,"import java.io.IOException;
import java.util.ArrayList;
public class InsertionSort extends Sorts{
	public ArrayList<Integer> insertionSort(ArrayList<Integer> unsortedList)
	{
		for(int i = 1; i < unsortedList.size(); i++)
		{
			int j = i - 1;
			boolean done = false;
			while(!done)
			{
				if(unsortedList.get(j) > unsortedList.get(j + 1))
				{
					swap(unsortedList, j, j + 1);
					j = j - 1;
					if(j < 0)
					{
						done = true;
					}
				}
				else
				{
					done = true;
				}
			}
		}
		return unsortedList;
	}
	public void swap(ArrayList<Integer> unsortedList, int swapOne, int swapTwo)
	{
		int holder = unsortedList.get(swapOne);
		unsortedList.set(swapOne, unsortedList.get(swapTwo));
		unsortedList.set(swapTwo, holder);
	}
	public void InsertionTime(IOClass ioStream) throws IOException
	{
		ioStream.readFromFile();
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		long timeBefore = System.nanoTime();
		sortedList = insertionSort(ioStream.getInputArray());
		long timeAfter = System.nanoTime();
		double rawTime = timeAfter - timeBefore;
		double timeInMilli = rawTime/1000000;
		if(isSorted(sortedList))
		{
			ioStream.setInputArray(sortedList);
			System.out.print(""InsertionSort time (in Milli): ""); 
			System.out.println(timeInMilli);
		}
		else
		{
			ioStream.setInputArray(sortedList);
			System.out.println(""Not sorted!"");
		}
	}
}",0,0,0,1,0,0,0,0,0
705,"package ro.geo.sorting.insertionsort;
public class InsertionSort {
	public static void sort(Integer[] unsortedArray){
		for(int i = 1; i < unsortedArray.length; i++){
			int x = unsortedArray[i];
			int j = i - 1;
			while( (j >= 0) && (unsortedArray[j] > x) ){
				unsortedArray[j+1] = unsortedArray[j];
				j--;
			}
			unsortedArray[j+1] = x;
		}
	}
}",0,0,0,1,0,0,0,0,0
706,"package Sorting;
import Comparing.BaseAreaCompare;
import Comparing.VolumeCompare;
import Objects.ThreeDGeoShape;
public class InsertionSort {
	public ThreeDGeoShape[] sort(String sortBy, ThreeDGeoShape[] shapeArray) {
		BaseAreaCompare ac = new BaseAreaCompare();
		VolumeCompare vc = new VolumeCompare();
		for(int i = 1; i < shapeArray.length; i++){
			int j = i - 1;
			if (sortBy.equalsIgnoreCase(""h"")) {
				while(j >= 0 && shapeArray[j].compareTo(shapeArray[j+1]) < 0) {
					swapElements(shapeArray, j, j+1);
					j--;
				}
			} else if (sortBy.equalsIgnoreCase(""a"")) {
				while(j >= 0 && ac.compare(shapeArray[j], shapeArray[j+1]) < 0) {
					swapElements(shapeArray, j, j+1);
					j--;
				}
			} else if (sortBy.equalsIgnoreCase(""v"")) {
				while(j >= 0 && vc.compare(shapeArray[j], shapeArray[j+1]) < 0) {
					swapElements(shapeArray, j, j+1);
					j--;
				}
			}
		}
		return shapeArray;
	}
	private static  void swapElements( Object[] array, int i, int j )
	{
		Object temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}
}",0,0,0,1,0,0,0,0,0
707,"exports.insertionSort = ({ list }, { shouldSwap, swap }) => {
  for (let i = 1; i < list.length; i += 1) {
    let insertionIndex = i;
    for (let j = i - 1; j >= 0; j -= 1) {
      if (shouldSwap(j, insertionIndex)) {
        swap(j, insertionIndex);
        insertionIndex = j;
      }
    }
  }
  return list;
};",0,0,0,1,0,0,0,0,0
708,"aij.insertionSort = function(items) {
    var sort = function(arr) {
      var length = arr.length;
      for (var i = 0; i < length; i++) {
        var j = i,
            item = arr[j];
        while(j > 0 && arr[j - 1] > item) {
          arr[j] = arr[j - 1];
          j--;
        };
        arr[j] = item;
      };
      return arr;
    };
    return aij.isSortable(items) ? sort(items) : items;
};",0,0,0,1,0,0,0,0,0
709,"def insertionSort(arr):
    n = len(arr) 
    for i in range(1,n): 
        temp = arr[i]
        j = i - 1
        while j>=0 and arr[j] > temp:
              arr[j+1] = arr[j]
              j = j - 1
        arr[j+1] = temp
    return arr 
def insertionSort2(arr):
    n = len(arr) 
    for i in range(1,n):
        temp = arr[i]
        for j in range(i-1,-2,-1):
            if(arr[j] > temp):
               arr[j+1] = arr[j]
            else:
               break
        arr[j+1] = temp 
    return arr 
def insertionSortModified(arr):
    n = len(arr)
    for i in range(1,n):
        temp = arr[i]
        li = 0
        ls = i-1
        while li<=ls:
           m = (li+ls)/2
           if arr[m] > temp:
              ls = m - 1
           else:
              li = m + 1 
        for j in range(i-1,li-1,-1):
            arr[j+1] = arr[j]
        arr[li] = temp
    return arr
arr = [9,8,7,6,5,4,3,2,1,0,-33,11,33]
print insertionSort2(arr)",0,0,0,1,0,0,0,0,0
710,"package io.github.marioluan.algorithms.sorting;
public final class InsertionSort extends Sortable {
    private InsertionSort() {
    }
    @SuppressWarnings(""rawtypes"")
    public static void sort(Comparable[] a, int lo, int hi) {
        for (int i = lo; i < hi + 1; i++)
            for (int j = i; j > lo && less(a[j], a[j - 1]); j--)
                swap(a, j, j - 1);
    }
}",0,0,0,1,0,0,0,0,0
711,"public class InsertionSort {
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    public static void main(String args[]) {
        int arr[] = {18, 11, 13, 5, 6};
        InsertionSort sorter = new InsertionSort();
        sorter.sort(arr);
        printArray(arr);
    }
    void sort(int arr[]) {
        int temp = arr.length;
        for (int i = 1; i < temp; ++i) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }
}",0,0,0,1,0,0,0,0,0
712,"class insertionSort{
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		int [] sortedArr = new int [sizeofArr];
		sortedArr = insertionSort(arr, sizeofArr);
		print(sortedArr);
	}
	static int [] insertionSort(int [] arr, int sizeofArr){
		int temp;
		for (int i=1;i<sizeofArr;i++){
			for (int k=i;k>0 && arr[k-1] >= arr[k];k--) {
				temp = arr[k];
				arr[k] = arr[k-1];
				arr[k-1] = temp; 
			}
		}
		return arr;
	}
	static void print (int [] arr){
		for (int a : arr)
		System.out.print("" ""+a);
	}
}",0,0,0,1,0,0,0,0,0
713,"import java.util.*;
public class Main{
    static int[] insertionsort(int[] a,int n){
      for(int i=1;i<n;i++){
          int key=a[i];
          int j=i-1;
          while( j>=0 && a[j]>key){
              a[j+1]=a[j];
              j=j-1;
          }
          a[j+1]=key;
      }
        return a;
    }
    public static void main (String args[]){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[] =new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int[] sortedArray=insertionsort(arr,n);
        for(int i:sortedArray){
            System.out.print("" ""+i);
        }
        sc.close();
    }
}",0,0,0,1,0,0,0,0,0
714,"import java.util.List;
import java.lang.Comparable;
public class InsertionSort<T extends Comparable<T>> implements SortingAlg<T> {
    @Override
    public void sort(List<T> elements) {
        if (elements == null) return;
        for (int i = 1; i < elements.size(); i++) {
            T key = elements.get(i);
            int j = i - 1;
            while (j >= 0 && isLessThan(key, elements.get(j))) {
                elements.set(j + 1, elements.get(j));
                j--;
            }
            elements.set(j + 1, key);
        }
    }
    private boolean isLessThan(T first, T second) {
        return (first.compareTo(second) < 0);
    }
    public static void main(String[] args) {
        SortingAlg<Integer> alg = new InsertionSort<Integer>();
        List<Integer> elems = java.util.Arrays.asList(9,5,2,7,3,8,2,1,4,7,5,3,9);
        alg.sort(elems);
        for (int i = 0; i < elems.size() - 1; i++) {
            if (elems.get(i).compareTo(elems.get(i+1)) > 0)
                throw new java.lang.RuntimeException(""Elems should be sorted."");
        }
        System.out.println(""All tests passed."");
    }
}",0,0,0,1,0,0,0,0,0
715,"import java.util.Arrays;
public class InsertionSort{
	public void insertionSort(int[] A) {
		int len = A.length;
		for (int i = 1; i < len; i ++) {
			for (int j = i; j > 0 && A[j] < A[j - 1]; j --) {
				swap(A, j, j - 1);
			}
		}
	}
	private void swap(int[] A, int idx1, int idx2) {
		int tmp = A[idx1];
		A[idx1] = A[idx2];
		A[idx2] = tmp;
	}
	public static void main(String[] args) {
		InsertionSort is = new InsertionSort();
		int[] A = {4, 5, 9, 2, 0, 1, 6, 8, 3, 7};
		System.out.println(""unsorted: "" + Arrays.toString(A));
		is.insertionSort(A);
		System.out.println(""sorted: "" + Arrays.toString(A));
	}
}",0,0,0,1,0,0,0,0,0
716,"package sorting.algorithms;
public class InsertionSort {
    public int[] sort(int[] inputArray) {
        int arrayLength = inputArray.length;
        int temp;
        int j;
        for (int i = 1; i < arrayLength; i++) {
            temp = inputArray[i];
            j = i;
            while (j > 0 && inputArray[j - 1] > temp) {
                inputArray[j] = inputArray[j - 1];
                j--;
            }
            inputArray[j] = temp;
        }
        return inputArray;
    }
}",0,0,0,1,0,0,0,0,0
717,"package com.intrafoundation;
import java.util.Arrays;
public class InsertionSort extends BaseSort {
    public void sort(int[] arr) {
        swaps = 0;
        final int begin = 1;
        final int end = arr.length;
        for (int index = begin; index < end; index++) {
            int key = arr[index];  
            int repositionIndex = index - 1;
            while ((repositionIndex >= 0) && (arr[repositionIndex] > key)) {
                arr[repositionIndex + 1] = arr[repositionIndex];
                repositionIndex--;
                swaps++;
            }
            arr[repositionIndex + 1] = key;  
        }
    }
}",0,0,0,1,0,0,0,0,0
718,"package ie.gmit.dip;
import java.util.Random;
import java.util.*; 
public class InsertionSort {
      public static void main(String[] args) {
        Random g = new Random();
       int [] number = new int [10];  
        System.out.print(""Random Numbers:"");
        for (int d = 0 ; d<number.length ; d++){
            int RandomG = g.nextInt(number.length)+1;
            number[d] = RandomG;
            System.out.print("" "" +RandomG);
            }
       System.out.print(""\nSorted Numbers:""+(Arrays.toString(InsertSort(number))));
    }
    public static int [] InsertSort(int[] number){
    long startTime= System.nanoTime();
    for(int i = 1; i < number.length; i++){
    int value = number[i];
    int j = i - 1;
    while(j >= 0 && number[j] > value){
      number[j + 1] = number[j];
      j = j - 1;
    }
    number[j + 1] = value;
  }
        long endTime= System.nanoTime();
        long elapsed = endTime-startTime;
        double timeMillis= elapsed/1000000.0;
        System.out.print(""\nSorted In: ""+ timeMillis );
        return number;  
}
}",0,0,0,1,0,0,0,0,0
719,"package sortAlgorithms;
import helperUtils.Utility;
public class InsertionSort {
  public static void main(String[] args) {
    int[] inputArr = { 10, -80, 5, 76, 92, 100, 52, 1, -10 };
    Utility.printArray(inputArr, true, ""Insertion Sort"");
    for (int firstUnsortedIndex = 1; firstUnsortedIndex < inputArr.length; firstUnsortedIndex++) {
      int pickedElement = inputArr[firstUnsortedIndex];
      int i;
      for (i = firstUnsortedIndex; i > 0 && inputArr[i - 1] > pickedElement; i--) {
        inputArr[i] = inputArr[i - 1];
      }
      inputArr[i] = pickedElement;
    }
    Utility.printArray(inputArr, false, null);
  }
}",0,0,0,1,0,0,0,0,0
720,"function insertionSort(arr) {
  for (let j = 1; j < arr.length; j++) {
    const key = arr[j];
    let i = j - 1;
    while (i >= 0 && arr[i] > key) {
      arr[i + 1] = arr[i];
      i = i - 1;
    }
    arr[i + 1] = key;
  }
  return arr;
}
module.exports = insertionSort;
const ar = [3, 4, 5, 1, 6, 7, 8, 2, 0];
insertionSort(ar);",0,0,0,1,0,0,0,0,0
721,"function insertionSort(items) {
	var length = items.length;
	var currentValue = undefined;
	for(var index = 1; index < length; index++) {
		currentValue = items[index];
		var position = index;
		while(position > 0) {
			var comparisonValue = items[position - 1]
			if(comparisonValue <= currentValue) {
				break;
			}
			items[position] = comparisonValue
			position--
		}
		items[position] = currentValue
	}
    return items	
}",0,0,0,1,0,0,0,0,0
722,"from time import sleep
from typing import List
from tkinter import Tk
from animated import Animator
class InsertionSort(Animator):
    def sort(self, array: List[int]) -> None:
        for i in range(1, len(array)):  
            comparator = array[i]  
            for section in range(
                i - 1, -2, -1
            ):  
                if (
                    comparator > array[section]
                ):  
                    array[section + 1] = comparator
                    self.render(array, cur=section + 2)
                    sleep(0.01)
                    break
                else:
                    array[section + 1] = array[
                        section
                    ]  
                    self.render(array, cur=section + 2)
                    sleep(0.01)
            else:
                array[
                    section + 1
                ] = comparator  
def main() -> int:
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    shuffledArray = randomSequence(0, 100)
    root = Tk()
    sorter = InsertionSort(
        root,
        background=""black"",
        width=root.winfo_screenwidth(),
        height=root.winfo_screenheight(),
    )
    sorter.pack()
    sorter.sort(shuffledArray)
    sorter.finished()
    return 0",0,0,0,1,0,0,0,0,0
723,"import java.util.Arrays;
public class InsertionSort {
    public static void main(String[] args) {
        int[] arr = {5, 4, 3, 2, 1};
        insertionSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    static void insertionSort(int[] arr){
        for(int i = 0; i < arr.length - 1; i++){
            for(int j = i+1; j > 0; j--){
                if(arr[j] < arr[j-1]){
                    int temp = arr[j];
                    arr[j] = arr[j-1];
                    arr[j-1] = temp;
                }else{
                    break;
                }
            }
        }
    }
}",0,0,0,1,0,0,0,0,0
724,"package project1.sorts;
import project1.ExperimentalResultsData;
public final class InsertionSort<E extends Comparable<E>> implements Sort<E> {
    @Override
    public SortType sort(ExperimentalResultsData experimentalResultsData, E[] list) {
        for (int i = 0; i < list.length; i++) {
            E currentElement = list[i];
            int k;
            experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
            for (k = i - 1; k >= 0 && list[k].compareTo(currentElement) > 0; k--) {
                experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
                list[k + 1] = list[k];
            }
            if (k + 1 != i) {
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
            }
            list[k + 1] = currentElement;
        }
        return SortType.INSERTION_SORT;
    }
}",0,0,0,1,0,0,0,0,0
725,"package io.lenur.sort;
public class InsertionSort implements Sortable {
    @Override
    public void sort(int[] data) {
        for (int i = 1; i < data.length; i++) {
            for (int j = i; j > 0 && data[j - 1] > data[j]; j--) {
                int temp = data[j];
                data[j] = data[j - 1];
                data[j - 1] = temp;
            }
        }
    }
}",0,0,0,1,0,0,0,0,0
726,"package sortingalgorithms;
import cnode.CNode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javafx.animation.FillTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.Transition;
import javafx.scene.paint.Color;
public class InsertionSort extends AbstractSort {
  private ArrayList<Transition> transitions;
  public InsertionSort() {
    this.transitions = new ArrayList<>();
  }
  @Override
  public ArrayList<Transition> startSort(CNode[] arr) {
    for (int i = 1; i < arr.length; i++) {
      int j = i - 1;
      CNode key = arr[i];
      int keyIndx = i;
      ParallelTransition pt = new ParallelTransition();
      transitions.add(colorCNode(arr, SELECT_COLOR, i));
      while(j >= 0 && arr[j].getValue() > key.getValue()) {
        pt.getChildren().add(arr[j].moveX(DX));
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = key;
      pt.getChildren().add(key.moveX(DX * (j + 1 - i)));
      transitions.add(pt);
      transitions.add(colorCNode(arr, START_COLOR, j + 1));
    }
    transitions.add(colorCNode(Arrays.asList(arr), SORTED_COLOR));
    return transitions;
  }
}",0,0,0,1,0,0,0,0,0
727,"package sorts;
import util.SortUtil;
public class InsertionSort {
    public static int[] sort(int[] arr) {
        for(int i = 0; i < arr.length; i++) {
            for(int j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
                SortUtil.swap(arr, j, j - 1);
            }
        }
        return arr;
    }
}",0,0,0,1,0,0,0,0,0
728,"package rosberglinhares.datastructuresandalgorithms.algorithms.sorting;
public class InsertionSort {
    public <T extends Comparable<T>> void iterativeInsertionSort(T[] items) {
        for (int i = 1; i < items.length; i++) {
            T insertItem = items[i];
            for (int j = i; j >= 1 && (items[j].compareTo(items[j - 1]) < 0); j--) {
                items[j] = items[j - 1];
                items[j - 1] = insertItem;
            }
        }
    }
    public <T extends Comparable<T>> void recursiveInsertionSort(T[] items) {
        this.recursiveInsertionSort(items, 1);
    }
    private <T extends Comparable<T>> void recursiveInsertionSort(T[] items, int itemIndex) {
        if (itemIndex < items.length) {
            T insertItem = items[itemIndex];
            for (int i = itemIndex; i >= 1 && (items[i].compareTo(items[i - 1]) < 0); i--) {
                items[i] = items[i - 1];
                items[i - 1] = insertItem;
            }
            recursiveInsertionSort(items, itemIndex + 1);
        }
    }
}",0,0,0,1,0,0,0,0,0
729,"import java.util.Arrays;
import java.util.Scanner;
public class InsertionSort {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Insertion Sort Algorithm"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSort = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSort[i] = input.nextInt();
        }
        int[] sortedArray = insertionSort(arrayOfIntegersToSort);
        System.out.printf(""Sorted array using Insertion Sort Algorithm: %s%n"",
                Arrays.toString(sortedArray));
        input.close();
    }
    private static int[] insertionSort(int[] arrayToSort) {
        for (int firstUnsortedIndex = 1; firstUnsortedIndex < arrayToSort.length; firstUnsortedIndex++) {
            int newElement = arrayToSort[firstUnsortedIndex];
            int i;
            for (i = firstUnsortedIndex; i > 0 && arrayToSort[i - 1] > newElement; i--) {
                arrayToSort[i] = arrayToSort[i - 1];
            }
            arrayToSort[i] = newElement;
        }
        return arrayToSort;
    }
}",0,0,0,1,0,0,0,0,0
730,"package com.jwetherell.algorithms.sorts;
public class InsertionSort<T extends Comparable<T>> {
    private InsertionSort() { }
    public static <T extends Comparable<T>> T[] sort(T[] unsorted) {
        int length = unsorted.length;
        for (int i = 1; i < length; i++) {
            sort(i, unsorted);
        }
        return unsorted;
    }
    private static <T extends Comparable<T>> void sort(int i, T[] unsorted) {
        for (int j = i; j > 0; j--) {
            T jthElement = unsorted[j];
            T jMinusOneElement = unsorted[j - 1];
            if (jthElement.compareTo(jMinusOneElement) < 0) {
                unsorted[j - 1] = jthElement;
                unsorted[j] = jMinusOneElement;
            } else {
                break;
            }
        }
    }
}",0,0,0,1,0,0,0,0,0
731,"public class InsertionSort{
     public static void main(String []args){
       int arr[] = {2,6,4,7,34,87,3};
        int len = arr.length;
        for(int i =1;i<len;i++)
        {
            int k = i-1;
            int element = arr[i];
            while(k>=0 && element<arr[k])
            {
                    arr[k+1] = arr[k];
                    arr[k] = element;
                    k--;
            }
        }
        for(int p =0; p<len;p++)
        {
            System.out.print(arr[p]+"" "");
        }
     }
}",0,0,0,1,0,0,0,0,0
732,"package Java;
public class InsertionSort extends Sort{
	public static void main(String[] args){
		int[] data = buildDataSet(5);
		timeSort(new InsertionSort(), data);
	}
	public InsertionSort(){ super(""Insertion""); }
	private void insertionSort(int[] data){
		for (int i = 1; i < data.length; i++)
		{
			int temp = data[i];  
			int j;
			for (j = i; j > 0 && data[j-1] > temp; j--)
				data[j] = data[j-1];
			data[j] = temp;
		}
	}
	@Override
	public void sort(int[] data){		
		insertionSort(data);
	}
}",0,0,0,1,0,0,0,0,0
733,"const insertionSort = (arr = []) => {
    const len = arr.length;
    for (let i = 0; i < len; i++) {
      let el = arr[i];
      let j;
      for (j = i - 1; j >= 0 && arr[j] > el; j--)
        arr[j + 1] = arr[j];
      arr[j + 1] = el;
    }
    return arr;
  }",0,0,0,1,0,0,0,0,0
734,"def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp
def insertionsort(array):
    for i in range(0, len(array)):
        j = i
        while j > 0 and array[j-1] > array[j]:
            swap(array, j-1, j)
            j -= 1
if __name__ == ""__main__"":
    array = [17, 9, 13, 8, 7, -5, 6, 11, 3, 4, 1, 2]
    insertionsort(array)
    print array",0,0,0,1,0,0,0,0,0
735,"package Sorting;
import java.util.Scanner;
public class InsertionSort {
    private static void insertionSort(int[] array) {
        int n = array.length;
        for(int i = 1; i < n ; i++) {
            int temp = array[i];
            int j;
            for(j = i-1 ; j >= 0 && array[j] > temp ; j--) {
                   array[j+1] = array[j];
            }
            array[j + 1] = temp;
        }
    }
    private static void print(int[] array) {
        for(int i : array) {
            System.out.print(i + "" "");
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i= 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        System.out.print(""Before Sorting : "");
        print(array);
        long startTime = System.nanoTime();
        insertionSort(array);
        long endTime = System.nanoTime();
        System.out.print(""\nAfter Sorting : "");
        print(array);
        long totalTime = endTime - startTime;
        System.out.printf(""\nTime in seconds : %.6fs"",(totalTime/ 1000000000.0));
        sc.close();
    }
}",0,0,0,1,0,0,0,0,0
736,"package Sorting;
public class InsertionSort {
    public static void main(String[] args) {
        int[] arr={20,35,-15,7,55,1,-22};
        IS(arr);
    }
    public static void IS(int[] arr){
        for (int fui = 1; fui < arr.length ; fui++) {
            int newElement = arr[fui];
            int i;
            for (i = fui; i > 0 && arr[i-1] > newElement; i--) {
                arr[i] = arr[i-1];
            }
            arr[i] = newElement;
        }
        for(int j=0;j<arr.length;j++){
            System.out.print(arr[j]+"" "");
        }
    }
}",0,0,0,1,0,0,0,0,0
737,"class InsertionSort 
{ 
    void sort(int arr[]) 
    { 
        int n = arr.length; 
        for (int i = 1; i < n; ++i) 
        { 
            int key = arr[i]; 
            int j = i - 1; 
            while (j >= 0 && arr[j] > key) 
            { 
                arr[j + 1] = arr[j]; 
                j = j - 1; 
            } 
            arr[j + 1] = key; 
        } 
    } 
    static void printArray(int arr[]) 
    { 
        int n = arr.length; 
        for (int i = 0; i < n; ++i) 
            System.out.print(arr[i] + "" ""); 
        System.out.println(); 
    } 
    public static void main(String args[]) 
    { 
        int arr[] = { 12, 11, 13, 5, 6 }; 
        InsertionSort ob = new InsertionSort(); 
        ob.sort(arr); 
        printArray(arr); 
    } 
}",0,0,0,1,0,0,0,0,0
738,"package com.growingwiththeweb.sorting;
public class InsertionSort {
    public static <T extends Comparable<T>> void sort(T[] array) {
        for (int i = 1; i < array.length; i++) {
            T item = array[i];
            int indexHole = i;
            while (indexHole > 0 && array[indexHole - 1].compareTo(item) > 0) {
                array[indexHole] = array[--indexHole];
            }
            array[indexHole] = item;
        }
    }
}",0,0,0,1,0,0,0,0,0
739,"export default function InsertionSort(items: Array<number>): Array<number> {
  const itemsCopy = [...items];
  let value;  
  let i;  
  let j;  
  for (i = 0; i < itemsCopy.length; i++) {
    value = itemsCopy[i];
    j = i - 1;
    while (j >= 0 && itemsCopy[j] > value) {
      itemsCopy[j + 1] = itemsCopy[j];
      j--;
    }
    itemsCopy[j + 1] = value;
  }
  return itemsCopy;
}",0,0,0,1,0,0,0,0,0
740,"def insertionSort(arr,low,high) :
	for i in range(1,high+1):
		keyValue = arr[i]  
  j=i-1
  while j>=0 and keyValue<=arr[j]:
			arr[j+1]=arr[j]
   j=j-1
  arr[j+1]=keyValue
 return arr",0,0,0,1,0,0,0,0,0
741,"public class InsertionSort {
    public static int[] sort(int[] array) {
        for (int i = 1; i < array.length; i++) {
            int key = array[i];
            for (int j = i - 1; j >= 0; j--) {
                if (key >= array[j]) break;
                array[j + 1] = array[j];
                array[j] = key;
            }
        }
        return array;
    }
}",0,0,0,1,0,0,0,0,0
742,"const insertionSort = (nums) => {
  for (let i = 1; i < nums.length; i++) {
    let j = i - 1
    let temp = nums[i]
    while (j >= 0 && nums[j] > temp) {
      nums[j + 1] = nums[j]
      j--
    }
    nums[j+1] = temp
  }
  return nums
}
console.log(insertionSort([3, 0, 2, 5, -1, 4, 1]));
console.log(insertionSort([2,6,5,12,-1,3,8,7,1,-4,0,23,1,-55,20,37,54,210,-23,7,483,9339,29,-3,90,-2,81,54,7372,-92,93,93,18,-43,21]));",0,0,0,1,0,0,0,0,0
743,"def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
arr = [12, 11, 13, 5, 6]
insertionSort(arr)
for i in range(len(arr)):
    print(""% d"" % arr[i])",0,0,0,1,0,0,0,0,0
744,"public class InsertionSort {
    private static void insertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int j = i - 1;
            int key = arr[i];	 
            while(j >= 0 && arr[j] > key) {
                arr[j+1] = arr[j];
                j--;
            }
            arr[j+1] = key;	 
        }
    }
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        insertionSort(arr);
        for (int x: arr) {	 
            System.out.print(x+"" "");
        }
    }
}",0,0,0,1,0,0,0,0,0
745,"export function insertionSort(array) {
  let result = [];
  array.forEach(item => {
    result.push(item);
    for (let i = 0; i < result.length; i++) {
      const a = result[result.length - i];
      const b = result[result.length - i - 1];
      if (a < b) {
        swap(result, result.length - i, result.length - i - 1)
      }
    }
  });
  return result;
}
function swap(array, index1, index2) {
  const val1 = array[index1];
  array[index1] = array[index2];
  array[index2] = val1;
}",0,0,0,1,0,0,0,0,0
746,"function insertionSort(array) {
    for(let i = 1; i < array.length; i++) {
        let temp = array[i];
        let j = i - 1;
        while(array[j] > temp) {
            array[j+1] = array[j];   
            j--;  
        }
        j++; 
        array[j] = temp; 
    }
    return array
}
(function test() {
    const testArray1 = [4, 5, 2, 1, 3, 8]
    const testArray2 = [5, 5, 6, 100, 3, 5, 2, 1, 5, 7, 8888, 4]
    const testArray3 = [2, 1]
    console.log(insertionSort(testArray1))
    console.log(insertionSort(testArray2))
    console.log(insertionSort(testArray3))
})()",0,0,0,1,0,0,0,0,0
747,"def insertion_sort(lista, n):
    p = 1
    while(p<n):
        temp = lista[p]
        j=p
        while(j>0 and temp < lista[j - 1]):
            lista[j] = lista[j - 1] 
            j-=1
        lista[j] = temp
        p+=1",0,0,0,1,0,0,0,0,0
748,"import numpy as np
n = int(input('enter the size of the array '))
arr_str = input(""Enter the elements of array "").split("" "")
arr = [int(num) for num in arr_str]
print(""Original unsorted array "")
print(arr)
print(""\n"")
for i in range(len(arr)):
    print(arr[i])
def insertion_sort(x):
    for i in range(len(x)):
        cursor = x[i]
        posi = i
        while(posi>0 and x[posi-1]> cursor):
            arr[posi] = arr[posi-1]
            posi = posi-1
        arr[posi] = cursor
    print(x) 
if __name__ == ""__main__"":
    insertion_sort(arr)",0,0,0,1,0,0,0,0,0
749,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class InsertionSortBinarySearch extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new InsertionSortBinarySearch();
	public void sort(SortArray array) {
		int length = array.length();
		array.setRange(0, length, SortArray.ElementState.INACTIVE);
		for (int i = 0; i < length; i++) {
			int index = binarySearch(array, i, 0, i);
			for (int j = i; j - 1 >= index; j--)
				array.swap(j, j - 1);
		}
		array.setRange(0, length, SortArray.ElementState.DONE);
	}
	private static int binarySearch(SortArray array, int index, int start, int end) {
		while (start != end) {
			int mid = (start + end) / 2;
			int temp = array.compare(index, mid);
			if (temp < 0)
				end = mid;
			else if (temp > 0)
				start = mid + 1;
			else
				return mid;
		}
		return start;
	}
	private InsertionSortBinarySearch() {
		super(""Insertion sort (binary search)"");
	}
}",0,0,0,1,0,0,1,0,0
750,"package sorting;
import java.util.*;
public class InsertionSortClass
{
   static int icount = 0;
   public static void main(String[] args)
   {
      Random gen=new Random(); int[] a=new int[32];
      int i; for (i=0; i<a.length; i++) a[i]=gen.nextInt(5000)+1;
      System.out.println(""Initial array:"");
      for (i=0; i<a.length; i++) System.out.println(a[i] + "" "");
      System.out.println();
      insertionsort(a);
      System.out.println(""Sorted array:"");
      for (i=0; i<a.length; i++) System.out.println(a[i] + "" "");
      System.out.println(""Done!"");
      System.out.println("" icount: ""+ icount);
   }
   public static void insertionsort(int[] arr) {
	     int i, j, newValue;  
	     for (i = 1; i < arr.length; i++) {  
	         newValue = arr[i];  
	         j = i;  
	         while (j > 0 && arr[j - 1] > newValue) {  
	             arr[j] = arr[j - 1];  
	             j--;  
	             icount++;  
	         }
	         arr[j] = newValue;  
	     }
	 }
	}",0,0,0,1,0,0,0,0,0
751,"const arrayRandom = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
const arrayOrdered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const arrayReversed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
function insertionSort(array) {
  let countOuter = 0;
  let countInner = 0;
  let countSwap = 0;
  for(let i = 0; i < array.length; i++) {
    countOuter++;
    let temp = array[i];
    let j = i - 1;
    while (j >= 0 && array[j] > temp) {
      countInner++;
      countSwap++;
      array[j + 1] = array[j];
      j--;
    }
    array[j + 1] = temp;
  }
  console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
  return array;
}
insertionSort(arrayRandom.slice());  
insertionSort(arrayOrdered.slice());  
insertionSort(arrayReversed.slice());  ",0,0,0,1,0,0,0,0,0
752,"package com.ianramzy;
public class InsertionSorter implements Sorter {
    public void sort(int num, int list[]) {
        int i, j, k, temp;
        for (i = 1; i < num; i++) {
            for (j = 0; j < i; j++) {
                temp = list[i];
                if (temp < list[j]) {
                    for (k = i; k > j; k--) {
                        list[k] = list[k - 1];
                    }
                    list[j] = temp;
                }
            }
        }
    }
}",0,0,0,1,0,0,0,0,0
753,"package sorters;
import java.util.Comparator;
import java.util.List;
public class InsertionSorter<E> extends AbstractSorter<E> {
	public void sort(List<E> list, Comparator<E> comp) {
		for (int i = 1; i < list.size(); i++) {
			for (int k = i; k > 0 && comp.compare(list.get(k - 1), list.get(k)) > 0; k--) {
				swap(list, k - 1, k);
			}
		}
	}
	public String getName() {
		return ""Insertion Sort"";
	}
}",0,0,0,1,0,0,0,0,0
754,"import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.*;
public class Solution {
    static void insertionSort2(int n, int[] arr) {
         for(int i=1;i<n;i++){
          int key=arr[i];
          int j=i-1;
          while( j>=0 && arr[j]>key){
              arr[j+1]=arr[j];
              j=j-1;
          }
          arr[j+1]=key;
               for(int k=0;k<n;k++){
          System.out.print(arr[k]+"" "");
      }
      System.out.println();
      }
    }
    private static final Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        int n = scanner.nextInt();
        scanner.skip(""(\r\n|[\n\r\u2028\u2029\u0085])?"");
        int[] arr = new int[n];
        String[] arrItems = scanner.nextLine().split("" "");
        scanner.skip(""(\r\n|[\n\r\u2028\u2029\u0085])?"");
        for (int i = 0; i < n; i++) {
            int arrItem = Integer.parseInt(arrItems[i]);
            arr[i] = arrItem;
        }
        insertionSort2(n, arr);
        scanner.close();
    }
}",0,0,0,1,0,0,0,0,0
755,"from random import randint
import time
def insertionSortRecursive(list):
    j = 1
    return insertionSortRecursiveAction(list, j)
def insertionSortRecursiveAction(list, j):
    if (j < len(list)):
        key = list[j]
        i = j - 1
        list, i = insertRecursive(list, key, i)
        list[i + 1] = key
        j = j + 1
        list = insertionSortRecursiveAction(list, j)
    return list
def insertRecursive(list, key, i):
    if (i >= 0 and list[i] > key):
        list[i + 1] = list[i]
        i = i - 1
        list, i = insertRecursive(list, key, i)
    return list, i
def insertionSortIterative(list):
    for j in range(1, len(list)):
        key = list[j]
        i = j - 1
        list, i = insertIterative(list, key, i)
        list[i + 1] = key
    return list
def insertIterative(list, key, i):
    while (i >= 0 and list[i] > key):
        list[i + 1] = list[i]
        i = i - 1
    return list, i
for i in range(0, 10):
    list = []
    for num in range(0, 100):
        list.append(randint(0, 100))
    iterativeStart = 0
    iterativeStop = 0  
    iterativeStart = time.clock()
    insertionSortIterative(list)
    iterativeStop = time.clock()
    iterativeTime = 1000000 * (iterativeStop - iterativeStart)
    print(""Iterative: "" + str(iterativeTime))
    recursiveStart = 0
    recursiveStop = 0
    recursiveStart = time.clock()
    insertionSortRecursive(list)
    recursiveStop = time.clock()
    recursiveTime = 1000000 * (recursiveStop - recursiveStart)
    print(""Recursive: "" + str(recursiveTime))
    print(""Speedup: "" + str(iterativeTime / recursiveTime))
    print()
list = []
for num in range(0, 100):
    list.append(randint(0, 100))
print(list)
print(insertionSortRecursive(list))
print()",0,0,0,1,0,0,0,0,0
756,"from typing import List
def insertionSort(array: List[int]) -> None:
    for i in range(1, len(array)):  
        comparator = array[i]  
        for section in range(i - 1, -2, -1):  
            if (
                comparator > array[section]
            ):  
                array[section + 1] = comparator
                break
            else:
                array[section + 1] = array[
                    section
                ]  
        else:
            array[
                section + 1
            ] = comparator  
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""INSERTION SORT"")
    shuffledArray = randomSequence(0, 1000)
    print(shuffledArray, ""\n"")
    insertionSort(shuffledArray)
    print(shuffledArray)",0,0,0,1,0,0,0,0,0
757,"import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;
class Sort
{
    void InsertionSort(int arr[])
    {
        int j, temp;
        for (int i = 0; i < arr.length ; ++i)
        {
            temp = arr[i];
            for (j = i; j > 0 && arr[j - 1] > temp; --j)
            {
                arr[j] = arr[j - 1];
            }
            arr[j] = temp;
        }
    }
    void Display(int arr[])
    {
        for (int i : arr)
        {
            System.out.print(i + ""  "");
        }
    }
}
class Main
{
    public static void main(String[] args)throws IOException
    {
        Sort obj = new Sort();
        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""\n\t---INSERTION SORT---"");
        System.out.print(""Enter the size of array = "");
        int n = Integer.parseInt(buf.readLine());
        int[] arr = new int[n];
        System.out.println(""Enter elements -"");
        for(int i = 0; i < n ; ++i)
        {
            System.out.print((i + 1) +"" : "");
            arr[i] = Integer.parseInt(buf.readLine());
        }
        System.out.println(""Elements in the array : "");
        obj.Display(arr);
        obj.InsertionSort(arr);
        System.out.println(""\nElements in ascending order : "");
        obj.Display(arr);
    }
}",0,0,0,1,0,0,0,0,0
758,"from random import randint
from timeit import repeat
def run_sorting_algorithm(algorithm, array):
    setup_code = f""from __main__ import {algorithm}""        if algorithm != ""sorted"" else """"
    stmt = f""{algorithm}({array})""
    times = repeat(setup=setup_code, stmt=stmt, repeat=3, number=10)
    print(f""Algorithm: {algorithm}. Minimum execution time: {min(times)}"")
def bubble_sort(array):
    n = len(array)
    for i in range(n):
        already_sorted = True
        for j in range(n - i - 1):
            if array[j] > array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]
                already_sorted = False
        if already_sorted:
            break
    return array
def insertion_sort(array):
    for i in range(1, len(array)):
        key_item = array[i]
        j = i - 1
        while j >= 0 and array[j] > key_item:
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = key_item
    return array
ARRAY_LENGTH = 10000
if __name__ == ""__main__"":
    array = [randint(0, 1000) for i in range(ARRAY_LENGTH)]
    run_sorting_algorithm(algorithm=""bubble_sort"", array=array)",0,0,0,1,1,0,0,0,0
759,"package sorting;
public class QuickInsertionSort<T extends Comparable<T>> implements Sort<T> {
    private PartialSort<T> simpleAlgorithm;
    private int threshold;
    public QuickInsertionSort(PartialSort<T> simpleAlgorithm, int threshold) {
        this.threshold = threshold;
        this.simpleAlgorithm = simpleAlgorithm;
    }
    @Override
    public void sort(T[] items) {
        sort(items, 0, items.length - 1);
    }
    public void sort(T[] items, int left, int right) {
        int up = left;
        int down = right - 1;
        T t = items[right];
        do {
            while (items[up].compareTo(t) < 0) {
                up++;
            }
            while (items[down].compareTo(t) >= 0 && down > up) {
                down--;
            }
            if (up < down) {
                SortUtils.swap(items, up, down);
            }
        } while (up < down);
        SortUtils.swap(items, up, right);
        if (left < up - 1) {
            int size = up - left;
            if (size < threshold) {
                simpleAlgorithm.sortPartially(items, left, up - 1);
            } else {
                sort(items, left, up - 1);
            }
        }
        if (right > up + 1) {
            int size = right - up;
            if (size < threshold) {
                simpleAlgorithm.sortPartially(items, up + 1, right);
            } else {
                sort(items, up + 1, right);
            }
        }
    }
}",1,0,0,1,0,0,0,0,0
760,"import java.util.*;
public class RecursiveInsertionSort {
	public static void main(String[] args) {
		int arr[] = {12, 11, 13, 5, 6};
        insertionSortRecursive(arr, arr.length);
        System.out.println(Arrays.toString(arr));
	}
	private static void insertionSortRecursive(int[] arr, int n) {
		 if (n <= 1)
	            return;
	        insertionSortRecursive( arr, n-1 );
	        int last = arr[n-1];
	        int j = n-2;
	        while (j >= 0 && arr[j] > last)
	        {
	            arr[j+1] = arr[j];
	            j--;
	        }
	        arr[j+1] = last;
	}
}",0,0,0,1,0,0,0,0,0
761,"function insertionSort (array) {
  for (let i = 1; i < array.length; i++) {
    let j = i - 1;
    let temp = array[i];
    while (j >= 0 && array[j] > temp) {
      array[j + 1] = array[j];
      j--;
    }
    array[j + 1] = temp;
  }
  return array;
}",0,0,0,1,0,0,0,0,0
762,"public class Sort {
public static void Swap(byte[] array, int i, int j) {
        var h = array[i];
        array[i] = array[j];
        array[j] = h;
}
public static void Swap(short[] array, int i, int j) {
        var h = array[i];
        array[i] = array[j];
        array[j] = h;
}
public static void Swap(int[] array, int i, int j) {
        var h = array[i];
        array[i] = array[j];
        array[j] = h;
}
public static void Swap(long[] array, int i, int j) {
        var h = array[i];
        array[i] = array[j];
        array[j] = h;
}
public static void Swap(double[] array, int i, int j) {
        var h = array[i];
        array[i] = array[j];
        array[j] = h;
}
public static void Swap(float[] array, int i, int j) {
        var h = array[i];
        array[i] = array[j];
        array[j] = h;
}
public static int[] MergeSort(int[] array) {
        if (array.length <= 1) return array;
        int m = array.length / 2;
        int[] left_array = new int[m];
        int[] right_array = new int[array.length - m];
        for (int i = 0; i < m; i++) left_array[i] = array[i];
        for (int i = m, x = 0; i < array.length; i++, x++) right_array[x] = array[i];
        left_array = MergeSort(left_array);
        right_array = MergeSort(right_array);
        return Merge(left_array, right_array);
}
public static int[] Merge(int[] left_array, int[] right_array) {
        int[] m = new int[left_array.length + right_array.length];
        int index_l = 0;
        int nl, nr;
        nl = left_array.length - 1;
        nr = right_array.length - 1;
        for (int i = 0; i <= nl + nr + 1; i++) {
                if (index_l > nl) {
                        m[i] = (right_array[i - index_l]);
                        continue;
                }
                if (index_l < i - nr) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                        continue;
                }
                if (left_array[index_l] <= (right_array[i - index_l])) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                } else {
                        m[i] = (right_array[i - index_l]);
                }
        }
        return m;
}
public static double[] MergeSort(double[] array) {
        if (array.length <= 1) return array;
        int m = array.length / 2;
        double[] left_array = new double[m];
        double[] right_array = new double[array.length - m];
        for (int i = 0; i < m; i++) left_array[i] = array[i];
        for (int i = m, x = 0; i < array.length; i++, x++) right_array[x] = array[i];
        left_array = MergeSort(left_array);
        right_array = MergeSort(right_array);
        return Merge(left_array, right_array);
}
public static double[] Merge(double[] left_array, double[] right_array) {
        double[] m = new double[left_array.length + right_array.length];
        int index_l = 0;
        int nl, nr;
        nl = left_array.length - 1;
        nr = right_array.length - 1;
        for (int i = 0; i <= nl + nr + 1; i++) {
                if (index_l > nl) {
                        m[i] = (right_array[i - index_l]);
                        continue;
                }
                if (index_l < i - nr) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                        continue;
                }
                if (left_array[index_l] <= (right_array[i - index_l])) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                } else {
                        m[i] = (right_array[i - index_l]);
                }
        }
        return m;
}
public static float[] MergeSort(float[] array) {
        if (array.length <= 1) return array;
        int m = array.length / 2;
        float[] left_array = new float[m];
        float[] right_array = new float[array.length - m];
        for (int i = 0; i < m; i++) left_array[i] = array[i];
        for (int i = m, x = 0; i < array.length; i++, x++) right_array[x] = array[i];
        left_array = MergeSort(left_array);
        right_array = MergeSort(right_array);
        return Merge(left_array, right_array);
}
public static float[] Merge(float[] left_array, float[] right_array) {
        float[] m = new float[left_array.length + right_array.length];
        int index_l = 0;
        int nl, nr;
        nl = left_array.length - 1;
        nr = right_array.length - 1;
        for (int i = 0; i <= nl + nr + 1; i++) {
                if (index_l > nl) {
                        m[i] = (right_array[i - index_l]);
                        continue;
                }
                if (index_l < i - nr) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                        continue;
                }
                if (left_array[index_l] <= (right_array[i - index_l])) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                } else {
                        m[i] = (right_array[i - index_l]);
                }
        }
        return m;
}
public static short[] MergeSort(short[] array) {
        if (array.length <= 1) return array;
        int m = array.length / 2;
        short[] left_array = new short[m];
        short[] right_array = new short[array.length - m];
        for (int i = 0; i < m; i++) left_array[i] = array[i];
        for (int i = m, x = 0; i < array.length; i++, x++) right_array[x] = array[i];
        left_array = MergeSort(left_array);
        right_array = MergeSort(right_array);
        return Merge(left_array, right_array);
}
public static short[] Merge(short[] left_array, short[] right_array) {
        short[] m = new short[left_array.length + right_array.length];
        int index_l = 0;
        int nl, nr;
        nl = left_array.length - 1;
        nr = right_array.length - 1;
        for (int i = 0; i <= nl + nr + 1; i++) {
                if (index_l > nl) {
                        m[i] = (right_array[i - index_l]);
                        continue;
                }
                if (index_l < i - nr) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                        continue;
                }
                if (left_array[index_l] <= (right_array[i - index_l])) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                } else {
                        m[i] = (right_array[i - index_l]);
                }
        }
        return m;
}
public static long[] MergeSort(long[] array) {
        if (array.length <= 1) return array;
        int m = array.length / 2;
        long[] left_array = new long[m];
        long[] right_array = new long[array.length - m];
        for (int i = 0; i < m; i++) left_array[i] = array[i];
        for (int i = m, x = 0; i < array.length; i++, x++) right_array[x] = array[i];
        left_array = MergeSort(left_array);
        right_array = MergeSort(right_array);
        return Merge(left_array, right_array);
}
public static long[] Merge(long[] left_array, long[] right_array) {
        long[] m = new long[left_array.length + right_array.length];
        int index_l = 0;
        int nl, nr;
        nl = left_array.length - 1;
        nr = right_array.length - 1;
        for (int i = 0; i <= nl + nr + 1; i++) {
                if (index_l > nl) {
                        m[i] = (right_array[i - index_l]);
                        continue;
                }
                if (index_l < i - nr) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                        continue;
                }
                if (left_array[index_l] <= (right_array[i - index_l])) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                } else {
                        m[i] = (right_array[i - index_l]);
                }
        }
        return m;
}
public static byte[] MergeSort(byte[] array) {
        if (array.length <= 1) return array;
        int m = array.length / 2;
        byte[] left_array = new byte[m];
        byte[] right_array = new byte[array.length - m];
        for (int i = 0; i < m; i++) left_array[i] = array[i];
        for (int i = m, x = 0; i < array.length; i++, x++) right_array[x] = array[i];
        left_array = MergeSort(left_array);
        right_array = MergeSort(right_array);
        return Merge(left_array, right_array);
}
public static byte[] Merge(byte[] left_array, byte[] right_array) {
        byte[] m = new byte[left_array.length + right_array.length];
        int index_l = 0;
        int nl, nr;
        nl = left_array.length - 1;
        nr = right_array.length - 1;
        for (int i = 0; i <= nl + nr + 1; i++) {
                if (index_l > nl) {
                        m[i] = (right_array[i - index_l]);
                        continue;
                }
                if (index_l < i - nr) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                        continue;
                }
                if (left_array[index_l] <= (right_array[i - index_l])) {
                        m[i] = (left_array[index_l]);
                        index_l++;
                } else {
                        m[i] = (right_array[i - index_l]);
                }
        }
        return m;
}
public static int[] SelectionSort(int[] array) {
        int n = array.length - 1;
        int index = 0;
        int minPos;
        do {
                minPos = index;
                for (int i = (index + 1); i <= n; i++) {
                        if (array[i] < array[minPos]) {
                                minPos = i;
                        }
                }
                Swap(array, minPos, index);
                index++;
        } while (index < n);
        return array;
}
public static double[] SelectionSort(double[] array) {
        int n = array.length - 1;
        int index = 0;
        int minPos;
        do {
                minPos = index;
                for (int i = (index + 1); i <= n; i++) {
                        if (array[i] < array[minPos]) {
                                minPos = i;
                        }
                }
                Swap(array, minPos, index);
                index++;
        } while (index < n);
        return array;
}
public static float[] SelectionSort(float[] array) {
        int n = array.length - 1;
        int index = 0;
        int minPos;
        do {
                minPos = index;
                for (int i = (index + 1); i <= n; i++) {
                        if (array[i] < array[minPos]) {
                                minPos = i;
                        }
                }
                Swap(array, minPos, index);
                index++;
        } while (index < n);
        return array;
}
public static byte[] SelectionSort(byte[] array) {
        int n = array.length - 1;
        int index = 0;
        int minPos;
        do {
                minPos = index;
                for (int i = (index + 1); i <= n; i++) {
                        if (array[i] < array[minPos]) {
                                minPos = i;
                        }
                }
                Swap(array, minPos, index);
                index++;
        } while (index < n);
        return array;
}
public static long[] SelectionSort(long[] array) {
        int n = array.length - 1;
        int index = 0;
        int minPos;
        do {
                minPos = index;
                for (int i = (index + 1); i <= n; i++) {
                        if (array[i] < array[minPos]) {
                                minPos = i;
                        }
                }
                Swap(array, minPos, index);
                index++;
        } while (index < n);
        return array;
}
public static short[] SelectionSort(short[] array) {
        int n = array.length - 1;
        int index = 0;
        int minPos;
        do {
                minPos = index;
                for (int i = (index + 1); i <= n; i++) {
                        if (array[i] < array[minPos]) {
                                minPos = i;
                        }
                }
                Swap(array, minPos, index);
                index++;
        } while (index < n);
        return array;
}
public static int[] BubbleSort(int[] array) {
        int n = array.length;
        int newn;
        do {
                newn = 1;
                for (int i = 0; i < n - 1; i++) {
                        if (array[i] > array[i + 1] ) {
                                Swap(array, i, i + 1);
                                newn = i + 1;
                        }
                }
                n = newn;
        } while (n > 1);
        return array;
}
public static double[] BubbleSort(double[] array) {
        int n = array.length;
        int newn;
        do {
                newn = 1;
                for (int i = 0; i < n - 1; i++) {
                        if (array[i] > array[i + 1] ) {
                                Swap(array, i, i + 1);
                                newn = i + 1;
                        }
                }
                n = newn;
        } while (n > 1);
        return array;
}
public static float[] BubbleSort(float[] array) {
        int n = array.length;
        int newn;
        do {
                newn = 1;
                for (int i = 0; i < n - 1; i++) {
                        if (array[i] > array[i + 1] ) {
                                Swap(array, i, i + 1);
                                newn = i + 1;
                        }
                }
                n = newn;
        } while (n > 1);
        return array;
}
public static short[] BubbleSort(short[] array) {
        int n = array.length;
        int newn;
        do {
                newn = 1;
                for (int i = 0; i < n - 1; i++) {
                        if (array[i] > array[i + 1] ) {
                                Swap(array, i, i + 1);
                                newn = i + 1;
                        }
                }
                n = newn;
        } while (n > 1);
        return array;
}
public static long[] BubbleSort(long[] array) {
        int n = array.length;
        int newn;
        do {
                newn = 1;
                for (int i = 0; i < n - 1; i++) {
                        if (array[i] > array[i + 1] ) {
                                Swap(array, i, i + 1);
                                newn = i + 1;
                        }
                }
                n = newn;
        } while (n > 1);
        return array;
}
public static byte[] BubbleSort(byte[] array) {
        int n = array.length;
        int newn;
        do {
                newn = 1;
                for (int i = 0; i < n - 1; i++) {
                        if (array[i] > array[i + 1] ) {
                                Swap(array, i, i + 1);
                                newn = i + 1;
                        }
                }
                n = newn;
        } while (n > 1);
        return array;
}
public static int[] QuickSort(int[] array, int lo, int hi) {
        if (lo < hi) {
                int pi = Partition(array, lo, hi);
                QuickSort(array, lo, pi - 1);
                QuickSort(array, pi + 1, hi);
        }
        return array;
}
public static int Partition(int[] array, int low, int high) {
        int pivot = array[high];
        int lowIndex = (low - 1);
        for (int j = low; j <= high - 1; j++) {
                if (array[j] <= pivot) {
                        lowIndex++;
                        Swap(array, lowIndex, j);
                }
        }
        Swap(array, lowIndex + 1, high);
        return (lowIndex + 1);
}
public static double[] QuickSort(double[] array, int lo, int hi) {
        if (lo < hi) {
                int pi = Partition(array, lo, hi);
                QuickSort(array, lo, pi - 1);
                QuickSort(array, pi + 1, hi);
        }
        return array;
}
public static int Partition(double[] array, int low, int high) {
        double pivot = array[high];
        int lowIndex = (low - 1);
        for (int j = low; j <= high - 1; j++) {
                if (array[j] <= pivot) {
                        lowIndex++;
                        Swap(array, lowIndex, j);
                }
        }
        Swap(array, lowIndex + 1, high);
        return (lowIndex + 1);
}
public static float[] QuickSort(float[] array, int lo, int hi) {
        if (lo < hi) {
                int pi = Partition(array, lo, hi);
                QuickSort(array, lo, pi - 1);
                QuickSort(array, pi + 1, hi);
        }
        return array;
}
public static int Partition(float[] array, int low, int high) {
        float pivot = array[high];
        int lowIndex = (low - 1);
        for (int j = low; j <= high - 1; j++) {
                if (array[j] <= pivot) {
                        lowIndex++;
                        Swap(array, lowIndex, j);
                }
        }
        Swap(array, lowIndex + 1, high);
        return (lowIndex + 1);
}
public static short[] QuickSort(short[] array, int lo, int hi) {
        if (lo < hi) {
                int pi = Partition(array, lo, hi);
                QuickSort(array, lo, pi - 1);
                QuickSort(array, pi + 1, hi);
        }
        return array;
}
public static int Partition(short[] array, int low, int high) {
        short pivot = array[high];
        int lowIndex = (low - 1);
        for (int j = low; j <= high - 1; j++) {
                if (array[j] <= pivot) {
                        lowIndex++;
                        Swap(array, lowIndex, j);
                }
        }
        Swap(array, lowIndex + 1, high);
        return (lowIndex + 1);
}
public static byte[] QuickSort(byte[] array, int lo, int hi) {
        if (lo < hi) {
                int pi = Partition(array, lo, hi);
                QuickSort(array, lo, pi - 1);
                QuickSort(array, pi + 1, hi);
        }
        return array;
}
public static int Partition(byte[] array, int low, int high) {
        byte pivot = array[high];
        int lowIndex = (low - 1);
        for (int j = low; j <= high - 1; j++) {
                if (array[j] <= pivot) {
                        lowIndex++;
                        Swap(array, lowIndex, j);
                }
        }
        Swap(array, lowIndex + 1, high);
        return (lowIndex + 1);
}
public static long[] QuickSort(long[] array, int lo, int hi) {
        if (lo < hi) {
                int pi = Partition(array, lo, hi);
                QuickSort(array, lo, pi - 1);
                QuickSort(array, pi + 1, hi);
        }
        return array;
}
public static int Partition(long[] array, int low, int high) {
        long pivot = array[high];
        int lowIndex = (low - 1);
        for (int j = low; j <= high - 1; j++) {
                if (array[j] <= pivot) {
                        lowIndex++;
                        Swap(array, lowIndex, j);
                }
        }
        Swap(array, lowIndex + 1, high);
        return (lowIndex + 1);
}
public static int[] InsertionSort(int[] array) {
        int n = array.length;
        int value;
        int j;
        for (int i = 1; i < n; i++) {
                value = array[i];
                j = i;
                while (j > 0 && (array[j - 1] > value)) {
                        array[j] = array[j - 1];
                        j -= 1;
                }
                array[j] = value;
        }
        return array;
}
public static double[] InsertionSort(double[] array) {
        int n = array.length;
        double value;
        int j;
        for (int i = 1; i < n; i++) {
                value = array[i];
                j = i;
                while (j > 0 && (array[j - 1] > value)) {
                        array[j] = array[j - 1];
                        j -= 1;
                }
                array[j] = value;
        }
        return array;
}
public static float[] InsertionSort(float[] array) {
        int n = array.length;
        float value;
        int j;
        for (int i = 1; i < n; i++) {
                value = array[i];
                j = i;
                while (j > 0 && (array[j - 1] > value)) {
                        array[j] = array[j - 1];
                        j -= 1;
                }
                array[j] = value;
        }
        return array;
}
public static short[] InsertionSort(short[] array) {
        int n = array.length;
        short value;
        int j;
        for (int i = 1; i < n; i++) {
                value = array[i];
                j = i;
                while (j > 0 && (array[j - 1] > value)) {
                        array[j] = array[j - 1];
                        j -= 1;
                }
                array[j] = value;
        }
        return array;
}
public static byte[] InsertionSort(byte[] array) {
        int n = array.length;
        byte value;
        int j;
        for (int i = 1; i < n; i++) {
                value = array[i];
                j = i;
                while (j > 0 && (array[j - 1] > value)) {
                        array[j] = array[j - 1];
                        j -= 1;
                }
                array[j] = value;
        }
        return array;
}
public static long[] InsertionSort(long[] array) {
        int n = array.length;
        long value;
        int j;
        for (int i = 1; i < n; i++) {
                value = array[i];
                j = i;
                while (j > 0 && (array[j - 1] > value)) {
                        array[j] = array[j - 1];
                        j -= 1;
                }
                array[j] = value;
        }
        return array;
}
public static int[] CombSort(int[] array) {
        int steplength = array.length;
        boolean swapped;
        do {
                swapped = false;
                for (int i = 0; i < (array.length - steplength); i++) {
                        if (array[i] > (array[i + steplength])) {
                                Swap(array, i, i + steplength);
                                swapped = true;
                        }
                }
                if (steplength > 1) {
                        steplength = (int)Math.floor(steplength / 1.3);
                }
        } while (swapped == true || steplength > 1);
        return array;
}
public static double[] CombSort(double[] array) {
        int steplength = array.length;
        boolean swapped;
        do {
                swapped = false;
                for (int i = 0; i < (array.length - steplength); i++) {
                        if (array[i] > (array[i + steplength])) {
                                Swap(array, i, i + steplength);
                                swapped = true;
                        }
                }
                if (steplength > 1) {
                        steplength = (int)Math.floor(steplength / 1.3);
                }
        } while (swapped == true || steplength > 1);
        return array;
}
public static float[] CombSort(float[] array) {
        int steplength = array.length;
        boolean swapped;
        do {
                swapped = false;
                for (int i = 0; i < (array.length - steplength); i++) {
                        if (array[i] > (array[i + steplength])) {
                                Swap(array, i, i + steplength);
                                swapped = true;
                        }
                }
                if (steplength > 1) {
                        steplength = (int)Math.floor(steplength / 1.3);
                }
        } while (swapped == true || steplength > 1);
        return array;
}
public static short[] CombSort(short[] array) {
        int steplength = array.length;
        boolean swapped;
        do {
                swapped = false;
                for (int i = 0; i < (array.length - steplength); i++) {
                        if (array[i] > (array[i + steplength])) {
                                Swap(array, i, i + steplength);
                                swapped = true;
                        }
                }
                if (steplength > 1) {
                        steplength = (int)Math.floor(steplength / 1.3);
                }
        } while (swapped == true || steplength > 1);
        return array;
}
public static byte[] CombSort(byte[] array) {
        int steplength = array.length;
        boolean swapped;
        do {
                swapped = false;
                for (int i = 0; i < (array.length - steplength); i++) {
                        if (array[i] > (array[i + steplength])) {
                                Swap(array, i, i + steplength);
                                swapped = true;
                        }
                }
                if (steplength > 1) {
                        steplength = (int)Math.floor(steplength / 1.3);
                }
        } while (swapped == true || steplength > 1);
        return array;
}
public static long[] CombSort(long[] array) {
        int steplength = array.length;
        boolean swapped;
        do {
                swapped = false;
                for (int i = 0; i < (array.length - steplength); i++) {
                        if (array[i] > (array[i + steplength])) {
                                Swap(array, i, i + steplength);
                                swapped = true;
                        }
                }
                if (steplength > 1) {
                        steplength = (int)Math.floor(steplength / 1.3);
                }
        } while (swapped == true || steplength > 1);
        return array;
}
public static int[] IntroSort(int[] array) {
        int p = Partition(array, 0, array.length - 1);
        if (p < 16) {
                array = InsertionSort(array);
        } else {
                array = p > (2 * Math.log(array.length)) ? HeapSort(array) : QuickSort(array, 0, array.length - 1);
        }
        return array;
}
public static double[] IntroSort(double[] array) {
        int p = Partition(array, 0, array.length - 1);
        if (p < 16) {
                array = InsertionSort(array);
        } else {
                array = p > (2 * Math.log(array.length)) ? HeapSort(array) : QuickSort(array, 0, array.length - 1);
        }
        return array;
}
public static float[] IntroSort(float[] array) {
        int p = Partition(array, 0, array.length - 1);
        if (p < 16) {
                array = InsertionSort(array);
        } else {
                array = p > (2 * Math.log(array.length)) ? HeapSort(array) : QuickSort(array, 0, array.length - 1);
        }
        return array;
}
public static short[] IntroSort(short[] array) {
        int p = Partition(array, 0, array.length - 1);
        if (p < 16) {
                array = InsertionSort(array);
        } else {
                array = p > (2 * Math.log(array.length)) ? HeapSort(array) : QuickSort(array, 0, array.length - 1);
        }
        return array;
}
public static byte[] IntroSort(byte[] array) {
        int p = Partition(array, 0, array.length - 1);
        if (p < 16) {
                array = InsertionSort(array);
        } else {
                array = p > (2 * Math.log(array.length)) ? HeapSort(array) : QuickSort(array, 0, array.length - 1);
        }
        return array;
}
public static long[] IntroSort(long[] array) {
        int p = Partition(array, 0, array.length - 1);
        if (p < 16) {
                array = InsertionSort(array);
        } else {
                array = p > (2 * Math.log(array.length)) ? HeapSort(array) : QuickSort(array, 0, array.length - 1);
        }
        return array;
}
public static int[] HeapSort(int[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(array, n, i);
        for (int i = n - 1; i >= 0; i--) {
                Swap(array, 0, i);
                array = Heapify(array, i, 0);
        }
        return array;
}
public static int[] Heapify(int[] array, int n, int i) {
        int largest = i;  
        int left = 2 * i + 1;  
        int right = 2 * i + 2;  
        if (left < n && left < n && array[left] > array[largest])
                largest = left;
        if (right < n && array[right] > array[largest])
                largest = right;
        if (largest != i) {
                Swap(array, i, largest);
                array = Heapify(array, n, largest);
        }
        return array;
}
public static double[] HeapSort(double[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(array, n, i);
        for (int i = n - 1; i >= 0; i--) {
                Swap(array, 0, i);
                array = Heapify(array, i, 0);
        }
        return array;
}
public static double[] Heapify(double[] array, int n, int i) {
        int largest = i;  
        int left = 2 * i + 1;  
        int right = 2 * i + 2;  
        if (left < n && array[left] > array[largest])
                largest = left;
        if (right < n && array[right] > array[largest])
                largest = right;
        if (largest != i) {
                Swap(array, i, largest);
                array = Heapify(array, n, largest);
        }
        return array;
}
public static float[] HeapSort(float[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(array, n, i);
        for (int i = n - 1; i >= 0; i--) {
                Swap(array, 0, i);
                array = Heapify(array, i, 0);
        }
        return array;
}
public static float[] Heapify(float[] array, int n, int i) {
        int largest = i;  
        int left = 2 * i + 1;  
        int right = 2 * i + 2;  
        if (left < n && array[left] > array[largest])
                largest = left;
        if (right < n && array[right] > array[largest])
                largest = right;
        if (largest != i) {
                Swap(array, i, largest);
                array = Heapify(array, n, largest);
        }
        return array;
}
public static short[] HeapSort(short[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(array, n, i);
        for (int i = n - 1; i >= 0; i--) {
                Swap(array, 0, i);
                array = Heapify(array, i, 0);
        }
        return array;
}
public static short[] Heapify(short[] array, int n, int i) {
        int largest = i;  
        int left = 2 * i + 1;  
        int right = 2 * i + 2;  
        if (left < n && array[left] > array[largest])
                largest = left;
        if (right < n && array[right] > array[largest])
                largest = right;
        if (largest != i) {
                Swap(array, i, largest);
                array = Heapify(array, n, largest);
        }
        return array;
}
public static byte[] HeapSort(byte[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(array, n, i);
        for (int i = n - 1; i >= 0; i--) {
                Swap(array, 0, i);
                array = Heapify(array, i, 0);
        }
        return array;
}
public static byte[] Heapify(byte[] array, int n, int i) {
        int largest = i;  
        int left = 2 * i + 1;  
        int right = 2 * i + 2;  
        if (left < n && array[left] > array[largest])
                largest = left;
        if (right < n && array[right] > array[largest])
                largest = right;
        if (largest != i) {
                Swap(array, i, largest);
                array = Heapify(array, n, largest);
        }
        return array;
}
public static long[] HeapSort(long[] array) {
        int n = array.length;
        for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(array, n, i);
        for (int i = n - 1; i >= 0; i--) {
                Swap(array, 0, i);
                array = Heapify(array, i, 0);
        }
        return array;
}
public static long[] Heapify(long[] array, int n, int i) {
        int largest = i;  
        int left = 2 * i + 1;  
        int right = 2 * i + 2;  
        if (left < n && array[left] > array[largest])
                largest = left;
        if (right < n && array[right] > array[largest])
                largest = right;
        if (largest != i) {
                Swap(array, i, largest);
                array = Heapify(array, n, largest);
        }
        return array;
}
}",1,1,1,1,1,0,0,0,0
763,"!function (SU, undefined) {
  SU.version = 'v0.1.2';
  SU.insertionSort = function(collection, compare) {
    var compare = compare || _defaultCompare,
        length  = collection.length,
        tmp     = null,
        i       = 0,
        j       = 0;
    for (i = 1; i < length; i++) {
      for (j = i; j > 0; j--) {
        if (compare(collection[j], collection[j - 1]) < 0) {
          tmp = collection[j];
          collection[j] = collection[j - 1];
          collection[j - 1] = tmp;
        } else {
          break;
        }
      }
    }
    return collection;
  };
  SU.mergesort = function (collection, compare) {
    var compare = compare || _defaultCompare;
    SU._mergesort(collection, 0, collection.length - 1, compare);
    return collection;
  }
  SU._mergesort = function(collection, left, right, compare) {
      var compare = compare || _defaultCompare,
          mid = null;
      if (Math.floor(right - left) <= 0) { return; }
      mid = Math.floor((left + right) / 2);
      SU._mergesort(collection, left, mid, compare);
      SU._mergesort(collection, mid + 1, right, compare);
      SU._merge(collection, left, mid, right, compare);
  };
  SU._merge = function(collection, left, mid, right, compare) {
    var compare      = compare || _defaultCompare,
        sorted       = [],
        leftPointer  = left,
        leftStop     = mid,
        rightPointer = mid + 1,
        length       = right - left + 1,
        i            = 0;
    while (leftPointer <= leftStop || rightPointer <= right) {
      if (leftPointer > leftStop) {         
        sorted.push(collection[rightPointer]);
        rightPointer++;
      } else if (rightPointer > right) {   
        sorted.push(collection[leftPointer]);
        leftPointer++;
      } else {                         
        if (compare(collection[leftPointer], collection[rightPointer]) > 0) {
          sorted.push(collection[rightPointer]);
          rightPointer++;
        } else {
          sorted.push(collection[leftPointer]);
          leftPointer++;
        }
      }
    }
    for (i = 0; i < length; i++) { collection[left + i] = sorted[i]; }
    return collection;
  };
  SU.quicksort = function (collection, compare) {
    var compare = compare || _defaultCompare;
    SU._quicksort(collection, 0, collection.length - 1, compare);
    return collection;
  }
  SU._quicksort = function(collection, left, right, compare) {
    var compare = compare || _defaultCompare,
        pivot   = null;
    if (left < right) {
      pivot = SU._partition(collection, left, right, compare);
      SU._quicksort(collection, left, pivot - 1, compare);
      SU._quicksort(collection, pivot + 1, right, compare);
    }
  }
  SU._partition = function(collection, left, right, compare) {
    var compare = compare || _defaultCompare,
        pivot   = collection[right],
        pIndex  = left,
        tmp     = null,
        i       = 0;
    for (i = left; i < right; i++) {
      if (compare(collection[i], pivot) <= 0) {
        tmp = collection[i];
        collection[i] = collection[pIndex];
        collection[pIndex] = tmp;
        pIndex++;
      }
    }
    collection[right] = collection[pIndex];
    collection[pIndex] = pivot;
    return pIndex;
  };
  SU.heapsort = function (collection, compare) {
        var compare   = compare || _defaultCompare,
            heapSize  = collection.length - 1,
            leafLevel = Math.floor(collection.length / 2),
            tmp       = null,
            i;
        for (i = leafLevel; i >= 0; i--) { SU._heapify(collection, i, heapSize); }
        for (i = heapSize; i > 0; i--) {
            tmp = collection[i];
            collection[i] = collection[0];
            collection[0] = tmp;
            SU._heapify(collection, 0, i - 1);
        }
        return collection;
    }
  SU._heapify = function (collection, i, iLast, compare) {
    var compare  = compare || _defaultCompare,
        iLeft    = SU._left(i),
        iRight   = SU._right(i),
        iLargest = i,
        tmp      = null;
    if (iLeft <= iLast && compare(collection[iLeft], collection[i]) > 0) {
      iLargest = iLeft;
    }
    if (iRight <= iLast && compare(collection[iRight], collection[iLargest]) > 0) {
      iLargest = iRight;
    }
    if (iLargest != i) {     
      tmp = collection[iLargest];
      collection[iLargest] = collection[i];
      collection[i] = tmp;
      SU._heapify(collection, iLargest, iLast, compare);
    }
    return collection;
  }
  SU._parent = function (i) { return Math.floor((i - 1) / 2); }
  SU._left   = function (i) { return Math.floor((2 * i) + 1); }
  SU._right  = function (i) { return Math.floor((2 * i ) + 2); }
  function _defaultCompare(a, b) {
    return a - b;
  }
}(window.SortUtil = window.SortUtil || {})",1,1,0,1,0,0,0,0,0
764,"package Sorting.Challenges;
public class Challenge1 {
    public static void main(String[] args) {
        int[] arr = {20,35,-15,7,55,1,-22};
        mS(arr,0,arr.length);
        for (int i = 0; i <arr.length ; i++) {
            System.out.print(arr[i]+"" "");
        }
    }
    public static void mS(int[] arr,int start,int end){
        if (end-start<2){
            return;
        }
        int mid = (start+end)/2;
        mS(arr,start,mid);
        mS(arr,mid,end);
        merge(arr,start,mid,end);
    }
    public static void merge(int[] arr,int start,int mid,int end){
        if (arr[mid-1]>=arr[mid]){
            return;
        }
        int i = start;
        int j = mid;
        int ti = 0;
        int[] temp = new int[end-start];
        while (i<mid && j<end){
            temp[ti++]= arr[i] >= arr[j] ? arr[i++] : arr[j++];
        }
        System.arraycopy(arr,i,arr,start+ti,mid - i);
        System.arraycopy(temp,0,arr,start,ti);
    }
}",0,1,0,0,0,0,0,0,0
765,"package sorting;
import java.util.concurrent.ForkJoinPool;
public class ConcurrentMergeSort<T extends Comparable<T>> implements Sort<T> {
    private final int threshold;
    public ConcurrentMergeSort(int threshold) {
        this.threshold = threshold;
    }
    @Override
    public void sort(T[] items) {
        ForkJoinPool pool = new ForkJoinPool();
        ConcurrentMergeSortTask<T> task = new ConcurrentMergeSortTask<>(items, threshold);
        pool.invoke(task);
    }
}",0,0,0,0,0,0,0,0,0
766,"package sorting;
import java.util.Arrays;
import java.util.concurrent.RecursiveAction;
@SuppressWarnings(""serial"")
public class ConcurrentMergeSortTask<T extends Comparable<T>> extends RecursiveAction {
    private final T items[];
    private final int min;
    private final int length;
    private final int threshold;
    public ConcurrentMergeSortTask(T items[], int threshold) {
        this.items = items;
        this.min = 0;
        this.length = items.length;
        this.threshold = threshold;
    }
    private ConcurrentMergeSortTask(T items[], int min, int length, int threshold) {
        this.items = items;
        this.min = min;
        this.length = length;
        this.threshold = threshold;
    }
    @Override
    protected void compute() {
        if (length - min + 1 <= threshold) {
            Arrays.sort(items, min, length);
        } else {
            int mid = min + (length - min) / 2;
            invokeAll(new ConcurrentMergeSortTask<T>(items, min, mid, threshold),
                    new ConcurrentMergeSortTask<T>(items, mid, length, threshold));
            merge(min, mid, length);
        }
    }
    private void merge(int min, int mid, int max) {
        T buf[] = Arrays.copyOfRange(items, min, mid);
        int readBuf = 0;
        int readArray = mid;
        int write = min;
        while (readBuf < buf.length) {
            if (readArray == max || buf[readBuf].compareTo(items[readArray]) < 0) {
                items[write++] = buf[readBuf++];
            } else {
                items[write++] = items[readArray++];
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
767,"package com.intrafoundation;
public class InPlaceMergeSort {
}",0,0,0,0,0,0,0,0,0
768,"package eu.happycoders.sort.method.mergesort;
import eu.happycoders.sort.method.Counters;
import eu.happycoders.sort.method.SortAlgorithm;
public class InPlaceMergeSort implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    int length = elements.length;
    mergeSort(elements, 0, length - 1);
  }
  private void mergeSort(int[] elements, int left, int right) {
    if (left == right) return;
    int middle = left + (right - left) / 2;
    mergeSort(elements, left, middle);
    mergeSort(elements, middle + 1, right);
    merge(elements, left, middle + 1, right);
  }
void merge(int[] elements, int leftPos, int rightPos, int rightEnd) {
  int leftEnd = rightPos - 1;
  while (leftPos <= leftEnd && rightPos <= rightEnd) {
    int leftValue = elements[leftPos];
    int rightValue = elements[rightPos];
    if (leftValue <= rightValue) {
      leftPos++;
    } else {
      int movePos = rightPos;
      while (movePos > leftPos) {
        elements[movePos] = elements[movePos - 1];
        movePos--;
      }
      elements[leftPos] = rightValue;
      leftPos++;
      leftEnd++;
      rightPos++;
    }
  }
}
  @Override
  public void sort(int[] elements, Counters counters) {
    int length = elements.length;
    mergeSort(elements, 0, length - 1, counters);
  }
  private void mergeSort(int[] elements, int left, int right,
                         Counters counters) {
    if (left == right) return;
    int middle = left + (right - left) / 2;
    mergeSort(elements, left, middle, counters);
    mergeSort(elements, middle + 1, right, counters);
    merge(elements, left, middle + 1, right, counters);
  }
  private void merge(int[] elements, int leftPos, int rightPos, int rightEnd,
                     Counters counters) {
    int leftEnd = rightPos - 1;
    while (isLessThanOrEqual(leftPos, leftEnd, counters) && isLessThanOrEqual(rightPos, rightEnd, counters)) {
      int leftValue = elements[leftPos];
      int rightValue = elements[rightPos];
      counters.addReads(2);
      counters.incComparisons();
      if (leftValue <= rightValue) {
        leftPos++;
      } else {
        int movePos = rightPos;
        while (isGreaterThan(movePos, leftPos, counters)) {
          counters.incReadsAndWrites();
          elements[movePos] = elements[movePos - 1];
          movePos--;
        }
        counters.incWrites();
        elements[leftPos] = rightValue;
        leftPos++;
        leftEnd++;
        rightPos++;
      }
    }
  }
  private boolean isLessThanOrEqual(int a, int b, Counters counters) {
    counters.incComparisons();
    return a <= b;
  }
  private boolean isGreaterThan(int a, int b, Counters counters) {
    counters.incComparisons();
    return a > b;
  }
}",0,1,0,0,0,0,0,0,0
769,"def merge(b , low , high , mid):
	i = low
 j = mid + 1
 new_list = list()
 while i <= mid and j <= high:
		if b[i] < b[j]:
			new_list.append(b[i])
   i+=1
  else:
			new_list.append(b[j])
   j+=1
 while (i<=mid):
		new_list.append(b[i])
  i+=1
 while (j<=high):
		new_list.append(b[j])
  j+=1
 x = low
 for i in new_list:
		b[x] = i
  x+=1
 return b
def iterative_merge_sort(a):
	n = len(a)
 p = 2
 while (p<=n):
		i = 0
  while (i+p-1 < n):
			l = i
   h = i+p-1
   mid = (l+h)//2
   merge(a , l , h , mid)
   i+=p
  p*=2
 if p//2 < n:
		merge(a , 0 , (p//2)-1 , n-1)
a = [8,3,7,4,5,2,6,5]
print(a)
iterative_merge_sort(a)
print(a)",0,1,0,0,0,0,0,0,0
770,"def iterative_merge_sort(arr):
    if len(arr) < 2:
        return arr
    middle = len(arr) // 2
    left = iterative_merge_sort(arr[:middle])
    right = iterative_merge_sort(arr[middle:])
    return merge(left, right)
def merge(left, right):
    if not len(left) or not len(right):
        return left or right
    result = []
    i, j = 0, 0
    while len(result) < len(left) + len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
        if i == len(left) or j == len(right):
            result.extend(left[i:] or right[j:])
            break
    return result",0,1,0,0,0,0,0,0,0
771,"package sortvisualiser.algorithms;
import sortvisualiser.SortArray;
public class IterativeMergeSort implements ISortAlgorithm
{
	private long stepDelay = 5;
	@Override
	public void runSort(SortArray array) 
	{
		for(int exp = 1; exp < array.arraySize(); exp <<= 1)
			for(int k = 0, j = exp+exp, s = array.arraySize()-exp; k<s; k+=j)
				merge(array, k, exp);
	}
	private int[] getSubArray(SortArray array, int start, int end)
	{
		int size = end - start;
		int arr[] = new int[size];
		for (int i = 0; i < size; i++) 
			arr[i] = array.getValue(start + i);		
		return arr;
	}
	private void merge(SortArray arr, int start, int exp)
	{
		int s = start;
		int m = start + exp;
		int end = (arr.arraySize() < m+exp) ? arr.arraySize() : m + exp;				
		int[] leftArr = getSubArray(arr, s, m);
		int[] rightArr = getSubArray(arr, m, end);
		int i = 0, j = 0;
		while(i < leftArr.length && j < rightArr.length)
			if(leftArr[i] <= rightArr[j])
				arr.updateSingle(start++, leftArr[i++], getDelay(), true);
			else
				arr.updateSingle(start++, rightArr[j++], getDelay(), true);
		while (i < leftArr.length)
			arr.updateSingle(start++, leftArr[i++], getDelay(), true);
		while (j < leftArr.length)
			arr.updateSingle(start++, rightArr[j++], getDelay(), true);		
	}	
	@Override
	public String getName() {
		return ""Iterative Merge Sort"";
	}
	@Override
	public long getDelay() {
		return stepDelay;
	}
	@Override
	public void setDelay(long delay) {
		this.stepDelay = delay;
	}
}",0,1,0,0,0,0,0,0,0
772,"from typing import List
def merge(array1: List[int], array2: List[int]) -> List[int]:
    array = []  
    first = second = 0  
    while first < len(array1) and second < len(array2):
        if array1[first] > array2[second]:
            array.append(array2[second])
            second += 1
        elif array1[first] < array2[second]:
            array.append(array1[first])
            first += 1
        else:
            array.append(array1[first])
            first += 1
            array.append(array2[second])
            second += 1
    while first < len(array1):
        array.append(array1[first])
        first += 1
    while second < len(array2):
        array.append(array2[second])
        second += 1
    return array
def mergeSort(array: List[int]) -> List[int]:
    if len(array) > 1:
        half = len(array) // 2  
        left = array[:half]
        right = array[half:]
        left = mergeSort(left)
        right = mergeSort(right)
        array = merge(left, right)
    return array
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""MERGE SORT"")
    shuffledArray = randomSequence(0, 1000)
    print(shuffledArray, ""\n"")
    sortedArray = mergeSort(shuffledArray)
    print(sortedArray)",0,1,0,0,0,0,0,0,0
773,"from typing import List
def merge(array: List[int], start: int, mid: int, end: int) -> None:
    start2 = mid + 1
    if array[mid] <= array[start2]:
        return
    while start <= mid and start2 <= end:
        if array[start] <= array[start2]:
            start += 1
        else:
            value = array[start2]
            index = start2
            while index != start:
                array[index] = array[index - 1]
                index -= 1
            array[start] = value
            start += 1
            mid += 1
            start2 += 1
def mergeSort(array: List[int], *args: List[int]) -> None:
    if len(args) == 2:
        left, right = args
    else:
        left, right = 0, len(array) - 1
    if right > left:
        half = left + (right - left) // 2  
        mergeSort(array, left, half)
        mergeSort(array, half + 1, right)
        merge(array, left, half, right)
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""MERGE SORT"")
    shuffledArray = [7, 3, 6, 9, 4, 8, 1, 0, 5, 2]
    print(shuffledArray, ""\n"")
    mergeSort(shuffledArray)
    print(shuffledArray)",0,1,0,0,0,0,0,0,0
774,"public interface MaxValue<T>
{
    public T getMaxObject();
}",0,0,0,0,0,0,0,0,0
775,"public class Merge {
    public static void sort(int[] input) {
        mergesort(input, 0, input.length - 1);
    }
    private static void mergesort(int[] list, int start, int end) {
        if(start >= end)
            return;
        int mid = start + ((end - start) / 2);
        mergesort(list, start, mid);
        mergesort(list, mid + 1, end);
        merge(list, start, mid, end);
    }
    @SuppressWarnings(""ManualArrayCopy"")
    private static void merge(int[] list, int start, int mid, int end) {
        int[] left = new int[mid - start + 1];
        int[] right = new int[end - mid];
        for (int i = 0; i < left.length; i++) {
            left[i] = list[i + start];
        }
        for (int i = 0; i < right.length; i++) {
            right[i] = list[i + mid + 1];
        }
        mid = 0;  
        end = 0;  
        while (mid < left.length && end < right.length) {
            if (left[mid] > right[end]) {
                list[start] = right[end];
                end++;
            } else {
                list[start] = left[mid];
                mid++;
            }
            start++;
        }
        while (mid < left.length) {
            list[start] = left[mid];
            start++;
            mid++;
        }
        while (end < right.length) {
            list[start] = right[end];
            start++;
            end++;
        }
    }
}",0,1,0,0,0,0,0,0,0
776,"import structures.src.util.sort_util as util
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    midpoint = int(len(arr) / 2)
    return _merge(merge_sort(arr[:midpoint]), merge_sort(arr[midpoint:]))
def _merge(a, b):
    out = []
    i, j = 0, 0
    while i < len(a) and j < len(b):
        if i == len(a): 
            out.append(b[j])
            j += 1
        elif j == len(b): 
            out.append(a[i])
            i += 1
        elif a[i] < b[j]: 
            out.append(a[i])
            i += 1
        else: 
            out.append(b[j])
            j += 1
    return out",0,1,0,0,0,0,0,0,0
777,"package piratezpdx.sortathon;
public class Merge extends ArrayBased {
    protected int comparisons;
    Merge(){
        super();
        comparisons = 0;
    }
    public int sort(){
        comparisons = 0;
        setSortingArray(split(getSortingArray()));
        return comparisons;
    }
    public int[] split(int[] incoming)throws ArrayIndexOutOfBoundsException{
        int leftlen = 0;
        int rightlen = 0;
        if (incoming.length == 1){
            return incoming;
        }
        if (incoming.length%2 == 0){
            leftlen = rightlen = incoming.length/2;
        }
        else{
            leftlen = incoming.length/2;
            rightlen = leftlen + 1;
        }
        int [] left = new int[leftlen];
        int [] right = new int[rightlen];
        System.arraycopy(incoming, 0, left, 0, leftlen);
        System.arraycopy(incoming, leftlen, right, 0, rightlen);
        left = split(left);
        right = split(right);
        return mergeThese(left,right);
    }
    public int[] mergeThese(int[] a, int[] b) throws ArrayIndexOutOfBoundsException{
        int num = 0;
        int aIndex = 0;
        int bIndex = 0;
        int aLen = a.length;
        int bLen = b.length;
        int resultLen = aLen + bLen;
        int [] result = new int [resultLen];
        while (num < resultLen){
            if (aIndex == aLen) {
                System.arraycopy(b, bIndex, result, num, 1);
                bIndex++;
            }
            else if (bIndex == bLen){
                System.arraycopy(a, aIndex, result, num, 1);
                aIndex++;
            }
            else if (a[aIndex] < b[bIndex]){
                System.arraycopy(a, aIndex, result, num, 1);
                aIndex++;
            }
            else{
                System.arraycopy(b, bIndex, result, num, 1);
                bIndex++;
            }
            num++;       
            this.comparisons++;
        }
        return result;
    }
}",0,1,0,0,0,0,0,0,0
778,"package Sorting;
import java.util.ArrayList;
public class Merge {
	public static <T extends Comparable<T>> void mergeSort(T arr[])
    {
		mergeSortHelper(arr,0,arr.length - 1);
    }
	private static <T extends Comparable<T>> void mergeSortHelper(T arr[], int left, int right)
    {
        if (left < right)
        {
            int middle = (left + right)/2;
            mergeSortHelper(arr, left, middle);
            mergeSortHelper(arr , middle + 1, right);
            merge(arr, left, middle, right);
        }
    }
	private static <T extends Comparable<T>> void merge(T arr[], int left, int middle, int right)
    {
        int first = middle - left + 1;
        int second = right - middle;
        ArrayList<T> L = new ArrayList <T>();
        ArrayList<T> R = new ArrayList <T>();
        for (int i=0; i<first; ++i)
            L.add(i,arr[left + i]);
        for (int j=0; j<second; ++j)
        	R.add(j,arr[middle + j + 1]);
        int i = 0, j = 0;
        int k = left;
        while (i < first && j < second)
        {
            if (L.get(i).compareTo(R.get(j)) <= 0)
            {
                arr[k] = L.get(i);
                i++;
            }
            else
            {
                arr[k] = R.get(j);
                j++;
            }
            k++;
        }
        while (i < first)
        {
            arr[k] = L.get(i);
            i++;
            k++;
        }
        while (j < second)
        {
            arr[k] = R.get(j);
            j++;
            k++;
        }
    }
 }",0,1,0,0,0,0,0,0,0
779,"class MergeSort 
{ 
    public static void merge(int arr[], int l, int m, int r) 
    { 
        int len1 = m - l + 1; 
        int len2 = r - m; 
        int left[] = new int [len1]; 
        int right[] = new int [len2]; 
        for (int i=0; i<len1; ++i)
        {
            left[i] = arr[l + i];
        }
        for (int j=0; j<len2; ++j) 
        {
            right[j] = arr[m + 1+ j];
        }
        int i = 0, j = 0, k = l;
        while (i < len1 && j < len2) 
        { 
            if (left[i] <= right[j]) 
            { 
                arr[k] = left[i]; 
                i++; 
            } 
            else
            { 
                arr[k] = right[j]; 
                j++; 
            } 
            k++; 
        } 
        while (i < len1) 
        { 
            arr[k] = left[i]; 
            i++; 
            k++; 
        } 
        while (j < len2) 
        { 
            arr[k] = right[j]; 
            j++; 
            k++; 
        } 
    } 
    public static void sort(int arr[], int left, int right) 
    { 
        if (left < right) 
        { 
            int m = (left+right)/2; 
            sort(arr, left, m); 
            sort(arr , m+1, right); 
            merge(arr, left, m, right); 
        } 
    } 
    static void output(int array[]) 
    { 
        int n = array.length; 
        for (int i=0; i<n; ++i) 
            System.out.print(array[i] + "" ""); 
        System.out.println(); 
    } 
    public static void main(String args[]) 
    { 
        int array[] = {14, 7, 3, 12, 9, 116, 2}; 
        System.out.println(""Given Array""); 
        output(array); 
        sort(array, 0, array.length-1); 
        System.out.println(""\nSorted array""); 
        output(array); 
    } 
}",0,1,0,0,0,0,0,0,0
780,"package com.sorting;
import java.util.Comparator;
public class Merge {
	private Merge() {
	}
	public static void sort(Comparable[] array) {
		if(array == null)
			throw new NullPointerException();
		Comparable[] aux = new Comparable[array.length];
		sort(array, aux, 0, array.length - 1);
	}
	public static void sort(Object[] array, Comparator com) {
		if(array == null)
			throw new NullPointerException();
		Comparable[] aux = new Comparable[array.length];
		sort(array, aux, com, 0, array.length - 1);
	}
	private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {
		if (hi <= lo)
			return;
		int mid = lo + (hi - lo) / 2;
		sort(a, aux, lo, mid);
		sort(a, aux, mid + 1, hi);
		merge(a, aux, lo, mid, hi);
	}
	private static void sort(Object[] a, Object[] aux, Comparator com, int lo,
			int hi) {
		if (hi <= lo)
			return;
		int mid = lo + (hi - lo) / 2;
		sort(a, aux, com, lo, mid);
		sort(a, aux, com, mid + 1, hi);
		merge(a, aux, com, lo, mid, hi);
	}
	private static void merge(Comparable[] a, Comparable[] aux, int lo,
			int mid, int hi) {
		for (int k = lo; k <= hi; k++) {
			aux[k] = a[k];
		}
		int i = lo, j = mid + 1;
		for (int k = lo; k <= hi; k++) {
			if (i > mid)
				a[k] = aux[j++];
			else if (j > hi)
				a[k] = aux[i++];
			else if (less(aux[j], aux[i]))
				a[k] = aux[j++];
			else
				a[k] = aux[i++];
		}
	}
	private static void merge(Object[] a, Object[] aux, Comparator com, int lo,
			int mid, int hi) {
		for (int k = lo; k <= hi; k++) {
			aux[k] = a[k];
		}
		int i = lo, j = mid + 1;
		for (int k = lo; k <= hi; k++) {
			if (i > mid)
				a[k] = aux[j++];
			else if (j > hi)
				a[k] = aux[i++];
			else if (less(com, aux[j], aux[i]))
				a[k] = aux[j++];
			else
				a[k] = aux[i++];
		}
	}
	private static boolean less(Comparable v, Comparable w) {
		return v.compareTo(w) < 0;
	}
	private static boolean less(Comparator c, Object v, Object w) {
		return c.compare(v, w) < 0;
	}
	private static void exch(Object[] a, int i, int j) {
		Object swap = a[i];
		a[i] = a[j];
		a[j] = swap;
	}
	public static void show(Comparable[] array) {
		int n = array.length;
		for (int i = 0; i < n; i++) {
			System.out.print(array[i] + "","");
		}
	}
}",0,1,0,0,0,0,0,0,0
781,"function merge(srcA, srcB) {
  return srcA.reduce((acc, item, index, itemsA) => [
      ...acc,
      ...(!index
        ? srcB.filter(itemB => itemB <= item)
        : srcB.filter(itemB => (itemB <= item && itemB > itemsA[index - 1]))
      ),
      item], []);
}",0,1,0,0,0,0,0,0,0
782,"__all__ = (""merge_sort"",)
from typing import List, TypeVar
T = TypeVar(""T"")
def merge_sort(
    data: List[T], *, reverse: bool = False, inplace: bool = False
) -> List[T]:
    if not inplace:
        data = data.copy()
    comparison_op: str = ""__lt__"" if reverse else ""__gt__""
    _merge_sort(data, comparison_op)
    return data
def _merge_sort(data: List[T], comparison: str) -> None:
    if len(data) <= 1:
        return
    mid: int = len(data) // 2
    left_part: List[T] = data[:mid]
    right_part: List[T] = data[mid:]
    _merge_sort(left_part, comparison)
    _merge_sort(right_part, comparison)
    right_i = left_i = i = 0
    while True:
        if getattr(left_part[left_i], comparison)(right_part[right_i]):
            data[i] = right_part[right_i]
            right_i += 1
            if right_i == len(right_part):
                data[i + 1 :] = left_part[left_i:]
                break
        else:
            data[i] = left_part[left_i]
            left_i += 1
            if left_i == len(left_part):
                data[i + 1 :] = right_part[right_i:]
                break
        i += 1",0,1,0,0,0,0,0,0,0
783,"def merge_in_place(a, b):
    try:
        aind = a.index(None) - 1
    except ValueError:
        return a
    bind = len(b) - 1
    cind = len(a) - 1
    while bind >= 0:
        if aind >= 0 and a[aind] > b[bind]:
            a[cind] = a[aind]
            aind -= 1
        else:
            a[cind] = b[bind]
            bind -= 1
        cind -= 1",0,1,0,0,0,0,0,0,0
784,"import time
import random
def merge(left, right):
	ret_list = []
 lsize = len(left)
 rsize = len(right)
 i = 0
 j = 0
 while i < lsize and j < rsize:
		if left[i] < right[j]:
			ret_list.append(left[i])
   i += 1
  else:
			ret_list.append(right[j])
   j += 1
 ret_list.extend(left[i:]) if i < lsize else ret_list.extend(right[j:])
 return ret_list
def merge_sort(data):
	size = len(data)
 if size == 1:
		return data
 middle = size // 2
 l_sorted = merge_sort(data[:middle])
 r_sorted = merge_sort(data[middle:])
 return merge(l_sorted, r_sorted)
if __name__ == '__main__':
	lista = [_ for _ in range(1000000)]
 random.shuffle(lista)
 start_time = time.time()
 lista = merge_sort(lista)
 end_time = time.time()
 print(""Time: "", end_time - start_time)",0,1,0,0,0,0,0,0,0
785,"def mergeSort(arr): 
    if len(arr) >1: 
        mid = len(arr)//2 
        L = arr[:mid] 
        R = arr[mid:] 
        mergeSort(L) 
        mergeSort(R) 
        i = j = k = 0
        while i < len(L) and j < len(R): 
            if L[i] < R[j]: 
                arr[k] = L[i] 
                i+=1
            else: 
                arr[k] = R[j] 
                j+=1
            k+=1
        while i < len(L): 
            arr[k] = L[i] 
            i+=1
            k+=1
        while j < len(R): 
            arr[k] = R[j] 
            j+=1
            k+=1
def printList(arr): 
    for i in range(len(arr)):         
        print(arr[i],end="" "") 
    print() 
if __name__ == '__main__': 
    arr = [1, 12, 11, 2, 13, 5, 6, 7]  
    print (""Given array is"", end=""\n"")  
    printList(arr) 
    mergeSort(arr) 
    print(""Sorted array is: "", end=""\n"") 
    printList(arr)",0,1,0,0,0,0,0,0,0
786,"from timeit import default_timer as timer
from heapq import merge
def merge_sort(m):
    if len(m) <= 1:
        return m
    middle = len(m) // 2
    left = m[:middle]
    right = m[middle:]
    left = merge_sort(left)
    right = merge_sort(right)
    return list(merge(left, right))
if __name__ == '__main__':
    time_taken = 0
    x = int(input(""Enter number of trials : ""))
    for n in range(1,x+1):
        with open(""data/reverse.txt"",""r"") as fileobj:
            list_to_sort = list(map(int, fileobj.readlines()))
            start = timer()
            r = merge_sort(list_to_sort, )
            current = timer()-start
            print(f""Running test {n} : {current:.2f} seconds"")
            time_taken += current
    assert sorted(list_to_sort) == r
    time_taken /= x
    print(f""Merge sort: average time = {time_taken:.2f} seconds"")",0,1,0,0,0,0,0,0,0
787,"def merge_sort(num_list):
    if len(num_list)>1:
        mid = len(num_list)//2
        left_half = num_list[:mid]
        right_half = num_list[mid:]  
        merge_sort(left_half)
        merge_sort(right_half)
        i=0
        j=0
        k=0
        while i<len(left_half) and j<len(right_half):
            if left_half[i]<right_half[j]:
                num_list[k]=left_half[i]
                i=i+1
            else:
                num_list[k]=right_half[j]
                j=j+1
            k=k+1
        while i<len(left_half):
            num_list[k]=left_half[i]
            i=i+1
            k=k+1
        while j<len(right_half):
            num_list[k]=right_half[j]
            j=j+1
            k=k+1
    return num_list
print merge_sort([54,26,93,17,77,31,44,55,20])",0,1,0,0,0,0,0,0,0
788,"from __future__ import print_function
def merge_sort(collection):
    def merge(left, right):
        result = []
        while left and right:
            result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))
        return result + left + right
    if len(collection) <= 1:
        return collection
    mid = len(collection) // 2
    return merge(merge_sort(collection[:mid]), merge_sort(collection[mid:]))
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(*merge_sort(unsorted), sep=',')",0,1,0,0,0,0,0,0,0
789,"def mergesort(lst):
    if len(lst)<=1:
        return lst
    else:
        mid = len(lst) // 2
        left = lst[mid:]
        right = lst[:mid]
        mergesort(left)
        mergesort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                lst[k] = left[i]
                i += 1
            else:
                lst[k] = right[j]
                j += 1
            k += 1
        return lst
lst = [7, 5, 3, 1, 5, 9, 8, 4, 6, 2, 10]
print(lst)",0,1,0,0,0,0,0,0,0
790,"def merge(left, right):
    if not len(left) or not len(right):
        return left or right
    result = []
    i, j = 0, 0
    while (len(result) < len(left) + len(right)):
        if left[i] < right[j]:
            result.append(left[i])
            i+= 1
        else:
            result.append(right[j])
            j+= 1
        if i == len(left) or j == len(right):
            result.extend(left[i:] or right[j:])
            break
    return result
def merge_sort(list):
    if len(list) < 2:
        return list
    mid = len(list)//2
    left = merge_sort(list[:mid])
    right = merge_sort(list[mid:])
    return merge(left, right)
a = [3,4,5,1,2,8,3,7,6]
print(merge_sort(a))",0,1,0,0,0,0,0,0,0
791,"def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left, right = merge_sort(arr[:mid]), merge_sort(arr[mid:])
    return merge(left, right, arr.copy())
def merge(left, right, merged):
    left_cursor, right_cursor = 0, 0
    while left_cursor < len(left) and right_cursor < len(right):
        if left[left_cursor] <= right[right_cursor]:
            merged[left_cursor+right_cursor]=left[left_cursor]
            left_cursor += 1
        else:
            merged[left_cursor + right_cursor] = right[right_cursor]
            right_cursor += 1
    for left_cursor in range(left_cursor, len(left)):
        merged[left_cursor + right_cursor] = left[left_cursor]
    for right_cursor in range(right_cursor, len(right)):
        merged[left_cursor + right_cursor] = right[right_cursor]
    return merged",0,1,0,0,0,0,0,0,0
792,"def mergeSort(arr,l,r):
    if(r>l):
        mid = l+(r-l)//2
        mergeSort(arr,l,mid)
        mergeSort(arr,mid+1,r)
        merge(arr,l,mid,r)
def merge(arr,l,m,r):
    l1 = m+1-l
    l2 = r-m
    arr1 = [0 for i in range(l1)]
    arr2 = [0 for i in range(l2)]
    i = 0
    j = 0
    for f in range(l1):
        arr1[f] = arr[l+f]
    for f in range(l2):
        arr2[f] = arr[m+1+f]
    k = l
    while i < l1 and j < l2:
        if(arr1[i]<arr2[j]):
            arr[k] = arr1[i]
            k += 1
            i += 1
        else:
            arr[k] = arr2[j]
            k += 1
            j += 1
    while(i<l1):
        arr[k] = arr1[i]
        i += 1
        k += 1
    while(j<l2):
        arr[k] = arr2[j]
        j += 1
        k += 1
arr = [64, 34, 25, 12, 22, 11, 90]
mergeSort(arr,0,len(arr)-1) 
print(""Sorted array is:"",arr)",0,1,0,0,0,0,0,0,0
793,"public class merge_sort 
{
    static void merge(int arr[], int l, int m, int r) {
        int n1 = m-l+1;
        int n2 = r-m;
        int L[] = new int [n1];
        int R[] = new int [n2];
        for(int i=0; i<n1; i++)
            L[i] = arr[l+i];
        for(int j=0; j<n2; j++)
            R[j] = arr[m+1+j];
        int i = 0, j = 0;
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
    static void MergeSort(int arr[], int l, int r) {
        if (l < r) {
            int m = (l+r)/2;
            MergeSort(arr, l, m);
            MergeSort(arr, m+1, r);
            merge(arr, l, m, r);
        }
    }
    static void printarray(int arr[]){
        for(int i=0; i<arr.length; i++)
            System.out.print(arr[i]+"" "");
    }
    public static void main(String args[]) {
        int arr[] = {10, 54, 63, 6, 420};
        MergeSort(arr, 0, arr.length-1);
        printarray(arr);
    }
}",0,1,0,0,0,0,0,0,0
794,"def merge(array, left, right):
    mid = (left + right) // 2
    l = array[left:mid + 1]
    r = array[mid + 1:right + 1]
    k = left
    while l and r:
        if l[0] < r[0]:
            array[k] = l.pop(0)
        else:
            array[k] = r.pop(0)
        k += 1
    while l:
        array[k] = l.pop(0)
        k += 1
    while r:
        array[k] = r.pop(0)
        k += 1
def merge_sort(array, left, right):
    if left < right:
        mid = (left + right) // 2
        merge_sort(array, left, mid)
        merge_sort(array, mid + 1, right)
        merge(array, left, right)
def main():
    a = [15, 19, 18, 26, 456, 87, 45, -1, 558897984]
    merge_sort(a, 0, len(a) - 1)
    print(a)
if __name__ == '__main__':
    main()",0,1,0,0,0,0,0,0,0
795,"from __future__ import print_function
def merge_sort(collection):
    length = len(collection)
    if length > 1:
        midpoint = length // 2
        left_half = merge_sort(collection[:midpoint])
        right_half = merge_sort(collection[midpoint:])
        i = 0
        j = 0
        k = 0
        left_length = len(left_half)
        right_length = len(right_half)
        while i < left_length and j < right_length:
            if left_half[i] < right_half[j]:
                collection[k] = left_half[i]
                i += 1
            else:
                collection[k] = right_half[j]
                j += 1
            k += 1
        while i < left_length:
            collection[k] = left_half[i]
            i += 1
            k += 1
        while j < right_length:
            collection[k] = right_half[j]
            j += 1
            k += 1
    return collection
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(merge_sort(unsorted))",0,1,0,0,0,0,0,0,0
796,"def merge_sort(array):
    if len(array)==1:
        return
    left_side = array[:len(array)//2]
    right_side = array[len(array)//2:]
    merge_sort(left_side)
    merge_sort(right_side)
    j = 0
    k = 0
    for i in range(len(array)):
        if j >= len(left_side):
            array[i] = right_side[k]
            k+=1
            continue
        if k >= len(right_side):
            array[i] = left_side[j]
            j+=1
            continue
        if left_side[j] <= right_side[k]:
            array[i] = left_side[j]
            j+=1
        else:
            array[i] = right_side[k]
            k+=1
def main():
    count = int(input())
    array = []
    for i in range(count):
        array.append(int(input()))
    merge_sort(array)
    for i in array:
        print(i, end=' ')
if __name__ == ""__main__"":
    main()",0,1,0,0,0,0,0,0,0
797,"def MergeSort(A):
    n=len(A)
    if(n<2):
        return A
    else:
        mid=n//2
        L=[0]*mid
        R=[0]*(n-mid)
        for i in range(0,mid):
            L[i] = A[i]
        for j in range(mid,n):
            R[j-mid] = A[j]
        MergeSort(L)
        MergeSort(R)
        Merge(L,R,A)
def Merge(L,R,A):
    nL=len(L)
    nR=len(R)
    i=0
    j=0
    k=0
    while(i<nL and j<nR):
        if(L[i]<=R[j]):
            A[k]=L[i]
            i=i+1
        else:
            A[k]=R[j]
            j=j+1
        k=k+1
    while(i<nL):
        A[k]=L[i]
        i=i+1
        k=k+1
    while(j<nR):
        A[k]=R[j]
        j=j+1
        k=k+1
if __name__==""__main__"":
    A=[]
    print(""Enter the elements in the array: "")
    A=list(map(int,input().split("" "")))
    print(""Sorted Array: "",end="""")
    MergeSort(A)
    for i in range(0,len(A)):
        print(A[i],end="" "")",0,1,0,0,0,0,0,0,0
798,"def mergeSort(alist):
    print(""Splitting "",alist)
    if len(alist)>1:
        mid = len(alist)//2
        lefthalf = alist[:mid]
        righthalf = alist[mid:]
        mergeSort(lefthalf)
        mergeSort(righthalf)
        i=0
        j=0
        k=0
        while i < len(lefthalf) and j < len(righthalf):
            if lefthalf[i] < righthalf[j]:
                alist[k]=lefthalf[i]
                i=i+1
            else:
                alist[k]=righthalf[j]
                j=j+1
            k=k+1
        while i < len(lefthalf):
            alist[k]=lefthalf[i]
            i=i+1
            k=k+1
        while j < len(righthalf):
            alist[k]=righthalf[j]
            j=j+1
            k=k+1
    print(""Merging "",alist)
alist = [54,26,93,17,77,31,44,55,20]
mergeSort(alist)
print(alist)",0,1,0,0,0,0,0,0,0
799,"package part2;
public class Merge_Sort {
	public static Comparable[] Merge_Sort(Comparable[]a, int first, int last) {
		if(first < last) {
			int mid = (first+last)/2;
			Merge_Sort(a,first,mid);
			Merge_Sort(a,mid+1,last);
			Merge(a,first,mid,last);
			for(Comparable n: a) {
				System.out.print(n +"" "");
			}
			System.out.println();
		}
		return a;
	} 
	private static void Merge(Comparable[]a, int first, int mid, int last) {
		Comparable[] temp = new Comparable[a.length];
		int first1 = first;
		int last1 = mid;
		int first2 = mid+1;
		int last2 = last;
		int index = first1;
		for(; first1<=last1 && first2<=last2; index++) {
			if(less(a[first1],a[first2])) {
				temp[index] = a[first1];
				first1++;
			}else {
				temp[index] = a[first2];
				first2++;
			}
		}
		while(first1 <= last1) {
			temp[index] = a[first1];
			index++;
			first1++;
		}
		while(first2 <= last2) {
			temp[index] = a[first2];
			index++;
			first2++;
		}
		for(int i=first; i<=last; i++) {
			a[i] = temp[i];
		}
	}
	private static boolean less(Comparable a, Comparable b) {
		if(a.compareTo(b) < 0) {
			return true;
		}
		return false;
	}
}",0,1,0,0,0,0,0,0,0
800,"import sort_tools
import copy
def merge(data, low, middle, high):
    data_a = []
    data_b = []
    len_a = middle - low + 1
    len_b = high - middle
    i = 0   
    j = 0   
    k = low 
    for idx in range(middle - low + 1):
        data_a.append(data[low + idx])
    for idx in range(high - middle):
        data_b.append(data[middle + idx + 1])
    while i < len_a and j < len_b:
        a = data[i]
        b = data[j]
        if a < b:
            data[k] = a
            i += 1
        else:
            data[k] = b
            j += 1
        k += 1
    while i < len_a:
        data[k] = data_a[i]
        i += 1
        k += 1
    while j < len_b:
        data[k] = data_b[j]
        j += 1
        k += 1
def merge_sort(data, low, high):
    if low < high:
        middle = (high - low) // 2 + low
        merge_sort(data, low, middle)
        merge_sort(data, middle + 1, high)
        merge(data, low, middle, high)
@sort_tools.timeit('merge')
def sort(data):
    merge_sort(data, 0, len(data) - 1)
def main():
    data = sort_tools.build_data_set(5)
    unsorted = copy.deepcopy(data)
    sort(unsorted)
if __name__ == ""__main__"":
    main()",0,1,0,0,0,0,0,0,0
801,"def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]
        merge_sort(left)
        merge_sort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            arr[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            arr[k] = right[j]
            j += 1
            k += 1
if __name__ == ""__main__"":
    array = [9, 8, 3, 4, 6, 5]
    expectation = sorted(array)
    merge_sort(array)
    print(array)
    assert array == expectation",0,1,0,0,0,0,0,0,0
802,"def sort(a):
    n = len(a)
    b = [0 for i in range(n)]
    mergesort_topdown(a, b, n)
def mergesort_topdown(a, b, n):
    copy_array(a, 0, n, b)
    split_merge_topdown(b, 0, n, a)
def split_merge_topdown(b, begin, end, a):
    if end - begin < 2:
        return
    middle = (end + begin) // 2
    split_merge_topdown(a, begin, middle, b)
    split_merge_topdown(a, middle, end, b)
    merge(b, begin, middle, end, a)
def merge(a, left, right, end, b):
    i, j = left, right
    for k in range(left, end):
        if i < right and (j >= end or a[i] <= a[j]):
            b[k] = a[i]
            i += 1
        else:
            b[k] = a[j]
            j += 1
def copy_array(a, begin, end, b):
    for k in range(begin, end):
        b[k] = a[k]",0,1,0,0,0,0,0,0,0
803,"def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        l = arr[:mid]
        r = arr[mid:]
        l = merge_sort(l)
        r = merge_sort(r)
        i = j = k = 0
        while i < len(l) and j < len(r):
            if l[i] < r[j]:
                arr[k] = l[i]
                i += 1
            else:
                arr[k] = r[j]
                j += 1
            k += 1
        while i < len(l):
            arr[k] = l[i]
            i += 1
            k += 1
        while j < len(r):
            arr[k] = r[j]
            j += 1
            k += 1
    return arr",0,1,0,0,0,0,0,0,0
804,"def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    left = []
    right = []
    for i in range(len(arr)):
        if i < len(arr)//2:
            left.append(arr[i])
        else:
            right.append(arr[i])
    left = merge_sort(left)
    right = merge_sort(right)
    return merge(left, right)
def merge(left, right):
    result = []
    l = 0
    r = 0
    while l < len(left) and r < len(right):
        if left[l] <= right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    while l < len(left):
        result.append(left[l])
        l += 1
    while r < len(right):
        result.append(right[r])
        r += 1
    return result",0,1,0,0,0,0,0,0,0
805,"from strategy import Order, BadOrderError
import sys
__author__ = ""Pablo Acereda""
__copyright__ = ""Copyright 2020""
__credits__ = [ ""Pablo Acereda"" ]
__license__ = ""Apache License 2.0""
__version__ = ""1.0""
__maintainer__ = ""Pablo Acereda""
__email__ = ""p.aceredag@gmail.com""
def sort(array:list, order: Order=Order.ASC) -> list:
    if (order not in [Order.ASC, Order.DESC]):
        raise BadOrderError(""Not Valid Ordering Preference"")
    return _merge_sort(array, order)
def _merge_sort(array, order):
    if (len(array) <= 1): 
        return array
    middle = len(array) // 2
    L = array[      :middle]    
    R = array[middle:      ]    
    L = _merge_sort(L, order)       
    R = _merge_sort(R, order)       
    return _merge(L, R, order)
def _merge(arr1, arr2, order):
    i = j = 0
    sorted_arr = []
    while i < len(arr1) and j < len(arr2):
        if (order == Order.ASC):     
            if (arr1[i] < arr2[j]):
                sorted_arr.append(arr1[i])
                i += 1
            else:
                sorted_arr.append(arr2[j])
                j += 1
        elif (order == Order.DESC):  
            if (arr1[i] > arr2[j]):
                sorted_arr.append(arr1[i])
                i += 1
            else:
                sorted_arr.append(arr2[j])
                j += 1
    while i < len(arr1):
        sorted_arr.append(arr1[i])
        i += 1
    while j < len(arr2):
        sorted_arr.append(arr2[j])
        j += 1
    return sorted_arr",0,1,0,0,0,0,0,0,0
806,"package Sorting;
public class Merge_Sort {
    void Merge_Sort(int [] givenArr,int low,int high){
        if(low<high){
            int mid = (low+high)/2;
            Merge_Sort(givenArr,low,mid);
            Merge_Sort(givenArr,mid+1,high);
            Merge(givenArr,low,mid,high);
        }
    }
    private void Merge(int[] givenArr, int low,int mid, int high) {
        int i=low;
        int j=mid+1;
        int k=0;
        int [] arr = new int[high+1-low] ;
        while(i<mid+1 && j<high+1){
            if(givenArr[i]>givenArr[j]){
                arr[k]=givenArr[j];
                j++;
            }
            else {
                arr[k]=givenArr[i];
                i++;
            }
            k++;
        }
        while(i<mid+1){
            arr[k]=givenArr[i];
            i++;
            k++;
        }
        while(j<high+1){
            arr[k]=givenArr[j];
            j++;
            k++;
        }
        for(int p = 0;p<high-low+1;p++) {
            givenArr[p+low] = arr[p];
        }
    }
    public static void main(String[] args) {
        int[] given_arr = new int[]{10,2,8,1,4,6,5,7,9};
        Merge_Sort merge_sort = new Merge_Sort();
        merge_sort.Merge_Sort(given_arr,0,given_arr.length-1);
        merge_sort.printArr(given_arr);
    }
    private void printArr(int[] given_arr) {
        for(int i=0;i<given_arr.length;i++){
            System.out.print(given_arr[i]+"" "");
        }
    }
}",0,1,0,0,0,0,0,0,0
807,"function merge_sort(left_part,right_part) 
{
	var i = 0;
	var j = 0;
	var results = [];
	while (i < left_part.length || j < right_part.length) {
		if (i === left_part.length) {
			results.push(right_part[j]);
			j++;
		} 
      else if (j === right_part.length || left_part[i] <= right_part[j]) {
			results.push(left_part[i]);
			i++;
		} else {
			results.push(right_part[j]);
			j++;
		}
	}
	return results;
}
console.log(merge_sort([1,3,4], [3,7,9]));",0,1,0,0,0,0,0,0,0
808,"def merge_sort(values):
    if len(values) <= 1:
        return values
    middle_index = len(values) // 2
    left_values = merge_sort(values[:middle_index])
    right_values = merge_sort(values[middle_index:])
    sorted_values = []
    left_index = 0
    right_index = 0
    while left_index < len(left_values) and right_index < len(right_values):
        if left_values[left_index] < right_values[right_index]:
            sorted_values.append(left_values[left_index])
            left_index += 1
        else:
            sorted_values.append(right_values[right_index])
            right_index += 1
    sorted_values += left_values[left_index:]
    sorted_values += right_values[right_index:]
    return sorted_values
numbers = [3, 21, 7, 1, 9, 17, 14, 2, 5, 10, 6]
print(merge_sort(numbers))",0,1,0,0,0,0,0,0,0
809,"def merge_sort(LIST):
    start = []
    end = []
    while len(LIST) > 1:
        a = min(LIST)
        b = max(LIST)
        start.append(a)
        end.append(b)
        LIST.remove(a)
        LIST.remove(b)
    if LIST: start.append(LIST[0])
    end.reverse()
    return (start + end)",0,1,0,0,0,0,0,0,0
810,"from __future__ import print_function
def merge_sort(collection):
    start, end = [], []
    while len(collection) > 1:
        min_one, max_one = min(collection), max(collection)
        start.append(min_one)
        end.append(max_one)
        collection.remove(min_one)
        collection.remove(max_one)
    end.reverse()
    return start + collection + end
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(*merge_sort(unsorted), sep=',')",0,1,0,0,0,0,0,0,0
811,"package sort.merge;
import sort.Sort;
public class MergeBU extends Sort {
    private static Comparable[] aux;  
    public void sortMethod(Comparable[] a) {
        for (int sz = 1; sz < a.length; sz = sz + sz)  
            for (int lo = 0; lo < a.length - sz; lo += sz + sz)  
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, a.length - 1));
    }
    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        new MergeBU().sortMethod(a);
    }
    private static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo, j = mid + 1;
        for (int k = lo; k <= hi; k++)
            aux[k] = a[k];
        for (int k = lo; k <= hi; k++) {
            if (i > mid) a[k] = aux[j++];  
            else if (j > hi) a[k] = aux[i++];  
            else if (less(aux[j], aux[i])) a[k] = aux[j++];  
            else a[k] = aux[i++];  
        }
    }
}",0,1,0,0,0,0,0,0,0
812,"class MergeSort {
    void merge(int arr[], int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int Left[] = new int[n1];
        int Right[] = new int[n2];
        for (int i = 0; i < n1; ++i)
            Left[i] = arr[left + i];
        for (int j = 0; j < n2; ++j)
            Right[j] = arr[mid + 1 + j];
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (Left[i] <= Right[j]) {
                arr[k] = Left[i];
                i++;
            } else {
                arr[k] = Right[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            arr[k] = Left[i];
            i++;
            k++;
        }
        while (j < n2) {
            arr[k] = Right[j];
            j++;
            k++;
        }
    }
    void sort(int arr[], int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            sort(arr, left, mid);
            sort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }
    static void printArray(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    public static void main(String args[]) {
        int arr[] = { 90, 30, 5, 3, 15, 1, 2 };
        MergeSort mergedArr = new MergeSort();
        mergedArr.sort(arr, 0, arr.length - 1);
        System.out.println(""Sorted:"");
        printArray(arr);
    }
}",0,1,0,0,0,0,0,0,0
813,"'use strict';
const merge = (arr = [], start, middle, end) => {
  let n1 = middle - start + 1;
  let n2 = end - middle;
  let Left  = [];
  let Right = [];
  for (let i = 0; i < n1; i++) {
    Left[i] = arr[start + i];
  }
  for (let j = 0; j < n2; j++) {
    Right[j] = arr[middle + 1 + j];
  }
  let i = 0;      
  let j = 0;      
  let k = start;  
  while (i < n1 && j < n2) {
    if (Left[i] <= Right[j]) {
      arr[k] = Left[i];
      i++;
    } else {
      arr[k] = Right[j];
      j++;
    }
    k++;
  }
  while (i < n1) {
    arr[k] = Left[i];
    i++;
    k++;
  }
  while (j < n2) {
    arr[k] = Right[j];
    j++;
    k++;
  }
};
const mergeSort = (arr = [], start, end) => {
  if (start < end) {
    let middle = Math.floor((start + end) / 2);
    mergeSort(arr, start, middle);
    mergeSort(arr, middle + 1, end);
    merge(arr, start, middle, end);
  }
};
module.exports = mergeSort;",0,1,0,0,0,0,0,0,0
814,"from time import sleep
from typing import List
from tkinter import Tk
from animated import Animator
class MergeSort(Animator):
    def merge(self, array: List[int], start: int, mid: int, end: int) -> None:
        start2 = mid + 1
        if array[mid] <= array[start2]:
            return
        while start <= mid and start2 <= end:
            self.render(array, cur=(start, start2))
            sleep(0.01)
            if array[start] <= array[start2]:
                start += 1
            else:
                value = array[start2]
                index = start2
                while index != start:
                    array[index] = array[index - 1]
                    index -= 1
                array[start] = value
                start += 1
                mid += 1
                start2 += 1
    def sort(self, array: List[int], *args: List[int]) -> None:
        if len(args) == 2:
            left, right = args
        else:
            left, right = 0, len(array) - 1
        if right > left:
            half = left + (right - left) // 2  
            self.sort(array, left, half)
            self.render(array, cur=(left, half))
            sleep(0.01)
            self.sort(array, half + 1, right)
            self.render(array, cur=(half + 1, right))
            sleep(0.01)
            self.merge(array, left, half, right)
            self.render(array, cur=(left, half + 1, right))
            sleep(0.01)
def main() -> int:
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    shuffledArray = randomSequence(0, 225)
    root = Tk()
    sorter = MergeSort(
        root,
        background=""black"",
        width=root.winfo_screenwidth(),
        height=root.winfo_screenheight(),
    )
    sorter.pack()
    sorter.sort(shuffledArray)
    sorter.finished()
    return 0",0,1,0,0,0,0,0,0,0
815,"package src.algorithms;
import java.util.Arrays;
import src.strategy.Order;
public class MergeSort<T extends Comparable<T>> extends SortingAlgorithm<T> {
	@Override
	@SuppressWarnings(""hiding"")
	public <T extends Comparable<T>> T[] sort(T[] elements, Order order) {
		return this.mergesort(elements, order);
	}
	@SuppressWarnings(""hiding"")
	private <T extends Comparable<T>> T[] mergesort(T[] elements, Order order) {
		if (elements.length <= 1) {
			return elements;
		}
		int middlePos = elements.length / 2;
		T[] left  = Arrays.copyOfRange(elements, 0,         middlePos);
		T[] right = Arrays.copyOfRange(elements, middlePos, elements.length);
		left  = this.mergesort(left,  order);
		right = this.mergesort(right, order);
		return this.merge(elements, left, right, order);
	}
	@SuppressWarnings(""hiding"")
	private <T extends Comparable<T>> T[] merge(T[] elements, T[] arr1, T[] arr2, Order order) {
		int i = 0;
		int j = 0;
		int k = 0;
		int n = arr1.length + arr2.length;
		T[] sortedArray = Arrays.copyOf(elements, n);
		while (i < arr1.length && j < arr2.length) {
			if        (order == Order.ASC) {   
				if (arr1[i].compareTo(arr2[j]) <= 0) {
					sortedArray[k] = arr1[i];
					i++;
				} else {
					sortedArray[k] = arr2[j];
					j++;
				}
			} else if (order == Order.DESC) {  
				if (arr1[i].compareTo(arr2[j]) >= 0) {
					sortedArray[k] = arr1[i];
					i++;
				} else {
					sortedArray[k] = arr2[j];
					j++;
				}
			}
			k++;
		}
		while (i < arr1.length) {
			sortedArray[k] = arr1[i];
			i++;
			k++;
		}
		while (j < arr2.length) {
			sortedArray[k] = arr2[j];
			j++;
			k++;
		}
		return sortedArray;
	}
}",0,1,0,0,0,0,0,0,0
816,"function mergeSort (arrData) {
  'use strict'
  const dataMax = arrData.length
  function merge (arrA, arrB) {
    let arrC = []
    while (arrA.length && arrB.length) {
      if (arrA[0] > arrB[0]) {
        arrC.push(arrB.shift())
      } else {
        arrC.push(arrA.shift())
      }
    }
    return arrC.concat(arrA).concat(arrB)
  }
  console.log('Initial:', arrData.join(), `[Count:${dataMax}]`)
  if (dataMax > 1) {
    let indexA = Math.floor(dataMax / 2)
    let indexB = arrData.slice(0, indexA)
    let indexC = arrData.slice(indexA)
    console.log('Final:', arrData.join())
    return merge(mergeSort(indexB), mergeSort(indexC))
  } else {
    console.log('Cycle:', arrData.join())
    return arrData
  }
}",0,1,0,0,0,0,0,0,0
817,"def _mergesort(array, start, end):
    mid = (start + end)/2
    if start < end:
        _mergesort(array, start, mid)
        _mergesort(array, mid+1, end)
    elif start == end: return
    L = start; R = mid+1
    tmp_array = []
    while ( L <= mid and R <= end):
        if (array[L] < array[R]):
            tmp_array.append(array[L])
            L += 1
        else:
            tmp_array.append(array[R])
            R += 1
    if L <= mid:
        tmp_array += array[L:]
    else:
        tmp_array += array[R:]
    i = 0;
    while (start <= end):
        array[start] = tmp_array[i]
        start += 1; i += 1;
def mergesort(array):
    _mergesort(array, 0, len(array)-1)
if __name__ == ""__main__"":
    array = [17, 9, 13, 8, 7, 7, -5, 6, 11, 3, 4, 1, 2]
    mergesort(array);
    print array",0,1,0,0,0,0,0,0,0
818,"package javaSorting;
public class MergeSort {
	private static void merge(int data[], int left_a, int middle, int right_b) {
		int lsize = (middle - left_a) + 1;
		int rsize = right_b - middle;
		int left[] = new int[lsize];
		int right[] = new int[rsize];
		for (int i = 0; i < lsize; i++) {
			left[i] = data[left_a + i];
		}
		for (int i = 0; i < rsize; i++) {
			right[i] = data[middle + 1 + i];
		}
		int i = 0, j = 0, br = left_a;
		while (i < lsize && j < rsize) {
			if (left[i] < right[j]) {
				data[br] = left[i];
				i++;
			} else {
				data[br] = right[j];
				j++;
			}
			br++;
		}
		if (i < lsize) {
			for (int k = i; k < lsize; k++) {
				data[br] = left[k];
				br++;
			}
		} else {
			for (int k = j; k < rsize; k++) {
				data[br] = right[k];
				br++;
			}
		}
		left = null;
		right = null;
	}
	public static void sort(int data[], int left, int right) {
		if (left < right) {
			int middle = left + (right - left) / 2;
			sort(data, left, middle);
			sort(data, middle + 1, right);
			merge(data, left, middle, right);
		}
		return;
	}
	private static void printSortedArray(int data[]) {
		for (int i = 0; i < data.length; i++) {
			System.out.println(data[i]);
		}
	}
	public static void main(String[] args) {
		int SIZE = 1000;
		int[] data = new int[SIZE];
		for (int i = 0; i < SIZE; i++) {
			data[i] = i;
		}
		Shuffle.shuffleData(data);
		long start = System.currentTimeMillis();
		sort(data, 0, SIZE - 1);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		printSortedArray(data);
		System.out.println(elapsed);
	}
}",0,1,0,0,0,0,0,0,0
819,"const mergeSort = (arr) => {
    if (arr.length <= 1) {
        return arr;
    }
    let midIdx = Math.floor(arr.length / 2);
    let left = arr.slice(0, midIdx);
    let right = arr.slice(midIdx);
    let leftSorted = mergeSort(left);
    let rightSorted = mergeSort(right);
    return merge(leftSorted, rightSorted);
};
const merge = (arr1, arr2) => {
    let merged = [];
    while (arr1.length && arr2.length) {
        if (arr1[0] < arr2[0]) {
            merged.push(arr1.shift());
        } else {
            merged.push(arr2.shift());
        }
    }
    return [...merged, ...arr1, ...arr2];
};",0,1,0,0,0,0,0,0,0
820,"def mergeSort(arr,low,high) :
	if low < high :
		mid = (low+high)//2
  mergeSort(arr,low,mid)
  mergeSort(arr,mid+1,high)
  _merge(arr,low,mid,high)
 return arr
def _merge(arr,low,mid,high):
	len1 = mid-low + 1
 len2 = high-mid
 list1 = [0] * (len1) 
 list2 = [0] * (len2) 
 for i in range(0 ,len1): 
		list1[i] = arr[low + i] 
 for j in range(0 ,len2): 
		list2[j] = arr[mid + 1 + j] 
 index = low
 i,j=0,0
 while (i<len1 and j<len2):
		if (list1[i] <= list2[j]):
			arr[index]=list1[i]
   i=i+1
  else :
			arr[index]=list2[j]
   j=j+1
  index=index+1
 while i<len1 :
		arr[index] = list1[i]
  index=index+1
  i=i+1
 while j<len2 :
		arr[index] = list2[j]
  index=index+1
  j=j+1
 return arr
def _mergeInPlace(arr,low,mid,high):
	start1,start2=low,mid+1
 while (start1<=mid and start2<=high):
		if (arr[start1]<=arr[start2] ):
			start1=start1+1
  else :
			val = arr[start2]
   arr[start1+1:start2+1]=arr[start1:start2]
   arr[start1] = val
   start1= start1+1
   start2 = start2+1
   mid = mid+1
 return arr",0,1,0,0,0,0,0,0,0
821,"import java.util.Scanner;
public class MergeSort {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements : "");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter "" + n + "" elements :"");
        for (int i = 0; i < n; i++)
            arr[i] = sc.nextInt();
        mergeSort(arr, 0, n - 1);
        System.out.println(""\nThe sorted array : ;"");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    static void mergeSort(int arr[], int lower, int upper) {
        if (lower >= upper)
            return;
        int m = (lower + upper) / 2;
        mergeSort(arr, lower, m);
        mergeSort(arr, m + 1, upper);
        merge(arr, lower, upper);
    }
    private static void merge(int arr[], int lower, int upper) {
        int m = (lower + upper) / 2;
        int a[] = new int[m - lower + 1];
        int b[] = new int[upper - m];
        int i, k = 0, k1 = 0, k2 = 0;
        for (i = lower; i <= m; i++, k++)
            a[k] = arr[i];
        k = 0;
        for (; i <= upper; i++, k++)
            b[k] = arr[i];
        for (i = lower; i <= upper && k1 < m - lower + 1 && k2 < upper - m; i++) {
            if (a[k1] < b[k2]) {
                arr[i] = a[k1];
                k1++;
            } else {
                arr[i] = b[k2];
                k2++;
            }
        }
        for (; k1 < m - lower + 1; k1++)
            arr[i++] = a[k1];
        for (; k2 < upper - m; k2++)
            arr[i++] = b[k2];
    }
}",0,1,0,0,0,0,0,0,0
822,"function mergeSort (arr) {
    if (arr.length < 2) {
      return arr;
    }
    var mid = Math.floor(arr.length / 2);
    var subLeft = mergeSort(arr.slice(0, mid));
    var subRight = mergeSort(arr.slice(mid));
    return merge(subLeft, subRight);
}
function merge (node1, node2) {
    var result = [];
    while (node1.length > 0 && node2.length > 0)
        result.push(node1[0] < node2[0] ? node1.shift() : node2.shift());
    return result.concat(node1.length ? node1 : node2);
}",0,1,0,0,0,0,0,0,0
823,,0,1,0,0,0,0,0,0,0
824,"public class MergeSort
{
    public MergeSort(int[] data)
    {
        sort(data, 0, data.length);
    }
    public int[] sort(int[] A, int i, int j)
    {
        if ((j-i) > 1)
        {
            int mid = (int) Math.floor((j-i)/2.0);
            int[] B = sort(A, 0, mid-1);
            int[] C = sort(B, mid, j);
            merge(B, C, A);
        }
        return A;
    }
    public void merge(int[] B, int[] C, int[] A)
    {
        int i = 0;
        int j = 0;
        int k = 0;
        while(i < B.length && j < C.length)
        {
            if(B[i] < C[j])
            {
                A[k] = B[i];
                i++;
            }
            else 
            {
                A[k] = C[j];
                j++;
            }
            k++;
        }
        if(i < B.length)
        {
            for(int p=i; p<B.length; p++)
            {
                A[k] = B[p];
                k++;
                p++;
            }
        }
        else
        {
            for(int q=j; q<C.length; q++)
            {
                A[k] = C[q];
                k++;
                q++;
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
825,"function merge(list1, list2) {
  var results = [];
  while(list1.length && list2.length) {
    if (list1[0] <= list2[0]) {
      results.push(list1.shift());
    } else {
      results.push(list2.shift());
    }
  }
  return results.concat(list1, list2);
}
function mergeSort(list) {
  if (list.length < 2) return list;
  var listHalf = Math.floor(list.length/2);
  var subList1 = list.slice(0, listHalf);
  var subList2 = list.slice(listHalf, list.length);
  return merge(mergeSort(subList1), mergeSort(subList2));
}
var unsortedArray = [10, 5, 3, 8, 2, 6, 4, 7, 9, 1];
var sortedArray = mergeSort(unsortedArray);
console.log('Before:', unsortedArray, 'After:', sortedArray);",0,1,0,0,0,0,0,0,0
826,"import random
from time import time
def createList(n):
    alist = []
    for i in range(n, 0, -1):
        alist.append(random.randint(0, n))
    return alist
def mergeSort(alist):
    if len(alist)>1:
        mid = len(alist)//2
        lefthalf = alist[:mid]
        righthalf = alist[mid:]
        mergeSort(lefthalf)
        mergeSort(righthalf)
        i=0
        j=0
        k=0
        while i < len(lefthalf) and j < len(righthalf):
            if lefthalf[i] < righthalf[j]:
                alist[k]=lefthalf[i]
                i=i+1
            else:
                alist[k]=righthalf[j]
                j=j+1
            k=k+1
        while i < len(lefthalf):
            alist[k]=lefthalf[i]
            i=i+1
            k=k+1
        while j < len(righthalf):
            alist[k]=righthalf[j]
            j=j+1
            k=k+1
def merge_2(seq):
    listOfLists = []
    for i in range(len(seq)):
        temp = [seq[i]]
        listOfLists.append(temp)
    while (len(listOfLists) != 1):
        j = 0
        while (j < len(listOfLists) - 1):
            tempList = merge(listOfLists[j], listOfLists[j + 1])
            listOfLists[j] = tempList
            del listOfLists[j + 1]
            j = j + 1
def merge(a, b):
    newList = []
    a1, a2 = 0, 0
    while ((a1 < len(a)) and (a2 < len(b))):
        if (a[a1] > b[a2]):
            newList.append(b[a2])
            a2 = a2 + 1
        elif (a[a1] < b[a2]):
            newList.append(a[a1])
            a1 = a1 + 1
        elif (a[a1] == b[a2]):
            newList.append(a[a1])
            newList.append(b[a2])
            a1, a2 = a1 + 1, a2 + 1
    if (a1 < len(a)):
        for f in range(a1, len(a)):
            newList.append(a[f])
    elif (a2 < len(b)):
        for k in range(a2, len(b)):
            newList.append(b[k])
    return newList
def performace(lenList):
    seqOri = createList(lenList)
    seq1 = list(seqOri)
    seq2 = list(seqOri)
    begin = time()
    mergeSort(seq1)
    end = time()
    diff = (end - begin) * 1000
    print(""Recursive: "" + str(diff))
    print(""seq1: "" + str(seq1))
    print("""")
    begin = time()
    merge_2(seq2)
    end = time()
    diff = (end - begin) * 1000
    print(""interative: "" + str(diff))
    print(""seq2: "" + str(seq2))
    print(""---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"")
if __name__ == '__main__':
    performace(10)",0,1,0,0,0,0,0,0,0
827,"import java.util.Arrays;
public class MergeSort {
	private int [] input;
	public MergeSort(int [] input) {
		this.input = input;
	}
	private int [] merge(int left [], int right[]){  
		int [] ret = new int [right.length + left.length];
		int j = 0;
		int right_index = 0;
		int left_index = 0;
		while (j < ret.length){
			if (right_index < right.length && left_index < left.length){
				if (right[right_index] < left[left_index]){
					ret[j] = right[right_index];
					right_index++;
				}else {
					ret[j] = left[left_index];
					left_index++;
				}
			}else if (right_index < right.length){
				ret[j] = right[right_index];
				right_index++;
			}else {
				ret[j] = left[left_index];
				left_index++;
			}
			j++;
		}
		return ret;
	}
	public  int [] sort(){
		if (this.input == null)
			return null;
		return merge_sort(this.input, this.input.length);
	}
	private int [] merge_sort(int [] input, int p){
		if (input.length == 1){  
			return input;
		}
		return merge(  
			merge_sort(copyofrange(input, 0, p/2), p/2),
			merge_sort(copyofrange(input, p/2, input.length), input.length - p/2)
		);
	}
	private int [] copyofrange(int [] input, int i, int j){  
		int range [] = new int [j-i]; 
		for (int k = i; k < j; k++) {
			range [k-i] = input[k];
		}
		return range;
	}
	public static void main(String[] args) {
		int array[] = {9,1,0,4,2,-1,5,2, 200, 99, 45, -100};
		MergeSort mergesort = new MergeSort(array);
		System.out.println(""Unsorted Array -> ""+ Arrays.toString(array));;
		System.out.println(""MergeSort -> ""+ Arrays.toString(mergesort.sort()));  
	}
}",0,1,0,0,0,0,0,0,0
828,"function mergeSort (items) {
  if (items.length < 2) {
    return items
  }
  let middle = Math.floor(items.length / 2)
  let left = items.slice(0, middle)
  let right = items.slice(middle)
  let params = _merge(mergeSort(left), mergeSort(right))
  params.unshift(0, items.length)
  items.splice(...params)
  return items
  function _merge (left, right) {
    const result = []
    let il = 0
    let ir = 0
    while (il < left.length && ir < right.length) {
      result.push(left[il] < right[ir] ? left[il++] : right[ir++])
    }
    return result.concat(left.slice(il)).concat(right.slice(ir))
  }
}",0,1,0,0,0,0,0,0,0
829,"class MergeSort:
    def sort(A):
        def merge(B, C, A):
            p = len(B)
            q = len(C)
            i = j = k = 0
            while ((i < p) and (j < q)):
                if(B[i] <= C[j]):
                    A[k] = B[i]
                    i = i + 1
                else:
                    A[k] = C[j]
                    j = j + 1
                k = k + 1
            if(i == p):
                A[k:(p+q)] = C[j:q]
            else:
                A[k:(p+q)] = B[i:p]
        a_len = len(A)
        if (a_len) > 1:
            B = A[0:int(len(A)/2)]
            C = A[int(len(A)/2):a_len]
            MergeSort.sort(B)
            MergeSort.sort(C)
            merge(B,C,A)
        return A",0,1,0,0,0,0,0,0,0
830,"package org.neeraj.algorithms.sorting;
public class MergeSort implements Sorter
{
	static Comparable [] arr;
    public void sort(Comparable[] array)
    {
    	this.arr=array;
    	mergeSort(0, arr.length-1);
    	array=this.arr;
    }
    private void mergeSort( int p, int r)
    {
		if (p < r) {
		    int q = (p + r) / 2;
		    mergeSort( p, q);
		    mergeSort( q+1, r);
		    merge(p, q, r);
		}
    }
    private void merge( int p, int q, int r)
    {
	int n1 = q - p + 1;
	int n2 = r - q;
	Comparable[] left = new Comparable[n1 + 1];
	Comparable[] right = new Comparable[n2 + 1];
	for (int i = 0; i < n1; i++)
	    left[i] = arr[p + i];
	for (int j = 0; j < n2; j++)
	    right[j] = arr[q + j + 1];
	left[n1] = null;	 
	right[n2] = null;
	for (int i = 0, j = 0, k = p; k <= r; k++) {
	    if (compare(left[i], right[j]) <= 0)
		arr[k] = left[i++];
	    else
		arr[k] = right[j++];
	}
    }
    private int compare(Comparable x, Comparable y)
    {
	if (x == null) {
	    if (y == null)
		return 0;	    
	    else
		return 1;	    
	}
	else if (y == null)
	    return -1;		    
	else
	    return x.compareTo(y);  
    }
}",0,1,0,0,0,0,0,0,0
831,"def mergeSort(list):
    length = len(list)
    if length <= 1:
        return list
    else:
        middleIndex = int(length / 2)
        leftList = list[0:middleIndex]
        rightList = list[middleIndex:]
        mergeSort(leftList)
        mergeSort(rightList)
        i = j = k = 0
        while len(leftList) > i and len(rightList) > j:
            if leftList[i] < rightList[j]:
                list[k] = leftList[i]
                i += 1
            else:
                list[k] = rightList[j]
                j += 1
            k += 1
        while i < len(leftList):
            list[k] = leftList[i]
            i += 1
            k += 1
        while j < len(rightList):
            list[k] = rightList[j]
            j += 1
            k += 1
        return list
myList = [67,34,3,56,24,77,23,89,56,35,65,764]
print(""List\n"", myList)
print(""Sorted List\n"", mergeSort(myList))",0,1,0,0,0,0,0,0,0
832,"public class MergeSort {
	public static void merge(int arr[], int l, int m, int r) {
		int leftSize = m - l + 1;
		int rightSize = r - m;
		int leftArray[] = new int[leftSize];
		int rightArray[] = new int[rightSize];
		for (int i = 0; i < leftSize; ++i) {
			leftArray[i] = arr[l + i];
		}
		for (int j = 0; j < rightSize; ++j) {
			rightArray[j] = arr[m + 1 + j];
		}
		int firstIndex = 0, secondIndex = 0;
		int k = l;
		while (firstIndex < leftSize && secondIndex < rightSize) {
			if (leftArray[firstIndex] <= rightArray[secondIndex]) {
				arr[k] = leftArray[firstIndex];
				firstIndex++;
			} else {
				arr[k] = rightArray[secondIndex];
				secondIndex++;
			}
			k++;
		}
		while (firstIndex < leftSize) {
			arr[k] = leftArray[firstIndex];
			firstIndex++;
			k++;
		}
		while (secondIndex < rightSize) {
			arr[k] = rightArray[secondIndex];
			secondIndex++;
			k++;
		}
	}
	public static void sort(int arr[], int l, int r) {
		if (l < r) {
			int m = (l + r) / 2;
			sort(arr, l, m);
			sort(arr, m + 1, r);
			merge(arr, l, m, r);
		}
	}
}",0,1,0,0,0,0,0,0,0
833,"import datetime
import json
import os
import time
from tempfile import mkstemp
from typing import List
import progressbar
def main(numbers_filepath):
    splitting_success_marker = os.path.abspath(""mergesort_temp/.splitting_done"")
    if not os.path.isfile(splitting_success_marker):
        filepaths = split(numbers_filepath)
        with open(splitting_success_marker, ""w"") as f:
            f.write(json.dumps(filepaths))
    else:
        with open(splitting_success_marker) as f:
            filepaths = json.loads(f.read())
        print(f""Restored filepaths: {filepaths}"")
    cleanup(os.path.abspath(""mergesort_temp/""), filepaths)
    result_path = merge_all(filepaths, splitting_success_marker)
    print(f""Sorted result is in {result_path}"")
def get_bool(text: str) -> bool:
    data = ""placeholder""
    yes = [""y"", ""yes"", ""true"", ""1""]
    no = [""n"", ""no"", ""false"", ""0""]
    while data.lower() not in yes + no:
        data = input(text)
    return data in yes
def cleanup(directory: str, filepaths: List[str]) -> List[str]:
    potential = [
        os.path.join(directory, f)
        for f in os.listdir(directory)
        if os.path.isfile(os.path.join(directory, f))
    ]
    no_delete = set(filepaths)
    no_delete.add(os.path.join(directory, "".splitting_done""))
    for filepath in potential:
        if filepath not in no_delete:
            delete = get_bool(f""Do you want to remove {filepath}? [y/n] "")
            if delete:
                os.remove(filepath)
                print(f""Removed {filepath}"")
def split(numbers_filepath: str) -> List[str]:
    tmp_dir_path = os.path.abspath(""mergesort_temp"")
    if not os.path.isdir(tmp_dir_path):
        os.mkdir(tmp_dir_path)
    breaker = 10 ** 6
    filepaths: List[str] = []
    with open(numbers_filepath) as f:
        filepath = os.path.join(tmp_dir_path, f""{breaker}-{len(filepaths)}.txt"")
        next_break = breaker
        to_sort: List[str] = []
        breaks = 0
        for index, line in progressbar.progressbar(enumerate(f)):
            if os.path.isfile(filepath):
                if index % breaker == 1:
                    print(f""Found {filepath}. Skipping..."")
                if index == next_break:
                    filepaths.append(filepath)
                    filepath = os.path.join(
                        tmp_dir_path, f""{breaker}-{len(filepaths)}.txt""
                    )
                    print(f""Next filepath: {filepath}"")
                    next_break += breaker
                continue
            if index == next_break:
                to_sort = sorted(to_sort)
                filepaths.append(filepath)
                write_data(filepath, to_sort)
                next_break += breaker
                filepath = os.path.join(tmp_dir_path, f""{breaker}-{len(filepaths)}.txt"")
                print(f""Next filepath: {filepath}"")
                to_sort = []
            to_sort.append(line)
    return filepaths
def merge_all(filepaths: List[str], filepaths_filename: str) -> str:
    while len(filepaths) >= 2:
        t0 = time.time()
        filepath1 = filepaths.pop()
        filepath2 = filepaths.pop()
        _, target_path = mkstemp(
            prefix=""mergesort-"", suffix="".txt"", dir=os.path.dirname(filepaths_filename)
        )
        os.close(_)
        written_lines = merge_files(filepath1, filepath2, target_path)
        filepaths.append(target_path)
        with open(filepaths_filename, ""w"") as f:
            f.write(json.dumps(filepaths))
        os.remove(filepath1)
        os.remove(filepath2)
        t1 = time.time()
        print(
            f""Merged {written_lines:,} lines in {t1 - t0:0.2f}s. Remaining: {len(filepaths)}""
        )
    return filepaths[0]
def write_data(filepath, data):
    with open(filepath, ""w"") as f:
        for line in data:
            f.write(line)
def read_data(filepath):
    last_line = None
    t0 = time.time()
    with open(filepath) as f:
        for line in f:
            last_line = line
    t1 = time.time()
    print(f""Read file in {t1 - t0:.1f}s"")
    return last_line
def merge_files(filepath1: str, filepath2: str, outpath: str) -> int:
    written_lines = 0
    with open(outpath, ""w"") as fout, open(filepath1) as f1, open(filepath2) as f2:
        l1 = f1.readline()
        l2 = f2.readline()
        while len(l1) > 0 and len(l2) > 0:
            written_lines += 1
            if l1 < l2:
                fout.write(l1)
                l1 = f1.readline()
            else:
                fout.write(l2)
                l2 = f2.readline()
        while len(l1) > 0:
            fout.write(l1)
            l1 = f1.readline()
            written_lines += 1
        while len(l2) > 0:
            fout.write(l2)
            l2 = f2.readline()
            written_lines += 1
    return written_lines
if __name__ == ""__main__"":
    filepath = os.path.abspath(""numbers-large.txt"")
    main(filepath)",0,1,0,0,0,0,0,0,0
834,"package com.aokolnychyi.sorting;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
public class MergeSort {
  public static <T extends Comparable<T>> void sort(List<T> list) {
    sort(list, 0, list.size() - 1);
  }
  private static <T extends Comparable<T>> void sort(List<T> list, int startIndex, int endIndex) {
    if (startIndex < endIndex) {
      final int middleIndex = (startIndex + endIndex) / 2;
      sort(list, startIndex, middleIndex);
      sort(list, middleIndex + 1, endIndex);
      mergeSortedSequences(list, startIndex, middleIndex, endIndex);
    }
  }
  private static <T extends Comparable<T>> void mergeSortedSequences(
      List<T> list,
      int startIndex,
      int splitIndex,
      int endIndex) {
    final List<T> firstSubList = new ArrayList<>(list.subList(startIndex, splitIndex + 1));
    final List<T> secondSubList = new ArrayList<>(list.subList(splitIndex + 1, endIndex + 1));
    int currentFirstSubListIndex = 0;
    int currentSecondSubListIndex = 0;
    int currentIndex = startIndex;
    while (currentFirstSubListIndex < firstSubList.size() && currentSecondSubListIndex < secondSubList.size()) {
      final T firstSubListElement = firstSubList.get(currentFirstSubListIndex);
      final T secondSubListElement = secondSubList.get(currentSecondSubListIndex);
      if (firstSubListElement.compareTo(secondSubListElement) <= 0) {
        list.set(currentIndex++, firstSubListElement);
        currentFirstSubListIndex++;
      } else {
        list.set(currentIndex++, secondSubListElement);
        currentSecondSubListIndex++;
      }
    }
    while (currentFirstSubListIndex < firstSubList.size()) {
      final T firstSubListElement = firstSubList.get(currentFirstSubListIndex);
      list.set(currentIndex++, firstSubListElement);
      currentFirstSubListIndex++;
    }
    while (currentSecondSubListIndex < secondSubList.size()) {
      final T secondSubListElement = secondSubList.get(currentSecondSubListIndex);
      list.set(currentIndex++, secondSubListElement);
      currentSecondSubListIndex++;
    }
  }
  public static <T extends Comparable<T>> LinkedList<T> sort(LinkedList<T> list) {
    if (list.size() <= 1) {
      return list;
    }
    final int numberOfElements = list.size();
    final int middleIndex = (numberOfElements - 1) / 2;
    final LinkedList<T> firstSubList = new LinkedList<>(list.subList(0, middleIndex + 1));
    final LinkedList<T> secondSubList = new LinkedList<>(list.subList(middleIndex + 1, numberOfElements));
    final LinkedList<T> sortedFirstSubList = sort(firstSubList);
    final LinkedList<T> sortedSecondSubList = sort(secondSubList);
    return mergeSortedLists(sortedFirstSubList, sortedSecondSubList);
  }
  private static <T extends Comparable<? super T>> LinkedList<T> mergeSortedLists(
    LinkedList<T> firstSortedList,
    LinkedList<T> secondSortedList) {
    final LinkedList<T> mergedList = new LinkedList<>();
    T firstListElement = firstSortedList.peek();
    T secondListElement = secondSortedList.peek();
    while (firstListElement != null && secondListElement != null) {
      if (firstListElement.compareTo(secondListElement) <= 0) {
        mergedList.add(firstListElement);
        firstSortedList.remove();
        firstListElement = firstSortedList.peek();
      } else {
        mergedList.add(secondListElement);
        secondSortedList.remove();
        secondListElement = secondSortedList.peek();
      }
    }
    while (firstListElement != null) {
      mergedList.add(firstListElement);
      firstSortedList.remove();
      firstListElement = firstSortedList.peek();
    }
    while (secondListElement != null) {
      mergedList.add(secondListElement);
      secondSortedList.remove();
      secondListElement = secondSortedList.peek();
    }
    return mergedList;
  }
  public static void main(String[] args) {
    final List<Integer> list = new ArrayList<>();
    list.add(4);
    list.add(1);
    list.add(5);
    list.add(3);
    list.add(9);
    list.add(10);
    list.add(1);
    sort(list);
    sort(new ArrayList<Integer>());
    System.out.println(list);
    final LinkedList<Integer> linkedList = new LinkedList<>();
    linkedList.add(4);
    linkedList.add(1);
    linkedList.add(5);
    linkedList.add(3);
    linkedList.add(9);
    linkedList.add(10);
    linkedList.add(1);
    sort(new LinkedList<Integer>());
    System.out.println(sort(linkedList));
  }
}",0,1,0,0,0,0,0,0,0
835,"def Sort(list, l, middle, r):
    left = list[l:middle+1]
    right = list[middle+1:r+1]
    print(left, right)
    i = 0
    j = 0
    k = l
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            list[k] = left[i]
            i+=1
        else:
            list[k]=right[j]
            j+=1
        k+=1
    while i < len(left):
        list[k]=list[i]
        k+=1
        i+=1
    while j < len(right):
        list[k]=list[j]
        k+=1
        j+=1
def MergeSort(list, l, r):
    if l == r:
        return
    MergeSort(list, l, (l+r)//2)
    MergeSort(list, (l+r)//2+1, r)
    Sort(list, l, (r+l)//2, r)",0,1,0,0,0,0,0,0,0
836,"package sorting;
import java.util.Scanner;
class mergeSort{
    static int[] merge(int a[],int b[]){
        int l_a=a.length;
        int l_b=b.length;
        int combined[] = new int[l_a+l_b];
        int ptr_c=0;
        int ptr_p=0,ptr_q=0;
        while(ptr_p<l_a && ptr_q<l_b){
            if(a[ptr_p]<b[ptr_q]){
                combined[ptr_c]=a[ptr_p];
                ptr_p++;
                ptr_c++;
            }
            else{
                combined[ptr_c]=b[ptr_q];
                ptr_q++;
                ptr_c++;
            }
        }
        if(ptr_p>=l_a){
            for(int i = 0;i<(l_b-ptr_q);i++){
                combined[ptr_c+i]=b[ptr_q+i];
            }
        }
        if(ptr_q>=l_b){
            for (int i = 0;i<(l_a-ptr_p); i++) {
                combined[ptr_c+i]=a[ptr_p+i];
            }
        }
        return combined;
    }
    static int[] mergeSort(int arr[]){
        int mid=0;
        if(arr.length>1){
            mid=(0+arr.length)/2;
        }
        else{
            return arr;
        }
        int left[] = new int[mid];
        for(int i =0;i<mid;i++){
            left[i]=arr[i];
        }
        int right[]=new int[arr.length-mid];
        for(int i =0;i<(arr.length-mid);i++){
            right[i]=arr[i+mid];
        }
        left=mergeSort(left);
        right=mergeSort(right);
        int mergedArr[] = merge(left,right);
        return mergedArr;
    }
}",0,1,0,0,0,0,0,0,0
837,"def merge(left_list, right_list):
    sorted_list = []
    left_list_index = right_list_index = 0
    left_list_length, right_list_length = len(left_list), len(right_list)
    for _ in range(left_list_length + right_list_length):
        if left_list_index < left_list_length and right_list_index < right_list_length:
            if left_list[left_list_index] <= right_list[right_list_index]:
                sorted_list.append(left_list[left_list_index])
                left_list_index += 1
            else:
                sorted_list.append(right_list[right_list_index])
                right_list_index += 1
        elif left_list_index == left_list_length:
            sorted_list.append(right_list[right_list_index])
            right_list_index += 1
        elif right_list_index == right_list_length:
            sorted_list.append(left_list[left_list_index])
            left_list_index += 1
    return sorted_list
def merge_sort(nums):
    if len(nums) <= 1:
        return nums
    mid = len(nums) // 2
    left_list = merge_sort(nums[:mid])
    right_list = merge_sort(nums[mid:])
    return merge(left_list, right_list)
random_list_of_nums = [120, 45, 68, 250, 176]
random_list_of_nums = merge_sort(random_list_of_nums)
print(random_list_of_nums)",0,1,0,0,0,0,0,0,0
838,"public class MergeSort {
    public static void main(String args[]) {
        int[] input = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};
        MergeSort mergeSort = new MergeSort();
        mergeSort.sort(input, 0, input.length - 1);
        System.out.println(""Merge Sort : Sorted List"");
        for (int i = 0; i < input.length; i++) {
            System.out.println(input[i] + """");
        }
    }
    void sort(int input[], int start, int end) {
        if (start < end) {
            int mid = (start + end) / 2;
            sort(input, start, mid);
            sort(input, mid + 1, end);
            merge(input, start, mid, end);
        }
    }
    void merge(int input[], int start, int middle, int end) {
        int left = middle - start + 1;
        int right = end - middle;
        int[] leftArray = new int[left];
        int[] rightArray = new int[right];
        for (int i = 0; i < left; ++i) {
            leftArray[i] = input[start + i];
        }
        for (int j = 0; j < right; ++j) {
            rightArray[j] = input[middle + 1 + j];
        }
        int i = 0, j = 0;
        int k = start;
        while (i < left && j < right) {
            if (leftArray[i] <= rightArray[j]) {
                input[k] = leftArray[i];
                i++;
            } else {
                input[k] = rightArray[j];
                j++;
            }
            k++;
        }
        while (i < left) {
            input[k] = leftArray[i];
            i++;
            k++;
        }
        while (j < right) {
            input[k] = rightArray[j];
            j++;
            k++;
        }
    }
}",0,1,0,0,0,0,0,0,0
839,"mergeSort = (function() {
  function merge(left, right) {
    var result = [];
    for (var i = 0, j = 0; i < left.length && j < right.length;) {
      if (left[i] < right[j])
        result.push(left[i++]);
      else
        result.push(right[j++]);
    }
    return result.concat(left.slice(i)).concat(right.slice(j));
  }
  return function(array) {
    if (array.length <= 1) return array;
    var midpoint = array.length >> 1;
    return merge(mergeSort(array.slice(0, midpoint)),
                 mergeSort(array.slice(midpoint)));
  };
})();",0,1,0,0,0,0,0,0,0
840,"const merge = (arrayA, arrayB) => {
  let pointerA = 0,
    pointerB = 0,
    sortedArray = [];
  while (pointerA < arrayA.length && pointerB < arrayB.length) {
    if (arrayA[pointerA] < arrayB[pointerB]) {
      sortedArray.push(arrayA[pointerA]);
      pointerA++;
    } else {
      sortedArray.push(arrayB[pointerB]);
      pointerB++;
    }
  }
  if (pointerA < arrayA.length) {
    sortedArray = sortedArray.concat(arrayA.slice(pointerA));
  }
  if (pointerB < arrayB.length) {
    sortedArray = sortedArray.concat(arrayB.slice(pointerB));
  }
  return sortedArray;
};
const mergeSort = array => {
  if (array.length <= 1) {
    return array;
  }
  const left = array.slice(0, array.length / 2);
  const right = array.slice(array.length / 2);
  const leftSorted = mergeSort(left);
  const rightSorted = mergeSort(right);
  return merge(leftSorted, rightSorted);
};
const array = [22, 18, -4, 58, 7, 31, 42];
const sortedArray = mergeSort(array);
console.log(sortedArray);",0,1,0,0,0,0,0,0,0
841,"import random
def merge(A, aux, l, m, r):
    for k in range(l, r + 1):
        aux[k] = A[k]
    i = l
    j = m + 1
    for k in range(l, r + 1):
        if i > m:
            A[k] = aux[j]
            j += 1
        elif j > r:
            A[k] = aux[i]
            i += 1
        elif aux[j] < aux[i]:
            A[k] = aux[j]
            j += 1
        else:
            A[k] = aux[i]
            i += 1
def mergesort(A, aux, l, r):
    if r <= l:
        return
    m = (l + r) // 2
    mergesort(A, aux, l, m)
    mergesort(A, aux, m + 1, r)
    merge(A, aux, l, m, r)
A = random.sample(range(-10, 10), 10)
print(""not ordered array: "", A)
aux = [0] * len(A)
mergesort(A, aux, 0, len(A) - 1)
print(""ordered array:"", A)",0,1,0,0,0,0,0,0,0
842,"package com.satishkumarprasad.algo.sortingalgos;
public class MergeSort implements SortingAlgorithm {
	@Override
	public void sort(int[] array) {
		mergeSort(array, 0, array.length - 1);
	}
	private void mergeSort(int[] array, int start, int end) {
		if (start < end) {
			int middle = (start + end) / 2;
			mergeSort(array, start, middle);
			mergeSort(array, middle + 1, end);
			merge(array, start, middle, end);
		}
	}
	private void merge(int[] array, int start, int middle, int end) {
		int n1 = middle - start + 1;
		int n2 = end - middle;
		int[] leftSubArray = new int[n1 + 1];
		int[] rightSubArray = new int[n2 + 1];
		for (int i = 0; i < n1; i++) {
			leftSubArray[i] = array[start + i];
		}
		leftSubArray[n1] = 12345678; 
		for (int i = 0; i < n2; i++) {
			rightSubArray[i] = array[middle + 1 + i];
		}
		rightSubArray[n2] = 1546328; 
		for (int k = start, i = 0, j = 0; k <= end; k++) {
			if (leftSubArray[i] <= rightSubArray[j]) { 
				array[k] = leftSubArray[i];
				i++;
			} else {
				array[k] = rightSubArray[j];
				j++;
			}
		}
	}
}",0,1,0,0,0,0,0,0,0
843,"def mergeSort(list):
    if len(list) > 1:
        midPointer = len(list) // 2
        left = list[:midPointer]
        right = list[midPointer:]
        mergeSort(left)
        mergeSort(right)
        i = 0
        j = 0
        k = 0
        while (i < len(left)) and (j < len(right)):
            if left[i] < right[j]:
                list[k] = left[i]
                i += 1
            else:
                list[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            list[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            list[k] = right[j]
            j += 1
            k += 1",0,1,0,0,0,0,0,0,0
844,"package me.gilday.revision.sorting.merge;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class MergeSort {
	private static Logger logger = LoggerFactory.getLogger(MergeSort.class);
	public static int[] sort(int[] values) {
		logger.trace(""Sorting {}"", Arrays.toString(values));
		if(values.length <= 1) {
			return values;
		}
		int elementsInLeft = values.length / 2;
		int elementsInRight = values.length - elementsInLeft;
		int[] left, right;
		left = new int[elementsInLeft];
		right = new int[elementsInRight];
		logger.trace(""Left {} and Right {}"", Arrays.toString(left), Arrays.toString(right));
		for (int i = 0; i < elementsInLeft; i++) {
			left[i] = values[i];
		}
		for (int i = elementsInLeft; i <values.length; i++) {
			right[i - elementsInLeft] = values[i];
		}
		logger.trace(""Left {} and Right {}"", Arrays.toString(left), Arrays.toString(right));
		left = sort(left);
		right = sort(right);
		return merge(left, right);
	}
	private static int[] merge(int[] left, int[] right) {
		logger.trace(""Merging {} with {}"", Arrays.toString(left), Arrays.toString(right));
		int[] result = new int[left.length + right.length];
		int i=0, l=0, r=0;
		while(l != left.length && r != right.length) {
			if(left[l] < right[r]) {
				result[i++] = left[l++];
			} else {
				result[i++] = right[r++];
			}
		}
		while(l != left.length) {
			result[i++] = left[l++];
		}
		while(r != right.length) {
			result[i++] = right[r++];
		}
		logger.trace(""Merge result: {}"", Arrays.toString(result));
		return result;
	}
}",0,1,0,0,0,0,0,0,0
845,"def merge_sort(l:list):
    arr = l[::]
    if len(arr) < 2:
        return arr
    mid = len(arr)//2;
    left = arr[:mid]
    right = arr[mid:]
    return merge(merge_sort(left), merge_sort(right))
def merge(l, r):
    arr = []
    i = j = 0
    while i < len(l) and j < len(r):
        if l[i] <= r[j]:
            arr.append(l[i])
            i += 1
        else:
            arr.append(r[j])
            j += 1
    while i < len(l):
        arr.append(l[i])
        i += 1
    while j < len(r):
        arr.append(r[j])
        j += 1
    return arr",0,1,0,0,0,0,0,0,0
846,"package main;
public class MergeSort {
    public static void main(String args[]) {
        int[] arr = {8, 4, 5, 1, 2, 3, 6, 9, 8};
        int length = arr.length;
        int[] tmp = new int[length];
        mergeSort(arr, tmp, 0, length - 1);
        for (int num : arr) {
            System.out.println(num);
        }
    }
    public static void mergeSort(int[] arr, int[] tmp, int low, int high) {
        if (low < high) {
            int middle = low + (high - low) / 2;
            mergeSort(arr, tmp, low, middle);
            mergeSort(arr, tmp, middle + 1, high);
            merge(arr, tmp, low, middle, high);
        }
    }
    private static void merge(int[] arr, int[] tmp, int low, int middle, int high) {
        int i = low;
        int j = middle + 1;
        int k = low;
        for (int o = low; o <= high; o++) {
            tmp[o] = arr[o];
        }
        while (i <= middle && j <= high) {
            if (tmp[i] < tmp[j]) {
                arr[k] = tmp[i];
                k++;
                i++;
            } else {
                arr[k] = tmp[j];
                k++;
                j++;
            }
        }
        while (i <= middle) {
            arr[k] = tmp[i];
            i++;
            k++;
        }
    }
}",0,1,0,0,0,0,0,0,0
847,"from __future__ import print_function
def mergesort(lst):
    if len(lst) < 2:
        return lst
    middle = len(lst) // 2
    lst1 = mergesort(lst[:middle])
    lst2 = mergesort(lst[middle:])
    return merge(lst1, lst2)
def merge(lst1, lst2):
    lst = []
    while len(lst1) != 0 and len(lst2) != 0:
        if lst1[0] < lst2[0]:
            lst.append(lst1[0])
            lst1.remove(lst1[0])
        else:
            lst.append(lst2[0])
            lst2.remove(lst2[0])
    if len(lst1) == 0:
        lst += lst2
    else:
        lst += lst1
    return lst
if __name__ in ""__main__"":
    LIST = [1, 0, 2, 4, 5, 6, 2, 7, 9, 1, 3, 8, -1]
    print('list      :', LIST)
    print('merge sort:', mergesort(LIST))",0,1,0,0,0,0,0,0,0
848,"package Sorts;
import static Sorts.SortUtils.print;
class MergeSort implements SortAlgorithm {
    @Override
    @SuppressWarnings(""unchecked"")
    public <T extends Comparable<T>> T[] sort(T[] unsorted) {
        T[] tmp = (T[]) new Comparable[unsorted.length];
        doSort(unsorted, tmp, 0, unsorted.length - 1);
        return unsorted;
    }
    private  static <T extends Comparable<T>> void doSort(T[] arr, T[] temp, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            doSort(arr, temp, left, mid);
            doSort(arr,  temp,mid + 1, right);
            merge(arr, temp, left, mid, right);
        }
    }
    private static <T extends Comparable<T>> void merge(T[] arr, T[] temp, int left, int mid, int right) {
        System.arraycopy(arr, left, temp, left, right - left + 1);
        int i= left;
        int j = mid + 1;
        int k = left;
        while (i <= mid && j <= right) {
            if (temp[i].compareTo(temp[j]) <= 0) {
                arr[k] = temp[i];
                i++;
            }
            else {
                arr[k] = temp[j];
                j++;
            }
            k++;
        }
        while (i <= mid) {
            arr[k] = temp[i];
            i++;
            k++;
        }
	while (j <= right) {
	    arr[k] = temp[j];
	    j++;
	    k++;
	}
    }
    public static void main(String[] args) {
        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        MergeSort mergeSort = new MergeSort();
        mergeSort.sort(arr);
        print(arr);
        String[] stringArray = {""c"", ""a"", ""e"", ""b"",""d""};
        mergeSort.sort(stringArray);
        print(stringArray);
    }
}",0,1,0,0,0,0,0,0,0
849,"def mergesort(a):
    b = [*a]
    n = len(b)
    if n <= 1:
        return b
    mid = n // 2
    left, right = mergesort(b[:mid]), mergesort(b[mid:])
    return _merge(left, right, b)
def _merge(left, right, merged):
    left_cursor, right_cursor = 0, 0
    while left_cursor < len(left) and right_cursor < len(right):
        if left[left_cursor] <= right[right_cursor]:
            merged[left_cursor + right_cursor] = left[left_cursor]
            left_cursor += 1
        else:
            merged[left_cursor + right_cursor] = right[right_cursor]
            right_cursor += 1
    for left_cursor in range(left_cursor, len(left)):
        merged[left_cursor + right_cursor] = left[left_cursor]
    for right_cursor in range(right_cursor, len(right)):
        merged[left_cursor + right_cursor] = right[right_cursor]
    return merged
if __name__ == ""__main__"":
    import unittest
    from random import shuffle
    class TestMergesort(unittest.TestCase):
        def setUp(self):
            self.ordered = [x for x in range(20)]
            self.shuffled = [*self.ordered]
            while self.ordered == self.shuffled:
                shuffle(self.shuffled)
        def test_mergesort(self):
            self.assertEqual(self.ordered, mergesort(self.shuffled))
            self.assertNotEqual(self.ordered, self.shuffled)
    unittest.main()",0,1,0,0,0,0,0,0,0
850,"package com.deepak.algorithms.Sorting;
import java.util.Arrays;
public class MergeSort {
	public static void main(String[] args) {
		int[] valuesToBeSorted = {7, 10, 47, 40};
		System.out.println(""******************* MERGE - SORT *******************"");
		int[] sortedValues = performMergeSort(valuesToBeSorted, 0, valuesToBeSorted.length - 1);
		Arrays.stream(sortedValues).forEach(System.out::println);
	}
	public static int[] performMergeSort(int[] list, int low, int high) {
		if (low < high) {
			int middle = low + (high - low) / 2;
			performMergeSort(list, low, middle);
			performMergeSort(list, middle + 1, high);
			merge(list, low, middle, high);
		}
		return list;
	}
	private static int[] merge(int[] list, int low, int middle, int high) {
		int[] copy = new int[list.length];
		for (int i = 0; i < list.length; i++ ) {
			copy[i] = list[i];
		}
		int i = low;
		int j = middle + 1;
		int k = low;
		while (i <= middle && j <= high) {
			if (copy[i] <= copy[j]) {
				list[k] = copy[i];
				i++;
			} else {
				list[k] = copy[j];
				j++;
			}
			k++;
		}
		while (i <= middle) {
			list[k] = copy[i];
			k++;
			i++;
		}
		return list;
	}
}",0,1,0,0,0,0,0,0,0
851,"import time 
def MergeSort(data, drawDataArray, sortSpeedTime):
    MergeSort2(data,0, len(data)-1, drawDataArray, sortSpeedTime)
def MergeSort2(data, left, right, drawDataArray, sortSpeedTime):
    if left < right: 
        middle = (left + right) // 2
        MergeSort2(data, left, middle, drawDataArray, sortSpeedTime)
        MergeSort2(data, middle+1, right, drawDataArray, sortSpeedTime)
        Merge(data, left, middle, right, drawDataArray, sortSpeedTime)
def Merge(data, left, middle, right, drawDataArray, sortSpeedTime):
    drawDataArray(data, getColorArray(len(data), left, middle, right))
    time.sleep(sortSpeedTime)
    leftHalf = data[left:middle+1]
    rightHalf = data[middle+1: right+1]
    leftIndex, rightIndex = 0, 0
    for dataIndex in range(left, right+1):
        if leftIndex < len(leftHalf) and rightIndex < len(rightHalf):
            if leftHalf[leftIndex] <= rightHalf[rightIndex]:
                data[dataIndex] = leftHalf[leftIndex]
                leftIndex += 1
            else: 
                data[dataIndex] = rightHalf[rightIndex]
                rightIndex += 1
        elif leftIndex < len(leftHalf):
            data[dataIndex] = leftHalf[leftIndex]
            leftIndex += 1
        else: 
            data[dataIndex] = rightHalf[rightIndex]
            rightIndex += 1
    drawDataArray(data, [""purple"" if x >= left and x <= right else ""red"" for x in range(len(data))])
    time.sleep(sortSpeedTime)
def getColorArray(leght, left, middle, right):
    colorArray = []
    for i in range(leght):
        if i >= left and i <= right:
            if i >= left and i <= middle:
                colorArray.append(""orange"") 
            else: 
                colorArray.append(""green"") 
        else:
            colorArray.append(""red"") 
    return colorArray",0,1,0,0,0,0,0,0,0
852,"package sortvisualiser.algorithms;
import sortvisualiser.SortArray;
public class MergeSort implements ISortAlgorithm {
    private long stepDelay = 20;
    private int[] getSubArray(SortArray array, int begin, int size) {
        int arr[] = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = array.getValue(begin + i);
        }
        return arr;
    }
    private void merge(SortArray array, int left, int middle, int right) {
        int leftSize = middle - left + 1;
        int rightSize = right - middle;
        int leftArray[] = getSubArray(array, left, leftSize);
        int rightArray[] = getSubArray(array, middle + 1, rightSize);
        int i = 0, j = 0, k = left;
        while (i < leftSize && j < rightSize) {
            if (leftArray[i] <= rightArray[j]) {
                array.updateSingle(k, leftArray[i], getDelay(), true);
                i++;
            } else {
                array.updateSingle(k, rightArray[j], getDelay(), true);
                j++;
            }
            k++;
        }
        while (i < leftSize) {
            array.updateSingle(k, leftArray[i], getDelay(), true);
            i++;
            k++;
        }
        while (j < rightSize) {
            array.updateSingle(k, rightArray[j], getDelay(), true);
            j++;
            k++;
        }
    }
    private void mergeSort(SortArray array, int left, int right) {
        if (left < right) {
            int middleIndex = (left + right) / 2;
            mergeSort(array, left, middleIndex);
            mergeSort(array, middleIndex + 1, right);
            merge(array, left, middleIndex, right);
        }
    }
    @Override
    public void runSort(SortArray array) {
        int left = 0;
        int right = array.arraySize() - 1;
        mergeSort(array, left, right);
    }
    @Override
    public String getName() {
        return ""Merge Sort"";
    }
    @Override
    public long getDelay() {
        return stepDelay;
    }
    @Override
    public void setDelay(long delay) {
        this.stepDelay = delay;
    }
}",0,1,0,0,0,0,0,0,0
853,"import time
from colors import *
def merge(data, start, mid, end, drawData, timeTick):
    p = start
    q = mid + 1
    tempArray = []
    for i in range(start, end+1):
        if p > mid:
            tempArray.append(data[q])
            q+=1
        elif q > end:
            tempArray.append(data[p])
            p+=1
        elif data[p] < data[q]:
            tempArray.append(data[p])
            p+=1
        else:
            tempArray.append(data[q])
            q+=1
    for p in range(len(tempArray)):
        data[start] = tempArray[p]
        start += 1
def merge_sort(data, start, end, drawData, timeTick):
    if start < end:
        mid = int((start + end) / 2)
        merge_sort(data, start, mid, drawData, timeTick)
        merge_sort(data, mid+1, end, drawData, timeTick)
        merge(data, start, mid, end, drawData, timeTick)
        drawData(data, [PURPLE if x >= start and x < mid else YELLOW if x == mid 
                        else DARK_BLUE if x > mid and x <=end else BLUE for x in range(len(data))])
        time.sleep(timeTick)
    drawData(data, [BLUE for x in range(len(data))])",0,1,0,0,0,0,0,0,0
854,"package com.calebkoy.sortingalgovisualiser;
import java.util.ArrayList;
public class MergeSort {
    private static final String NAME = ""Merge sort"";
    public void sort(ArrayList<Integer> data) {
        if (data == null) {
            throw new IllegalArgumentException(""The data should not be null"");
        }
        sort(data, 0, data.size() - 1);
    }
    private void sort(ArrayList<Integer> data, int lowIndex, int highIndex) {
        if (lowIndex < highIndex) {
            int middleIndex = (int) Math.floor((double) (lowIndex + highIndex) / 2);
            sort(data, lowIndex, middleIndex);
            sort(data, middleIndex + 1, highIndex);
            merge(data, lowIndex, middleIndex, highIndex);
        }
    }
    public void merge(ArrayList<Integer> data, int lowIndex, int middleIndex, int highIndex) {
        if (data == null) {
            throw new IllegalArgumentException(""The data should not be null"");
        }
        if ((data.isEmpty()) || (data.size() == 1) || (middleIndex > data.size() - 1)) {
            return;
        }
        validateIndices(data, lowIndex, middleIndex, highIndex);
        ArrayList<Integer> leftSubArray = new ArrayList<>(data.subList(lowIndex, middleIndex + 1));
        ArrayList<Integer> rightSubArray = new ArrayList<>(data.subList(middleIndex + 1, highIndex + 1));
        leftSubArray.add(Integer.MAX_VALUE);
        rightSubArray.add(Integer.MAX_VALUE);
        int i = 0;
        int j = 0;
        for (int k = lowIndex; k < highIndex + 1; k++) {
            if (leftSubArray.get(i) < rightSubArray.get(j)) {
                data.set(k, leftSubArray.get(i));
                i++;
            } else {
                data.set(k, rightSubArray.get(j));
                j++;
            }
        }
    }
    private void validateIndices(ArrayList<Integer> data, int lowIndex, int middleIndex, int highIndex) {
        if (lowIndex < 0) {
            throw new IllegalArgumentException(""lowIndex must be >= 0 but is "" + lowIndex);
        }
        if (lowIndex > middleIndex) {
            throw new IllegalArgumentException(""lowIndex must be <= middleIndex, but lowIndex is "" + lowIndex +
                    "" and middleIndex is "" + middleIndex);
        }
        if (highIndex > data.size() - 1) {
            throw new IllegalArgumentException(""highIndex must be <= data.size() - 1, but highIndex is "" +
                    highIndex + "" and (data.size() - 1) equals "" + (data.size() - 1));
        }
        if (middleIndex > highIndex) {
            throw new IllegalArgumentException(""middleIndex must be <= highIndex, but middleIndex is "" + middleIndex +
                    "" and highIndex is "" + highIndex);
        }
    }
    public static String getName() {
        return NAME;
    }
}",0,1,0,0,0,0,0,0,0
855,"import time
count = 0
def sort(bar, layout, num, colors):
    data = list(bar.y)
    alldata = list(bar.y)
    msort(data, bar, layout, num, colors, 0, alldata)
def msort(data, bar, layout, num, colors, startindex, alldata): 
    global count
    if len(data)>1: 
        mid = len(data)//2
        rightindex = startindex + mid
        left = data[:mid]
        right = data[mid:]
        msort(left, bar, layout, num, colors, startindex, alldata)
        msort(right, bar, layout, num, colors, rightindex, alldata)
        i = j = k2 = 0
        k = startindex
        colors[startindex:rightindex] = ['yellow']* (rightindex - startindex)
        colors[rightindex:rightindex+mid] = ['orange'] * (mid)
        bar.marker.color = colors
        time.sleep(0.1)
        while i<len(left) and j<len(right):
            count += 1
            layout.xaxis.title.text = ""Number of operations: "" + str(count)
            if left[i] < right[j]: 
                alldata[k] = left[i]
                data[k2] = left[i]
                bar.y = alldata
                time.sleep(0.1)
                i += 1
            else:
                alldata[k] = right[j]
                data[k2] = right[j]
                bar.y = alldata
                time.sleep(0.1)
                j += 1
            k += 1
            k2 += 1
        while i < len(left): 
            count += 1
            layout.xaxis.title.text = ""Number of operations: "" + str(count)
            alldata[k] = left[i]
            data[k2] = left[i]
            bar.y = alldata
            time.sleep(0.1)
            i += 1
            k += 1
            k2 += 1
        while j < len(right): 
            count += 1
            layout.xaxis.title.text = ""Number of operations: "" + str(count)
            alldata[k] = right[j]
            data[k2] = right[j]
            bar.y = alldata
            time.sleep(0.1)
            j += 1
            k += 1
            k2 += 1
        bar.y = alldata
        time.sleep(0.1)
        colors[startindex:rightindex] = ['blue'] * (rightindex - startindex)
        colors[rightindex:rightindex+mid] = ['blue'] * (mid)
        bar.marker.color = colors
        time.sleep(0.1)",0,1,0,0,0,0,0,0,0
856,"package sorting;
import edu.princeton.cs.algs4.StdOut;
public class MergeSort {
  private static Comparable[] aux;  
  private MergeSort() { }
  public static void sort(Comparable[] a) {
    aux = new Comparable[a.length];  
    sort(a, 0, a.length - 1);
  }
  private static void sort(Comparable[] a, int lo, int hi) {  
    if (hi <= lo) return;
    int mid = lo + (hi - lo)/2;
    sort(a, lo, mid);  
    sort(a, mid+1, hi);  
    merge(a, lo, mid, hi);  
  }
  private static void merge(Comparable[] a, int lo, int mid, int hi) {  
    int i = lo, j = mid+1;
    for (int k = lo; k <= hi; k++)  
      aux[k] = a[k];
    for (int k = lo; k <= hi; k++)  
      if (i > mid) a[k] = aux[j++];
      else if (j > hi ) a[k] = aux[i++];
      else if (less(aux[j], aux[i])) a[k] = aux[j++];
      else a[k] = aux[i++];
  }
  private static boolean less(Comparable v, Comparable w) { 
    return v.compareTo(w) < 0;  
  }
  private static void exch(Comparable[] a, int i, int j) { 
    Comparable t = a[i]; 
    a[i] = a[j]; 
    a[j] = t; 
  }
  private static void show(Comparable[] a) {  
    for (int i = 0; i < a.length; i++)
      StdOut.print(a[i] + "" "");
      StdOut.println();
    }
  public static boolean isSorted(Comparable[] a) {  
    for (int i = 1; i < a.length; i++)
      if (less(a[i], a[i-1])) return false;
    return true;
  }
  public static void main(String[] args) {  
    String example = ""M E R G E S O R T E X A M P L E"";
    String [] a = example.split("" "");
    sort(a);
    assert isSorted(a);
    show(a);
  }
}",0,1,0,0,0,0,0,0,0
857,"package merge_sort;
public class MergeSort {
    public void sort(int[] array) {
        int[] aux = new int[array.length];
        sort(array, aux, 0, array.length - 1);
    }
    private void sort(int[] array, int[] aux, int start, int end) {
        if (end <= start) return;
        int mid = start + (end - start) / 2;
        sort(array, aux, start, mid);  
        sort(array, aux, mid + 1, end);  
        merge(array, aux, start, mid, end);
    }
    private void merge(int[] array, int[] aux, int start, int mid, int end) {
        for (int k = start; k <= end; k++) {
            aux[k] = array[k];
        }
        int i = start, j = mid + 1;
        for (int k = start; k <= end; k++) {
            if (j > end) {  
                array[k] = aux[i++];
            } else if (i > mid) {  
                array[k] = aux[j++];
            } else if (aux[i] < aux[j]) {
                array[k] = aux[i++];
            } else {
                array[k] = aux[j++];
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
858,"package com.mehmetpekdemir.sort.mergesort;
public final class MergeSort {
	public static void sort(int[] array, int start, int end) {
		if (end - start < 2) {
			return;
		}
		final int mid = (start + end) / 2;
		sort(array, start, mid);
		sort(array, mid, end);
		merge(array, start, mid, end);
	}
	private static void merge(int[] array, int start, int mid, int end) {
		if (array[mid - 1] <= array[mid]) {
			return;
		}
		int i = start;
		int j = mid;
		int tempIndex = 0;
		int[] temp = new int[end - start];
		while (i < mid && j < end) {
			temp[tempIndex++] = array[i] <= array[j] ? array[i++] : array[j++];
		}
		System.arraycopy(array, i, array, start + tempIndex, mid - i);
		System.arraycopy(temp, 0, array, start, tempIndex);
	}
}",0,1,0,0,0,0,0,0,0
859,"package eu.happycoders.sort.method.mergesort;
import eu.happycoders.sort.method.Counters;
import eu.happycoders.sort.method.SortAlgorithm;
public class MergeSort implements SortAlgorithm {
  private static final int MAX_INPUT_SIZE = 1 << 28;
  @Override
  public void sort(int[] elements) {
    int length = elements.length;
    int[] sorted = mergeSort(elements, 0, length - 1);
    System.arraycopy(sorted, 0, elements, 0, length);
  }
  private int[] mergeSort(int[] elements, int left, int right) {
    if (left == right) return new int[]{elements[left]};
    int middle = left + (right - left) / 2;
    int[] leftArray = mergeSort(elements, left, middle);
    int[] rightArray = mergeSort(elements, middle + 1, right);
    return merge(leftArray, rightArray);
  }
  int[] merge(int[] leftArray, int[] rightArray) {
    int leftLen = leftArray.length;
    int rightLen = rightArray.length;
    int[] target = new int[leftLen + rightLen];
    int targetPos = 0;
    int leftPos = 0;
    int rightPos = 0;
    while (leftPos < leftLen && rightPos < rightLen) {
      int leftValue = leftArray[leftPos];
      int rightValue = rightArray[rightPos];
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (leftPos < leftLen) {
      target[targetPos++] = leftArray[leftPos++];
    }
    while (rightPos < rightLen) {
      target[targetPos++] = rightArray[rightPos++];
    }
    return target;
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    int length = elements.length;
    int[] sorted = mergeSort(elements, 0, length - 1, counters);
    System.arraycopy(sorted, 0, elements, 0, length);
    counters.addReadsAndWrites(length);
  }
  private int[] mergeSort(int[] elements, int left, int right,
                          Counters counters) {
    if (left == right) return new int[]{elements[left]};
    int middle = left + (right - left) / 2;
    int[] leftArray = mergeSort(elements, left, middle, counters);
    int[] rightArray = mergeSort(elements, middle + 1, right, counters);
    return merge(leftArray, rightArray, counters);
  }
  int[] merge(int[] leftArray, int[] rightArray, Counters counters) {
    int leftLen = leftArray.length;
    int rightLen = rightArray.length;
    int[] target = new int[leftLen + rightLen];
    int targetPos = 0;
    int leftPos = 0;
    int rightPos = 0;
    while (isLessThan(leftPos, leftLen, counters)
          && isLessThan(rightPos, rightLen, counters)) {
      counters.incIterations();
      int leftValue = leftArray[leftPos];
      int rightValue = rightArray[rightPos];
      counters.addReads(2);
      counters.incComparisons();
      counters.incWrites();
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (isLessThan(leftPos, leftLen, counters)) {
      counters.incIterations();
      target[targetPos++] = leftArray[leftPos++];
      counters.incReadsAndWrites();
    }
    while (isLessThan(rightPos, rightLen, counters)) {
      counters.incIterations();
      target[targetPos++] = rightArray[rightPos++];
      counters.incReadsAndWrites();
    }
    return target;
  }
  private boolean isLessThan(int a, int b, Counters counters) {
    counters.incComparisons();
    return a < b;
  }
  @Override
  public boolean isSuitableForInputSize(int size) {
    return size <= MAX_INPUT_SIZE;
  }
}",0,1,0,0,0,0,0,0,0
860,"require('../../../common/array-extensions');
const { isEmpty, isFunction } = require('../../../common/utils');
const mergeSort = function(list) {
    if (isEmpty(list)) {
        return list;
    }
    if (list.length < 2) {
        return list;
    }
    sort(list, [], 0, list.length - 1);
    return list;
};
function sort(list, tempList, leftStart, rightEnd) {
    if (leftStart >= rightEnd) {
        return;
    }
    var middle = Math.floor((leftStart + rightEnd) / 2);
    sort(list, tempList, leftStart, middle);
    sort(list, tempList, middle + 1, rightEnd);
    merge(list, tempList, leftStart, rightEnd);
}
function merge(list, tempList, leftStart, rightEnd) {
    var leftEnd = Math.floor((leftStart + rightEnd) / 2);
    var rightStart = leftEnd + 1;
    var size = rightEnd - leftStart + 1;
    var leftIndex = leftStart;
    var rightIndex = rightStart;
    var tempIndex = leftStart;
    const allItemsComparable = list.reduce(
        (acc, item) => (acc &= isFunction(item.compareTo)),
        true
    );
    while (leftIndex <= leftEnd && rightIndex <= rightEnd) {
        if (allItemsComparable) {
            tempList[tempIndex++] =
                list[leftIndex].compareTo(list[rightIndex]) < 0
                    ? list[leftIndex++]
                    : list[rightIndex++];
        } else {
            tempList[tempIndex++] =
                list[leftIndex] < list[rightIndex] ? list[leftIndex++] : list[rightIndex++];
        }
    }
    list.copy(leftIndex, tempList, tempIndex, leftEnd - leftIndex + 1);
    list.copy(rightIndex, tempList, tempIndex, rightEnd - rightIndex + 1);
    tempList.copy(leftStart, list, leftStart, size);
}
module.exports = { mergeSort };",0,1,0,0,0,0,0,0,0
861,"function merge(array, low, middle, high){
    var i = 0
    var j = 0
    var k = low
    var lenA = middle - low + 1
    var lenB = high - middle
    var arrayA = new Array(lenA)
    var arrayB = new Array(lenB)
    for (let idx = 0; idx < lenA; idx++)
        arrayA[idx] = array[idx + low]
    for (let idx = 0; idx < lenB; idx++)
        arrayB[idx] = array[idx + middle + 1]
    while ( i < lenA && j < lenB )
    {
        if ( arrayA[i] < arrayB[j] )
            array[k++] = arrayA[i++]
        else
            array[k++] = arrayB[j++]
    }
    while ( i < lenA )
        array[k++] = arrayA[i++]
    while ( j < lenB )
        array[k++] = arrayB[j++]
}
function mergeSort(array, low, high){
    if ( low < high )
    {
        let middle = Math.floor((high - low) / 2) + low
        mergeSort(array, low, middle)
        mergeSort(array, middle + 1, high)
        merge(array, low, middle, high)
    }
}
function sort(array){
    mergeSort(array, 0, array.length - 1)
}",0,1,0,0,0,0,0,0,0
862,"from typing import List
def merge(arr: List[int], aux: List[int], lo: int, mid: int, hi: int) -> None:
    for x in range(lo, hi + 1):
        aux[x] = arr[x]
    i = lo
    j = mid + 1
    for k in range(lo, hi + 1):
        if i > mid:
            arr[k] = aux[j]
            j += 1
        elif j > hi:
            arr[k] = aux[i]
            i += 1
        elif aux[j] < aux[i]:
            arr[k] = aux[j]
            j += 1
        else:
            arr[k] = aux[i]
            i += 1
def sort_util(arr: List[int], aux: List[int], lo: int, hi: int) -> None:
    if lo >= hi:
        return
    mid = lo + (hi - lo) // 2
    sort_util(arr, aux, lo, mid)
    sort_util(arr, aux, mid + 1, hi)
    merge(arr, aux, lo, mid, hi)
def merge_sort(arr: List[int]) -> None:
    aux = [0 for _ in range(len(arr))]
    sort_util(arr, aux, 0, len(arr) - 1)
def main():
    a = [9, 8, 1, 3, 0, 7, 6, 4, 5, 2]
    merge_sort(a)
    print(a)
if __name__ == ""__main__"":
    main()",0,1,0,0,0,0,0,0,0
863,"package sorting;
import java.util.Arrays;
public class MergeSort<T extends Comparable<T>> implements Sort<T> {
    private final PartialSort<T> algorithmSmallN;
    private final int thresholdSmallN;
    public MergeSort(PartialSort<T> algorithmSmallN, int thresholdSmallN) {
        this.algorithmSmallN = algorithmSmallN;
        this.thresholdSmallN = thresholdSmallN;
    }
    @Override
    public void sort(T[] items) {
        sort(items, 0, items.length - 1);
    }
    public void sort(T[] items, int min, int max) {
        if (max - min + 1 < thresholdSmallN) {
            algorithmSmallN.sortPartially(items, min, max + 1);
        } else {
            int mid = min + (max - min + 1) / 2;
            sort(items, min, mid);
            sort(items, mid, max);
            merge(items, min, mid, max);
        }
    }
    private void merge(T items[], int min, int mid, int max) {
        T buf[] = Arrays.copyOfRange(items, min, mid);
        int readBuf = 0;
        int readArray = mid;
        int write = min;
        while (readBuf < buf.length) {
            if (readArray == max || buf[readBuf].compareTo(items[readArray]) < 0) {
                items[write++] = buf[readBuf++];
            } else {
                items[write++] = items[readArray++];
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
864,"package dev.jeffreybender.sort;
import java.util.Arrays;
import java.util.Comparator;
public final class MergeSort {
    private MergeSort() {
    }
    public static <T> void sort(T[] array, Comparator<? super T> comparator) {
        if (array.length <= 1) {
            return;
        }
        if (comparator == null) {
            comparator = SortUtils.getDefaultComparator();
        }
        mergeSort(array, array.length, comparator);
    }
    public static <T extends Comparable<? super T>> void sort(T[] array) {
        sort(array, null);
    }
    private static <T> void mergeSort(T[] array, int endIndex, Comparator<T> comparator) {
        if (array.length <= 1) {
            return;
        }
        int middleIndex = endIndex / 2;
        T[] left = Arrays.copyOfRange(array, 0, middleIndex);
        T[] right = Arrays.copyOfRange(array, middleIndex, endIndex);
        int leftStop = middleIndex;
        int rightStop = endIndex - middleIndex;
        mergeSort(left, middleIndex, comparator);
        mergeSort(right, endIndex - middleIndex, comparator);
        merge(array, left, leftStop, right, rightStop, comparator);
    }
    private static <T> void merge(T[] array, T[] left, int leftStop, T[] right, int rightStop,
            Comparator<T> comparator) {
        int leftIndex = 0;
        int rightIndex = 0;
        int arrayIndex = 0;
        while (leftIndex < leftStop && rightIndex < rightStop) {
            if (comparator.compare(left[leftIndex], right[rightIndex]) <= 0) {
                array[arrayIndex++] = left[leftIndex++];
            } else {
                array[arrayIndex++] = right[rightIndex++];
            }
        }
        while (leftIndex < leftStop) {
            array[arrayIndex++] = left[leftIndex++];
        }
        while (rightIndex < rightStop) {
            array[arrayIndex++] = right[rightIndex++];
        }
    }
}",0,1,0,0,0,0,0,0,0
865,"package ie.peternagy.algorithms.sorting;
import java.util.Arrays;
public class MergeSort {
    public static void sort(Comparable[] items) {
        sort(items, true);
    }
    public static void sort(Comparable[] items, boolean isAsc) {
        int arrayLength = items.length;
        mergeSort(items, 0, arrayLength - 1, isAsc);
    }
    private static void mergeSort(Comparable[] items, int lowIndex, int highIndex, boolean isAsc) {
        if (lowIndex < highIndex) {
            int middle = lowIndex + (highIndex - lowIndex) / 2;
            mergeSort(items, lowIndex, middle, isAsc);
            mergeSort(items, middle + 1, highIndex, isAsc);
            merge(items, lowIndex, middle, highIndex, isAsc);
        }
    }
    private static void merge(Comparable[] items, int lowIndex, int middle, int highIndex, boolean isAsc) {
        Comparable[] helper = new Comparable[items.length];
        System.arraycopy(items, lowIndex, helper, lowIndex, (highIndex - lowIndex) + 1);
        int i = lowIndex;
        int j = middle + 1;
        int k = lowIndex;
        while (i <= middle && j <= highIndex) {
            if (isAsc && helper[i].compareTo(helper[j]) < 0 ||
                    !isAsc && helper[i].compareTo(helper[j]) > 0) {
                items[k] = helper[i];
                i++;
            } else {
                items[k] = helper[j];
                j++;
            }
            k++;
        }
        System.arraycopy(helper, i, items, k, (middle - i) + 1);
    }
}",0,1,0,0,0,0,0,0,0
866,"package raymond.com.sorting;
public class MergeSort extends Sorting 
{
	private int [] numbersArray;
	public MergeSort(int[] array)
	{
		numbersArray = array;
	}
	public int [] sort ()
	{
		return sort(numbersArray);
	}
	public int []  sort (int [] array)
	{
		if (array.length == 1)
		{
			return array;
		}
		else
		{
			int [] tempArray1 = new int[array.length / 2];
			int [] tempArray2 = new int[array.length - array.length / 2];
			for (int i = 0; i < array.length; i ++)
			{
				if (i < array.length / 2)
				{
					tempArray1[i] = array[i];
				}
				else
				{
					tempArray2[i - array.length / 2] = array[i];
				}
			}
			int [] sortedArray1 = sort(tempArray1);
			int [] sortedArray2 = sort(tempArray2);
			return mergeArrays(sortedArray1, sortedArray2);
		}
	}
	private int [] mergeArrays(int [] array1, int[] array2) 
	{
		int [] sortedArray = new int [array1.length + array2.length];
		int array1Index = 0;
		int array2Index = 0;
		int sortedIndex = 0;
		while (array1Index < array1.length && array2Index < array2.length)
		{
			if (array1[array1Index] <= array2[array2Index])
			{
				sortedArray[sortedIndex] = array1[array1Index];
				array1Index++;
			}
			else
			{
				sortedArray[sortedIndex] = array2[array2Index];
				array2Index++;
			}
			sortedIndex++;
		}
		while (array1Index < array1.length)
		{
			sortedArray[sortedIndex] = array1[array1Index];
			array1Index++;
			sortedIndex++;
		}
		while (array2Index < array2.length)
		{
			sortedArray[sortedIndex] = array2[array2Index];
			array2Index++;
			sortedIndex++;
		}
		return sortedArray;
	}
}",0,1,0,0,0,0,0,0,0
867,"package ec;
import java.util.ArrayList;
public class MergeSort<T extends Comparable<T>> implements SortingAlgorithms{
	 ArrayList<T> merge = new ArrayList<T>();
	public MergeSort() {
		sortingAlgorithms();
	}
	private static  long comparisons = 0;
	private static  long swaps = 0;
	private static  long runtime = 0;
	static long start;
	static long end;
	public ArrayList<T> mergeSort1(ArrayList<T> list3) {
		ArrayList<T> left = new ArrayList<T>();
		ArrayList<T> right = new ArrayList<T>();
		if(list3.size() > 1) {
			int half = (list3.size() - 1) / 2;
			for(int i = 0 ; i <= half ; i++) {
				left.add(list3.get(i));
			}
			for(int j = half + 1; j <= list3.size() - 1; j++) {
				right.add(list3.get(j));
			}
			left = mergeSort1(left);
			right = mergeSort1(right);
		}
		return mergeSort2(left, right, list3);
	}
	public ArrayList<T> mergeSort2(ArrayList<T> left, ArrayList<T> right, ArrayList<T> list3) {
		int a = 0, b = 0, c = 0;
		long comparisons = 0;
		long swaps = 0;
		while((a < left.size()) && (b < right.size())) {
			comparisons++;
			if(left.get(a).compareTo(right.get(b)) < 0) {
				list3.set(c, left.get(a));
				a++;
			}
			else {
				list3.set(c, right.get(b));
				b++;
			}
			c++;
		}
		while(a < left.size()) {
			list3.set(c, left.get(a));
			a++;
			c++;
		}
		while(b < right.size()) {
			list3.set(c, right.get(b));
			b++;
			c++;
		}
		MergeSort.comparisons = comparisons;
		MergeSort.swaps = swaps;
		return list3;		
	}
	public ArrayList<T> mergeSort3(ArrayList<T> mergeList) {
		start = System.currentTimeMillis();
		mergeSort1(mergeList);
		end = System.currentTimeMillis();
		runtime = end - start;
		return mergeList;
	}
	public ArrayList<T> print(ArrayList<T> bubble) {
		ArrayList<T> bs = new ArrayList<T>();
		for(int i = 0 ; i < bubble.size() ; i++) {
			bs.add(bubble.get(i));
		}
		return bs;
	}
	public static void runtime() {
		System.out.print(""Runtime: ""  + runtime + "" ms"");
	}
	@Override
	public void sortingAlgorithms() {
		mergeSort1(merge);
	}
	public static void compare() {
		System.out.print(""Comparisons: "" + comparisons);
	}
	public static void swap() {
		System.out.print(""Swaps: "" + swaps);
	}
	public static void euntime() {
		System.out.print(""Runtime: ""  + (runtime * 2) + "" ms"");
	}
}",0,1,0,0,0,0,0,0,0
868,"public class mergeSort {
    public static void main (String[] args){
        int [] ar = {12, 11 ,13 ,5 , 6 ,7};
        mergeSorting(ar,0,ar.length-1);
    } 
    public static void mergeSorting(int[] A ,int a ,int b ){
        if(a<b){
            int p = (a+b)/2;
            System.out.println(""Inside the mergeSort, start value : ""+a +""   mid value : ""+p +""    end value : ""+b);
            System.out.println(""Left mergeSort"");
            mergeSorting(A,a,p);
            System.out.println(""right mergeSort"");
            mergeSorting(A,p+1,b);
            merge(A,a,p,b);
        }
    }
    public static void merge(int[] A ,int p ,int q ,int r){
        System.out.println(""Inside the merge part"");
        int n1 = q-p+1;
        int n2 = r-q;
        int[] B = new int [n1+1];
        int[] C = new int [n2+1];
        System.out.println(""Initial Arrry "");
        printArray(A);
        B[n1]= Integer.MAX_VALUE;
        C[n2]= Integer.MAX_VALUE;
        for(int i=0 ; i<n1 ;i++){
            B[i] = A[p+i];
        }
        for(int i=0 ; i<n2 ;i++){
            C[i] = A[q+i+1];
        }
        System.out.println(""After devide into tempary sub arry "");
        printArray(B);
        printArray(C);
        int i=0;
        int j=0;
        for(int k=p ; k<r+1 ;k++){
            if(B[i]<C[j]){
                A[k]=B[i];
                i++;
            }
            else{
                A[k]=C[j];
                j++;
            }
        }
        System.out.println(""Sorted Arrry "");
        printArray(A);
    } 
    public static void printArray(int[] ar){
        for(int g : ar){
            System.out.print(g+"" "");
        }
        System.out.println();
     }
}",0,1,0,0,0,0,0,0,0
869,"package com.srt.sort;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.function.BiFunction;
@SuppressWarnings({""unchecked"", ""unused""})
public class MergeSort<T extends Comparable> extends JSort<T> {
    private Class<T> clazz;
    public MergeSort(Class<T> clazz) {
        this.clazz = clazz;
    }
    private T[] merge(T[] left, T[] right, BiFunction<T, T, Boolean> compare) {
        int i = 0, j = 0, k = 0;
        T[] mergedArray = getArray(clazz, left.length + right.length);
        while (i < left.length || j < right.length) {
            if (i == left.length) {
                while (j != right.length)
                    mergedArray[k++] = right[j++];
            } else if (j == right.length) {
                while (i != left.length)
                    mergedArray[k++] = left[i++];
            } else if (compare.apply(left[i], right[j])) {
                mergedArray[k++] = left[i++];
            } else {
                mergedArray[k++] = right[j++];
            }
        }
        return mergedArray;
    }
    private T[] getArray(Class<T> clazz, int size) {
        T[] es = (T[]) Array.newInstance(clazz, size);
        return es;
    }
    T[] Sort(T[] array, BiFunction<T, T, Boolean> compare) {
        if (array.length == 1) {
            return array;
        }
        return merge(Sort(FirstHalf(array), compare),
                Sort(secondHalf(array), compare), compare);
    }
    private T[] secondHalf(T[] array) {
        return Arrays.copyOfRange(array, array.length / 2, array.length);
    }
    private T[] FirstHalf(T[] array) {
        return Arrays.copyOfRange(array, 0, (array.length / 2));
    }
}",0,1,0,0,0,0,0,0,0
870,"package MergeSort;
import java.util.Comparator;
import Utils.Convert;
import Utils.Order;
public class MergeSort {
	@SuppressWarnings(""rawtypes"")
	private static Comparable[] sorted;
	private static byte[] BYTESorted;
	private static char[] CHARSorted;
	private static short[] SHORTSorted;
	private static int[] INTSorted;
	private static long[] LONGSorted;
	private static float[] FLOATSorted;
	private static double[] DOUBLESorted;
	public static void sort(byte[] a) {
		BYTESorted = new byte[a.length];
		sort(a, 0, a.length - 1);
		BYTESorted = null;
	}
	private static void sort(byte[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(byte[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				BYTESorted[idx++] = a[l++];
			}
			else {
				BYTESorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				BYTESorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				BYTESorted[idx++] = a[l++];
			}
		}
		System.arraycopy(BYTESorted, left, a, left, right - left + 1);
	}
	public static void sort(char[] a) {
		CHARSorted = new char[a.length];
		sort(a, 0, a.length - 1);
		CHARSorted = null;
	}
	private static void sort(char[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(char[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				CHARSorted[idx++] = a[l++];
			}
			else {
				CHARSorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				CHARSorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				CHARSorted[idx++] = a[l++];
			}
		}
		System.arraycopy(CHARSorted, left, a, left, right - left + 1);
	}
	public static void sort(short[] a) {
		SHORTSorted = new short[a.length];
		sort(a, 0, a.length - 1);
		SHORTSorted = null;
	}
	private static void sort(short[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(short[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				SHORTSorted[idx++] = a[l++];
			}
			else {
				SHORTSorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				SHORTSorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				SHORTSorted[idx++] = a[l++];
			}
		}
		System.arraycopy(SHORTSorted, left, a, left, right - left + 1);
	}
	public static void sort(int[] a) {
		INTSorted = new int[a.length];
		sort(a, 0, a.length - 1);
		INTSorted = null;
	}
	private static void sort(int[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(int[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				INTSorted[idx++] = a[l++];
			}
			else {
				INTSorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				INTSorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				INTSorted[idx++] = a[l++];
			}
		}
		System.arraycopy(INTSorted, left, a, left, right - left + 1);
	}
	public static void sort(long[] a) {
		LONGSorted = new long[a.length];
		sort(a, 0, a.length - 1);
		LONGSorted = null;
	}
	private static void sort(long[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(long[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				LONGSorted[idx++] = a[l++];
			}
			else {
				LONGSorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				LONGSorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				LONGSorted[idx++] = a[l++];
			}
		}
		System.arraycopy(LONGSorted, left, a, left, right - left + 1);
	}
	public static void sort(float[] a) {
		FLOATSorted = new float[a.length];
		sort(a, 0, a.length - 1);
		FLOATSorted = null;
	}
	private static void sort(float[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(float[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				FLOATSorted[idx++] = a[l++];
			}
			else {
				FLOATSorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				FLOATSorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				FLOATSorted[idx++] = a[l++];
			}
		}
		System.arraycopy(FLOATSorted, left, a, left, right - left + 1);
	}
	public static void sort(double[] a) {
		DOUBLESorted = new double[a.length];
		sort(a, 0, a.length - 1);
		DOUBLESorted = null;
	}
	private static void sort(double[] a, int left, int right) {
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high);
			}
		}
	}
	private static void merge(double[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l] <= a[r]) {
				DOUBLESorted[idx++] = a[l++];
			}
			else {
				DOUBLESorted[idx++] = a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				DOUBLESorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				DOUBLESorted[idx++] = a[l++];
			}
		}
		System.arraycopy(DOUBLESorted, left, a, left, right - left + 1);
	}
	public static void sort(Object[] a) {
		sort(a, 0, a.length - 1);
	}
	private static void sort(Object[] a, int left, int right) {
		sorted = new Comparable[a.length];
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge((Comparable[])a, l, l + size - 1, high);
			}
		}
		sorted = null;
	}
	@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private static void merge(Comparable[] a, int left, int mid, int right) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (a[l].compareTo(a[r]) <= 0) {
				sorted[idx++] = a[l++];
			}
			else {
				sorted[idx++] =  a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				sorted[idx++] = a[r++];
			}
		} else {
			while (l <= mid) {
				sorted[idx++] = a[l++];
			}
		}
		System.arraycopy(sorted, left, a, left, right - left + 1);
	}
	public static <T> void sort(T[] a, Comparator<? super T> c) {
		if(c == null) {
			sort(a, 0, a.length - 1);
		}
		else {
			sort(a, 0, a.length - 1, c);
		}
	}
	private static <T> void sort(T[] a, int left, int right, Comparator<? super T> c) {
		sorted = new Comparable[a.length];
		for (int size = 1; size <= right; size += size) {
			for (int l = 0; l <= right - size; l += (2 * size)) {
				int high = Math.min(l + (2 * size) - 1, right);
				merge(a, l, l + size - 1, high, c);
			}
		}
		sorted = null;
	}
	@SuppressWarnings({ ""rawtypes"" })
	private static <T> void merge(T[] a, int left, int mid, int right , Comparator<? super T> c) {
		int l = left;
		int r = mid + 1;
		int idx = left;
		while (l <= mid && r <= right) {
			if (c.compare(a[l], a[r]) <= 0) {
				sorted[idx++] =  (Comparable) a[l++];
			}
			else {
				sorted[idx++] =  (Comparable) a[r++];
			}
		}
		if (l > mid) {
			while (r <= right) {
				sorted[idx++] = (Comparable) a[r++];
			}
		} else {
			while (l <= mid) {
				sorted[idx++] = (Comparable) a[l++];
			}
		}
		System.arraycopy(sorted, left, a, left, right - left + 1);
	}
	public static void sort(byte[] a, boolean isReverse) {
		if(isReverse) {
			Byte[] b = Convert.toByteArray(a);
			sort(b, Order.reverseOrder());
			Convert.tobyteArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(char[] a, boolean isReverse) {
		if(isReverse) {
			Character[] b = Convert.toCharacterArray(a);
			sort(b, Order.reverseOrder());
			Convert.tocharArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(short[] a, boolean isReverse) {
		if(isReverse) {
			Short[] b = Convert.toShortArray(a);
			sort(b, Order.reverseOrder());
			Convert.toshortArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(int[] a, boolean isReverse) {
		if(isReverse) {
			Integer[] b = Convert.toIntegerArray(a);
			sort(b, Order.reverseOrder());
			Convert.tointtArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(long[] a, boolean isReverse) {
		if(isReverse) {
			Long[] b = Convert.toLongArray(a);
			sort(b, Order.reverseOrder());
			Convert.tolongArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(float[] a, boolean isReverse) {
		if(isReverse) {
			Float[] b = Convert.toFloatArray(a);
			sort(b, Order.reverseOrder());
			Convert.toflostArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(double[] a, boolean isReverse) {
		if(isReverse) {
			Double[] b = Convert.toDoubleArray(a);
			sort(b, Order.reverseOrder());
			Convert.todoubleArray(b, a);
		}
		else {
			sort(a);
		}
	}
}",0,1,0,0,0,0,0,0,0
871,"import java.util.Scanner;
public class MergeSort
{
   static void merge(int arr[] , int beg , int mid , int end)
    {
        int nl = mid - beg +1 , nr = end-mid;
        int leftArr[] = new int[nl];
        int rightArr[] = new int[nr];
        for (int i = 0; i < nl; i++) {
            leftArr[i] = arr[beg+i];
        }
        for (int i = 0; i < nr; i++) {
            rightArr[i] = arr[mid +1 + i];
        }
        int i=0 , j=0 , k=beg;
        while(i<nl && j<nr){
            if(leftArr[i] <= rightArr[j])
            {
                arr[k]=leftArr[i];
                i++;
                k++;
            }
            else{
                arr[k]=rightArr[j];
                j++;
                k++;
            }
        }
        while(i<nl){
            arr[k]=leftArr[i];
            i++;
            k++;
        }
        while(j<nr){
            arr[k]=rightArr[j];
            j++;
            k++;
        }
    }
    static void mergeSort(int [] arr, int beg , int end )
    {
        if(beg<end)
        {
            int mid = (beg + end) /2;
            mergeSort(arr,beg,mid);
            mergeSort(arr,mid+1,end);
            merge(arr,beg,mid,end);
        }
    }
    static void print(int arr[],int n)
    {
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i]+"" "");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements: "");
        int n = sc.nextInt();
        int arr[] = new int [n];
        System.out.print(""Enter elements : "");
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.print(""Array before sort: "");
        print(arr,n);
        mergeSort(arr,0,n-1);
        System.out.print(""Array after sort: "");
        print(arr,n);
    }
}",0,1,0,0,0,0,0,0,0
872,"function merge (left, right) {
	let i = 0;
	let j = 0;
	let size = left.length + right.length;
	let arr = [];
	for (let k = 0; k < size; k++) {
		if (i > left.length - 1 && j < right.length) {
			arr[k] = right[j];
			j++;
		} else if (j > right.length - 1 && i < left.length) {
			arr[k] = left[i];
			i++;
		} else if (left[i] < right[j]) {
			arr[k] = left[i];
			i++;
		} else {
			arr[k] = right[j];
			j++;
		}
	}
	return arr;
}
function mergeSort (arr) {
	if (arr.length < 2) {
		return arr;
	}
	let middle = parseInt(arr.length / 2);
	let left = arr.slice(0, middle);
	let right = arr.slice(middle, arr.length);
	return merge(mergeSort(left), mergeSort(right));
}
function main () {
	let arr = [2, 1, 6, 444, 8, 99, 10];
	console.log('Sorted data is :');
	arr = mergeSort(arr);
	console.log(arr);
}
main();",0,1,0,0,0,0,0,0,0
873,"""use strict"";
Array.prototype.mergesort = function(compare) {
    if (""function"" != typeof compare) {
        var desc = compare || false;
        compare = function(a, b) {
            return desc ? a < b : a > b;
        }
    }
    var that = this;
    function merge(left, right) {
        var result = [];
        var il = 0, ir = 0;
        var llen = left.length, rlen = right.length;
        while (il < llen && ir < rlen) {
            if (compare(right[ir], left[il])) {
                result.push(left[il]);
                il += 1;
            } else {
                result.push(right[ir]);
                ir += 1;
            }
        }
        if (il < llen) {
            result = result.concat(left.slice(il));
        }
        if (ir < rlen) {
            result = result.concat(right.slice(ir));
        }
        return result;
    }
    function sort(array) {
        var max = array.length;
        if (max <= 1) {
            return array;
        }
        var mid = max >> 1;
        var left = sort(array.slice(0, mid));
        var right = sort(array.slice(mid, max));
        return merge(left, right);
    }
    return sort(this);
}",0,1,0,0,0,0,0,0,0
874,"import random
def merge_sort(alist):
    if len(alist) > 1:
        middle = len(alist) // 2
        left = alist[:middle]
        right = alist[middle:]
        merge_sort(left)
        merge_sort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                alist[k] = left[i]
                i += 1
            else:
                alist[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            alist[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            alist[k] = right[j]
            j += 1
            k += 1
unordered_list = []
for i in range(100):
    unordered_list.append(i)
random.shuffle(unordered_list)
merge_sort(unordered_list)
print(unordered_list)
success = True
for index in range(len(unordered_list) - 1):
    if unordered_list[index] > unordered_list[index + 1]:
        success = False
if success:
    print(""Merge Sort successful!"")",0,1,0,0,0,0,0,0,0
875,"import java.util.*;
public class MergeSort {
	void merge(int a[], int low, int mid, int high)
	{
		int b[]= new int[high-low+1];
		int i=low;
		int j= mid+1;
		int k=0;
		while(i<=mid && j<=high)
			b[k++]=a[i]<a[j]?a[i++]:a[j++];
		while(i<=mid)
			b[k++]=a[i++];
		while(j<=high)
			b[k++]=a[j++];
		System.arraycopy(b, 0, a, low, b.length);
	}
	void mergeSort(int a[],int low, int high)
	{
		if(low<high)
		{			
			int mid = (low+high)/2;
			mergeSort(a,low,mid);
			mergeSort(a,mid+1,high);
			merge(a,low,mid,high);
			System.out.println(Arrays.toString(a));
		}
	}
	public static void main(String args[])
	{
		MergeSort m = new MergeSort();
		int a[] = {2,4,1,6,8,5,3,7};
		m.mergeSort(a,0,a.length-1);	
	}
}",0,1,0,0,0,0,0,0,0
876,"package ro.geo.sorting.mergesort;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class MergeSort {
	public static void sort(Integer[] unsortedArray){
		List<Integer> result = sort(new ArrayList<Integer>(Arrays.asList(unsortedArray)));
		for(int i = 0; i < result.size(); i++){
			unsortedArray[i] = result.get(i);
		}
	}
	private static List<Integer> sort(List<Integer> unsortedArray){
		if(unsortedArray.size() <= 1){
			return unsortedArray;
		}
		int arrayLength = unsortedArray.size();
		int middle = arrayLength / 2;
        List<Integer> left = new ArrayList<>();
        List<Integer> right = new ArrayList<>();
		for(int i = 0; i < arrayLength; i++){
			if(i < middle){
				left.add(unsortedArray.get(i));
			} else{
				right.add(unsortedArray.get(i));
			}
		}
		left = sort(left);
		right = sort(right);
		return merge(left, right);
	}
	private static List<Integer> merge(List<Integer> left, List<Integer> right){
		List<Integer> result = new ArrayList<>(left.size() + right.size());
		while( (!left.isEmpty()) && (!right.isEmpty()) ){
			if(left.get(0) <= right.get(0)){
				result.add(left.get(0));
				left = rest(left, left.get(0));
			} else{
				result.add(right.get(0));
				right = rest(right, right.get(0));
			}
		}
		while( !left.isEmpty() ){
			result.add(left.get(0));
			left = rest(left, left.get(0));
		}
		while( !right.isEmpty() ){
			result.add(right.get(0));
			right = rest(right, right.get(0));
		}
		return result;
	}
	private static List<Integer> rest(List<Integer> list, Integer elementToRemove){
		list.remove(list.indexOf(elementToRemove));
		return new ArrayList<>(list);
	}
}",0,1,0,0,0,0,0,0,0
877,"package Sorting;
import Comparing.BaseAreaCompare;
import Comparing.VolumeCompare;
import Objects.ThreeDGeoShape;
public class MergeSort {
	public ThreeDGeoShape[] sort(String sortBy, ThreeDGeoShape[] shapeArray, int length) {
		if (length < 2) {
			return shapeArray;
		}
			int middle = length /2;
			ThreeDGeoShape leftArray[] = new ThreeDGeoShape[middle];
			ThreeDGeoShape rightArray[] = new ThreeDGeoShape[length - middle];
			for (int i=0; i < middle; i++) {
				leftArray[i] = shapeArray[i];
			}
			for (int i= middle; i < length; i++) {
				rightArray[i - middle] = shapeArray[i];
			}
			sort(sortBy, leftArray, middle);
			sort(sortBy, rightArray, length - middle);
			shapeArray = merge(sortBy, shapeArray, leftArray, rightArray, middle, length - middle);
		return shapeArray;
	}
	private ThreeDGeoShape[] merge(String sortBy, ThreeDGeoShape[] shapeArray,ThreeDGeoShape[] leftArray, ThreeDGeoShape[] rightArray, int left, int right) {
		int i = 0;
		int j = 0;
		int k = 0 ;
		int result = 0;
		BaseAreaCompare ac = new BaseAreaCompare();
		VolumeCompare vc = new VolumeCompare();
		while( i < left && j < right) {
			if (sortBy.equalsIgnoreCase(""h"")) {
				result = leftArray[i].compareTo(rightArray[j]);
			}else if (sortBy.equalsIgnoreCase(""a"")) {
				result = ac.compare(leftArray[i], rightArray[j]);
			}else if (sortBy.equalsIgnoreCase(""v"")) {
				result = vc.compare(leftArray[i], rightArray[j]);
			}
			if (result == 1) {
				shapeArray[k] = leftArray[i];
				i++;
			}else {
				shapeArray[k] = rightArray[j];
				j++;
			}
			k++;
		}
		while (j < right) {
			shapeArray[k] = rightArray[j];
			j++;
			k++;
		}
		while (i < left) {
			shapeArray[k] = leftArray[i];
			i++;
			k++;
		}
		return shapeArray;
	}
}",0,1,0,0,0,0,0,0,0
878,"public class MergeSort {
    @SuppressWarnings(""unchecked"")
    public static<T extends Comparable<T>> void mergeSort(T[] arr) {
        if (arr.length == 1) {
            return;
        }
        int mid = arr.length/2;
        T[] l = (T[]) new Comparable[mid];
        T[] r = (T[]) new Comparable[arr.length - mid];
        for (int i = 0; i < mid; i++) {
            l[i] = arr[i];
        }
        for (int i = mid; i < arr.length; i++) {
            r[i - mid] = arr[i];
        }
        mergeSort(l);
        mergeSort(r);
        merge(arr, l, r);
    }
    private static<T extends Comparable<T>> void merge(T[] arr, T[] leftArr, T[] rightArr) {
        int index = 0, i, j;
        for (i = 0, j = 0; i < leftArr.length && j < rightArr.length;) {
            if (leftArr[i].compareTo(rightArr[j]) <= 0) {
                arr[index++] = leftArr[i++];
            } else {
                arr[index++] = rightArr[j++];
            }
        }
        while (i < leftArr.length) {
            arr[index++] = leftArr[i++];
        }
        while (j < rightArr.length) {
            arr[index++] = rightArr[j++];
        }
    }
    public static void main(String[] args) {
        Integer[] arr = {5, 1, 3, 9, 23, 8, 7, 4};
        mergeSort(arr);
        int[] sorted = new int[arr.length];
        for (int i = 0; i < sorted.length; i++) {
            sorted[i] = arr[i];
        }
        printArr(sorted);
    }
    private static void printArr(int[] arr)  {
        for (int i : arr) {
            System.out.print(i + "" "");
        }
        System.out.print(""\n"");
    }
}",0,1,0,0,0,0,0,0,0
879,"public class MergeSort{
    void merge(int[] arr,int l,int m,int r){
        int n1=m-l+1;
        int n2=r-m;
        int L[]=new int[n1];
        int R[]=new int[n2];
        for(int i=0;i<n1;++i){
            L[i]=arr[l+i];
        }
        for(int j=0;j<n2;++j){
           R[j]=arr[m+1+j]; 
        }
        int i=0;int j=0;
        int k=1;
        while(i<n1 && j<n2){
            if(L[i]<=R[i]){
                arr[k]=L[i];
                i++;
            }else{
                arr[k]=R[j];
                j++;
            }
            k++;
        }
        while(i<n1){
            arr[k]=L[i];
            i++;
            k++;
        }
        while(j<n2){
            arr[k]=R[j];
            j++;
            k++;
        }
    }
    void sort(int arr[],int l,int r){
        if(l<r){
            int m=l+(r-l)/2;
            sort(arr,l,m);
            sort(arr,m+1,r);
            merge(arr,l,m,r);
            }
    }
    static void printArray(int arr[]){
        int n=arr.length;
        for(int i=0;i<n;i++){
            System.out.println(arr[i]+"" "");
        }
    }
    public static void main(String args[]){
        int arr[]={4,29,30,6,20,2};
        MergeSort obj=new MergeSort();
        obj.sort(arr,0,arr.length-1);
        System.out.println(""Sorted array is"");
        printArray(arr);
    }
}",0,1,0,0,0,0,0,0,0
880,"import java.lang.Comparable;
import java.util.List;
import java.util.ArrayList;
public class MergeSort<T extends Comparable<T>> implements SortingAlg<T> {
    private List<T> buffer;
    @Override
    public void sort(List<T> elements) {
        if (elements == null)
            return;
        this.buffer = new ArrayList<T>(elements.size());
        sort(elements, 0, elements.size() - 1);
        this.buffer = null;
    }
    private void sort(List<T> elements, int min, int max) {
        if (min == max)
            return;
        int mid = (min + max) >> 1;
        sort(elements, min, mid);
        sort(elements, mid + 1, max);
        merge(elements, min, mid, max);
    }
    private void merge(List<T> elements, int min, int mid, int max) {
        if (lessThanOrEquals(elements.get(mid), elements.get(mid+1)))
            return;
        for (int k = min; k <= max; k++)
            this.buffer.add(k, elements.get(k));
        int left = min;
        int right = mid + 1;
        for (int k = min; k <= max; k++) {
            if (left > mid)
                elements.set(k, this.buffer.get(right++));
            else if (right > max)
                elements.set(k, this.buffer.get(left++));
            else if (lessThan(this.buffer.get(left), this.buffer.get(right)))
                elements.set(k, this.buffer.get(left++));
            else
                elements.set(k, this.buffer.get(right++));
        }
    }
    private boolean lessThanOrEquals(T first, T second) {
        return (first.compareTo(second) <= 0);
    }
    private boolean lessThan(T first, T second) {
        return (first.compareTo(second) < 0);
    }
    public static void main(String[] args) {
        SortingAlg<Integer> alg = new MergeSort<Integer>();
        List<Integer> elems = java.util.Arrays.asList(9,5,2,7,3,8,2,1,4,7,5,3,9);
        alg.sort(elems);
        for (int i = 0; i < elems.size() - 1; i++) {
            if (elems.get(i).compareTo(elems.get(i+1)) > 0)
                throw new java.lang.RuntimeException(""Elems should be sorted."");
        }
        System.out.println(""All tests passed."");
    }
}",0,1,0,0,0,0,0,0,0
881,"import java.util.Arrays;
public class MergeSort {
	public void mergeSort(int[] A) {
		mergeSort(A, new int[A.length], 0, A.length - 1);
	}
	private void mergeSort(int[] A, int[] tmp, int leftStart, int rightEnd) {
		if (leftStart >= rightEnd) {
			return;
		}
		int middle = (leftStart + rightEnd) / 2;
		mergeSort(A, tmp, leftStart, middle);
		mergeSort(A, tmp, middle + 1, rightEnd);
		merge(A, tmp, leftStart, rightEnd);
	}
	private void merge(int[] A, int[] tmp, int leftStart, int rightEnd) {
		int leftEnd = (leftStart + rightEnd) / 2;
		int rightStart = leftEnd + 1;
		int size = rightEnd - leftStart + 1;
		int left = leftStart;
		int right = rightStart;
		int tmpIdx = leftStart;
		while (left <= leftEnd && right <= rightEnd) {
			if (A[left] <= A[right]) {
				tmp[tmpIdx] = A[left];
				left ++;
			} else {
				tmp[tmpIdx] = A[right];
				right ++;
			}
			tmpIdx ++;
		}
		System.arraycopy(A, left, tmp, tmpIdx, leftEnd - left + 1);
		System.arraycopy(A, right, tmp, tmpIdx, rightEnd - right + 1);
		System.arraycopy(tmp, leftStart, A, leftStart, size);
	}
	public static void main(String[] args) {
		int[] A = {4, 5, 9, 2, 0, 1, 6, 8, 3, 7};
		MergeSort ms = new MergeSort();
		System.out.println(""unsorted: "" + Arrays.toString(A));
		ms.mergeSort(A);
		System.out.println(""sorted: "" + Arrays.toString(A));
	}
}",0,1,0,0,0,0,0,0,0
882,"package sorting.algorithms;
public class MergeSort {
}",0,0,0,0,0,0,0,0,0
883,"public class MergeSort {
    public static void sort(int[] a) {
        int[] helper = new int[a.length];
        sort(a, 0, a.length - 1, helper);
    }
    public static void sort(int[] a, int low, int high, int[] helper) {
        if (low >= high) {
            return;
        }
        int middle = low + (high - low) / 2;
        sort(a, low, middle, helper);
        sort(a, middle + 1, high, helper);
        merge(a, low, middle, high, helper);
    }
    public static void merge(int[] a, int low, int middle, int high, int[] helper) {
        for (int i = low; i <= high; i++) {
            helper[i] = a[i];
        }
        int i = low;
        int j = middle + 1;
        for (int k = low; k <= high; k++) {
            if (i > middle) {
                a[k] = helper[j++];
            } else if (j > high) {
                a[k] = helper[i++];
            } else if (helper[i] <= helper[j]) {
                a[k] = helper[i++];
            } else {
                a[k] = helper[j++];
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
884,"exports.mergeSort = ({ list }, { shouldSwap }) => {
  const getMiddleIndex = (startIndex, endIndex) => (
    startIndex + Math.floor((endIndex - startIndex) / 2)
  );
  const partitionAndSort = (startIndex = 0, endIndex = list.length - 1) => {
    if (endIndex - startIndex <= 0) return [startIndex, startIndex + 1];
    const middleIndex = getMiddleIndex(startIndex, endIndex);
    const leftPartition = partitionAndSort(startIndex, middleIndex);
    const rightPartition = partitionAndSort(middleIndex + 1, endIndex);
    const [leftStart, leftEnd] = leftPartition;
    const [rightStart, rightEnd] = rightPartition;
    const merged = [];
    let leftIndex = leftStart;
    let rightIndex = rightStart;
    while (leftIndex < leftEnd || rightIndex < rightEnd) {
      if (rightIndex === rightEnd) {
        merged.push(list[leftIndex]);
        leftIndex += 1;
      } else if (leftIndex === leftEnd) {
        merged.push(list[rightIndex]);
        rightIndex += 1;
      } else if (shouldSwap(leftIndex, rightIndex)) {
        merged.push(list[rightIndex]);
        rightIndex += 1;
      } else {
        merged.push(list[leftIndex]);
        leftIndex += 1;
      }
    }
    let j = 0;
    for (let i = leftStart; i < rightEnd; i += 1) {
      list[i] = merged[j];  
      j += 1;
    }
    return [leftStart, rightEnd];
  };
  partitionAndSort();
  return list;
};",0,1,0,0,0,0,0,0,0
885,"def compare(a,b):
    return True if a < b else False
def merge_sort(sort_list):
    if len(sort_list)>1:
        mid = len(sort_list)//2
        left_half = merge_sort(sort_list[:mid])
        right_half = merge_sort(sort_list[mid:])
        output = []
        while left_half!=[] and right_half!=[]:
            output.append(left_half.pop(0) if compare(left_half[0],right_half[0]) else right_half.pop(0))
        output += left_half+right_half
        return output
    else:
        return sort_list",0,1,0,0,0,0,0,0,0
886,"package com.intrafoundation;
public class MergeSort extends BaseSort {
    public void sort(int[] arr) {
        if (arr.length <= 1)
            return;
        swaps = 0;
        mergeSort(arr, arr.length);
    }
    public void mergeSort(int[] arr, final int len) {
        if (len < 2) {
            return;
        }
        final int mid = len / 2;
        final int lenmid = len - mid;
        int[] l = new int[mid];
        int[] r = new int[lenmid];
        System.arraycopy(arr, 0, l, 0, mid);
        if (lenmid >= 0)
            System.arraycopy(arr, mid, r, 0, lenmid);
        mergeSort(l, mid);
        mergeSort(r, lenmid);
        merge(arr, l, r, mid, lenmid);
        swaps++;
    }
    public static void merge(
            int[] a, int[] l, int[] r, final int left, final int right
    ) {
        int i = 0, j = 0, k = 0;
        while (i < left && j < right) {
            if (l[i] <= r[j]) {
                a[k++] = l[i++];
            } else {
                a[k++] = r[j++];
            }
        }
        while (i < left) {
            a[k++] = l[i++];
        }
        while (j < right) {
            a[k++] = r[j++];
        }
    }
}",0,1,0,0,0,0,0,0,0
887,"package ie.gmit.dip;
import java.util.Random;
public class MergeSort {
    public static void main(String[] args) {
        Random g = new Random();
       int [] number = new int [10000];  
        System.out.print(""Random Numbers:"");
        for (int d = 0 ; d<number.length ; d++){
            int RandomG = g.nextInt(number.length)+1;
            number[d] = RandomG;
            System.out.print("" "" +RandomG);
        }
        System.out.println(""Given Array""); 
        printArray(number); 
        long startTime= System.nanoTime();
        MergeSort ob = new MergeSort(); 
        ob.sort(number, 0, number.length-1); 
        System.out.println(""\nSorted array""); 
        printArray(number); 
        long endTime= System.nanoTime();
        long elapsed = endTime-startTime;
        double timeMillis= elapsed/1000000.0;
        System.out.print(""\nSorted In: ""+ timeMillis );
        System.out.print(""\n"" );
    }
    void merge(int number[], int l, int m, int r) 
    { 
        int n1 = m - l + 1; 
        int n2 = r - m; 
        int L[] = new int [n1]; 
        int R[] = new int [n2]; 
        for (int i=0; i<n1; ++i) 
            L[i] = number[l + i]; 
        for (int j=0; j<n2; ++j) 
            R[j] = number[m + 1+ j]; 
        int i = 0, j = 0; 
        int k = l; 
        while (i < n1 && j < n2) 
        { 
            if (L[i] <= R[j]) 
            { 
                number[k] = L[i]; 
                i++; 
            } 
            else
            { 
                number[k] = R[j]; 
                j++; 
            } 
            k++; 
        } 
        while (i < n1) 
        { 
            number[k] = L[i]; 
            i++; 
            k++; 
        } 
        while (j < n2) 
        { 
            number[k] = R[j]; 
            j++; 
            k++; 
        } 
    } 
    void sort(int number[], int l, int r) 
    { 
        if (l < r) 
        { 
            int m = (l+r)/2; 
            sort(number, l, m); 
            sort(number , m+1, r); 
            merge(number, l, m, r); 
        } 
    } 
    static void printArray(int number[]) 
    { 
        int n = number.length; 
        for (int i=0; i<n; ++i) 
            System.out.print(number[i] + "" ""); 
        System.out.println(); 
    } 
} ",0,1,0,0,0,0,0,0,0
888,"class MergeSort
{
	void merge(int arr[], int l, int m, int r)
	{
		int n1 = m - l + 1;
		int n2 = r - m;
		int L[] = new int[n1];
		int R[] = new int[n2];
		for (int i = 0; i < n1; ++i)
			L[i] = arr[l + i];
		for (int j = 0; j < n2; ++j)
			R[j] = arr[m + 1 + j];
		int i = 0, j = 0;
		int k = l;
		while (i < n1 && j < n2) {
			if (L[i] <= R[j]) {
				arr[k] = L[i];
				i++;
			}
			else {
				arr[k] = R[j];
				j++;
			}
			k++;
		}
		while (i < n1) {
			arr[k] = L[i];
			i++;
			k++;
		}
		while (j < n2) {
			arr[k] = R[j];
			j++;
			k++;
		}
	}
	void sort(int arr[], int l, int r)
	{
		if (l < r) {
			int m =l+ (r-l)/2;
			sort(arr, l, m);
			sort(arr, m + 1, r);
			merge(arr, l, m, r);
		}
	}
	static void printArray(int arr[])
	{
		int n = arr.length;
		for (int i = 0; i < n; ++i)
			System.out.print(arr[i] + "" "");
		System.out.println();
	}
	public static void main(String args[])
	{
		int arr[] = { 12, 11, 13, 5, 6, 7 };
		System.out.println(""Given Array"");
		printArray(arr);
		MergeSort ob = new MergeSort();
		ob.sort(arr, 0, arr.length - 1);
		System.out.println(""\nSorted array"");
		printArray(arr);
	}
}",0,1,0,0,0,0,0,0,0
889,"package mergesort;
public class MergeSort<T extends Comparable>
{
    private final T[] items, aux;
    public MergeSort(T[] items)
    {
        this.items = items;
        this.aux = (T[]) new Comparable[items.length];
    }
    public void sort()
    {
        this.sort(0, this.items.length - 1);
    }
    private void sort(int low, int high)
    {
        if (low >= high)
        {
            return;
        }
        int mid = low + ((high - low) / 2);
        this.sort(low, mid);
        this.sort(mid + 1, high);
        this.merge(low, mid, high);
    }
    private void merge(int low, int mid, int high)
    {
        int i = low;         
        int j = low;         
        int k = mid + 1;     
        for (int x = low; x <= high; x++)
        {
            this.aux[x] = this.items[x];
        }
        while (j <= mid || k <= high)
        {
            if (j > mid)
            {
                this.items[i] = this.aux[k++];
            }
            else if (k > high)
            {
                this.items[i] = this.aux[j++];
            }
            else if (this.aux[j].compareTo(this.aux[k]) > 0)
            {
                this.items[i] = this.aux[k++];
            }
            else
            {
                this.items[i] = this.aux[j++];
            }
            i++;     
        }
    }
    public T[] getSortedItems()
    {
        return this.items;
    }
}",0,1,0,0,0,0,0,0,0
890,"package project1.sorts;
import project1.ExperimentalResultsData;
public final class MergeSort<E extends Comparable<E>> implements Sort<E> {
    @Override
    public SortType sort(ExperimentalResultsData experimentalResultsData, E[] list) {
        if (list.length > 1) {
            E[] firstHalf = (E[]) new Comparable[list.length / 2];
            System.arraycopy(list, 0, firstHalf, 0, list.length / 2);
            sort(experimentalResultsData, firstHalf);
            int secondHalfLength = list.length - list.length / 2;
            E[] secondHalf = (E[]) new Comparable[secondHalfLength];
            System.arraycopy(list, list.length / 2, secondHalf, 0, secondHalfLength);
            sort(experimentalResultsData, secondHalf);
            merge(experimentalResultsData, firstHalf, secondHalf, list);
        }
        return SortType.MERGE_SORT;
    }
    private void merge(ExperimentalResultsData experimentalResultsData, E[] list1, E[] list2, E[] temp) {
        int current1 = 0;
        int current2 = 0;
        int current3 = 0;
        while (current1 < list1.length && current2 < list2.length) {
            experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
            if (list1[current1].compareTo(list2[current2]) < 0) {
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
                temp[current3++] = list1[current1++];
            } else {
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
                temp[current3++] = list2[current2++];
            }
            while (current1 < list1.length) {
                experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
                temp[current3++] = list1[current1++];
            }
            while (current2 < list2.length) {
                experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
                temp[current3++] = list2[current2++];
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
891,"package io.lenur.sort;
public class MergeSort implements Sortable {
    @Override
    public void sort(int[] data) {
        sort(data, 0, data.length - 1);
    }
    private void sort(int[] data, int left, int right) {
        if (left < right) {
            int middle = (left + right) / 2;
            sort(data, left, middle);
            sort(data, middle + 1, right);
            merge(data, left, middle, right);
        }
    }
    private void merge(int[] data, int left, int middle, int right) {
        int n1 = middle - left + 1;
        int n2 = right - middle;
        int[] lData = new int[n1];
        int[] rData = new int[n2];
        if (n1 >= 0) {
            System.arraycopy(data, left, lData, 0, n1);
        }
        for (int j = 0; j < n2; j++) {
            rData[j] = data[middle + 1 + j];
        }
        int i = 0, j = 0;
        int k = left;
        while (i < n1 && j < n2) {
            if (lData[i] <= rData[j]) {
                data[k] = lData[i];
                i++;
            } else {
                data[k] = rData[j];
                j++;
            }
            k++;
        }
        while (i < n1) {
            data[k] = lData[i];
            i++;
            k++;
        }
        while (j < n2) {
            data[k] = rData[j];
            j++;
            k++;
        }
    }
}",0,1,0,0,0,0,0,0,0
892,"package sortingalgorithms;
import cnode.CNode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javafx.animation.FillTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.Transition;
import javafx.scene.paint.Color;
import javafx.util.Duration;
public class MergeSort extends AbstractSort {
  private CNode[] tmp;
  private ArrayList<Transition> merge(CNode[] arr, int p, int q, int r) {
    ArrayList<Transition> transitions = new ArrayList<>();
    List<CNode> tmpList = new ArrayList<>();
    for (int i = p; i <= r; i++) {
      tmp[i] = arr[i];
      tmpList.add(tmp[i]);
    }
    int i = p;
    int j = q + 1;
    int k = p;
    while (i <= q && j <= r) {
      if (tmp[i].getValue() <= tmp[j].getValue()) {
        arr[k++] = tmp[i++];
      } else {
        arr[k++] = tmp[j++];
      }
    }
    while (i <= q) {
      arr[k++] = tmp[i++];
    }
    while (j <= r) {
      arr[k++] = tmp[j++];
    }
    transitions.add(colorCNode(tmpList, SELECT_COLOR));
    ParallelTransition pt = new ParallelTransition(); 
    for (int x = p; x <= r; x++) {
      for (int y = p; y <= r; y++) {
        if (tmp[x].equals(arr[y])) {
          pt.getChildren().add(tmp[x].moveX(DX * (y - x)));
        }
      }
    }
    transitions.add(pt);
    transitions.add(colorCNode(tmpList, SELECT_COLOR));
    return transitions;
  }
  private ArrayList<Transition> mergeSort(CNode[] arr, int p, int r) {
    ArrayList<Transition> transitions = new ArrayList<>();
    if (p < r) {
      int q = (p + r) / 2;
      transitions.addAll(mergeSort(arr, p, q));
      transitions.addAll(mergeSort(arr, q + 1, r));
      transitions.addAll(merge(arr, p, q, r));
    }
    return transitions;
  }
  @Override
  public ArrayList<Transition> startSort(CNode[] arr) {
    ArrayList<Transition> transitions = new ArrayList<>();
    this.tmp = new CNode[arr.length];
    transitions.addAll(mergeSort(arr, 0, arr.length - 1));
    transitions.add(colorCNode(Arrays.asList(arr), SORTED_COLOR));
    return transitions;
  }
}",0,1,0,0,0,0,0,0,0
893,"package sorts;
import java.util.Arrays;
public class MergeSort {
    public static int[] sort(int[] arr) {
        if(arr.length == 1) {
            return arr;
        }
        int[] frontHalf = Arrays.copyOfRange(arr, 0, arr.length / 2);
        int[] backHalf = Arrays.copyOfRange(arr, arr.length / 2, arr.length);
        return merge(sort(frontHalf), sort(backHalf));
    }
    private static int[] merge(int[] a, int[] b) {
        int i = 0, j = 0;
        int merged[] = new int[a.length + b.length];
        while(i < a.length && j < b.length) {
            if(a[i] < b[j]) {
                merged[i + j] = a[i];
                i++;
            } else {
                merged[i + j] = b[j];
                j++;
            }
        }
        while(i < a.length) {
            merged[i + j] = a[i];
            i++;
        }
        while(j < b.length) {
            merged[i + j] = b[j];
            j++;
        }
        return merged;
    }
}",0,1,0,0,0,0,0,0,0
894,"import java.util.Arrays;
import java.util.Scanner;
public class Mergesort {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Mergesort Algorithm"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSort = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSort[i] = input.nextInt();
        }
        int[] sortedArray = mergesort(arrayOfIntegersToSort);
        System.out.printf(""Sorted array using Mergesort Algorithm: %s%n"",
                Arrays.toString(sortedArray));
        input.close();
    }
    private static int[] mergesort(int[] arrayToSort) {
        mergeSortRecursively(arrayToSort, 0, arrayToSort.length);
        return arrayToSort;
    }
    public static void mergeSortRecursively(int[] input, int start, int end) {
        if (end - start < 2) {
            return;
        }
        int mid = (start + end) / 2;
        mergeSortRecursively(input, start, mid);
        mergeSortRecursively(input, mid, end);
        merge(input, start, mid, end);
    }
    public static void merge(int[] input, int start, int mid, int end) {
        if (input[mid - 1] <= input[mid]) {
            return;
        }
        int i = start;
        int j = mid;
        int tempIndex = 0;
        int[] tempArray = new int[end - start];
        while (i < mid && j < end) {
            tempArray[tempIndex++] = input[i] <= input[j] ? input[i++] : input[j++];
        }
        System.arraycopy(input, i, input, start + tempIndex, mid - i);
        System.arraycopy(tempArray, 0, input, start, tempIndex);
    }
}",0,1,0,0,0,0,0,0,0
895,"package sortAlgorithms;
import helperUtils.Utility;
public class MergeSort {
  public static void main(String args[]) {
    int[] inputArr = { 10, -80, 5, 76, 92, 100, 52, 1, -10 };
    Utility.printArray(inputArr, true, ""Merge Sort"");
    mergeSort(inputArr, 0, inputArr.length);
    Utility.printArray(inputArr, false, null);
  }
  public static void mergeSort(int[] arr, int start, int end) {
    split(arr, start, end);
  }
  public static void split(int[] arr, int start, int end) {
    if (end - start < 2) {
      return;
    }
    int mid = (start + end) / 2;
    split(arr, start, mid);
    split(arr, mid, end);
    merge(arr, start, mid, end);
  }
  public static void merge(int[] arr, int start, int mid, int end) {
    if (arr[mid - 1] <= arr[mid]) {
      return;
    }
    int i = start;
    int j = mid;
    int tempIndex = 0;
    int[] temp = new int[end - start];
    while ((i < mid) && (j < end)) {
      temp[tempIndex++] = arr[i] > arr[j] ? arr[j++] : arr[i++];
    }
    System.arraycopy(arr, i, arr, start + tempIndex, mid - i);
    System.arraycopy(temp, 0, arr, start, tempIndex);
  }
}",0,1,0,0,0,0,0,0,0
896,"aij.mergeSort = function(items) {
    var merge = function(left, right) {
        var result = [];
        while (left.length || right.length) {
            result.push(
                left.length && left[0] <= (right[0] || Number.MAX_VALUE) ?
                left.shift() :
                right.shift());
        }
        return result;
    }
    var sort = function(arr) {
        var middle = arr && (arr.length / 2) << 0;
        if (!middle) {
            return arr;
        } else if (arr.length === 2) {
            return arr[1] < arr[0] ? arr.reverse() : arr;
        }
        return merge(sort(arr.slice(0, middle)), sort(arr.slice(middle)));
    }
    return sort(items);
};",0,1,0,0,0,0,0,0,0
897,"class Mergesort:
      vec = []
      len = -1
      def __init__(self,arr):
          self.vec = arr
          self.len = len(arr)
      def sort(self):
          self._divimp(0,self.len-1)
      def _merge(self,li,m,ls):
          i = li
          j = m+1
          k = li
          b = []
          for bb in range(0,self.len):
              b.append(0) 
          for t in range(li,ls+1): 
              b[t] = self.vec[t]
          while i<=m and j<=ls:
              if b[i]<b[j]:
                 self.vec[k] = b[i]
                 k = k + 1
                 i = i + 1
              else:
                 self.vec[k] = b[j]
                 k = k + 1
                 j = j + 1
          if i<=m:
             for w in range(i,m+1):
                 self.vec[k] = b[w]   
                 k = k + 1
          if j<=ls:
             for w in range(j,ls+1):
                 self.vec[k] = b[w]
                 k = k + 1
      def _divimp(self,li,ls):
          if li == ls:
             return
          m = (li+ls)/2
          self._divimp(li,m)
          self._divimp(m+1,ls)
          self._merge(li,m,ls)
      def get(self):
          return self.vec 
arr = [9,8,7,6,5,4,3,2,1,-1,111,-1221,0,12]
obj = Mergesort(arr)
obj.sort()
print obj.get()",0,1,0,0,0,0,0,0,0
898,"package com.jwetherell.algorithms.sorts;
@SuppressWarnings(""unchecked"")
public class MergeSort<T extends Comparable<T>> {
    public static enum SPACE_TYPE { IN_PLACE, NOT_IN_PLACE }
    private MergeSort() { }
    public static <T extends Comparable<T>> T[] sort(SPACE_TYPE type, T[] unsorted) {
        sort(type, 0, unsorted.length, unsorted);
        return unsorted;
    }
    private static <T extends Comparable<T>> void sort(SPACE_TYPE type, int start, int length, T[] unsorted) {
        if (length > 2) {
            int aLength = (int) Math.floor(length / 2);
            int bLength = length - aLength;
            sort(type, start, aLength, unsorted);
            sort(type, start + aLength, bLength, unsorted);
            if (type == SPACE_TYPE.IN_PLACE)
                mergeInPlace(start, aLength, start + aLength, bLength, unsorted);
            else
                mergeWithExtraStorage(start, aLength, start + aLength, bLength, unsorted);
        } else if (length == 2) {
            T e = unsorted[start + 1];
            if (e.compareTo(unsorted[start]) < 0) {
                unsorted[start + 1] = unsorted[start];
                unsorted[start] = e;
            }
        }
    }
    private static <T extends Comparable<T>> void mergeInPlace(int aStart, int aLength, int bStart, int bLength, T[] unsorted) {
        int i = aStart;
        int j = bStart;
        int aSize = aStart + aLength;
        int bSize = bStart + bLength;
        while (i < aSize && j < bSize) {
            T a = unsorted[i];
            T b = unsorted[j];
            if (b.compareTo(a) < 0) {
                System.arraycopy(unsorted, i, unsorted, i+1, j-i);
                unsorted[i] = b;
                i++;
                j++;
                aSize++;
            } else {
                i++;
            }
        }
    }
    private static <T extends Comparable<T>> void mergeWithExtraStorage(int aStart, int aLength, int bStart, int bLength, T[] unsorted) {
        int count = 0;
        T[] output = (T[]) new Comparable[aLength + bLength];
        int i = aStart;
        int j = bStart;
        int aSize = aStart + aLength;
        int bSize = bStart + bLength;
        while (i < aSize || j < bSize) {
            T a = null;
            if (i < aSize) {
                a = unsorted[i];
            }
            T b = null;
            if (j < bSize) {
                b = unsorted[j];
            }
            if (a != null && b == null) {
                output[count++] = a;
                i++;
            } else if (b != null && a == null) {
                output[count++] = b;
                j++;
            } else if (b != null && b.compareTo(a) <= 0) {
                output[count++] = b;
                j++;
            } else {
                output[count++] = a;
                i++;
            }
        }
        int x = 0;
        int size = aStart + aLength + bLength;
        for (int y = aStart; y < size; y++) {
            unsorted[y] = output[x++];
        }
    }
}",0,1,0,0,0,0,0,0,0
899,"package Sorting;
import java.util.Scanner;
public class MergeSort {
    private static void merge(int[] array,int lb,int mid,int ub) {
        int i = lb ;
        int j = mid+1 ;
        int k = lb;
        int[] sortedArray = new int[ub+1];
        while(i <= mid && j <= ub) {
            if(array[i] < array[j]) {
                sortedArray[k] = array[i];
                i++;
            }else {
                sortedArray[k] = array[j];
                j++;
            }
            k++;
        }
        if(i > mid) {
            while (j <= ub) {
                sortedArray[k] = array[j];
                j++;
                k++;
            }
        }else {
            while (i <= mid) {
                sortedArray[k] = array[i];
                i++;
                k++;
            }
        }
        for(k = lb ; k <= ub ; k++) {
            array[k] = sortedArray[k];
        }
    }
    private static void mergeSort(int[] array, int lb, int ub) {
        if(lb < ub)  {
            int mid = lb + (ub-lb) / 2 ;
            mergeSort(array,lb,mid);
            mergeSort(array,mid+1,ub);
            merge(array,lb,mid,ub);
        }
    }
    private static void print(int[] array) {
        for(int i : array) {
            System.out.print(i + "" "");
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i= 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        System.out.print(""Before Sorting : "");
        print(array);
        long startTime = System.nanoTime();
        mergeSort(array,0,array.length-1);
        long endTime = System.nanoTime();
        System.out.print(""\nAfter Sorting : "");
        print(array);
        long totalTime = endTime - startTime;
        System.out.printf(""\nTime in seconds : %.6fs"",(totalTime/ 1000000000.0));
        sc.close();
    }
}",0,1,0,0,0,0,0,0,0
900,"package Sorting;
public class MergeSort {
    public static void main(String[] args) {
        int[] arr={20,35,-15,7,55,1,-22};
        MS(arr,0,arr.length);
        for(int j=0;j<arr.length;j++) {
            System.out.print(arr[j] + "" "");
        }
    }
    public static void MS(int [] arr,int start,int end){
        if(end - start<2){
            return;
        }
        int mid = (start+end)/2;
        MS(arr,start,mid);  
        MS(arr,mid,end);  
        merge(arr,start,mid,end);
    }
    public static void merge(int[] arr,int start,int mid,int end){
        int[] temp = new int[end-start];
        if(arr[mid-1]<= arr[mid]){
            return;
        }
        int i = start;
        int j = mid;
        int ti = 0;
        while(i<mid && j<end){
            temp[ti++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
        }
        System.arraycopy(arr,i,arr,start+ti,mid - i);
        System.arraycopy(temp,0,arr,start,ti);
    }
}",0,1,0,0,0,0,0,0,0
901,"package Java;
public class MergeSort extends Sort{
	public static void main(String[] args){
		int[] data = buildDataSet(5);
		timeSort(new MergeSort(), data);
	}
	public MergeSort(){ super(""Merge""); }
	private int[] merge(int[] data, int low, int middle, int high){
		int i = 0; 		 
		int j = 0; 		 
		int k = low; 	 
		int lenA = middle - low + 1;
		int lenB = high - middle;
		int[] dataA = new int[lenA];
		int[] dataB = new int[lenB];
		for (int idx = 0; idx < lenA; idx++)
			dataA[idx] = data[low + idx];
		for (int idx = 0; idx < lenB; idx++)
			dataB[idx] = data[middle + idx + 1];
		while ( i < lenA && j < lenB )
		{
			if ( dataA[i] < dataB[j] )
				data[k++] = dataA[i++];
			else
				data[k++] = dataB[j++];
		}
		while ( i < dataA.length )
			data[k++] = dataA[i++];
		while ( j < dataB.length )
			data[k++] = dataB[j++];
		return data;
	}
	private void mergeSort(int[] data, int low, int high){
		if ( low < high )
		{
			int middle = (high - low) / 2 + low;
			mergeSort(data, low, middle);
			mergeSort(data, middle + 1, high);
			merge(data, low, middle, high);
		}
	}
	@Override
	public void sort(int[] data){
		mergeSort(data, 0, data.length - 1);
	}
}",0,1,0,0,0,0,0,0,0
902,"function merge(left, right) {
    var result = [];
    var leftIndex = 0;
    var rightIndex = 0;
    while (leftIndex < left.length) {
        if (rightIndex >= right.length) {
            break;
        }
        if (left[leftIndex] < right[rightIndex]){
            result.push(left[leftIndex]);
            leftIndex++;
        } else {
            result.push(right[rightIndex]);
            rightIndex++;
        }
    }
    result = result.concat(left.slice(leftIndex))
    return result.concat(right.slice(rightIndex));
}
function mergeSort(items) {
    if (items.length < 2) {
        return items;
    }
    var middle = Math.floor(items.length / 2);
    var left = items.slice(0, middle);
    var right = items.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}",0,1,0,0,0,0,0,0,0
903,"def merge(left, right):
    left_len = len(left)
    right_len = len(right)
    min_len = min(left_len, right_len)
    merged_lis = []
    i, j = 0, 0
    while i < min_len and j < min_len:
        if left[i] < right[j]:
            merged_lis.append(left[i])
            i += 1
        else:
            merged_lis.append(right[j])
            j += 1
    merged_lis.extend(left[i:])
    merged_lis.extend(right[j:])
    return merged_lis
def mergesort(lis):
    n = len(lis)
    if n == 1 or n == 0:  
        return lis
    mid = n//2
    left_lis = lis[:mid]
    right_lis = lis[mid:]
    left_lis = mergesort(left_lis)  
    right_lis = mergesort(right_lis)  
    mergesorted_lis = merge(left_lis, right_lis)  
    return mergesorted_lis
def main():
    assert mergesort([4, 1, 2, 3, 9]) == [1, 2, 3, 4, 9]
    assert mergesort([1]) == [1]
    assert mergesort([2, 2, 1, -1, 0, 4, 5, 2]) == [-1, 0, 1, 2, 2, 2, 4, 5]
if __name__ == '__main__':
    main()",0,1,0,0,0,0,0,0,0
904,"package com.growingwiththeweb.sorting;
public class MergeSort {
    public static Integer[] sort(Integer[] array) {
        if (array.length <= 1)
            return array;
        int middle = array.length / 2;
        Integer[] left = new Integer[middle];
        Integer[] right = new Integer[array.length - middle];
        for (int i = 0; i < left.length; i++) {
            left[i] = array[i];
        }
        for (int i = 0; i < right.length; i++) {
            right[i] = array[i + left.length];
        }
        left = sort(left);
        right = sort(right);
        return merge(left, right);
    }
    public static Integer[] merge(Integer[] left, Integer[] right) {
        Integer[] result = new Integer[left.length + right.length];
        int leftIndex = 0;
        int rightIndex = 0;
        int resultIndex = 0;
        while (leftIndex < left.length || rightIndex < right.length) {
            if (leftIndex < left.length && rightIndex < right.length) {
                if (left[leftIndex] <= right[rightIndex]) {
                    result[resultIndex++] = left[leftIndex++];
                } else {
                    result[resultIndex++] = right[rightIndex++];
                }
            } else if (leftIndex < left.length) {
                result[resultIndex++] = left[leftIndex++];
            } else if (rightIndex < right.length) {
                result[resultIndex++] = right[rightIndex++];
            }
        }
        return result;
    }
}",0,1,0,0,0,0,0,0,0
905,"function merge(sortedArr1, sortedArr2) {
  let p1 = 0;
  let p2 = 0;
  let res = [];
  while (p1 < sortedArr1.length && p2 < sortedArr2.length) {
    if (sortedArr1[p1] < sortedArr2[p2]) {
      res.push(sortedArr1[p1]);
      p1++;
    } else {
      res.push(sortedArr2[p2]);
      p2++;
    }
  }
  while (p1 < sortedArr1.length) {
    res.push(sortedArr1[p1]);
    p1++;
  }
  while (p2 < sortedArr2.length) {
    res.push(sortedArr2[p2]);
    p2++;
  }
  return res;
}
merge([4, 6, 7], [1, 5]);",0,1,0,0,0,0,0,0,0
906,"def merge(left, right):
    if not len(left) or not len(right):
        return left or right
    result = []
    value, value_2 = 0, 0
    while (len(result) < len(left) + len(right)):
        if left[value] < right[value_2]:
            result.append(left[value])
            value+= 1
        else:
            result.append(right[value_2])
            value_2+= 1
        if value == len(left) or value_2 == len(right):
            result.extend(left[value:] or right[value_2:])
            break
    return result
def mergesort(list):
    if len(list) < 2:
        return list
    middle = int(len(list)/2)
    left = mergesort(list[:middle])
    right = mergesort(list[middle:])
    return merge(left, right)",0,1,0,0,0,0,0,0,0
907,"package sort.merge;
import sort.Sort;
public class MergeSort extends Sort {
    private static Comparable[] aux;  
    @Override
    public void sortMethod(Comparable[] a) {
        sort(a, 0, a.length - 1);
    }
    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        new MergeSort().sortMethod(a);
    }
    private static void sort(Comparable[] a, int lo, int hi) {
        if (lo >= hi) return;
        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);  
        sort(a, mid + 1, hi);  
        merge(a, lo, mid, hi);  
    }
    private static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo, j = mid + 1;
        for (int k = lo; k <= hi; k++)
            aux[k] = a[k];
        for (int k = lo; k <= hi; k++) {
            if (i > mid) a[k] = aux[j++];  
            else if (j > hi) a[k] = aux[i++];  
            else if (less(aux[j], aux[i])) a[k] = aux[j++];  
            else a[k] = aux[i++];  
        }
    }
}",0,1,0,0,0,0,0,0,0
908,"const myArray = [2, 4, 1, 6, -7, 8, 5, 9, 3, 4];
const mergeSort = (arr) => {
  if (arr.length <= 1) {
    return arr;
  }
  let midIdx = Math.floor(arr.length / 2);
  let left = arr.slice(0, midIdx);
  let right = arr.slice(midIdx);
  let leftSorted = mergeSort(left);
  let rightSorted = mergeSort(right);
  return merge(leftSorted, rightSorted);
};
const merge = (arr1, arr2) => {
  let merged = [];
  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) {
      merged.push(arr1.shift());
    } else {
      merged.push(arr2.shift());
    }
  }
  return [...merged, ...arr1, ...arr2];
};
console.log(mergeSort(myArray));",0,1,0,0,0,0,0,0,0
909,"def mergeSort(arr): 
    if len(arr) >1: 
        mid = len(arr)//2 
        L = arr[:mid] 
        R = arr[mid:] 
        mergeSort(L) 
        mergeSort(R) 
        i = j = k = 0
        while i < len(L) and j < len(R): 
            if L[i] < R[j]: 
                arr[k] = L[i] 
                i+=1
            else: 
                arr[k] = R[j] 
                j+=1
            k+=1
        while i < len(L): 
            arr[k] = L[i] 
            i+=1
            k+=1
        while j < len(R): 
            arr[k] = R[j] 
            j+=1
            k+=1
def printList(arr): 
    for i in range(len(arr)):         
        print(arr[i],end="" "") 
    print() 
if __name__ == '__main__': 
    arr = [12, 11, 13, 2, 6, 7, 1]  
    print (""Given array is"", end=""\n"")  
    printList(arr) 
    mergeSort(arr) 
    print(""Sorted array is: "", end=""\n"") 
    printList(arr) ",0,1,0,0,0,0,0,0,0
910,"const array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function mergeSortTopDown(array) {
  if(array.length < 2) {
    return array;
  }
  const middle = Math.floor(array.length / 2);
  const left = array.slice(0, middle);
  const right = array.slice(middle);
  return mergeTopDown(mergeSortTopDown(left), mergeSortTopDown(right));
}
function mergeTopDown(left, right) {
  const array = [];
  while(left.length && right.length) {
    if(left[0] < right[0]) {
      array.push(left.shift());
    } else {
      array.push(right.shift());
    }
  }
  return array.concat(left.slice()).concat(right.slice());
}
console.log(mergeSortTopDown(array.slice()));  
function mergeSortBottomUp(array) {
  let step = 1;
  while (step < array.length) {
    let left = 0;
    while (left + step < array.length) {
      mergeBottomUp(array, left, step);
      left += step * 2;
    }
    step *= 2;
  }
  return array;
}
function mergeBottomUp(array, left, step) {
  const right = left + step;
  const end = Math.min(left + step * 2 - 1, array.length - 1);
  let leftMoving = left;
  let rightMoving = right;
  const temp = [];
  for (let i = left; i <= end; i++) {
    if ((array[leftMoving] <= array[rightMoving] || rightMoving > end) &&
        leftMoving < right) {
      temp[i] = array[leftMoving];
      leftMoving++;
    } else {
      temp[i] = array[rightMoving];
      rightMoving++;
    }
  }
  for (let j = left; j <= end; j++) {
    array[j] = temp[j];
  }
}
console.log(mergeSortBottomUp(array.slice()));  ",0,1,0,0,0,0,0,0,0
911,"public class MergeSort {
    private static void merge(int[] a, int first, int mid, int last) {
        int l = mid - first + 1;
        int r = last - mid;
        int[] left = new int[l];
        int[] right = new int[r];
        for (int i = 0; i < l; i++) {   
            left[i] = a[first + i];
        }
        for (int j = 0; j < r; j++) {   
            right[j] = a[mid + j + 1];
        }
        int i = 0;
        int j = 0;
        int k = first;
        while (i < l && j < r) {   
            if (left[i] <= right[j]) {
                a[k] = left[i];
                i++;
            } else {
                a[k] = right[j];
                j++;
            }
            k++;
        }
        while (i < l) {   
            a[k] = left[i];
            i++;
            k++;
        }
        while (j < r) {   
            a[k] = right[j];
            j++;
            k++;
        }
    }
    private static void mergeSort(int[] a, int first, int last) {
        if (first < last) {
            int mid = (first + last) / 2;   
            mergeSort(a, first, mid);   
            mergeSort(a, mid + 1, last);   
            merge(a, first, mid, last);   
        }
    }
    public static void main(String[] args) {
        int[] arr = new int[] {2, 4, 9, 6, 7, 8};
        mergeSort(arr, 0, arr.length - 1);
        for (int element : arr) {
            System.out.println(element);
        }
    }
}",0,1,0,0,0,0,0,0,0
912,"export function mergeSort(array) {
  if (array.length <= 1) {
    return array;
  }
  const middleIndex = Math.floor(array.length / 2);
  const left = array.slice(0, middleIndex);
  const right = array.slice(middleIndex);
  return merge(mergeSort(left), mergeSort(right));
}
function merge(array1, array2) {
  let index1 = 0;
  let index2 = 0;
  const array = [];
  while (index1 < array1.length && index2 < array2.length) {
    if (array1[index1] <= array2[index2]) {
      array.push(array1[index1]);
      index1++;
    } else if (array1[index1] >= array2[index2]) {
      array.push(array2[index2]);
      index2++;
    }
  }
  return [...array, ...array1.slice(index1), ...array2.slice(index2)];
}",0,1,0,0,0,0,0,0,0
913,"function mergeSortTopDown(array) {
    if(array.length <= 1) {
        return array
    }
    const middle = Math.floor(array.length / 2);
    const left = array.slice(0, middle);
    const right = array.slice(middle);
    return mergeTopDown(mergeSortTopDown(left), mergeSortTopDown(right))
}
function mergeTopDown(left, right) {
    const array = [];
    while (left.length && right.length) {
        if(left[0]< right[0]) {
            array.push(left.shift());
        } else {
            array.push(right.shift());
        }
    }
    return array.concat(left.slice()).concat(right.slice());
}
(function test() {
    const testArray1 = [4, 5, 2, 1, 3, 8]
    const testArray2 = [5, 5, 6, 100, 3, 5, 2, 1, 5, 7, 8888, 4]
    const testArray3 = [2, 1]
    console.log(mergeSortTopDown(testArray1))
    console.log(mergeSortTopDown(testArray2))
    console.log(mergeSortTopDown(testArray3))
})()",0,1,0,0,0,0,0,0,0
914,"def merge_sort(obj):
    if len(obj) > 1:
        mid = len(obj)/2
        left = obj[:mid]
        right = obj[mid:]
        merge_sort(left)
        merge_sort(right)
        i = 0
        j = 0
        k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                obj[k] = left[i]
                i += 1
            else:
                obj[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            obj[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            obj[k] = right[j]
            j += 1
            k += 1",0,1,0,0,0,0,0,0,0
915,"package eu.happycoders.sort.method.mergesort;
import eu.happycoders.sort.method.*;
public class MergeSort2 implements SortAlgorithm {
  private static final int MAX_INPUT_SIZE = 1 << 28;
  @Override
  public void sort(int[] elements) {
    mergeSort(elements, 0, elements.length - 1);
  }
  private void mergeSort(int[] elements, int left, int right) {
    if (left == right) return;
    int middle = left + (right - left) / 2;
    mergeSort(elements, left, middle);
    mergeSort(elements, middle + 1, right);
    merge(elements, left, middle, right);
  }
  void merge(int[] elements, int leftStart, int leftEnd, int rightEnd) {
    int leftPos = leftStart;
    int rightPos = leftEnd + 1;
    int length = rightEnd + 1 - leftPos;
    int[] target = new int[length];
    int targetPos = 0;
    while (leftPos <= leftEnd && rightPos <= rightEnd) {
      int leftValue = elements[leftPos];
      int rightValue = elements[rightPos];
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (leftPos <= leftEnd) {
      target[targetPos++] = elements[leftPos++];
    }
    while (rightPos <= rightEnd) {
      target[targetPos++] = elements[rightPos++];
    }
    System.arraycopy(target, 0, elements, leftStart, length);
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    mergeSort(elements, 0, elements.length - 1, counters);
  }
  private void mergeSort(int[] elements, int left, int right,
                         Counters counters) {
    if (left == right) return;
    int middle = left + (right - left) / 2;
    mergeSort(elements, left, middle, counters);
    mergeSort(elements, middle + 1, right, counters);
    merge(elements, left, middle, right, counters);
  }
  void merge(int[] elements, int leftStart, int leftEnd, int rightEnd,
             Counters counters) {
    int leftPos = leftStart;
    int rightPos = leftEnd + 1;
    int length = rightEnd + 1 - leftPos;
    int[] target = new int[length];
    int targetPos = 0;
    while (leftPos <= leftEnd && rightPos <= rightEnd) {
      counters.incIterations();
      int leftValue = elements[leftPos];
      int rightValue = elements[rightPos];
      counters.addReads(2);
      counters.incComparisons();
      counters.incWrites();
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (leftPos <= leftEnd) {
      counters.incIterations();
      target[targetPos++] = elements[leftPos++];
      counters.incReadsAndWrites();
    }
    while (rightPos <= rightEnd) {
      counters.incIterations();
      target[targetPos++] = elements[rightPos++];
      counters.incReadsAndWrites();
    }
    System.arraycopy(target, 0, elements, leftStart, length);
    counters.addReadsAndWrites(length);
  }
  @Override
  public boolean isSuitableForInputSize(int size) {
    return size <= MAX_INPUT_SIZE;
  }
}",0,1,0,0,0,0,0,0,0
916,"class Mergesort:
      vec = []
      len = -1
      def __init__(self,arr):
          self.vec = arr
          self.len = len(arr)
      def sort(self):
          self._divimp(0,self.len-1)
      def _merge(self,li,m,ls):
          i = li
          j = m+1
          k = 0
          temp = []
          for q in range(0,self.len):
              temp.append(0)
          while i<=m and j<=ls:
              if self.vec[i]<self.vec[j]:
                 temp[k] = self.vec[i]
                 k = k + 1
                 i = i + 1
              else:
                 temp[k] = self.vec[j]
                 k = k + 1
                 j = j + 1
          if i<=m:
             for w in range(i,m+1):
                 temp[k] = self.vec[w]   
                 k = k + 1
          if j<=ls:
             for w in range(j,ls+1):
                 temp[k] = self.vec[w]
                 k = k + 1
          k = 0
          for i in range(li,ls+1):
              self.vec[i] = temp[k]
              k = k + 1
      def _divimp(self,li,ls):
          if((ls-li)<=1):
              self.swap(li,ls)
          else:
              m = (li+ls)/2
              self._divimp(li,m)
              self._divimp(m+1,ls)
              self._merge(li,m,ls)
      def swap(self,i,j):
          if self.vec[i] > self.vec[j]:
              temp = self.vec[i]
              self.vec[i] = self.vec[j]
              self.vec[j] = temp  
      def get(self):
          return self.vec 
arr = [9,8,7,6,5,4,3,2,1,-1,111,-1221,0,12]
obj = Mergesort(arr)
obj.sort()
print obj.get()",0,1,0,0,0,0,0,0,0
917,"package eu.happycoders.sort.method.mergesort;
import eu.happycoders.sort.method.*;
import java.util.Arrays;
public class MergeSort3 implements SortAlgorithm {
  private static final int MAX_INPUT_SIZE = 1 << 28;
  @Override
  public void sort(int[] elements) {
    mergeSort(elements);
  }
  private void mergeSort(int[] elements) {
    int length = elements.length;
    if (length == 1) return;
    int middle = length / 2;
    int[] left = Arrays.copyOfRange(elements, 0, middle);
    int[] right = Arrays.copyOfRange(elements, middle, length);
    mergeSort(left);
    mergeSort(right);
    merge(elements, left, right);
  }
  void merge(int[] target, int[] leftArray, int[] rightArray) {
    int leftLen = leftArray.length;
    int rightLen = rightArray.length;
    int targetPos = 0;
    int leftPos = 0;
    int rightPos = 0;
    while (leftPos < leftLen && rightPos < rightLen) {
      int leftValue = leftArray[leftPos];
      int rightValue = rightArray[rightPos];
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (leftPos < leftLen) {
      target[targetPos++] = leftArray[leftPos++];
    }
    while (rightPos < rightLen) {
      target[targetPos++] = rightArray[rightPos++];
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    mergeSort(elements, counters);
  }
  private void mergeSort(int[] elements, Counters counters) {
    int length = elements.length;
    if (length == 1) return;
    int middle = length / 2;
    int[] left = Arrays.copyOfRange(elements, 0, middle);
    int[] right = Arrays.copyOfRange(elements, middle, length);
    counters.addReadsAndWrites(length);
    mergeSort(left, counters);
    mergeSort(right, counters);
    merge(elements, left, right, counters);
  }
  void merge(int[] target, int[] leftArray, int[] rightArray,
             Counters counters) {
    int leftLen = leftArray.length;
    int rightLen = rightArray.length;
    int targetPos = 0;
    int leftPos = 0;
    int rightPos = 0;
    while (leftPos < leftLen && rightPos < rightLen) {
      counters.incIterations();
      int leftValue = leftArray[leftPos];
      int rightValue = rightArray[rightPos];
      counters.addReads(2);
      counters.incComparisons();
      counters.incWrites();
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (leftPos < leftLen) {
      counters.incIterations();
      target[targetPos++] = leftArray[leftPos++];
      counters.incReadsAndWrites();
    }
    while (rightPos < rightLen) {
      counters.incIterations();
      target[targetPos++] = rightArray[rightPos++];
      counters.incReadsAndWrites();
    }
  }
  @Override
  public boolean isSuitableForInputSize(int size) {
    return size <= MAX_INPUT_SIZE;
  }
}",0,1,0,0,0,0,0,0,0
918,"import java.lang.reflect.Array;
import java.util.ArrayList;
public class MergeSortAny<T extends MaxValue<T> & Comparable<T>>
{
    public static <T extends MaxValue<T> & Comparable<T>> void sort(ArrayList<T> arrayList)
    {
        mergeSortSplit(arrayList, 0, arrayList.size()-1);
    }
    private static <T extends MaxValue<T> & Comparable<T>> void mergeSortSplit(ArrayList<T> listToSort, int start, int end)
    {
        if (start < end)
        {
            int middle = (start + end) / 2;
            mergeSortSplit(listToSort, start, middle);
            mergeSortSplit(listToSort, middle+1, end);
            merge(listToSort, start, middle, end);
        }
    }
    private static <T extends MaxValue<T> & Comparable<T>> void merge(ArrayList<T> listToSort, int start, int middle, int end)
    {
        ArrayList<T> A = new ArrayList<T>(listToSort.subList(start, middle+1));
        ArrayList<T> B = new ArrayList<T>(listToSort.subList(middle+1, end+1));
        A.add(A.get(0).getMaxObject());
        B.add(B.get(0).getMaxObject());
        int i = 0;
        int j = 0;
        for (int k = start; k <= end; k++)
        {
            if (A.get(i).compareTo(B.get(j)) <= 0)
            {
                listToSort.set(k, A.get(i));
                i++;
            }
            else
            {
                listToSort.set(k, B.get(j));
                j++;
            }
        }
    }
    public static <T extends MaxValue<T> & Comparable<T>> void sort(T[] array)
    {
        mergeSortSplitArray(array, 0, array.length-1);
    }
    private static <T extends MaxValue<T> & Comparable<T>> void mergeSortSplitArray(T[] listToSort, int start, int end)
    {
        if (start < end)
        {
            int middle = (start + end) / 2;
            mergeSortSplitArray(listToSort, start, middle);
            mergeSortSplitArray(listToSort, middle+1, end);
            mergeArray(listToSort, start, middle, end);
        }
    }
    private static <T extends MaxValue<T> & Comparable<T>> void mergeArray(T[] listToSort, int start, int middle, int end)
    {
        T[] A = (T[]) Array.newInstance(listToSort[0].getClass(),middle-start +2);
        T[] B = (T[]) Array.newInstance(listToSort[0].getClass(),end - middle +1);
        cloneArray(listToSort, A, start);
        cloneArray(listToSort, B, middle+1);
        int i = 0;
        int j = 0;
        for (int k = start; k <= end; k++)
        {
            if (A[i].compareTo(B[j]) <= 0)
            {
                listToSort[k] = A[i];
                i++;
            }
            else
            {
                listToSort[k] = B[j];
                j++;
            }
        }
    }
    private static <T extends MaxValue<T> & Comparable<T>> void cloneArray(T[] listIn, T[] cloneInto, int start)
    {
        for (int i = start; i < start+cloneInto.length-1; i++)
        {
            cloneInto[i - start] = listIn[i];
        }
        cloneInto[cloneInto.length-1] = listIn[0].getMaxObject();
    }
}",0,1,0,0,0,0,0,0,0
919,"package javaSorting;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public class MergeSortArrayList {
	private static List<Integer> merge(List<Integer> left, List<Integer> right) {
		List<Integer> retList = new ArrayList<>();
		int lsize = left.size();
		int rsize = right.size();
		int i = 0;
		int j = 0;
		while (i < lsize && j < rsize) {
			if (left.get(i) < right.get(j)) {
				retList.add(left.get(i));
				i++;
			} else {
				retList.add(right.get(j));
				j++;
			}
		}
		if (i < lsize) {
			retList.addAll(left.subList(i, left.size()));
		} else {
			retList.addAll(right.subList(j, right.size()));
		}
		return retList;
	}
	public static List<Integer> sort(List<Integer> data) {
		int size = data.size();
		if (size == 1)
			return data;
		int middle = size / 2;
		List<Integer> l_sorted = sort(data.subList(0, middle));
		List<Integer> r_sorted = sort(data.subList(middle, data.size()));
		return merge(l_sorted, r_sorted);
	}
	public static void main(String[] args) {
		List<Integer> data = new ArrayList<Integer>();
		for (int i = 0; i < 1000000; i++) {
			data.add(i);
		}
		Collections.shuffle(data);
		long start = System.currentTimeMillis();
		List<Integer> dataSorted = MergeSortArrayList.sort(data);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		System.out.println(elapsed);
	}
}",0,1,0,0,0,0,0,0,0
920,"package com.growingwiththeweb.sorting;
public class MergeSortBottomUp {
    public static void sort(Integer[] array) {
        Integer[] workArray = new Integer[array.length];
        int chunkSize = 1;
        while (chunkSize < array.length) {
            int i = 0;
            while (i < array.length - chunkSize) {
                merge(array, i, chunkSize, workArray);
                i += chunkSize * 2;
            }
            chunkSize *= 2;
        }
    }
    public static void merge(Integer[] array, int leftPosition, int chunkSize, Integer[] workArray) {
        int rightPosition = leftPosition + chunkSize;
        int endPosition = Math.min(leftPosition + chunkSize * 2 - 1, array.length - 1);
        int leftIndex = leftPosition;
        int rightIndex = rightPosition;
        for (int i = 0; i <= endPosition - leftPosition; i++) {
            if (leftIndex < rightPosition &&
                    (rightIndex > endPosition ||
                    array[leftIndex] <= array[rightIndex])) {
                workArray[i] = array[leftIndex++];
            } else {
                workArray[i] = array[rightIndex++];
            }
        }
        for (int i = leftPosition; i <= endPosition; i++) {
            array[i] = workArray[i - leftPosition];
        }
    }
}",0,1,0,0,0,0,0,0,0
921,"package mergesort;
public class MergeSortClassTest
{
    private final Person[] persons;
    public MergeSortClassTest()
    {
        persons = new Person[10];
        persons[0] = new Person(""Joshua"");
        persons[1] = new Person(""James"");
        persons[2] = new Person(""Alexander"");
        persons[3] = new Person(""Morkel"");
        persons[4] = new Person(""Zoey"");
        persons[5] = new Person(""Tamara"");
        persons[6] = new Person(""Lambert"");
        persons[7] = new Person(""Christian"");
        persons[8] = new Person(""Reba"");
        persons[9] = new Person(""Ganesh"");
    }
    public Person[] getPersons()
    {
        return this.persons;
    }
    private class Person implements Comparable<Person>
    {
        private final String name;
        public Person(String name)
        {
            this.name = name;
        }
        public String getName()
        {
            return this.name;
        }
        @Override
        public int compareTo(Person otherPerson)
        {
            return (this.name.compareTo(otherPerson.getName()));
        }
        @Override
        public String toString()
        {
            return ""Person -- Name: "" + this.name;
        }
    }
    public static void main(String[] args)
    {
        MergeSortClassTest test = new MergeSortClassTest();
        MergeSort<Person> sort = new MergeSort<>(test.getPersons());
        sort.sort();
        System.out.println(""Printing Sorted Items: "");
        for (Person x : sort.getSortedItems())
        {
            System.out.println(x);
        }
    }
}",0,0,0,0,0,0,0,0,0
922,"const arrayRandom = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
const arrayOrdered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const arrayReversed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
let countOuter = 0;
let countInner = 0;
let countSwap = 0;
function resetCounters() {
  countOuter = 0;
  countInner = 0;
  countSwap = 0;
}
function mergeSortTopDown(array) {
  countOuter++;
  if(array.length < 2) {
    return array;
  }
  const middle = Math.floor(array.length / 2);
  const left = array.slice(0, middle);
  const right = array.slice(middle);
  return mergeTopDown(mergeSortTopDown(left), mergeSortTopDown(right));
}
function mergeTopDown(left, right) {
  const array = [];
  while(left.length && right.length) {
    countInner++;
    if(left[0] < right[0]) {
      array.push(left.shift());
    } else {
      array.push(right.shift());
    }
  }
  return array.concat(left.slice()).concat(right.slice());
}
mergeSortTopDown(arrayRandom.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
mergeSortTopDown(arrayOrdered.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
mergeSortTopDown(arrayReversed.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
function mergeSortBottomUp(array) {
  let step = 1;
  while (step < array.length) {
    countOuter++;
    let left = 0;
    while (left + step < array.length) {
      countInner++;
      mergeBottomUp(array, left, step);
      left += step * 2;
    }
    step *= 2;
  }
  return array;
}
function mergeBottomUp(array, left, step) {
  const right = left + step;
  const end = Math.min(left + step * 2 - 1, array.length - 1);
  let leftMoving = left;
  let rightMoving = right;
  const temp = [];
  for (let i = left; i <= end; i++) {
    if ((array[leftMoving] <= array[rightMoving] || rightMoving > end) &&
        leftMoving < right) {
      temp[i] = array[leftMoving];
      leftMoving++;
    } else {
      temp[i] = array[rightMoving];
      rightMoving++;
    }
  }
  for (let j = left; j <= end; j++) {
    countSwap++;
    array[j] = temp[j];
  }
}
mergeSortBottomUp(arrayRandom.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
mergeSortBottomUp(arrayOrdered.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
mergeSortBottomUp(arrayReversed.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();",0,1,0,0,0,0,0,0,0
923,"package com.ianramzy;
public class MergeSorter implements Sorter {
    private int list[];
    private int num;
    private int temp[];
    public void sort(int theNum, int theList[]) {
        num = theNum;
        list = theList;
        temp = new int[num];
        mergeSort(0, num - 1);
    }
    public void mergeSort(int first, int last) {
        int middle;
        if (last > first) {
            middle = (int) (first + last) / 2;
            mergeSort(first, middle);
            mergeSort(middle + 1, last);
            merge(first, middle, last);
        }
    }
    public void merge(int first, int middle, int last) {
        int point1, point2, point3;
        point1 = first;
        point2 = middle + 1;
        point3 = first;
        while (point3 <= last) {
            if ((point1 < middle + 1) && (point2 > last || list[point1] < list[point2])) {
                temp[point3] = list[point1];
                point1++;
            } else {
                temp[point3] = list[point2];
                point2++;
            }
            point3++;
        }
        for (int i = first; i <= last; i++) {
            list[i] = temp[i];
        }
    }
}",0,1,0,0,0,0,0,0,0
924,"package sorters;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
public class MergeSorter<E> extends AbstractSorter<E> {
	public void sort(List<E> list, Comparator<E> comp) {
		int n = list.size();
		if (n <= 1)
			return;
		int mid = n / 2;
		List<E> left = new ArrayList<>(list.subList(0, mid));
		List<E> right = new ArrayList<>(list.subList(mid, n));
		sort(left, comp);
		sort(right, comp);
		merge(left, right, list, comp);
	}
	private void merge(List<E> left, List<E> right, List<E> list, Comparator<E> comp) {
		int leftIndex = 0;
		int rightIndex = 0;
		int listIndex = 0;
		E item;
		while (leftIndex < left.size() && rightIndex < right.size()) {
			item = comp.compare(left.get(leftIndex), right.get(rightIndex)) <= 0 
					? left.get(leftIndex++) : right.get(rightIndex++);
			list.set(listIndex++, item);
		}
		while (leftIndex < left.size()) {
			list.set(listIndex++, left.get(leftIndex++));
		}
		while (rightIndex < right.size()) {
			list.set(listIndex++, right.get(rightIndex++));
		}
	}
	public String getName() {
		return ""Merge Sort"";
	}
}",0,1,0,0,0,0,0,0,0
925,"package mergesort;
public class MergeSortIntegerTest
{
    public static void main(String[] args)
    {
        Integer[] items =
        {
            8, 10, 13, 5, 14, 11, 7, 12, 1, 4, 17, 20, 18, 6, 9, 15, 19, 2, 16
        };
        MergeSort<Integer> mergeSort = new MergeSort<>(items);
        mergeSort.sort();
        System.out.println(""Printing Sorted Items: "");
        for (Integer x : mergeSort.getSortedItems())
        {
            System.out.print(x + "" "");
        }
    }
}",0,0,0,0,0,0,0,0,0
926,"package io.github.marioluan.algorithms.sorting;
public final class MergeSortIterative extends Sortable {
    private MergeSortIterative() {
    }
    @SuppressWarnings(""rawtypes"")
    public static void sort(Comparable[] a) {
        Comparable[] aux = new Comparable[a.length];
        sort(a, aux);
    };
    @SuppressWarnings(""rawtypes"")
    private static void sort(Comparable[] a, Comparable[] aux) {
        int n = a.length;
        for (int size = 1; size < n; size = size + size)
            for (int lo = 0; lo < n - size; lo += size + size)
                merge(a, aux, lo, lo + size - 1,
                        Math.min(lo + size + size - 1, n - 1));
    }
    @SuppressWarnings(""rawtypes"")
    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid,
            int hi) {
        copy(a, aux, lo, hi);
        int i = lo;
        int j = mid + 1;
        for (int k = lo; k <= hi; k++) {
            if (i > mid)
                a[k] = aux[j++];
            else if (j > hi)
                a[k] = aux[i++];
            else if (lessOrEqual(aux[j], aux[i]))
                a[k] = aux[j++];
            else
                a[k] = aux[i++];
        }
    }
}",0,1,0,0,0,0,0,0,0
927,"package com.growingwiththeweb.sorting;
import java.util.LinkedList;
import java.util.Queue;
public class MergeSortNatural {
    public static <T extends Comparable<T>> Queue<T> sort(Queue<T> input) {
        Queue<T> output = new LinkedList<T>();
        Queue<T> tempArray1 = new LinkedList<T>();
        Queue<T> tempArray2 = new LinkedList<T>();
        while (input.size() > 0) {
            while (input.size() > 0) {
                merge(input, output, tempArray1);
                merge(input, output, tempArray2);
            }
            while (tempArray1.size() > 0 || tempArray2.size() > 0) {
                merge(tempArray1, tempArray2, output);
                merge(tempArray1, tempArray2, input);
            }
        }
        return output;
    }
    public static <T extends Comparable<T>> void merge(Queue<T> left, Queue<T> right, Queue<T> output) {
        T prevLeft = null;
        T prevRight = null;
        while ((left.size() > 0 && (prevLeft == null || prevLeft.compareTo(left.peek()) <= 0)) ||
               (right.size() > 0 && (prevRight == null || prevRight.compareTo(right.peek()) <= 0))) {
            if (right.size() == 0 || (left.size() > 0 && left.peek().compareTo(right.peek()) <= 0)) {
                prevLeft = left.poll();
                output.add(prevLeft);
            } else {
                prevRight = right.poll();
                output.add(prevRight);
            }
        }
    }
}",0,1,0,0,0,0,0,0,0
928,"package io.github.marioluan.algorithms.sorting;
public final class MergeSortRecursive extends Sortable {
    private MergeSortRecursive() {
    }
    private static final int CUTOFF = 7;
    @SuppressWarnings(""rawtypes"")
    public static void sort(Comparable[] a) {
        Comparable[] aux = new Comparable[a.length];
        sort(a, aux, 0, a.length - 1);
    }
    @SuppressWarnings(""rawtypes"")
    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {
        if (hi <= lo + CUTOFF - 1) {
            InsertionSort.sort(a, lo, hi);
            return;
        }
        int mid = lo + (hi - lo) / 2;
        sort(a, aux, lo, mid);
        sort(a, aux, mid + 1, hi);
        if (!lessOrEqual(a[mid + 1], a[mid]))
            return;
        merge(a, aux, lo, mid, hi);
    }
    @SuppressWarnings(""rawtypes"")
    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid,
            int hi) {
        copy(a, aux, lo, hi);
        int i = lo;
        int j = mid + 1;
        for (int k = lo; k <= hi; k++) {
            if (i > mid)
                a[k] = aux[j++];
            else if (j > hi)
                a[k] = aux[i++];
            else if (lessOrEqual(aux[j], aux[i]))
                a[k] = aux[j++];
            else
                a[k] = aux[i++];
        }
    }
}",0,1,0,0,0,0,0,0,0
929,"export default function MergeSortRecursive(items: number[]): number[] {
  return _divide(items);
}
const _items: Array<Array<number>> = [];
function _divide(array: Array<number>): any {
  switch (array.length) {
    case 1:
      _items.push(array);
      return _items;
    default: {
      const middle = Math.floor(array.length / 2);
      const first = array.splice(middle);
      return _merge(_divide(first), _divide(array));
    }
  }
}
function _merge(first: Array<number>, second: Array<number>): Array<number> {
  const merged = [];
  const [target, source] =
    first.length > second.length ? [first, second] : [second, first];
  for (let i = 0; i < target.length && i < source.length; i++) {
    if (target[i] < source[i]) {
      merged.push(target[i]);
      merged.push(source[i]);
    } else {
      merged.push(source[i]);
      merged.push(target[i]);
    }
  }
  if (merged.length < target.length + source.length) {
    const diff = target.length - source.length;
    for (let i = target.length - diff; i < target.length; i++) {
      merged.push(target[i]);
    }
  }
  return merged;
}",0,1,0,0,0,0,0,0,0
930,"mergev2Sort = (function() {
  var merge = function(a, b, left, right, end) {
    for (var i = left, j = right, k = left; k < end; k++) {
      if (i < right && (j >= end || a[i] <= a[j]))
        b[k] = a[i++];
      else
        b[k] = a[j++];
    }
  };
  var impl = function(a, b, n) {
    for (var width = 1; width < n; width <<= 1) {
      for (var i = 0; i < n; i = i + (width << 1)) {
        merge(a, b, i, Math.min(i + width, n), Math.min(i + (width << 1), n));
      }
      for (i = 0; i < n; i++)
        a[i] = b[i];
    }
  };
  return function(array) {
    var a = array.slice(0),
        b = a.slice(0);
    impl(a, b, a.length);
    return a;
  };
})();",0,1,0,0,0,0,0,0,0
931,"package eu.happycoders.sort.method.mergesort;
import eu.happycoders.sort.method.Counters;
import eu.happycoders.sort.method.SortAlgorithm;
public class NaturalMergeSort implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    int numElements = elements.length;
    int[] tmp = new int[numElements];
    int[] starts = new int[numElements + 1];
    int runCount = 0;
    starts[0] = 0;
    for (int i = 1; i <= numElements; i++) {
      if (i == numElements || elements[i] < elements[i - 1]) {
        starts[++runCount] = i;
      }
    }
    int[] from = elements;
    int[] to = tmp;
    while (runCount > 1) {
      int newRunCount = 0;
      for (int i = 0; i < runCount - 1; i += 2) {
        merge(from, to, starts[i], starts[i + 1], starts[i + 2]);
        starts[newRunCount++] = starts[i];
      }
      if (runCount % 2 == 1) {
        int lastStart = starts[runCount - 1];
        System.arraycopy(from, lastStart, to, lastStart,
              numElements - lastStart);
        starts[newRunCount++] = lastStart;
      }
      starts[newRunCount] = numElements;
      runCount = newRunCount;
      int[] help = from;
      from = to;
      to = help;
    }
    if (from != elements) {
      System.arraycopy(from, 0, elements, 0, numElements);
    }
  }
  private void merge(int[] source, int[] target, int startLeft,
                     int startRight, int endRight) {
    int leftPos = startLeft;
    int rightPos = startRight;
    int targetPos = startLeft;
    while (leftPos < startRight && rightPos < endRight) {
      int leftValue = source[leftPos];
      int rightValue = source[rightPos];
      if (leftValue <= rightValue) {
        target[targetPos++] = leftValue;
        leftPos++;
      } else {
        target[targetPos++] = rightValue;
        rightPos++;
      }
    }
    while (leftPos < startRight) {
      target[targetPos++] = source[leftPos++];
    }
    while (rightPos < endRight) {
      target[targetPos++] = source[rightPos++];
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
  }
}",0,1,0,0,0,0,0,0,0
932,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
import io.nayuki.sortalgodemo.core.SortArray.ElementState;
public final class RotationMergeSort extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new RotationMergeSort();
	public void sort(SortArray array) {
		sort(array, 0, array.length());
		array.setRange(0, array.length(), ElementState.DONE);
	}
	private static void sort(SortArray array, int start, int end) {
		if (!(0 <= start && start <= end && end <= array.length()))
			throw new IllegalArgumentException();
		if (end - start <= 1)
			return;
		array.setRange(start, end, ElementState.ACTIVE);
		int mid = (start + end) / 2;
		array.setRange(mid, end, ElementState.INACTIVE);
		sort(array, start, mid);
		array.setRange(start, mid, ElementState.INACTIVE);
		sort(array, mid, end);
		merge(array, start, mid, end);
	}
	private static void merge(SortArray array, int start, int mid, int end) {
		if (!(0 <= start && start <= mid && mid <= end && end <= array.length()))
			throw new IllegalArgumentException();
		if (start == mid || mid == end)
			return;
		array.setRange(start, end, ElementState.ACTIVE);
		int left = mid - 1;
		int right = mid;
		while (start <= left && right < end && array.compare(left, right) > 0) {
			left--;
			right++;
		}
		int n = right - mid;
		for (int i = 0; i < n; i++)
			array.swap(mid - n + i, mid + i);
		array.setRange(mid, end, ElementState.INACTIVE);
		merge(array, start, left + 1, mid);
		array.setRange(start, mid, ElementState.INACTIVE);
		merge(array, mid, right, end);
	}
	private RotationMergeSort() {
		super(""Rotation merge sort"");
	}
}",0,1,0,0,0,0,0,0,0
933,"package mergesort;
import java.util.*;
public class Sort <T extends Comparable<T>> implements Comparator<T> {
	public ArrayList<T> list;
	Object[] temp;
	public int compare(T a, T b) {
		return a.compareTo(b);
	}
	public Sort(){
		list = new ArrayList<T>();
	}
	@Override
	public String toString(){
		String listOut = """";
		listOut += ""-->"";
		for (int i = 0; i < list.size(); i++) {
			listOut += list.get(i) + "" "";
		}
		return listOut;
	}
	public void MainSort() {
		int length = list.size();
		temp = new Object[length];
		MergeSort(0, length - 1);
	}
	private void MergeSort(int low, int high) {
		if (low < high) {
			int mid = low + ((high - low) / 2);
			MergeSort(low, mid);
			MergeSort(mid + 1, high);
			MergeLists(low, mid, high);
		}
	}
	@SuppressWarnings(""unchecked"")
	private void MergeLists(int low, int mid, int high) {
		for (int i = low; i <= high; i++) {
			temp[i] = list.get(i);
		}
		int i = low;
		int j = mid + 1;
		int k = low;
		while ((i <= mid) && (j <= high)) {
			if (compare((T) temp[i], (T) temp[j]) > 0) {
				list.set(k, (T) temp[i]);
				i++;
			} else {
				list.set(k, (T) temp[j]);
				j++;
			}
			k++;
		}
		while (i <= mid) {
			list.set(k, (T) temp[i]);
			k++;
			i++;
		}
	}
}",0,1,0,0,0,0,0,0,0
934,"package sortingandsearch;
import java.util.Arrays;
public class SortedMerge {
    public static void main(String[] args) {
        Integer[] array1 = new Integer[12];
        for (int i = 0; i < array1.length; i++) {
            array1[i] = (i < 5) ? (i + 10) * 2 * 2 : Integer.MAX_VALUE;
        }
        Integer[] array2 = new Integer[7];
        array2[0] = 1;
        array2[1] = 3;
        array2[2] = 5;
        array2[3] = 9;
        array2[4] = 10;
        array2[5] = 12;
        array2[6] = 14;
        System.out.println(Arrays.toString(array1));
        System.out.println(Arrays.toString(array2));
        merge(array1, array2);
    }
    private static void merge(Integer[] arrA, Integer[] arrB) {
        int lastIndexA = findLastFilledIndex(arrA);
        int lastIndexB = arrB.length - 1;
        int sizeOfMergedArray = lastIndexA + 1 + arrB.length - 1;
        while (sizeOfMergedArray >= 0) {
            if (lastIndexA >= 0 && arrA[lastIndexA] > arrB[lastIndexB]) {
                arrA[sizeOfMergedArray] = arrA[lastIndexA];
                lastIndexA--;
            } else {
                arrA[sizeOfMergedArray] = arrB[lastIndexB];
                lastIndexB--;
            }
            sizeOfMergedArray--;
        }
        System.out.println(java.util.Arrays.toString(arrA));
    }
    private static int findLastFilledIndex(Integer[] arrA) {
        int current = 0;
        for (Integer i : arrA) {
            if (i == Integer.MAX_VALUE) break;
            current++;
        }
        return current - 1;
    }
}",0,1,0,0,0,0,0,0,0
935,"import java.util.*; 
public class ThreeWayMergeSort 
{ 
    public static void mergeSort3Way(Integer[] gArray) 
    { 
        if (gArray == null) 
            return; 
        Integer[] fArray = new Integer[gArray.length]; 
        for (int i = 0; i < fArray.length; i++) 
            fArray[i] = gArray[i]; 
        mergeSort3WayRec(fArray, 0, gArray.length, gArray); 
        for (int i = 0; i < fArray.length; i++) 
            gArray[i] = fArray[i]; 
    } 
    public static void mergeSort3WayRec(Integer[] gArray, 
                  int low, int high, Integer[] destArray) 
    { 
        if (high - low < 2) 
            return; 
        int mid1 = low + ((high - low) / 3); 
        int mid2 = low + 2 * ((high - low) / 3) + 1; 
        mergeSort3WayRec(destArray, low, mid1, gArray); 
        mergeSort3WayRec(destArray, mid1, mid2, gArray); 
        mergeSort3WayRec(destArray, mid2, high, gArray); 
        merge(destArray, low, mid1, mid2, high, gArray); 
    } 
    public static void merge(Integer[] gArray, int low, 
                           int mid1, int mid2, int high, 
                                   Integer[] destArray) 
    { 
        int i = low, j = mid1, k = mid2, l = low; 
        while ((i < mid1) && (j < mid2) && (k < high)) 
        { 
            if (gArray[i].compareTo(gArray[j]) < 0) 
            { 
                if (gArray[i].compareTo(gArray[k]) < 0) 
                    destArray[l++] = gArray[i++]; 
                else
                    destArray[l++] = gArray[k++]; 
            } 
            else
            { 
                if (gArray[j].compareTo(gArray[k]) < 0) 
                    destArray[l++] = gArray[j++]; 
                else
                    destArray[l++] = gArray[k++]; 
            } 
        } 
        while ((i < mid1) && (j < mid2)) 
        { 
            if (gArray[i].compareTo(gArray[j]) < 0) 
                destArray[l++] = gArray[i++]; 
            else
                destArray[l++] = gArray[j++]; 
        } 
        while ((j < mid2) && (k < high)) 
        { 
            if (gArray[j].compareTo(gArray[k]) < 0) 
                destArray[l++] = gArray[j++]; 
            else
                destArray[l++] = gArray[k++]; 
        } 
        while ((i < mid1) && (k < high)) 
        { 
            if (gArray[i].compareTo(gArray[k]) < 0) 
                destArray[l++] = gArray[i++]; 
            else
                destArray[l++] = gArray[k++]; 
        } 
        while (i < mid1) 
            destArray[l++] = gArray[i++]; 
        while (j < mid2) 
            destArray[l++] = gArray[j++]; 
        while (k < high) 
            destArray[l++] = gArray[k++]; 
    } 
    public static void main(String args[]) 
    { 
        Integer[] data = new Integer[] {45, -2, -45, 78, 
                               30, -42, 10, 19, 73, 93}; 
        mergeSort3Way(data); 
        System.out.println(""After 3 way merge sort: ""); 
        for (int i = 0; i < data.length; i++) 
            System.out.print(data[i] + "" ""); 
    } 
}",0,1,0,0,0,0,0,0,0
936,"package sorting;
import java.util.concurrent.ForkJoinPool;
public class ConcurrentQuickSort<T extends Comparable<T>> implements Sort<T> {
    private final int threshold;
    public ConcurrentQuickSort(int threshold) {
        this.threshold = threshold;
    }
    @Override
    public void sort(T[] items) {
        ForkJoinPool pool = new ForkJoinPool();
        ConcurrentQuickSortTask<T> task = new ConcurrentQuickSortTask<>(items, threshold);
        pool.invoke(task);
    }
}",0,0,0,0,0,0,0,0,0
937,"package sorting;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.RecursiveAction;
@SuppressWarnings(""serial"")
public class ConcurrentQuickSortTask<T extends Comparable<T>> extends RecursiveAction {
    private final T items[];
    private final int left;
    private final int right;
    private final int threshold;
    public ConcurrentQuickSortTask(T items[], int threshold) {
        this.items = items;
        this.left = 0;
        this.right = items.length - 1;
        this.threshold = threshold;
    }
    private ConcurrentQuickSortTask(T items[], int left, int right, int threshold) {
        this.items = items;
        this.left = left;
        this.right = right;
        this.threshold = threshold;
    }
    @Override
    protected void compute() {
        int up = left;
        int down = right - 1;
        T t = items[right];
        do {
            while (items[up].compareTo(t) < 0) {
                up++;
            }
            while (items[down].compareTo(t) >= 0 && down > up) {
                down--;
            }
            if (up < down) {
                SortUtils.swap(items, up, down);
            }
        } while (up < down);
        SortUtils.swap(items, up, right);
        List<ConcurrentQuickSortTask<T>> tasks = new ArrayList<>();
        if (left < up - 1) {
            int size = (up - 1) - left + 1;
            if (size < threshold) {
                Arrays.sort(items, left, up);
            } else {
                tasks.add(new ConcurrentQuickSortTask<>(items, left, up - 1, threshold));
            }
        }
        if (right > up + 1) {
            int size = right - (up + 1) + 1;
            if (size < threshold) {
                Arrays.sort(items, up + 1, right + 1);
            } else {
                tasks.add(new ConcurrentQuickSortTask<>(items, up + 1, right, threshold));
            }
        }
        if (!tasks.isEmpty()) {
            invokeAll(tasks);
        }
    }
}",1,0,0,0,0,0,0,0,0
938,"public class DualPivotQuickSort{
    static void swap(int[] array, int i, int j)
    {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    static void dualPivotQuickSort(int[] array,int low, int high)
    {
        if (low < high)
        {
            int[] piv;
            piv = partition(array, low, high);
            dualPivotQuickSort(array, low, piv[0] - 1);
            dualPivotQuickSort(array, piv[0] + 1, piv[1] - 1);
            dualPivotQuickSort(array, piv[1] + 1, high);
        }
    }
    static int[] partition(int[] arr, int low, int high)
    {
        if (arr[low] > arr[high])
            swap(arr, low, high);
        int j = low + 1;
        int g = high - 1, k = low + 1,
                p = arr[low], q = arr[high];
        while (k <= g)
        {
            if (arr[k] < p)
            {
                swap(arr, k, j);
                j++;
            }
            else if (arr[k] >= q)
            {
                while (arr[g] > q && k < g)
                    g--;
                swap(arr, k, g);
                g--;
                if (arr[k] < p)
                {
                    swap(arr, k, j);
                    j++;
                }
            }
            k++;
        }
        j--;
        g++;
        swap(arr, low, j);
        swap(arr, high, g);
        return new int[] { j, g };
    }
    public static void main(String[] args)
    {
        int[] arr = { 83, 7, 58, 31, 99, 5, 88, 15 };
        dualPivotQuickSort(arr, 0, 7);
        System.out.print(""Sorted array: "");
        for (int i = 0; i < 8; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
}",1,0,0,0,0,0,0,0,0
939,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.method.*;
import eu.happycoders.sort.utils.ArrayUtils;
public class DualPivotQuicksort implements SortAlgorithm {
  private final PivotStrategy pivotStrategy;
  public DualPivotQuicksort(PivotStrategy pivotStrategy) {
    this.pivotStrategy = pivotStrategy;
  }
  @Override
  public String getName() {
    return this.getClass().getSimpleName() + ""(pivot: "" + pivotStrategy + "")"";
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return pivotStrategy != PivotStrategy.LEFT_RIGHT || size <= 2 << 14;
  }
  @Override
  public void sort(int[] elements) {
    quicksort(elements, 0, elements.length - 1);
  }
  private void quicksort(int[] elements, int left, int right) {
    if (left >= right) return;
    int[] pivotPos = partition(elements, left, right);
    int p0 = pivotPos[0];
    int p1 = pivotPos[1];
    quicksort(elements, left, p0 - 1);
    quicksort(elements, p0 + 1, p1 - 1);
    quicksort(elements, p1 + 1, right);
  }
  int[] partition(int[] elements, int left, int right) {
    findPivotsAndMoveToLeftRight(elements, left, right);
    int leftPivot = elements[left];
    int rightPivot = elements[right];
    int leftPartitionEnd = left + 1;
    int leftIndex = left + 1;
    int rightIndex = right - 1;
    while (leftIndex <= rightIndex) {
      if (elements[leftIndex] < leftPivot) {
        ArrayUtils.swap(elements, leftIndex, leftPartitionEnd);
        leftPartitionEnd++;
      }
      else if (elements[leftIndex] >= rightPivot) {
        while (elements[rightIndex] > rightPivot && leftIndex < rightIndex)
          rightIndex--;
        ArrayUtils.swap(elements, leftIndex, rightIndex);
        rightIndex--;
        if (elements[leftIndex] < leftPivot) {
          ArrayUtils.swap(elements, leftIndex, leftPartitionEnd);
          leftPartitionEnd++;
        }
      }
      leftIndex++;
    }
    leftPartitionEnd--;
    rightIndex++;
    ArrayUtils.swap(elements, left, leftPartitionEnd);
    ArrayUtils.swap(elements, right, rightIndex);
    return new int[]{leftPartitionEnd, rightIndex};
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    quicksort(elements, 0, elements.length - 1, counters);
  }
  private void quicksort(int[] elements, int left, int right,
                         Counters counters) {
    if (left >= right) return;
    int[] pivotPos = partition(elements, left, right, counters);
    int p0 = pivotPos[0];
    int p1 = pivotPos[1];
    quicksort(elements, left, p0 - 1, counters);
    quicksort(elements, p0 + 1, p1 - 1, counters);
    quicksort(elements, p1 + 1, right, counters);
  }
  int[] partition(int[] elements, int left, int right, Counters counters) {
    findPivotsAndMoveToLeftRight(elements, left, right);
    int leftPivot = elements[left];
    int rightPivot = elements[right];
    counters.addReads(2);
    int leftPartitionEnd = left + 1;
    int leftIndex = left + 1;
    int rightIndex = right - 1;
    while (leftIndex <= rightIndex) {
      counters.incIterations();
      counters.incReads();
      counters.incComparisons();
      if (elements[leftIndex] < leftPivot) {
        ArrayUtils.swap(elements, leftIndex, leftPartitionEnd);
        counters.addReadsAndWrites(2);
        leftPartitionEnd++;
      } else {
        counters.incReads();
        counters.incComparisons();
        if (elements[leftIndex] >= rightPivot) {
          while (leftIndex < rightIndex) {
            counters.incIterations();
            counters.incReads();
            counters.incComparisons();
            if (!(elements[rightIndex] > rightPivot)) break;
            rightIndex--;
          }
          ArrayUtils.swap(elements, leftIndex, rightIndex);
          counters.addReadsAndWrites(2);
          rightIndex--;
          counters.incReads();
          counters.incComparisons();
          if (elements[leftIndex] < leftPivot) {
            ArrayUtils.swap(elements, leftIndex, leftPartitionEnd);
            counters.addReadsAndWrites(2);
            leftPartitionEnd++;
          }
        }
      }
      leftIndex++;
    }
    leftPartitionEnd--;
    rightIndex++;
    ArrayUtils.swap(elements, left, leftPartitionEnd);
    ArrayUtils.swap(elements, right, rightIndex);
    counters.addReadsAndWrites(4);
    return new int[]{leftPartitionEnd, rightIndex};
  }
  private void findPivotsAndMoveToLeftRight(int[] elements,
                                            int left, int right) {
    switch (pivotStrategy) {
      case LEFT_RIGHT -> {
        if (elements[left] > elements[right]) {
          ArrayUtils.swap(elements, left, right);
        }
      }
      case THIRDS -> {
        int len = right - left + 1;
        int firstPos = left + (len - 1) / 3;
        int secondPos = right - (len - 2) / 3;
        int first = elements[firstPos];
        int second = elements[secondPos];
        if (first > second) {
          if (secondPos == right) {
            if (firstPos == left) {
              ArrayUtils.swap(elements, left, right);
            } else {
              elements[right] = first;
              elements[firstPos] = elements[left];
              elements[left] = second;
            }
          } else if (firstPos == left) {
            elements[left] = second;
            elements[secondPos] = elements[right];
            elements[right] = first;
          } else {
            ArrayUtils.swap(elements, firstPos, right);
            ArrayUtils.swap(elements, secondPos, left);
          }
        } else {
          if (secondPos != right)
            ArrayUtils.swap(elements, secondPos, right);
          if (firstPos != left)
            ArrayUtils.swap(elements, firstPos, left);
        }
      }
      default -> throw new IllegalStateException(""Unexpected value: "" + pivotStrategy);
    }
  }
  public enum PivotStrategy {LEFT_RIGHT, THIRDS}
}",1,0,0,0,0,0,0,0,0
940,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.method.*;
import eu.happycoders.sort.method.quicksort.DualPivotQuicksort.PivotStrategy;
public class DualPivotQuicksortImproved implements SortAlgorithm {
  private final int threshold;
  private final PivotStrategy pivotStrategy;  
  private final DualPivotQuicksort standardQuicksort;
  private final InsertionSort insertionSort;
  public DualPivotQuicksortImproved(int threshold,
                                    PivotStrategy pivotStrategy) {
    this.threshold = threshold;
    this.pivotStrategy = pivotStrategy;
    this.standardQuicksort = new DualPivotQuicksort(pivotStrategy);
    this.insertionSort = new InsertionSort();
  }
  @Override
  public String getName() {
    return this.getClass().getSimpleName() + ""(threshold: "" + threshold +
          "", pivot: "" + pivotStrategy + "")"";
  }
  @Override
  public void sort(int[] elements) {
    quicksort(elements, 0, elements.length - 1);
  }
  private void quicksort(int[] elements, int left, int right) {
    if (left >= right) return;
    if (right - left < threshold) {
      insertionSort.sort(elements, left, right + 1);
      return;
    }
    int[] pivotPos = standardQuicksort.partition(elements, left, right);
    int p0 = pivotPos[0];
    int p1 = pivotPos[1];
    quicksort(elements, left, p0 - 1);
    quicksort(elements, p0 + 1, p1 - 1);
    quicksort(elements, p1 + 1, right);
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    quicksort(elements, 0, elements.length - 1, counters);
  }
  private void quicksort(int[] elements, int left, int right,
                         Counters counters) {
    if (left >= right) return;
    if (right - left < threshold) {
      insertionSort.sort(elements, left, right + 1, counters);
      return;
    }
    int[] pivotPos = standardQuicksort.partition(elements, left, right,
          counters);
    int p0 = pivotPos[0];
    int p1 = pivotPos[1];
    quicksort(elements, left, p0 - 1, counters);
    quicksort(elements, p0 + 1, p1 - 1, counters);
    quicksort(elements, p1 + 1, right, counters);
  }
  @Override
  public boolean isSuitableForInputSize(int size) {
    return standardQuicksort.isSuitableForInputSize(size);
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return standardQuicksort.isSuitableForSortedInput(size);
  }
}",1,0,0,0,0,0,0,0,0
941,"function quickSort(items, left, right) {
  let index;
  if (items.length > 1) {
    left = typeof left != 'number' ? 0 : left;
    right = typeof right != 'number' ? items.length - 1 : right;
    index = partition(items, left, right);
    if (left < index - 1) {
      quickSort(items, left, index - 1);
    }
    if (index < right) {
      quickSort(items, index, right);
    }
  }
  return items;
}
module.exports = {quickSort};",0,0,0,0,0,0,0,0,0
942,"package QuickSort;
import java.util.Comparator;
import Utils.Convert;
import Utils.Order;
public class LPQuickSort {
	public static void sort(byte[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(byte[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(byte[] a, int left, int right) {
		int lo = left;
		int hi = right;
		byte pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(byte[] a, int i, int j) {
		byte temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(char[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(char[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(char[] a, int left, int right) {
		int lo = left;
		int hi = right;
		char pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(char[] a, int i, int j) {
		char temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(short[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(short[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(short[] a, int left, int right) {
		int lo = left;
		int hi = right;
		short pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(short[] a, int i, int j) {
		short temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(int[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(int[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(int[] a, int left, int right) {
		int lo = left;
		int hi = right;
		int pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(long[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(long[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(long[] a, int left, int right) {
		int lo = left;
		int hi = right;
		long pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(long[] a, int i, int j) {
		long temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(float[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(float[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(float[] a, int left, int right) {
		int lo = left;
		int hi = right;
		float pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(float[] a, int i, int j) {
		float temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(double[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(double[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	private static int partition(double[] a, int left, int right) {
		int lo = left;
		int hi = right;
		double pivot = a[left];	
		while(lo < hi) {
			while(a[hi] > pivot) --hi;
			while(a[lo] <= pivot && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static void swap(double[] a, int i, int j) {
		double temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static <T> void sort(T[] a, Comparator<? super T> c) {
		if(c == null) {
			sort(a);
		}
		else {
			qsort(a, 0, a.length - 1, c);
		}
	}
	public static void sort(Object[] a) {
		qsort(a, 0, a.length - 1);
	}
	private static void qsort(Object[] a, int lo, int hi) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi);	
		qsort(a, lo, pivot - 1);
		qsort(a, pivot + 1, hi);
	}
	@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
	private static int partition(Object[] a, int left, int right) {
		int lo = left;
		int hi = right;
		Comparable pivot = ((Comparable) a[left]);	
		while(lo < hi) {
			while(pivot.compareTo(a[hi]) < 0) --hi;
			while(pivot.compareTo(a[lo]) >= 0 && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static <T> void qsort(T[] a, int lo, int hi, Comparator<? super T> c) {
		if(lo >= hi) {
			return;
		}
		int pivot = partition(a, lo, hi, c);	
		qsort(a, lo, pivot - 1, c);
		qsort(a, pivot + 1, hi, c);
	}
	private static <T> int partition(T[] a, int left, int right, Comparator<? super T> c) {
		int lo = left;
		int hi = right;
		T pivot = a[left];
		while(lo < hi) {
			while(c.compare(pivot, a[hi]) < 0) --hi;
			while(c.compare(a[lo], pivot) <= 0 && lo < hi) ++lo;
			swap(a, lo, hi);
		}
		swap(a, left, lo);
		return lo;
	}
	private static <T> void swap(T[] a, int i, int j) {
		T temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void sort(byte[] a, boolean isReverse) {
		if(isReverse) {
			Byte[] b = Convert.toByteArray(a);
			sort(b, Order.reverseOrder());
			Convert.tobyteArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(char[] a, boolean isReverse) {
		if(isReverse) {
			Character[] b = Convert.toCharacterArray(a);
			sort(b, Order.reverseOrder());
			Convert.tocharArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(short[] a, boolean isReverse) {
		if(isReverse) {
			Short[] b = Convert.toShortArray(a);
			sort(b, Order.reverseOrder());
			Convert.toshortArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(int[] a, boolean isReverse) {
		if(isReverse) {
			Integer[] b = Convert.toIntegerArray(a);
			sort(b, Order.reverseOrder());
			Convert.tointtArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(long[] a, boolean isReverse) {
		if(isReverse) {
			Long[] b = Convert.toLongArray(a);
			sort(b, Order.reverseOrder());
			Convert.tolongArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(float[] a, boolean isReverse) {
		if(isReverse) {
			Float[] b = Convert.toFloatArray(a);
			sort(b, Order.reverseOrder());
			Convert.toflostArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(double[] a, boolean isReverse) {
		if(isReverse) {
			Double[] b = Convert.toDoubleArray(a);
			sort(b, Order.reverseOrder());
			Convert.todoubleArray(b, a);
		}
		else {
			sort(a);
		}
	}
}",1,0,0,0,0,0,0,0,0
943,"from typing import List
def partition(array: List[int], left: int, right: int, pt: int) -> int:
    while True:
        swaps = 0  
        for i in range(
            left, pt
        ):  
            if array[pt] < array[i]:  
                array[pt], array[i] = array[i], array[pt]
                pt = i
                swaps += 1
                break
        for i in range(right, pt, -1):  
            if array[pt] > array[i]:  
                array[pt], array[i] = array[i], array[pt]
                pt = i
                swaps += 1
                break
        if swaps == 0:
            break  
    return pt
def quickSort(array: List[int], *args: List[int]) -> None:
    left, right = 0, len(array) - 1
    if len(args) == 2:
        left, right = args
    if left < right - 1:
        half = (left + right) // 2  
        start, middle, end = array[left], array[half], array[right]
        if (start > end and start < middle) or (start < end and start > middle):
            pivotPt = left
        elif (end > start and end < middle) or (end < start and end > middle):
            pivotPt = right - 1
        else:
            pivotPt = half
        pt = partition(array, left, right, pivotPt)
        quickSort(array, pt, right)
        quickSort(array, left, pt)
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""IN PLACE QUICK SORT"")
    shuffledArray = randomSequence(0, 1000)
    print(shuffledArray, ""\n"")
    quickSort(shuffledArray)
    print(shuffledArray)",1,0,0,0,0,0,0,0,0
944,"from random import random
import sys
import os
import burst
import insertion
from burstSettings import EOS, INS_SORT_THRESHOLD
class mkqsorter(object):
    def setup(self, data, indexes):
        self.data = data
        self.a = indexes
    def swap(self, i, j):
        self.a[i], self.a[j] = self.a[j], self.a[i]
    def nswap(self, i, j, l):
        self.a[i: i + l], self.a[j: j + l] = self.a[j: j + l], self.a[i: i + l]
    def ch(self, i):
        return self.data[self.a[i] + self.d]
    def sort(self, n):
        stack = [(0, n, 0)]
        while len(stack) > 0:
            L, R, self.d = stack.pop()
            n = R - L
            if n < INS_SORT_THRESHOLD:
                insertion.sort(self.data, self.a, self.d, L, R)
                continue
            if n < 2:
                continue
            p = L + int(random() * n)
            p = L
            self.swap(L, p)
            lEq = l = L + 1
            rEq = r = R - 1
            pivot = self.ch(L)
            while True:
                while l <= r and self.ch(l) <= pivot:
                    if self.ch(l)  == pivot:
                        self.swap(lEq, l)
                        lEq += 1
                    l += 1
                while l <= r and self.ch(r) >= pivot:
                    if self.ch(r) == pivot:
                        self.swap(rEq, r)
                        rEq -= 1
                    r -= 1
                if l > r:
                    break
                self.swap(l, r)
                l += 1
                r -= 1
            c = min(lEq - L, l - lEq)
            self.nswap(L, l - c, c)
            c = min(R - 1 - rEq, rEq - r)
            self.nswap(l, R - c, c)
            stack.append((L, L + l - lEq, self.d))
            if pivot != EOS:
                stack.append((L + l - lEq, l + (R - 1 - rEq), self.d + 1))
            stack.append((R - (rEq - r), R, self.d))
sorter = mkqsorter() 
def sort(data, array, n = -1):
    if n == -1:
        n = len(array)
    sorter.setup(data, array)
    sorter.sort(n)
def index(data):
    indexes = [0]
    for i in xrange(len(data)):
        if data[i] == EOS:
            indexes.append(i + 1);
    indexes.pop()
    return indexes
def output(data, indexes):
    output = bytearray(len(data))
    counter = 0
    for i in indexes:
        j = i
        while True:
            output[counter] = data[j]
            counter += 1
            if data[j] == EOS:
                break
            j += 1
    return output
def main(filename = sys.argv[1]):
    data, finalEOS = burst.read(filename)
    strings = index(data)
    sort(data, strings)
    outputBuffer = output(data, strings);
    if not finalEOS:
        outputBuffer.pop()
    sys.stdout.write(outputBuffer)
if __name__ == '__main__':
    main()",1,0,0,0,0,0,0,0,0
945,"public class MyClass {
    public static void main(String args[]) {
     int[] arr={29,40,1,30,22};
     int leng=arr.length;
     MyClass qsm=new MyClass();
     qsm.quickSortMiddle(arr,0,leng-1);
      printArray(arr);
    }
    int partition(int[] arr,int low,int high){
        int pivot=arr[(low+high)/2];
        while(low<=high){
            while(arr[low]<pivot){
                low++;
            }
            while(arr[high]>pivot){
                high--;
            }
            if(low<=high){
                int temp=arr[low];
                arr[low]=arr[high];
                arr[high]=temp;
                low++;
                high--;
            }
        }
        return low;
    }
    void quickSortMiddle(int[] arr,int low,int high){
        int pi=partition(arr,low,high);
        if(low<pi-1){
            quickSortMiddle(arr,low,pi-1);
       }
       if(pi<high){
           quickSortMiddle(arr,pi,high);
       }
    }
     static void printArray(int arr[]){
        int n=arr.length;
        for(int i=0;i<n;i++){
            System.out.println(arr[i]+"" "");
        }
    }
}",1,0,0,0,0,0,0,0,0
946,"import random
def QuickSort(A,start,end):
    if(start<end):
        pindex=RandomPartition(A,start,end)
        QuickSort(A,start,pindex-1)
        QuickSort(A,pindex+1,end)
def RandomPartition(A,start,end):
    pivotIndex=random.randint(start,end)
    A[pivotIndex],A[end]=A[end],A[pivotIndex]
    pindex=Partition(A,start,end)
    return pindex
def Partition(A,start,end):
    pivot=A[end]
    pIndex=start
    for i in range(start,end):
        if(A[i]<=pivot):
            A[i],A[pIndex]=A[pIndex],A[i]
            pIndex+=1
    A[pIndex],A[end]=A[end],A[pIndex]
    return pIndex
if __name__==""__main__"":
    A=[]
    print(""Enter the elements in the Array: "")
    A=list(map(int,input().split("" "")))
    end=len(A)-1
    print(""Sorted Array: "",end="""")
    QuickSort(A,0,end)
    for i in range(0,len(A)):
        print(A[i],end="" "")",1,0,0,0,0,0,0,0,0
947,"package ParallelSort;
import java.util.Comparator;
import java.util.concurrent.RecursiveAction;
import Utils.Convert;
import Utils.Order;
public class ParallelLPQuickSort {
	final static int THRESHOLD = 1 << 13;
	public static void sort(byte[] a) {
		new ParLPQuickByte.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickByte {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final byte[] a;
			final int lo;
			final int hi;
			QSort(byte[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(byte[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(byte[] a, int left, int right) {
			int lo = left;
			int hi = right;
			byte pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(byte[] a, int i, int j) {
			byte temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(char[] a) {
		new ParLPQuickChar.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickChar {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final char[] a;
			final int lo;
			final int hi;
			QSort(char[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(char[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(char[] a, int left, int right) {
			int lo = left;
			int hi = right;
			char pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(char[] a, int i, int j) {
			char temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(short[] a) {
		new ParLPQuickShort.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickShort {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final short[] a;
			final int lo;
			final int hi;
			QSort(short[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(short[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(short[] a, int left, int right) {
			int lo = left;
			int hi = right;
			short pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(short[] a, int i, int j) {
			short temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(int[] a) {
		new ParLPQuickInt.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickInt {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final int[] a;
			final int lo;
			final int hi;
			QSort(int[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(int[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(int[] a, int left, int right) {
			int lo = left;
			int hi = right;
			int pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(int[] a, int i, int j) {
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(long[] a) {
		new ParLPQuickLong.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickLong {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final long[] a;
			final int lo;
			final int hi;
			QSort(long[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(long[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(long[] a, int left, int right) {
			int lo = left;
			int hi = right;
			long pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(long[] a, int i, int j) {
			long temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(float[] a) {
		new ParLPQuickFloat.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickFloat {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final float[] a;
			final int lo;
			final int hi;
			QSort(float[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(float[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(float[] a, int left, int right) {
			int lo = left;
			int hi = right;
			float pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(float[] a, int i, int j) {
			float temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(double[] a) {
		new ParLPQuickDouble.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickDouble {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final double[] a;
			final int lo;
			final int hi;
			QSort(double[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(double[] a, int lo, int hi) {	
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		private static int partition(double[] a, int left, int right) {
			int lo = left;
			int hi = right;
			double pivot = a[left];	
			while(lo < hi) {
				while(a[hi] > pivot) --hi;
				while(a[lo] <= pivot && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(double[] a, int i, int j) {
			double temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static <T> void sort(T[] a, Comparator<? super T> c) {
		if(c == null) {
			sort(a);
		}
		else {
			new ParLPQuickDComparator.QSort<>(a, 0, a.length - 1, c).invoke();
		}
	}
	public static void sort(Object[] a) {
		new ParLPQuickDComparable.QSort(a, 0, a.length - 1).invoke();
	}
	private static final class ParLPQuickDComparable {	
		private static final class QSort extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final Object[] a;
			final int lo;
			final int hi;
			QSort(Object[] a, int lo, int hi) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi);
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1);
					qsort(a, pivot + 1, hi);
				}
				else {
					QSort left = new QSort(a, lo, pivot - 1);
					QSort right = new QSort(a, pivot + 1, hi);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static void qsort(Object[] a, int lo, int hi) {
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi);	
			qsort(a, lo, pivot - 1);
			qsort(a, pivot + 1, hi);
		}
		@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
		private static int partition(Object[] a, int left, int right) {
			int lo = left;
			int hi = right;
			Comparable pivot = ((Comparable) a[left]);	
			while(lo < hi) {
				while(pivot.compareTo(a[hi]) < 0) --hi;
				while(pivot.compareTo(a[lo]) >= 0 && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static void swap(Object[] a, int i, int j) {
			Object temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	private static final class ParLPQuickDComparator {
		private static final class QSort<T> extends RecursiveAction {
			private static final long serialVersionUID = 1L;
			final T[] a;
			final int lo;
			final int hi;
			final Comparator<? super T> c;
			QSort(T[] a, int lo, int hi, Comparator<? super T> c) {
				this.a = a;
				this.lo = lo;
				this.hi = hi;
				this.c = c;
			}
			public final void compute() {
				if(lo >= hi) {
					return;
				}
				int pivot = partition(a, lo, hi, c);	
				if(hi - lo < THRESHOLD) {
					qsort(a, lo, pivot - 1, c);
					qsort(a, pivot + 1, hi, c);
				}
				else {
					QSort<T> left = new QSort<>(a, lo, pivot - 1, c);
					QSort<T> right = new QSort<>(a, pivot + 1, hi, c);
					left.fork();
					right.compute();
					left.join();
				}
			}
		}
		private static <T> void qsort(T[] a, int lo, int hi, Comparator<? super T> c) {
			if(lo >= hi) {
				return;
			}
			int pivot = partition(a, lo, hi, c);	
			qsort(a, lo, pivot - 1, c);
			qsort(a, pivot + 1, hi, c);
		}
		private static <T> int partition(T[] a, int left, int right, Comparator<? super T> c) {
			int lo = left;
			int hi = right;
			T pivot = a[left];
			while(lo < hi) {
				while(c.compare(pivot, a[hi]) < 0) --hi;
				while(c.compare(a[lo], pivot) <= 0 && lo < hi) ++lo;
				swap(a, lo, hi);
			}
			swap(a, left, lo);
			return lo;
		}
		private static <T> void swap(T[] a, int i, int j) {
			T temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	public static void sort(byte[] a, boolean isReverse) {
		if(isReverse) {
			Byte[] b = Convert.toByteArray(a);
			sort(b, Order.reverseOrder());
			Convert.tobyteArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(char[] a, boolean isReverse) {
		if(isReverse) {
			Character[] b = Convert.toCharacterArray(a);
			sort(b, Order.reverseOrder());
			Convert.tocharArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(short[] a, boolean isReverse) {
		if(isReverse) {
			Short[] b = Convert.toShortArray(a);
			sort(b, Order.reverseOrder());
			Convert.toshortArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(int[] a, boolean isReverse) {
		if(isReverse) {
			Integer[] b = Convert.toIntegerArray(a);
			sort(b, Order.reverseOrder());
			Convert.tointtArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(long[] a, boolean isReverse) {
		if(isReverse) {
			Long[] b = Convert.toLongArray(a);
			sort(b, Order.reverseOrder());
			Convert.tolongArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(float[] a, boolean isReverse) {
		if(isReverse) {
			Float[] b = Convert.toFloatArray(a);
			sort(b, Order.reverseOrder());
			Convert.toflostArray(b, a);
		}
		else {
			sort(a);
		}
	}
	public static void sort(double[] a, boolean isReverse) {
		if(isReverse) {
			Double[] b = Convert.toDoubleArray(a);
			sort(b, Order.reverseOrder());
			Convert.todoubleArray(b, a);
		}
		else {
			sort(a);
		}
	}
}",1,0,0,0,0,0,0,0,0
948,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.utils.ArrayUtils;
import java.util.concurrent.ThreadLocalRandom;
public class PivotHelper {
  static void findPivotAndMoveRight(int[] elements, int left, int right,
                                    PivotStrategy pivotStrategy) {
    int pivotPos = findPivotPos(elements, left, right, pivotStrategy);
    if (pivotPos != right)
      ArrayUtils.swap(elements, pivotPos, right);
  }
  static int findPivotPos(int[] elements, int left, int right,
                          PivotStrategy pivotStrategy) {
    return switch (pivotStrategy) {
      case RIGHT -> right;
      case RANDOM -> ThreadLocalRandom.current().nextInt(left, right + 1);
      case LEFT -> left;
      case MIDDLE -> {
        int rl = right - left;
        yield rl < 2 ? right : left + rl / 2;
      }
      case MEDIAN3 -> getMedian3Pos(elements, left, right);
      default -> throw new IllegalStateException(""Unexpected value: "" + pivotStrategy);
    };
  }
  private static int getMedian3Pos(int[] elements, int left, int right) {
    int rl = right - left;
    if (rl < 2) {
      return right;
    }
    int middle = left + rl / 2;
    int first = left + (middle - left) / 2;
    int last = right - (right - middle) / 2;
    int l = elements[first];
    int m = elements[middle];
    int r = elements[last];
    if (l < r) {
      if (l >= m) {
        return first;
      } else if (r < m) {
        return last;
      }
    } else {
      if (l < m) {
        return first;
      } else if (r >= m) {
        return last;
      }
    }
    return middle;
  }
}",0,0,0,0,0,0,0,0,0
949,"package eu.happycoders.sort.method.quicksort;
public enum PivotStrategy {RANDOM, LEFT, RIGHT, MIDDLE, MEDIAN3}",0,0,0,0,0,0,0,0,0
950,"package sorting;
import edu.princeton.cs.algs4.StdOut;
import edu.princeton.cs.algs4.StdRandom;
public class Quick {
  public static void sort(Comparable[] a) {
    StdRandom.shuffle(a);  
    sort(a, 0, a.length - 1);
  }
  private static void sort(Comparable[] a, int lo, int hi) {
    if (hi <= lo) return;
    int j = partition(a, lo, hi);  
    sort(a, lo, j-1);  
    sort(a, j+1, hi);  
  }
  private static int partition(Comparable[] a, int lo, int hi) {  
    int i = lo, j = hi+1;  
    Comparable v = a[lo];  
    while (true) {  
      while (less(a[++i], v)) if (i == hi) break;
      while (less(v, a[--j])) if (j == lo) break;
      if (i >= j) break;
      exch(a, i, j);
    }
    exch(a, lo, j);  
    return j;  
  }
  private static boolean less(Comparable v, Comparable w) {
      if (v == w) return false;    
      return v.compareTo(w) < 0;
  }
  private static void exch(Object[] a, int i, int j) {
      Object swap = a[i];
      a[i] = a[j];
      a[j] = swap;
  }
  private static void show(Comparable[] a) {  
    for (int i = 0; i < a.length; i++)
      StdOut.print(a[i] + "" "");
      StdOut.println();
    }
  public static boolean isSorted(Comparable[] a) {  
    for (int i = 1; i < a.length; i++)
      if (less(a[i], a[i-1])) return false;
    return true;
  }
  public static void main(String[] args) {
    String example = ""Q U I C K S O R T E X A M P L E"";
    String [] a = example.split("" "");
    sort(a);
    assert isSorted(a);
    show(a);
  }
}",1,0,0,0,0,0,0,0,0
951,"import structures.src.util.sort_util as util
def quicksort(arr):
   if arr == []: return []
   return quicksort([n for n in arr[1:] if n < arr[0]]) + arr[0:1] +          quicksort([n for n in arr[1:] if n >= arr[0]])",1,0,0,0,0,0,0,0,0
952,"public class Quick {
    public static void sort(int[] input) {
        quicksort(input, 0, input.length - 1);
    }
    private static void quicksort(int[] input, int start, int end) {
        if (end <= start)
            return;
        int pivot = partition(input, start, end);
        quicksort(input, start, pivot - 1);
        quicksort(input, pivot + 1, end);
    }
    private static int partition(int[] input, int start, int end) {
        int pivot = input[end];
        int i = start;
        for (int j = start; j < end; j++) {
            if (input[j] < pivot) {
                swap(input, i, j);
                i++;
            }
        }
        swap(input, i, end);
        return i;
    }
    private static void swap(int[] input, int a, int b) {
        int cache = input[a];
        input[a] = input[b];
        input[b] = cache;
    }
}",1,0,0,0,0,0,0,0,0
953,"package piratezpdx.sortathon;
import java.util.Random;
public class Quick extends ArrayBased {
    public Random pivotPoint;
    Quick() {
        super();
        pivotPoint = new Random();
    }
    public int sort (){
        return partitionRecurse(0, sortingArray.length);
    }
    public int partitionRecurse(int startIndex, int quantity){
        if (quantity <= 1){
            return 0;
        }
        int pivot = ((Math.abs(pivotPoint.nextInt()) % quantity) + startIndex);
        int temp = 0;
        int count = 0;
        int i = startIndex+1;
        temp = sortingArray[pivot];
        sortingArray[pivot] = sortingArray[startIndex];
        sortingArray[startIndex] = temp;
        for (int j = startIndex; j < startIndex+quantity; j++ ){
            if (sortingArray[j] < sortingArray[startIndex]){
                temp = sortingArray[j];
                sortingArray[j] = sortingArray[i];
                sortingArray[i] = temp;
                i++;
            }
            count++;
        }
        temp = sortingArray[startIndex];
        sortingArray[startIndex] = sortingArray[i-1];
        sortingArray[i-1] = temp;
        count += (partitionRecurse(startIndex, i-startIndex-1));    
        count += (partitionRecurse(i, quantity+startIndex-i) + 1);  
        return count;                                               
    }
}",1,0,0,0,0,0,0,0,0
954,"package Sorting;
public class Quick { 
	public static <T extends Comparable<T>> void quickSort(T arr[])
    {
		quickSortHelper(arr,0,arr.length - 1);
    }
	private static <T extends Comparable<T>> void quickSortHelper(T arr[], int low, int high)
    {
        if (low < high)
        {
            int index = partition(arr, low, high);
            quickSortHelper(arr, low, index-1);
            quickSortHelper(arr, index+1, high);
        } 
    }
	private static <T extends Comparable<T>> int partition(T arr[], int low, int high)
    {
        T pivot = arr[high]; 
        int i = (low-1);  
        for (int j = low; j <high; j++)
        {
            if (arr[j].compareTo(pivot) <= 0)
            {
                i++;
                T temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        T temp = arr[i+1];
        arr[i+1] = arr[high];
        arr[high] = temp;
        return i+1;
    }   
}",1,0,0,0,0,0,0,0,0
955,"def quicksort(A,low,high):
    if high-low <= 0:
        return
quicksort(A,low,pivot-1)
quicksort(A,pivot+1,high)",0,0,0,0,0,0,0,0,0
956,"package com.sorting;
public class Quick {
	private Quick() {
	}
	public static void sort(Comparable[] array) {
		sort(array, 0, array.length - 1);
	}
	private static void sort(Comparable[] array, int lo, int hi) {
		if (hi <= lo)
			return;
		int i = lo;
		int j = hi;
		int mid = lo + (hi - lo) / 2;
		Comparable pivot = array[lo + (hi - lo) / 2];
		while (i <= j) {
			while (less(array[i], pivot)) {
				i++;
			}
			while (less(pivot, array[j])) {
				j--;
			}
			if (i <= j) {
				exchange(array, i, j);
				i++;
				j--;
			}
			if (j < i)
				break;
			show(array);
		}
		if (lo < j)
			sort(array, lo, j);
		if (i < hi)
			sort(array, i, hi);
	}
	private static boolean less(Comparable v, Comparable w) {
		return v.compareTo(w) < 0;
	}
	private static void exchange(Object[] a, int i, int j) {
		Object swap = a[i];
		a[i] = a[j];
		a[j] = swap;
	}
	public static void show(Comparable[] array) {
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + "","");
		}
	}
}",1,0,0,0,0,0,0,0,0
957,"__all__ = (
    ""quick_sort"",
    ""first_pivot"",
    ""middle_pivot"",
    ""last_pivot"",
)
from typing import List, TypeVar, Callable
T = TypeVar(""T"")
def first_pivot(low: int, high: int) -> int:
    return low
def middle_pivot(low: int, high: int) -> int:
    return (low + high) // 2
def last_pivot(low: int, high: int) -> int:
    return high
def quick_sort(
    data: List[T],
    *,
    reverse: bool = False,
    inplace: bool = False,
    pivot_cb: Callable[[int, int], int] = middle_pivot
) -> List[T]:
    if not inplace:
        data = data.copy()
    comparison_op: str = ""__lt__"" if reverse else ""__gt__""
    def sort(low: int, high: int) -> None:
        if low >= high:
            return
        mid: int = partition(low, high)
        sort(low, mid - 1)
        sort(mid + 1, high)
    def partition(low: int, high: int) -> int:
        pivot_index: int = pivot_cb(low, high)
        data[high], data[pivot_index] = data[pivot_index], data[high]
        pivot = data[high]
        left: int = low
        right: int = high - 1
        while True:
            while getattr(pivot, comparison_op)(data[left]) and left < right:
                left += 1
            while not getattr(pivot, comparison_op)(data[right]) and left < right:
                right -= 1
            if left >= right:
                break
            data[left], data[right] = data[right], data[left]
        if getattr(pivot, comparison_op)(data[left]):
            left += 1
        data[left], data[high] = data[high], data[left]
        return left
    sort(0, len(data) - 1)
    return data",1,0,0,0,0,0,0,0,0
958,"import time
import random
def partition(lista, left, right):
    pivot = lista[right]
    i = left-1
    for j in range(left, right):
        if lista[j] <= pivot:
            i += 1
            lista[i], lista[j] = lista[j], lista[i]
    i += 1
    lista[i], lista[right] = lista[right], lista[i]
    return i
def quick_sort(lista, left, right):
    if left < right:
        pivot = partition(lista, left, right)
        quick_sort(lista, left, pivot-1)
        quick_sort(lista, pivot+1, right)
if __name__ == '__main__':
	lista = [_ for _ in range(1000)]
 random.shuffle(lista)
 start_time = time.time()
 quick_sort(lista, 0, len(lista) - 1)
 end_time = time.time()
 print(""Time: "", end_time - start_time)",1,0,0,0,0,0,0,0,0
959,"from timeit import default_timer as timer
def quick_sort(array):
    _quicksort(array, 0, len(array) - 1)
def _quicksort(array, start, stop):
    if stop - start > 0:
        pivot, left, right = array[start], start, stop
        while left <= right:
            while array[left] < pivot:
                left += 1
            while array[right] > pivot:
                right -= 1
            if left <= right:
                array[left], array[right] = array[right], array[left]
                left += 1
                right -= 1
        _quicksort(array, start, right)
        _quicksort(array, left, stop)
if __name__ == '__main__':
    time_taken = 0
    x = int(input(""Enter number of trials : ""))
    for n in range(1,x+1):
        with open(""data/random.txt"",""r"") as fileobj:
            list_to_sort = list(map(int, fileobj.readlines()))
            start = timer()
            l = quick_sort(list_to_sort)
            current = timer()-start
            print(f""Running test {n} : {current:.2f} seconds"")
            time_taken += current
    assert sorted(list_to_sort) == l
    time_taken /= x
    print(f""Quick sort: average time = {time_taken:.2f} seconds"")",1,0,0,0,0,0,0,0,0
960,"def quick_sort(num_list):
   quick_sort_partition(num_list,0,len(num_list)-1)
   return num_list 
def quick_sort_partition(num_list,first,last):
   if first<last:
       split_point = partition(num_list,first,last)
       quick_sort_partition(num_list,first,split_point-1)
       quick_sort_partition(num_list,split_point+1,last)
def partition(num_list,first,last):
   pivot = num_list[first]
   left_mart = first+1
   right_mark = last
   done = False
   while not done:
       while left_mart <= right_mark and num_list[left_mart] <= pivot:
           left_mart = left_mart + 1
       while num_list[right_mark] >= pivot and right_mark >= left_mart:
           right_mark = right_mark -1
       if right_mark < left_mart:
           done = True
       else:
           temp = num_list[left_mart]
           num_list[left_mart] = num_list[right_mark]
           num_list[right_mark] = temp
   temp = num_list[first]
   num_list[first] = num_list[right_mark]
   num_list[right_mark] = temp
   return right_mark
print quick_sort([54,26,93,17,77,31,44,55,20])",1,0,0,0,0,0,0,0,0
961,"def quicksort(lst):
    if len(lst) <= 1:
        return lst
    else:
        pivot = lst.pop()
    left = []
    right = []
    for i in lst:
        if i < pivot:
            left.append(i)
        else:
            right.append(i)
    return quicksort(left) + [pivot] + quicksort(right)
lst = [7, 5, 3, 1, 5, 9, 8, 4, 6, 2, 10]
print(quicksort(lst))",1,0,0,0,0,0,0,0,0
962,"from __future__ import print_function
def quick_sort(ARRAY):
    ARRAY_LENGTH = len(ARRAY)
    if( ARRAY_LENGTH <= 1):
        return ARRAY
    else:
        PIVOT = ARRAY[0]
        GREATER = [ element for element in ARRAY[1:] if element > PIVOT ]
        LESSER = [ element for element in ARRAY[1:] if element <= PIVOT ]
        return quick_sort(LESSER) + [PIVOT] + quick_sort(GREATER)
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [ int(item) for item in user_input.split(',') ]
    print( quick_sort(unsorted) )",1,0,0,0,0,0,0,0,0
963,"from random import randint
def quicksort(lst, start, end):
    if start < end:
        pivot = randint(start, end)
        lst[end],lst[pivot] = lst[pivot],lst[end]
        split = partition(lst, start, end)
        quicksort(lst, start, split-1)
        quicksort(lst, split+1, end)
def partition(lst, start, end):
    pivot_index = start-1
    for index in range(start, end):
        if lst[index] < lst[end]:
            pivot_index = pivot_index + 1
            lst[pivot_index],lst[index] = lst[index],lst[pivot_index]
    lst[pivot_index+1],lst[end] = lst[end],lst[pivot_index+1]
    return pivot_index+1
nums = [7,2,5,1,29,6,4,19,11]
quicksort(nums,0,len(nums)-1)
print(nums)      ",1,0,0,0,0,0,0,0,0
964,"def partition(array, begin, end):
    pivot_idx = begin
    for i in xrange(begin+1, end+1):
        if array[i] <= array[begin]:
            pivot_idx += 1
            array[i], array[pivot_idx] = array[pivot_idx], array[i]
    array[pivot_idx], array[begin] = array[begin], array[pivot_idx]
    return pivot_idx
def quick_sort_recursion(array, begin, end):
    if begin >= end:
        return
    pivot_idx = partition(array, begin, end)
    quick_sort_recursion(array, begin, pivot_idx-1)
    quick_sort_recursion(array, pivot_idx+1, end)
def quick_sort(array, begin=0, end=None):
    if end is None:
        end = len(array) - 1
    return quick_sort_recursion(array, begin, end)",1,0,0,0,0,0,0,0,0
965,"from __future__ import print_function
def quick_sort(collection):
    length = len(collection)
    if length <= 1:
        return collection
    else:
        pivot = collection[0]
        greater = [element for element in collection[1:] if element > pivot]
        lesser = [element for element in collection[1:] if element <= pivot]
        return quick_sort(lesser) + [pivot] + quick_sort(greater)
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [ int(item) for item in user_input.split(',') ]
    print( quick_sort(unsorted) )",1,0,0,0,0,0,0,0,0
966,"package Sorting;
public class Quick_Sort {
    void Quick_Sort(int[] givenArr,int low,int high){
        if(low<high){
            int pi = partition(givenArr,low,high);
            Quick_Sort(givenArr,low,pi-1);
            Quick_Sort(givenArr,pi+1,high);
        }
    }
    private int partition(int[] givenArr, int low, int high) {
        int pivot = givenArr[high];
        int i=low-1;
        for(int j=low;j<=high-1;j++){
            if(pivot>givenArr[j]){
                i++;
                swap(givenArr,i,j);
            }
        }
        swap(givenArr,i+1,high);
        return i+1;
    }
    void swap(int[] arr, int a,int b){
        int tmp = arr[a];
        arr[a]=arr[b];
        arr[b]=tmp;
    }
    public static void main(String[] args) {
        int[] given_arr = new int[]{10,2,8,1,4,6,5,7,9};
        Quick_Sort quick_sort = new Quick_Sort();
        quick_sort.Quick_Sort(given_arr,0,given_arr.length-1);
        quick_sort.printArr(given_arr);
    }
    private void printArr(int[] given_arr) {
        for(int i=0;i<given_arr.length;i++){
            System.out.print(given_arr[i]+"" "");
        }
    }
}",1,0,0,0,0,0,0,0,0
967,"def median(a, i, j, k):
    ai, aj, ak = a[i], a[j], a[k]
    med_val = ai + aj + ak - max(ai, aj, ak) - min(ai, aj, ak)
    if ai == med_val:
        return i
    elif aj == med_val:
        return j
    return k
def partition(array, l, r):
    i = l - 1
    pivot_index = median(array, l, r, (l+r) // 2)
    array[pivot_index], array[r] = array[r], array[pivot_index]
    pivot = array[r]
    for j in range(l, r):
        if array[j] <= pivot:
            i += 1
            array[i], array[j] = array[j], array[i]
    i += 1
    array[r], array[i] = array[i], array[r]
    return i
def quick_sort(array, left, right):
    if left < right:
        q = partition(array, left, right)
        quick_sort(array, left, q - 1)
        quick_sort(array, q + 1, right)
def main():
    a = [1, 2, 1, 2, 3, 1, 2, 2, 1]
    quick_sort(a, 0, len(a) - 1)
    print(a)
if __name__ == '__main__':
    main()",1,0,0,0,0,0,0,0,0
968,"def QuickSort(A,start,end):
    if(start<end):
        pindex=Partition(A,start,end)
        QuickSort(A,start,pindex-1)
        QuickSort(A,pindex+1,end)
def Partition(A,start,end):
    pivot=A[end]
    pIndex=start
    for i in range(start,end):
        if(A[i]<=pivot):
            A[i],A[pIndex]=A[pIndex],A[i]
            pIndex+=1
    A[pIndex],A[end]=A[end],A[pIndex]
    return pIndex
if __name__==""__main__"":
    A=[]
    print(""Enter the elements in the Array: "")
    A=list(map(int,input().split("" "")))
    end=len(A)-1
    print(""Sorted Array: "",end="""")
    QuickSort(A,0,end)
    for i in range(0,len(A)):
        print(A[i],end="" "")",1,0,0,0,0,0,0,0,0
969,"Pseudo Code for recursive QuickSort function :
quickSort(arr[], low, high)
{
    if (low < high)
    {
        pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);   
        quickSort(arr, pi + 1, high);  
    }
}
Pseudo code for partition():
partition (arr[], low, high)
{
    pivot = arr[high];  
    i = (low - 1)   
    for (j = low; j <= high- 1; j++)
    {
        if (arr[j] < pivot)
        {
            i++;     
            swap arr[i] and arr[j]
        }
    }
    swap arr[i + 1] and arr[high])
    return (i + 1)
}
*/
class QuickSort 
{ 
	int partition(int arr[], int low, int high) 
	{ 
		int pivot = arr[high]; 
		int i = (low-1);  
		for (int j=low; j<high; j++) 
		{ 
			if (arr[j] < pivot) 
			{ 
				i++; 
				int temp = arr[i]; 
				arr[i] = arr[j]; 
				arr[j] = temp; 
			} 
		} 
		int temp = arr[i+1]; 
		arr[i+1] = arr[high]; 
		arr[high] = temp; 
		return i+1; 
	} 
	void sort(int arr[], int low, int high) 
	{ 
		if (low < high) 
		{ 
			int pi = partition(arr, low, high); 
			sort(arr, low, pi-1); 
			sort(arr, pi+1, high); 
		} 
	} 
	public static void main(String args[]) 
	{ 
		int arr[] = {10, 7, 8, 9, 1, 5}; 
		int n = arr.length; 
		QuickSort ob = new QuickSort(); 
		ob.sort(arr, 0, n-1); 
		System.out.println(""sorted array""); 
		int n = arr.length; 
		for (int i=0; i<n; ++i) 
			System.out.print(arr[i]+"" ""); 
		System.out.println();  
	} 
} ",1,0,0,0,0,0,0,0,0
970,"def quick_first(list_first):
	pass
def quick_last(list_last):
	print('\n<<<<<<<<<< This is quick sort with pivot as last element >>>>>>>>>>')
 length = len(list_last)
 def partition(list_last, low, high):
		i = low - 1  
  pivot = list_last[high]  
  for j in range(low, high):
			if list_last[j] <= pivot:
				i = i + 1
    list_last[i], list_last[j] = list_last[j], list_last[i]
  list_last[i + 1], list_last[high] = list_last[high], list_last[i + 1]
  return i + 1
 def quicksort_last(list_last, low, high):
		if len(list_last) == 1:
			return list_last
  elif low < high:
			pi = partition(list_last, low, high)
   quicksort_last(list_last, low, pi - 1)  
   quicksort_last(list_last, pi + 1, high) 
 quicksort_last(list_last, 0, length - 1) 
 print('\nThe sorted list is :: ', list_last)
def quick_mid(list_mid):
	length = len(list_mid)
 def listPartition(list1,lb,up):
	    pivot=list1[(up+lb)//2]
     start=lb
     end=up-1
     while start<end:
	        while(list1[start]<pivot):
	            start=start+1
         while(list1[end]>pivot):
	            end=end-1
         if start<end:
	            temp=list1[start]
             list1[start]=list1[end]
             list1[end]=temp
     return start
 def quickSort(list1,lb,up):
		if lb<up:
			pos=listPartition(list1,lb,up)
   quickSort(list1,lb,pos)
   quickSort(list1,pos+1,up)
 quickSort(list_mid, 0, length - 1) 
 print('\nThe sorted list is :: ', list_mid)
def quick_random(list_random):
	pass
def dict_switch(choice):
	raw_dict = {
      1 : quick_first,
      2 : quick_last,
      3 : quick_mid,
      4 : quick_random
 }
 return raw_dict.get(choice, lambda : print('Wrong Input'))(raw_list)
raw_list = []
value = int(input('Enter the number of values in list :: '))
for i in range(value):
	list_val = int(input(f'Enter the value {i + 1} in list :: '))
 raw_list.append(list_val)
print('\nThe list is :: ', raw_list)
print(""""""
	1. Enter ->1<- for sorting through first value as pivot
	2. Enter ->2<- for sorting through last value as pivot
	3. Enter ->3<- for sorting through mid value as pivot
	4. Enter ->4<- for sorting through random value as pivot"""""")
choice = int(input('\nEnter your Choice ::'))
dict_switch(choice)",1,0,0,0,0,0,0,0,0
971,"import java.util.Random;
class quick_sort 
{
    static void QuickSort(int arr[], int left, int right) {
        int l = left;
        int r = right - 1;
        int size = right - left;
        if(size > 1) {
            Random rn = new Random();
            int pivot = arr[rn.nextInt(size) + l];
            while(l < r) {
                while(arr[r] > pivot && r > l) {
                    r--;
                }
                while(arr[l] < pivot && l <= r) {
                    l++;
                }
                if(l < r) {
                    int temp = arr[l];
                    arr[l] = arr[r];
                    arr[r] = temp;
                    l++;
                }
            }
            QuickSort(arr, left, l);
            QuickSort(arr, r, right);
        }
    }
    static void printArray(int arr[]) {
        for(int i = 0; i < arr.length; ++i)
            System.out.print(arr[i]+"" "");
        System.out.println();
    }
    public static void main(String args[]) {
        int arr[] = {10, 54, 63, 6, 420, 11, 41, 32, 17, 22};
        QuickSort(arr, 0, arr.length);
        printArray(arr);
    }
}",1,0,0,0,0,0,0,0,0
972,"import copy 
import sort_tools
def swap(data, index1, index2):
    temp = data[index1]
    data[index1] = data[index2]
    data[index2] = temp
def median_of_three(data, low, high):
    middle = (high - low) // 2 + low
    if data[low] > data[middle]:
        swap(data, low, middle)
    if data[low] > data[high]:
        swap(data, low, high)
    if data[middle] > data[high]:
        swap(data, middle, high)
    swap(data, middle, high - 1)
    return high - 1
def partition(data, low, high):
    pivot = median_of_three(data, low, high)
    while low < pivot:
        if data[low] > data[pivot]:
            temp = data[low]
            data[low] = data[pivot-1]
            data[pivot-1] = data[pivot]
            data[pivot] = temp
            pivot -= 1
        else:
            low += 1
    return pivot
def quick_sort(data, low, high):
    if low < high:
        middle = partition(data, low, high)
        quick_sort(data, low, middle - 1)
        quick_sort(data, middle + 1, high)
@sort_tools.timeit('quick')
def sort(data):
    quick_sort(data, 0, len(data) - 1)
def main():
    data = sort_tools.build_data_set(5)
    unsorted = copy.deepcopy(data)
    sort(unsorted)
if __name__ == ""__main__"":
    main()",1,0,0,0,0,0,0,0,0
973,"package part2;
public class Quick_Sort {
	public static Comparable[] quickSort(Comparable[] a, int first, int last) {
		if(first<last) {
			int pivot = choosePivot(a, first, last);
			quickSort(a, first, pivot-1);
			quickSort(a, pivot+1, last);
		}
		return a;
	}
	private static int choosePivot(Comparable[] a, int first, int last) {
		Comparable pivot = a[last];
		int i = (first-1);
		for(int j=first; j< last; j++) {
			if(less(a[j],pivot)) { 
				i++;
				swap(a, i, j);
			}
		}
		swap(a,i+1,last);
		return i+1;
	}
	private static boolean less(Comparable a, Comparable b) {
		if(a.compareTo(b) < 0 || a.compareTo(b) == 0) {
			return true;
		}
		return false;
	}
	private static void swap(Comparable[] a, int i, int j) {
		Comparable temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
}",1,0,0,0,0,0,0,0,0
974,"def quick_sort(arr, low, high):
    if low == high:
        return
    max_ = partition(arr, low, high)
    quick_sort(arr, low, max_)
    quick_sort(arr, max_ + 1, high)
def partition(arr, low, high):
    pivot = arr[low]
    i = low
    j = high
    while i <= j:
        while True:
            i += 1
            if i >= len(arr) or arr[i] > pivot:
                break
        while True:
            j -= 1
            if j < 0 or arr[j] <= pivot:
                break
        if i < j:
            arr[i], arr[j] = arr[j], arr[i]
    arr[low], arr[j] = arr[j], arr[low]
    return j
def test_1():
    array = [1000, 10, 16, 8, 12, 15, 6, 3, 9, 5, 1000000]
    expected = sorted(array)
    quick_sort(array, 0, len(array))
    assert array == expected
def test_2():
    array = [1000, 5, 100, 8, 0, 1000000, 9]
    expected = sorted(array)
    quick_sort(array, 0, len(array))
    assert array == expected
def test_3():
    array = [1000, 5, 100, 8, 0, 1, 4, 9]
    expected = sorted(array)
    quick_sort(array, 0, len(array))
    assert array == expected
def test_4():
    array = [90, 5, 100]
    expected = sorted(array)
    quick_sort(array, 0, len(array))
    assert array == expected
def test_5():
    array = [90, 100]
    expected = sorted(array)
    quick_sort(array, 0, len(array))
    assert array == expected
if __name__ == ""__main__"":
    test_1()
    test_2()
    test_3()
    test_4()
    test_5()",1,0,0,0,0,0,0,0,0
975,"def sort(arr, iterative=True):
    if iterative is True:
        quicksort_iterative(arr, 0, len(arr) - 1)
    else:
        quicksort_recursive(arr, 0, len(arr) - 1)
def _partition_lomuto(arr, lo, hi):
    i = lo
    pivot = arr[hi]
    for j in range(lo, hi):
        if arr[j] <= pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
    arr[i], arr[hi] = arr[hi], arr[i]
    return i
def quicksort_iterative(arr, lo, hi):
    stack = [(lo, hi)]
    while len(stack) > 0:
        lo, hi = stack.pop()
        if lo < hi:
            p = _partition_lomuto(arr, lo, hi)
            stack.append((lo, p - 1))
            stack.append((p + 1, hi))
def quicksort_recursive(arr, lo, hi):
    if lo < hi:
        p = _partition_lomuto(arr, lo, hi)
        quicksort_recursive(arr, lo, p - 1)
        quicksort_recursive(arr, p + 1, hi)",1,0,0,0,0,0,0,0,0
976,"def partition(A, start, end):
    pivot = A[end]
    i = start - 1
    for j in range(start, end):
        if A[j] <= pivot:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[end] = A[end], A[i+1]
    return i+1, A
def quick_sort(A, start=0, end=-1):
    if end < 0:
        end = len(A) - 1
    if start < end:
        pivot_position, A = partition(A, start, end)
        quick_sort(A, start, pivot_position-1)
        quick_sort(A, pivot_position + 1, end)
    return A",1,0,0,0,0,0,0,0,0
977,"def quick_sort(arr, lo, hi):
    if hi > lo:
        pivot = arr[lo]
        p = partition(arr, pivot, lo, hi)
        mid1 = p[0]
        mid2 = p[1]
        quick_sort(arr, lo, mid1)
        quick_sort(arr, mid2, hi)
    return arr
def partition(arr, pivot, lo, hi):
    if hi - lo <= 1:
        if arr[hi] < arr[lo]:
            arr[hi], arr[lo] = arr[lo], arr[hi]
        return (lo, hi)
    mid = lo
    while mid <= hi:
        if arr[mid] < pivot:
            arr[mid], arr[lo] = arr[lo], arr[mid]
            lo += 1
            mid += 1
        elif arr[mid] == pivot:
            mid += 1
        else:
            arr[mid], arr[hi] = arr[hi], arr[mid]
            hi -= 1
    return (lo, mid)",1,0,0,0,0,0,0,0,0
978,"from strategy import Order, Pivot, BadOrderError, BadPivotError
import random
import sys
__author__ = ""Pablo Acereda""
__copyright__ = ""Copyright 2020""
__credits__ = [ ""Pablo Acereda"" ]
__license__ = ""Apache License 2.0""
__version__ = ""1.0""
__maintainer__ = ""Pablo Acereda""
__email__ = ""p.aceredag@gmail.com""
def sort(array:list, order:Order=Order.ASC, strategy:Pivot=Pivot.MEDIAN) -> list:
    if (order not in [Order.ASC, Order.DESC]):
        raise BadOrderError(""Not Valid Ordering Preference"")
    if (strategy not in [Pivot.FIRST, Pivot.LAST, Pivot.RANDOM, Pivot.MEDIAN]):
        raise BadPivotError(""Not valid Pivot"")
    return quicksort(array, order, strategy, 0, len(array) - 1)
def quicksort(array, order, strategy, lower, upper):
    if lower > upper or not array: 
        return array
    pivot = None
    if (strategy == Pivot.FIRST):       
        pivot = lower
    elif (strategy == Pivot.LAST):      
        pivot = upper
    elif (strategy == Pivot.RANDOM):    
        pivot = random.randrange(lower, (upper+1))
    elif (strategy == Pivot.MEDIAN):    
        pivot = _median_of_three(array, lower, upper)
    pivot = _partition(array, order, pivot, lower, upper)
    quicksort(array, order, strategy, lower,     pivot - 1)
    quicksort(array, order, strategy, pivot + 1, upper)
    return array
def _partition(array, order, pivot, lower, upper):
    array[pivot], array[upper] = array[upper], array[pivot]
    idx = lower
    for j in range(lower, upper):
        if (order == Order.ASC  and array[j] < array[upper] or 
            order == Order.DESC and array[j] > array[upper]):  
            array[idx], array[j] = array[j], array[idx]
            idx += 1
    array[idx], array[upper] = array[upper], array[idx]
    return idx
def _median_of_three(array, lower, upper):
    mid =  (lower + upper) // 2
    a = array[lower]
    b = array[mid]
    c = array[upper]
    if a <= b <= c or c <= b <= a:
        return mid
    if a <= c <= b or b <= c <= a:
        return upper
    return lower",1,0,0,0,0,0,0,0,0
979,"function quicksort(values) {
    if (values.length <= 1) {
        return values
    }
    var lessThanPivot = [];
    var greaterThanPivot = [];
    var pivot = values[0];
    for (var i = 1; i < values.length; i++) {
        if (values[i] <= pivot) {
            lessThanPivot.push(values[i]);
        } else {
            greaterThanPivot.push(values[i]);
        }
    }
    return quicksort(lessThanPivot).concat(pivot, quicksort(greaterThanPivot));
}
const testValues = [32, 100, 1, 2, 29, 28, 88, 3, 50, 67, 37, 1, 57, 20];
var sorted = quicksort(testValues);
console.log(sorted);",1,0,0,0,0,0,0,0,0
980,"def quicksort(values):
    if len(values) <= 1:
        return values
    less_than_pivot = []
    greater_than_pivot = []
    pivot = values[0]
    for value in values[1:]:
        if value <= pivot:
            less_than_pivot.append(value)
        else:
            greater_than_pivot.append(value)
    return quicksort(less_than_pivot) + [pivot] + quicksort(greater_than_pivot)
numbers = [8, 3, 19, 43, 17, 22, 1, 4, 15, 2, 16, 32, 5]
sorted_numbers = quicksort(numbers)
print(sorted_numbers)",1,0,0,0,0,0,0,0,0
981,"from __future__ import print_function
def quick_sort_3partition(sorting, left, right):
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [ int(item) for item in user_input.split(',') ]
    quick_sort_3partition(unsorted,0,len(unsorted)-1)
    print(unsorted)",1,0,0,0,0,0,0,0,0
982,"package sort.quick;
import sort.Sort;
public class Quick3Way extends Sort {
    public void sortMethod(Comparable[] a) {
        sort(a, 0, a.length - 1);
    }
    private void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int lt = lo, i = lo + 1, gt = hi;
        Comparable v = a[lo];
        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            if (cmp < 0) exch(a, lt++, i++);
            else if (cmp > 0) exch(a, i, gt--);
            else i++;
        }
        sort(a, lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}",1,0,0,0,0,0,0,0,0
983,"package java;
public class QuickSort {
    private int partition(int arr[], int low, int high) {
        int pivotEl = arr[high];  
        int i = low - 1;   
        for (int j = low; j < high; j++) {
            if (arr[j] < pivotEl) {
                i++;
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
        int temp0 = arr[high];
        arr[high] = arr[i + 1];
        arr[i + 1] = temp0;
        return i + 1;
    }
    private void sort(int[] arr, int low, int high) {
        if(low < high) {
            int pi = partition(arr, low, high);
            sort(arr, low, pi - 1);
            sort(arr, pi + 1, high);
        }
    }
    private static void printArray(int arr[]) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        int[] myArr = {2, 6, 9, 1, 7, 3};
        QuickSort qObj = new QuickSort();
        qObj.sort(myArr, 0, myArr.length - 1);
        System.out.println(""Sorted Array:"");
        printArray(myArr);
    }
}",1,0,0,0,0,0,0,0,0
984,"'use strict';
const partition = (arr = [], start, end) => {
  let pivot  = arr[end];  
  let pIndex = start;
  for (let i = start; i < end; i++) {
    if (arr[i] <= pivot) {
      let temp1 = arr[i];
      arr[i] = arr[pIndex];
      arr[pIndex] = temp1;
      pIndex++;
    }
  }
  let temp2 = arr[pIndex];
  arr[pIndex] = arr[end];
  arr[end] = temp2;
  return pIndex;
};
const quickSort = (arr = [], start, end) => {
  if (start < end) {
    let pIndex = partition(arr, start, end);
    quickSort(arr, start, pIndex - 1);   
    quickSort(arr, pIndex + 1, end);  
  }
};
module.exports = quickSort;",1,0,0,0,0,0,0,0,0
985,"from time import sleep
from typing import List
from tkinter import Tk
from animated import Animator
class QuickSort(Animator):
    def partition(self, array: List[int], left: int, right: int, pt: int) -> int:
        while True:
            swaps = 0  
            for i in range(
                left, pt
            ):  
                if array[pt] < array[i]:  
                    array[pt], array[i] = array[i], array[pt]
                    self.render(array, cur=(pt, i))
                    sleep(0.01)
                    pt = i
                    swaps += 1
                    break
            for i in range(right, pt, -1):  
                if array[pt] > array[i]:  
                    array[pt], array[i] = array[i], array[pt]
                    self.render(array, cur=(pt, i))
                    sleep(0.01)
                    pt = i
                    swaps += 1
                    break
            if swaps == 0:
                break  
        return pt
    def sort(self, array: List[int], *args: List[int]) -> None:
        left, right = 0, len(array) - 1
        if len(args) == 2:
            left, right = args
        if left < right - 1:
            half = (left + right) // 2  
            start, middle, end = array[left], array[half], array[right]
            if (start > end and start < middle) or (start < end and start > middle):
                pivotPt = left
            elif (end > start and end < middle) or (end < start and end > middle):
                pivotPt = right - 1
            else:
                pivotPt = half
            pt = self.partition(array, left, right, pivotPt)
            self.render(array, cur=(left, right, pivotPt))
            sleep(0.01)
            self.sort(array, left, pt)
            self.render(array, cur=(pt, left))
            sleep(0.01)
            self.sort(array, pt, right)
            self.render(array, cur=(pt, right))
            sleep(0.01)
def main() -> int:
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    shuffledArray = randomSequence(0, 200)
    root = Tk()
    sorter = QuickSort(
        root,
        background=""black"",
        width=root.winfo_screenwidth(),
        height=root.winfo_screenheight(),
    )
    sorter.pack()
    sorter.sort(shuffledArray)
    sorter.finished()
    return 0",1,0,0,0,0,0,0,0,0
986,"public class QuickSort {
    public static void quickSort(int[] input) {
        int n=input.length;
        qsort(input,0,n-1);
    }
    public static void qsort(int input[],int s,int e)
    {
        if(s>=e)
            return;
        int a=input[s];
        int count=s;
        for(int i=s+1;i<=e;i++)
        {
            if(input[i]<=a)
                count++;
        }
        input[s]=input[count];
        input[count]=a;
        int i=s;
        int j=e;
        while(i<=count && j>=count)
        {
            if(input[i]<=a)
                i++;
            else
            {
                if(input[j]<=a)
                {
                    int temp=input[j];
                    input[j]=input[i];
                    input[i]=temp;
                    i++;
                    j--;
                }
                else
                    j--;
            }
        }
        qsort(input,s,count-1);
        qsort(input,count+1,e);
    }
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6 };
        quickSort(arr);
        printArray(arr);
    }
}",1,0,0,0,0,0,0,0,0
987,"var array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function quicksortBasic(array) {
  if(array.length < 2) {
    return array;
  }
  var pivot = array[0];
  var lesser = [];
  var greater = [];
  for(var i = 1; i < array.length; i++) {
    if(array[i] < pivot) {
      lesser.push(array[i]);
    } else {
      greater.push(array[i]);
    }
  }
  return quicksortBasic(lesser).concat(pivot, quicksortBasic(greater));
}
console.log(quicksortBasic(array.slice()));  
function swap(array, i, j) {
  var temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
function quicksort(array, left, right) {
  left = left || 0;
  right = right || array.length - 1;
  var pivot = partitionHoare(array, left, right);  
  if(left < pivot - 1) {
    quicksort(array, left, pivot - 1);
  }
  if(right > pivot) {
    quicksort(array, pivot, right);
  }
  return array;
}
function partitionLomuto(array, left, right) {
  var pivot = right;
  var i = left;
  for(var j = left; j < right; j++) {
    if(array[j] <= array[pivot]) {
      swap(array, i, j);
      i = i + 1;
    }
  }
  swap(array, i, j);
  return i;
}
function partitionHoare(array, left, right) {
  var pivot = Math.floor((left + right) / 2 );
  while(left <= right) {
    while(array[left] < array[pivot]) {
      left++;
    }
    while(array[right] > array[pivot]) {
      right--;
    }
    if(left <= right) {
      swap(array, left, right);
      left++;
      right--;
    }
  }
  return left;
}
console.log(quicksort(array.slice()));  ",1,0,0,0,0,0,0,0,0
988,"def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp
def partition(array, start, end):
    pivot = array[end]
    L = start
    R = end
    while L < R:
        while array[L] < pivot:
            L += 1
        while array[R] > pivot:
            R -= 1
        swap(array, L, R)
        if ( array[L] == array[R] ):
            L += 1
    return R
def _quicksort(array, start, end):
    if start < end:
        split = partition(array, start, end)
        _quicksort(array, start, split-1)
        _quicksort(array, split+1, end)
def quicksort(array):
    _quicksort(array, 0, len(array)-1)
if __name__ == ""__main__"":
    array = [17, 9, 13, 8, 7, 7, -5, 6, 11, 3, 4, 1, 2]
    quicksort(array)
    print array",1,0,0,0,0,0,0,0,0
989,"package src.algorithms;
import src.strategy.Order;
import src.strategy.Pivot;
public class QuickSort<T> extends SortingAlgorithm<T> {
	@Override
	@SuppressWarnings(""hiding"")
	public <T extends Comparable<T>> T[] sort(T[] elements, Order order) {
		return this.sort(elements, order, Pivot.MEDIAN);
	}
	@SuppressWarnings(""hiding"")
	public <T extends Comparable<T>> T[] sort(T[] elements, Order order, Pivot pivot) {
		return this.quicksort(elements, order, pivot, 0, elements.length-1);
	}
	@SuppressWarnings(""hiding"")
	private <T extends Comparable<T>> T[] quicksort(T[] elements, Order order, Pivot pivot, int lower, int upper) {
		if (lower > upper || elements.length == 0 || elements == null) {
			return elements;
		}
		int p;
		if        (pivot == Pivot.FIRST) {   
			p = lower;
		} else if (pivot == Pivot.LAST) {    
			p = upper;
		} else if (pivot == Pivot.RANDOM) {  
			p = (int) (Math.random() * (upper-lower+1) + lower);
		} else {                             
			p = this.medianOfThree(elements, lower, upper);
		}
		p = this.partition(elements, order, p, lower, upper);
		quicksort(elements, order, pivot, lower, p - 1);
		quicksort(elements, order, pivot, p + 1, upper);
		return elements;
	}
	@SuppressWarnings(""hiding"")
	private <T extends Comparable<T>> int partition(T[] elements, Order order, int pivot, int lowerPos, int upperPos) {
		this.swap(elements, pivot, upperPos);
		int idx = lowerPos;
		for (int j=lowerPos; j<upperPos; j++) {
			if ((order == Order.ASC  && elements[j].compareTo(elements[upperPos]) < 0)  || 
				(order == Order.DESC && elements[j].compareTo(elements[upperPos]) > 0)) {
				this.swap(elements, idx, j);
				idx++;
			}
		}
		this.swap(elements, idx, upperPos);
		return idx;
	}
	@SuppressWarnings(""hiding"")
	private <T extends Comparable<T>> int medianOfThree(T[] elements, int lowerPos, int upperPos) {
		int middlePos = (lowerPos + upperPos) / 2;
		T a = elements[lowerPos];
		T b = elements[middlePos];
		T c = elements[upperPos];
		if ((a.compareTo(b) <= 0 && b.compareTo(c) <= 0)  || 
			(c.compareTo(b) <= 0 && b.compareTo(a) <= 0)) {
			return middlePos;
		}
		if ((a.compareTo(c) <= 0 || c.compareTo(b) <= 0)  && 
			(b.compareTo(c) <= 0 || c.compareTo(a) <= 0)) {
			return upperPos;
		}
		return lowerPos;
	}
}",1,0,0,0,0,0,0,0,0
990,"function quickSort (arrData) {
  'use strict'
  function _swap (arrData, numSrc, numTgt) {
    let swap = arrData[numSrc]
    arrData[numSrc] = arrData[numTgt]
    arrData[numTgt] = swap
  }
  function _partition (arrData, numStart, numEnd) {
    let pivot = arrData[numEnd]
    let pIndex = numStart
    for (let idx = numStart; idx < numEnd; idx++) {
      if (arrData[idx] <= pivot) {
        _swap(arrData, idx, pIndex++)
      }
    }
    _swap(arrData, pIndex, numEnd)
    return pIndex
  }
  function _quickSort (arrData, numStart, numEnd) {
    if (numStart < numEnd) {
      const pIndex = _partition(arrData, numStart, numEnd)
      _quickSort(arrData, numStart, pIndex - 1)
      _quickSort(arrData, pIndex + 1, numEnd)
      console.log('Cycle:', arrData.join())
    }
  }
  console.log('Initial:', arrData.join(), `[Count:${arrData.length}]`)
  _quickSort(arrData, 0, arrData.length - 1)
  console.log('Final:', arrData.join())
  return arrData
}",1,0,0,0,0,0,0,0,0
991,"def partition(arr,low,high): 
    i = ( low-1 )         
    pivot = arr[high]     
    for j in range(low , high): 
        if   arr[j] <= pivot: 
            i = i+1 
            arr[i],arr[j] = arr[j],arr[i] 
    arr[i+1],arr[high] = arr[high],arr[i+1] 
    return ( i+1 ) 
def quickSort(arr,low,high): 
    if low < high: 
        pi = partition(arr,low,high) 
        quickSort(arr, low, pi-1) 
        quickSort(arr, pi+1, high) 
arr = [10, 7, 8, 9, 1, 5] 
n = len(arr) 
quickSort(arr,0,n-1) 
print (""Sorted array is:"") 
for i in range(n): 
    print (""%d"" %arr[i]), ",1,0,0,0,0,0,0,0,0
992,"package javaSorting;
public class QuickSort {
	public static int partition(int data[], int left, int right) {
		int pivot = data[right];
		int i = left - 1;
		for (int j = left; j < right; j++) {
			if (data[j] <= pivot) {
				i++;
				int temp = data[i];
				data[i] = data[j];
				data[j] = temp;
			}
		}
		i++;
		int temp = data[i];
		data[i] = data[right];
		data[right] = temp;
		return i;
	}
	public static void sort(int data[], int left, int right) {
		if (left < right) {
			int pivot = partition(data, left, right);
			sort(data, left, pivot - 1);
			sort(data, pivot + 1, right);
		}
	}
	private static void printSortedArray(int data[]) {
		for (int i = 0; i < data.length; i++) {
			System.out.println(data[i]);
		}
	}
	public static void main(String[] args) {
		int SIZE = 1000;
		int[] data = new int[SIZE];
		for (int i = 0; i < SIZE; i++) {
			data[i] = i;
		}
		Shuffle.shuffleData(data);
		long start = System.currentTimeMillis();
		sort(data, 0, SIZE - 1);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		printSortedArray(data);
		System.out.println(elapsed);
	}
}",1,0,0,0,0,0,0,0,0
993,"function quickSort(arr, left, right){
   var len = arr.length, 
   pivot,
   partitionIndex;
  if(left < right){
    pivot = right;
    partitionIndex = partition(arr, pivot, left, right);
   quickSort(arr, left, partitionIndex - 1);
   quickSort(arr, partitionIndex + 1, right);
  }
  return arr;
}
function partition(arr, pivot, left, right){
   var pivotValue = arr[pivot],
       partitionIndex = left;
   for(var i = left; i < right; i++){
    if(arr[i] < pivotValue){
      swap(arr, i, partitionIndex);
      partitionIndex++;
    }
  }
  swap(arr, right, partitionIndex);
  return partitionIndex;
}
function swap(arr, i, j){
   var temp = arr[i];
   arr[i] = arr[j];
   arr[j] = temp;
}",1,0,0,0,0,0,0,0,0
994,"import math
import sys
import itertools
def SelectPivot(R):
    length = len(R)    
    i_first = 0
    i_last = length-1
    i_mid = int(math.ceil((length-1)/2))
    if i_last == i_mid :
        return i_first 
    if R[i_last] >= R[i_mid] : 
        if R[i_mid] >= R[i_first] : 
            return i_mid
        elif R[i_first] >= R[i_last] : 
            return i_last
        else : 
            return  i_first
    else: 
        if R[i_mid] <= R[i_first] : 
            return i_mid
        elif R[i_first] <= R[i_last] : 
            return i_last
        else : 
            return i_first
    return None
def TernaryQuickSort(R):
    length = len(R)
    if length <= 1:
        return R
    x = SelectPivot(R)
    R_less = [] 
    R_equal = [] 
    R_greater = []
    for s in R : 
        if s < R[x] :
            R_less.append(s)
        elif s == R[x] :
            R_equal.append(s)
        else :
            R_greater.append(s)
    R_less = TernaryQuickSort(R_less)
    R_greater = TernaryQuickSort(R_greater)
    return R_less + R_equal + R_greater
def QuickSort(iterable, depth=0):
    stack = [[iterable, depth]] 
    result = [] 
    while stack :
        R, l = stack.pop() 
        length = len(R)
        if length <= 1:
            if length == 1 :
                result += R
            continue
        R_less = [] 
        R_equal = [] 
        R_greater = []
        R_new = [] 
        for S in R:
            if len(S) <= l :
                result.append(S)
            else :
                R_new.append(S)
        if len(R_new) == 0 :
            continue
        X = R_new[SelectPivot(R_new)]
        char_at_x = X[l]
        for S in R_new : 
            if S[l] < char_at_x :
                R_less.append(S)
            elif S[l] == char_at_x :
                R_equal.append(S)
            else :
                R_greater.append(S)
        stack.append((R_greater, l))
        stack.append((R_equal, l+1))
        stack.append((R_less, l))
    return result
if __name__ == ""__main__"" :
    _R = ['abc','def', 'i', 'aaf','adsf1','gxxa','a']
    print(TernaryQuickSort(_R))
    print(QuickSort(_R))",1,0,0,0,0,0,0,0,0
995,"import java.util.Scanner;
public class QuickSort {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements : "");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter "" + n + "" elements :"");
        for (int i = 0; i < n; i++)
            arr[i] = sc.nextInt();
        quickSort(arr, 0, n - 1);
        System.out.println(""\nThe sorted array : ;"");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    static void quickSort(int arr[], int lower, int upper) {
        if (lower >= upper)
            return;
        int p = partition(arr, lower, upper);
        quickSort(arr, lower, p - 1);
        quickSort(arr, p + 1, upper);
    }
    private static int partition(int arr[], int lower, int upper) {
        int pivot = arr[upper];
        int j = lower;
        int tmp;
        for (int i = lower; i <= upper; i++) {
            if (arr[i] < pivot) {
                tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
                j++;
            }
        }
        tmp = arr[upper];
        arr[upper] = arr[j];
        arr[j] = tmp;
        return j;
    }
}",1,0,0,0,0,0,0,0,0
996,"def quickSort(arr,low,high) :
	if(low<high) :
		pivotIndex = _partition(arr,low,high)
  quickSort(arr,low,pivotIndex-1)
  quickSort(arr,pivotIndex+1,high)
 return arr
def _partition(arr,low,high) :
	pivot = arr[low]
 i=low+1
 j=high
 while (True) :
		while i<=high and arr[i]<pivot :
			i=i+1
  while j>low and arr[j]>=pivot:
			j=j-1
  if i<j :
			arr[i],arr[j]=arr[j],arr[i] 
  else:
			break
 arr[low],arr[j]=arr[j],arr[low]
 return j
def swap(arr,index1,index2) :
	temp = arr[index1]
 arr[index1] = arr[index2]
 arr[index2] = temp",1,0,0,0,0,0,0,0,0
997,"import java.util.Arrays;
public class QuickSort {
	private int [] input;
	public QuickSort(int [] input) {
		this.input = input.clone();
	}
	public int [] sort(){
		quick_sort(0, this.input.length - 1);
		return this.input;
	}
	private void quick_sort(int left, int right){  
		if (left < right){
			int pivot = partition(left, right);
			quick_sort(left, pivot - 1);
			quick_sort(pivot + 1, right);
		}
	}
	private int partition(int left, int right){  
		int pivot =  ((int) (Math.random() * (right - left)) + left);
		int pivot_value = this.input[pivot];
		swap(pivot, right);
		int last_index = left;
		for (int i = left; i < right; i++) {
			if (this.input[i] < pivot_value){
				swap(last_index, i);
				last_index++;
			}
		}
		swap(last_index, right);
		return last_index;
	}
	private void swap(int i, int j){  
		int tmp = this.input[i];
		this.input[i] = this.input[j];
		this.input[j] = tmp;
	}
	public static void main(String[] args) {
		int array[] = {9,1,0,4,2,-1,5,2, 200, 99, 45, -100};
		QuickSort quicksort = new QuickSort(array);
		System.out.println(""Unsorted Array -> ""+ Arrays.toString(array));
		System.out.println(""QuickSort -> ""+ Arrays.toString(quicksort.sort()));  
	}
}",1,0,0,0,0,0,0,0,0
998,"def partition(arr, low, high):
    i = (low-1)         
    pivot = arr[high]     
    for j in range(low, high):
        if arr[j] < pivot:
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)
def quickSort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
arr = [10, 7, 8, 9, 1, 5]
n = len(arr)
quickSort(arr, 0, n-1)
print(""Sorted array is:"")
for i in range(n):
    print(""%d"" % arr[i]),",1,0,0,0,0,0,0,0,0
999,"package org.neeraj.algorithms.sorting;
public class Quicksort implements Sorter
{
    protected Partitioner part;
    protected void quicksort(Comparable[] array, int p, int r)
    {
	if (p < r) {
	    int q = part.partition(array, p, r);
	    quicksort(array, p, q - 1);
	    quicksort(array, q + 1, r);
	}
    }
    public void sort(Comparable[] array)
    {
	part = new Partitioner();  
	quicksort(array, 0, array.length - 1);  
    }
}",1,0,0,0,0,0,0,0,0
1000,"import random
from time import time
def CreatList(n):
    alist = []
    for i in range(n, 0, -1):
        alist.append(random.randint(0, n))
    return alist
def Inplace_quick_sort(S, a, b):
    if a >= b: return
    pivot = S[b]
    left = a
    right = b - 1
    while left <= right:
        while left <= right and S[left] < pivot:
            left += 1
        while left <= right and pivot < S[right]:
            right -= 1
        if left <= right:
            S[left], S[right] = S[right], S[left]
            left, right = left + 1, right - 1
    S[left], S[b] = S[b], S[left]
    Inplace_quick_sort(S, a, left - 1)
    Inplace_quick_sort(S, left + 1, b)
def performace(lenList):
    seqOri = CreatList(lenList)
    seq = list(seqOri)
    begin = time()
    Inplace_quick_sort(seq, 0, (len(seq) - 1))
    end = time()
    diff = (end - begin) * 1000
    print(""inplace_quick_sort: "" + str(diff))
    print(""seq: "" + str(seq))
    print(
        ""****************************************************************************************************************************************************************************"")
if __name__ == '__main__':
    performace(50)
    performace(100)
    performace(500)
    performace(1000)
    performace(10000)",1,0,0,0,0,0,0,0,0
1001,"package com.aokolnychyi.sorting;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
public class QuickSort {
  public static <T extends Comparable<T>> void sort(List<T> list) {
    sort(list, 0, list.size() - 1);
  }
  private static <T extends Comparable<T>> void sort(List<T> list, int startIndex, int endIndex) {
    if (startIndex < endIndex) {
      final int partitionIndex = partition(list, startIndex, endIndex);
      sort(list, startIndex, partitionIndex - 1);
      sort(list, partitionIndex + 1, endIndex);
    }
  }
  private static <T extends Comparable<T>> int partition(List<T> list, int startIndex, int endIndex) {
    final int randomPivotIndex = ThreadLocalRandom.current().nextInt(startIndex, endIndex + 1);
    Collections.swap(list, randomPivotIndex, endIndex);
    final T pivotal = list.get(endIndex);
    int notGreaterBoundIndex = startIndex - 1;
    for (int currentIndex = startIndex; currentIndex < endIndex; currentIndex++) {
      final T currentElement = list.get(currentIndex);
      if (currentElement.compareTo(pivotal) <= 0) {
        notGreaterBoundIndex++;
        if (notGreaterBoundIndex != currentIndex) {
          Collections.swap(list, notGreaterBoundIndex, currentIndex);  
        }
      }
    }
    notGreaterBoundIndex++;  
    Collections.swap(list, notGreaterBoundIndex, endIndex);
    return notGreaterBoundIndex;
  }
  public static void main(String[] args) {
    final List<Integer> list = new ArrayList<>();
    list.add(4);
    list.add(1);
    list.add(5);
    list.add(3);
    list.add(9);
    list.add(10);
    list.add(1);
    sort(list);
    sort(new ArrayList<Integer>());
    System.out.println(list);
  }
}",1,0,0,0,0,0,0,0,0
1002,"class QuickSort:
    def sort(A):
        if(len(A) <= 1):
            return A
        else:
            lt = []
            eq = []
            gt = []
            p = A[0]
            for i in range(0, len(A)):
                if (A[i] < p):
                    lt.append(A[i])
                elif (A[i] == p):
                    eq.append(A[i])
                else:
                    gt.append(A[i])
            lt = QuickSort.sort(lt)
            eq = QuickSort.sort(eq)
            gt = QuickSort.sort(gt)
            return lt + eq + gt",1,0,0,0,0,0,0,0,0
1003,"package sorting;
class quickSort {
    static void quicksort(int a[],int low,int high){
        int p = partition(a,low,high);
        if(low<p-1){
            quicksort(a, low, p-1);
        }
        if(p<high){
            quicksort(a, p, high);
        }
    }
    static int partition(int a[],int low,int high){
        int i=low,j=high;
        int temp;
        int pivot = a[(low+high)/2];
        while(i<=j){
            while(a[i]<pivot){i++;}
            while(a[j]>pivot){j--;}
            if(i<=j){
                swap(a,i,j);
                i++;
                j--;
            }
        }
        return i;
    }
    static void swap(int a[],int p,int q){
                    int temp = a[p];
                    a[p]=a[q];
                    a[q]=temp;
    }
}",1,0,0,0,0,0,0,0,0
1004,"def QuickSort(list, start, end):
    pivot = list[(start+end)//2]
    i = start
    j = end
    while i <= j:
        while list[i] < pivot:
            i+=1
        while list[j] > pivot:
            j-=1
        if i <= j:
            list[i], list[j] = list[j], list[i]
            i+=1
            j-=1
    if i < end:
        QuickSort(list, i, end)
    if j > start:
        QuickSort(list, start, j)",1,0,0,0,0,0,0,0,0
1005,"package com.satishkumarprasad.algo.sortingalgos;
public class QuickSort implements SortingAlgorithm {
	@Override
	public void sort(int[] array) {
		quickSort(array, 0, array.length - 1);
	}
	private void quickSort(int[] array, int start, int end) {
		if (start < end) {
			int pivot = partition(array, start, end);
			quickSort(array, start, pivot - 1);
			quickSort(array, pivot + 1, end);
		}
	}
	private int partition(int[] array, int start, int end) {
		int i = start - 1;
		int pivot = array[end];
		for (int j = start; j < end; j++) {
			if (array[j] <= pivot) 
				exchange(array, ++i, j);
		}
		return exchange(array, ++i, end);
	}
	private int exchange(int[] array, int source, int destination) {
		int temp = array[destination];
		array[destination] = array[source];
		array[source] = temp;
		return source;
	}
}",1,0,0,0,0,0,0,0,0
1006,"def partition(nums, low, high):
    pivot = nums[(low + high) // 2]
    i = low - 1
    j = high + 1
    while True:
        i += 1
        while nums[i] < pivot:
            i += 1
        j -= 1
        while nums[j] > pivot:
            j -= 1
        if i >= j:
            return j
        nums[i], nums[j] = nums[j], nums[i]
def quick_sort(nums):
    def _quick_sort(items, low, high):
        if low < high:
            split_index = partition(items, low, high)
            _quick_sort(items, low, split_index)
            _quick_sort(items, split_index + 1, high)
    _quick_sort(nums, 0, len(nums) - 1)
random_list_of_nums = [22, 5, 1, 18, 99]
quick_sort(random_list_of_nums)
print(random_list_of_nums)",1,0,0,0,0,0,0,0,0
1007,"import java.util.Scanner;
public class QuickSort {
  static int partition (int arr[], int low, int high)
    {
        int pivot = arr[high];
        int i = (low - 1);
        for (int j = low; j <= high - 1; j++)
        {
            if (arr[j] < pivot)
            {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i+1];
        arr[i+1] = arr[high];
        arr[high] = temp;
        return (i + 1);
    }
    static void quickSort(int arr[] , int beg , int end )
    {
        if(beg <end)
        {
            int pivotIndex = partition(arr,beg , end);
            quickSort(arr , beg , pivotIndex-1);
            quickSort(arr , pivotIndex+1 , end);
        }
    }
    static void print(int arr[],int n)
    {
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i]+"" "");
        }
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements: "");
        int n = sc.nextInt();
        int arr[] = new int [n];
        System.out.print(""Enter elements : "");
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.print(""Array before sort: "");
        print(arr,n);
        quickSort(arr,0,n-1);
        System.out.print(""Array after sort: "");
        print(arr,n);
    }
}",1,0,0,0,0,0,0,0,0
1008,"quickSort = function(array) {
  if (array.length < 2) {
    return array;
  }
  var i, l, pivot,
      a = array.slice(0),
      less    = [],
      equal   = [],
      greater = [];
  pivot = a[Math.floor(a.length / 2)];
  for (i = 0, l = a.length; i < l; i++) {
    if (a[i] < pivot) {
      less.push(a[i]);
    } else if (a[i] > pivot) {
      greater.push(a[i]);
    } else {
      equal.push(a[i]);
    }
  }
  return quickSort(less)
    .concat(equal, quickSort(greater));
};",1,0,0,0,0,0,0,0,0
1009,"const swap = (array, i, j) => {
  let temp = array[i];
  array[i] = array[j];
  array[j] = temp;
};
const partiton = (array, low, high) => {
  const pivotIndex = high;
  const pivotElement = array[pivotIndex];
  let i = low,
    j = pivotIndex - 1;
  while (true) {
    while (array[i] < pivotElement) {
      i++;
    }
    while (array[j] >= pivotElement) {
      j--;
    }
    if (i > j) {
      break;
    } else {
      swap(array, i, j);
    }
  }
  swap(array, i, pivotIndex);
  return i;
};
const quickSort = (array, low, high) => {
  if (low > high) {
    return;
  } else {
    const pivotIndex = partiton(array, low, high);
    quickSort(array, low, pivotIndex - 1);
    quickSort(array, pivotIndex + 1, high);
  }
};
const array = [9, 5, 2, 6, 1, 11, 3];
quickSort(array, 0, array.length - 1);
console.log(array);",1,0,0,0,0,0,0,0,0
1010,"def quicksort(array, startIndex, endIndex):
    if startIndex < endIndex:
        middle = partition(array, startIndex, endIndex)
        quicksort(array, startIndex, middle - 1)
        quicksort(array, middle + 1, endIndex)
    return array
def partition(array, startIndex, endIndex):
    pivot = startIndex + (endIndex - startIndex) // 2;
    pivotIndex = startIndex
    array[pivot], array[endIndex] = array[endIndex], array[pivot]
    for i in range(startIndex, endIndex):
        if array[i] < array[endIndex]:
            array[pivotIndex], array[i] = array[i], array[pivotIndex]
            pivotIndex += 1
    array[endIndex], array[pivotIndex] = array[pivotIndex], array[endIndex]
    return pivotIndex
if __name__ == '__main__':
    arr = [97, 200, 100, 101, 211, 107]
    print(""My array is:\n"", [x for x in arr])
    print(""\nMy sorted array is: "")
    print(quicksort(arr, 0, len(arr) - 1))",1,0,0,0,0,0,0,0,0
1011,"package me.gilday.revision.sorting.quicksort;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Quicksort {
	private static Logger logger = LoggerFactory.getLogger(Quicksort.class);
	public static void sort(int[] values) {
		logger.trace(""===Sorting: {}"", Arrays.toString(values));
		sort(values, 0, values.length - 1);
	}
	private static void sort(int[] values, int left, int right) {
		int index = partition(values, left, right);
		logger.trace(Arrays.toString(values));
		if(left < index - 1) {
			sort(values, left, index - 1);
		} 
		if(index < right) {
			sort(values, index, right);
		}
	}
	private static int partition(int[] values, int left, int right) {
		int i=left, j=right;
		int tmp;
		int pivot = values[(left+right) / 2];
		while (i<=j) {
			while (values[i] < pivot) {
				i++;
			}
			while(values[j] > pivot) {
				j--;
			}
			if(i<=j) {
				tmp = values[i];
				logger.trace(""Swapping {} and {}"", values[i], values[j]);
				values[i] = values[j]; 
				values[j] = tmp;
				i++;
				j--;
			}			
		}
		return i;
	}
}",1,0,0,0,0,0,0,0,0
1012,"def partition(arr,low,high): 
    i = ( low-1 )         
    pivot = arr[high]     
    for j in range(low , high): 
        if   arr[j] <= pivot: 
            i = i+1 
            arr[i],arr[j] = arr[j],arr[i] 
    arr[i+1],arr[high] = arr[high],arr[i+1] 
    return (i+1) 
def quickSort(arr,low,high): 
    if low < high: 
        pi = partition(arr,low,high) 
        quickSort(arr, low, pi-1) 
        quickSort(arr, pi+1, high) 
if __name__ == ""__main__"":
    arr = [5, 3, 2, 5, 9, 1]
    quickSort(arr, 0, len(arr) - 1)
    print(arr)",1,0,0,0,0,0,0,0,0
1013,"package Sorts;
import static Sorts.SortUtils.*;
class QuickSort implements SortAlgorithm {
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        doSort(array, 0, array.length - 1);
        return array;
    }
    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {
        if (left < right) {
            int pivot = partition(array, left, right);
            doSort(array, left, pivot - 1);
            doSort(array, pivot , right);
        }
    }
    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {
        int mid = (left + right) / 2;
        T pivot = array[mid];
        while(left <= right) {
            while(less(array[left], pivot)){
                ++left;
            }
            while(less(pivot, array[right])) {
                --right;
            }
            if(left <= right) {
                swap(array, left, right);
                ++left;
                --right;
            }
        }
        return left;
    }
    public static void main(String[] args) {
        Integer[] array =  {3, 4, 1, 32, 0, 1, 5, 12 ,2, 5 ,7 ,8 ,9, 2, 44, 111, 5};
        QuickSort quickSort = new QuickSort();
        print(array);
        String[] stringArray =  {""c"", ""a"", ""e"", ""b"", ""d""};
        quickSort.sort(stringArray);
        print(stringArray);
    }
}",1,0,0,0,0,0,0,0,0
1014,"def quicksort(l:list) -> list:
    arr = l[::]
    if len(arr) <= 1:
        return arr
    l = [x for x in arr[1:] if x <= arr[0]]
    r = [x for x in arr[1:] if x > arr[0]]
    return quicksort(l) + arr[0:1] + quicksort(r)",1,0,0,0,0,0,0,0,0
1015,"package com.deepak.algorithms.Sorting;
import java.util.Arrays;
public class QuickSort {
	public static void main(String[] args) {
		int[] valuesToBeSorted = {7, 10, 47, 40, 83, 84, 65, 61, 32, 55, 49, 46, 25, 20, 93, 63, 54, 10};
		quickSort(valuesToBeSorted, 0, valuesToBeSorted.length - 1);
		Arrays.stream(valuesToBeSorted).forEach(n -> System.out.print(n + "", ""));
	}
	private static void quickSort(int[] values, int low, int high) {
		int middle = low + (high - low) / 2;
		int pivot = values[middle];
		int i = low, j = high;
		while (i < j) {
			while (values[i] < pivot) {
				i++;
			}
			while (values[j] > pivot) {
				j--;
			}
			if (i <= j) {
				int temp = values[j];
				values[j] = values[i];
				values[i] = temp;
				i++;
				j--;
			}
			if (low < j) {
				quickSort(values, low, j);
			}
			if (high > i) {
				quickSort(values, i, high);
			}
		}
	}
}",1,0,0,0,0,0,0,0,0
1016,"import random
def partition(lst, start, end):
    x = lst[end]
    store_index = start
    i = start
    for i in range(start, end):
        if lst[i] <= x:
            if i != store_index:
                lst[i], lst[store_index] = lst[store_index], lst[i]
            store_index += 1
    lst[store_index], lst[i + 1] = lst[i + 1], lst[store_index]
    return store_index
def quick_sort(lst, start, end):
    if start >= end:
        return lst
    new_pivot = partition(lst, start, end)
    quick_sort(lst, start, new_pivot - 1)
    quick_sort(lst, new_pivot + 1, end)
def quick_sort_median(lst, start, end):
    if start >= end:
        return lst
    elif end - start >= 30:
        median_values = {}
        while len(median_values) < 3:
            rand = random.randint(start, end)
            median_values[lst[rand]] = rand
        pivot_value = list(median_values.keys())[1]
        pivot = median_values[pivot_value]
    else:
        pivot = random.randint(start, end)
    lst[-1], lst[pivot] = lst[-1], lst[pivot]
    new_pivot = partition(lst, start, end)
    quick_sort_median(lst, start, new_pivot - 1)
    quick_sort_median(lst, new_pivot + 1, end)
def quick_sort_random(lst, start, end):
    if start >= end:
        return lst
    pivot = random.randint(start, end)
    lst[-1], lst[pivot] = lst[-1], lst[pivot]
    new_pivot = partition(lst, start, end)
    quick_sort_random(lst, start, new_pivot - 1)
    quick_sort_random(lst, new_pivot + 1, end)
def quicksort(lst):
    quick_sort(lst, 0, len(lst) - 1)
    return lst
def quicksort_random(lst):
    quick_sort_random(lst, 0, len(lst) - 1)
    return lst
def quicksort_median(lst):
    quick_sort_median(lst, 0, len(lst) - 1)
    return lst
if __name__ in ""__main__"":
    a = [2, 8, 7, 1, 3, 5, 6, 4]
    print('list            :', a)
    print('quicksort       :', quicksort(a), quicksort(a) == sorted(a))
    print('quicksort random:', quicksort_random(a), quicksort_random(a) == sorted(a))
    print('quicksort median:', quicksort_median(a), quicksort_median(a) == sorted(a))",1,0,0,0,0,0,0,0,0
1017,"package sortvisualiser.algorithms;
import sortvisualiser.SortArray;
public class QuickSort implements ISortAlgorithm {
    private long stepDelay = 30;
    private int findPivotPoint(SortArray array, int lowIndex, int highIndex) {
        int pivotValue = array.getValue(highIndex);
        int i = lowIndex - 1;
        for (int j = lowIndex; j <= highIndex - 1; j++) {
            if (array.getValue(j) <= pivotValue) {
                i++;
                array.swap(i, j, getDelay(), true);
            }
        }
        array.swap(i + 1, highIndex, getDelay(), true);
        return i + 1;
    }
    private void quickSort(SortArray array, int lowIndex, int highIndex) {
        if (lowIndex < highIndex) {
            int pivotPoint = findPivotPoint(array, lowIndex, highIndex);
            quickSort(array, lowIndex, pivotPoint - 1);
            quickSort(array, pivotPoint + 1, highIndex);
        }
    }
    @Override
    public void runSort(SortArray array) {
        quickSort(array, 0, array.arraySize() - 1);
    }
    @Override
    public String getName() {
        return ""Quick Sort"";
    }
    @Override
    public long getDelay() {
        return stepDelay;
    }
    @Override
    public void setDelay(long delay) {
        this.stepDelay = delay;
    }
}",1,0,0,0,0,0,0,0,0
1018,"from random import randint
def quickSort(A, p, r):
    if (p < r):
        A, q1, q2 = partitionModified(A, p, r)
        A = quickSort(A, p, q1-1)
        A = quickSort(A, q2+1, r)
    return A
def partition(A, p, r):
    x = A[r]
    i = p - 1
    for j in range(p, r):
        if (A[j] <= x):
            i += 1
            temp1 = A[i]
            A[i] = A[j]
            A[j] = temp1
    temp2 = A[i+1]
    A[i+1] = A[r]
    A[r] = temp2
    return i+1
def partitionModified(A, p, r):
    x = A[r]
    i = p - 1
    k = 0
    j = p
    while (j < r-k):
        if (A[j] < x):
            i += 1
            temp1 = A[i]
            A[i] = A[j]
            A[j] = temp1
        if (A[j] == x):
            k += 1
            temp1 = A[j]
            A[j] = A[r-k]
            A[r-k] = temp1
            j -= 1
        j += 1
    for l in range(0, k+1):
        temp2 = A[i+1+l]
        A[i+1+l] = A[r-k+l]
        A[r-k+l] = temp2
    return A, i+1, i+k+1
list = []
hehe = 10
for num in range(0, hehe):
    list.append(randint(0, hehe / 2))
print(list)
print(quickSort(list, 0, hehe-1))
print()",1,0,0,0,0,0,0,0,0
1019,"package dip107;
import java.util.Comparator;
public class QuickSort implements SortingAlgorithm {
    public static Comparator<Integer> ascending = Comparator.naturalOrder();
    public static Comparator<Integer> descending = (o1, o2) -> -ascending.compare(o1, o2);
    public static void sort(int[] arr, int low, int high, int order) {
        if (low < high) {
            Comparator<Integer> comp = order == 1 ? ascending : descending;
            int part = partition(arr, low, high, comp);
            sort(arr, low, part, order);
            sort(arr, part + 1, high, order);
        }
    }
    private static int partition(int[] arr, int low, int high, Comparator<Integer> comp) {
        int pivot = arr[(high + low) / 2];
        int i = low - 1;
        int j = high + 1;
        while (true) {
            do i++; while (comp.compare(arr[i], pivot) < 0);
            do j--; while (comp.compare(arr[j], pivot) > 0);
            if (i >= j) {
                return j;
            }
            swap(arr, i, j);
        }
    }
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    @Override
    public void sort(int[] arr, int order) {
        sort(arr, 0, arr.length - 1, order);
    }
}",1,0,0,0,0,0,0,0,0
1020,"import time
numbers = []
def partition(list, start, end):
    pivot = list[end]                          
    bottom = start-1                           
    top = end                                  
    done = 0
    while not done:                            
        while not done:                        
            bottom = bottom+1                  
            if bottom == top:                  
                done = 1                       
                break
            if list[bottom] > pivot:           
                list[top] = list[bottom]       
                break                          
        while not done:                        
            top = top-1                        
            if top == bottom:                  
                done = 1                       
                break
            if list[top] < pivot:              
                list[bottom] = list[top]       
                break                          
    list[top] = pivot                          
    return top                                 
def quicksort(list, start, end):
    if start < end:                            
        split = partition(list, start, end)    
        quicksort(list, start, split-1)        
        quicksort(list, split+1, end)
    else:
        return
def read_from_file(filepath):
    del numbers[:] 
    file = open(filepath, ""r"")
    for i in file:
        numbers.append(int(i))
def print_first_ten_number():
    print numbers[0:9]
def print_last_ten_number():
    print numbers[len(numbers)-10:len(numbers)]
def append_result_to_file(str):
    with open(""results.txt"", ""a"") as result:
        result.write(str+""\n"")
        result.close()
if __name__==""__main__"":                       
    read_from_file(""../1k.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""1k = "" + str(end-start))
    read_from_file(""../10k.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""10k = "" + str(end-start))
    read_from_file(""../100k.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""100k = "" + str(end-start))
    read_from_file(""../1m.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""1m = "" + str(end-start))
    read_from_file(""../2m.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""2m = "" + str(end-start))     
    read_from_file(""../4m.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""4m = "" + str(end-start))
    read_from_file(""../8m.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""8m = "" + str(end-start))
    read_from_file(""../10m.lst"")
    start = time.clock()
    quicksort(numbers,0,len(numbers)-1)
    end = time.clock()
    append_result_to_file(""10m = "" + str(end-start))    ",1,0,0,0,0,0,0,0,0
1021,"package quick_sort;
public class QuickSort {
    public static void sort(int[] a) {
        sort(a, 0, a.length - 1);
    }
    private static void sort(int[] a, int low, int high) {
        if (high <= low) return;
        int j = partition(a, low, high);
        sort(a, low, j - 1);
        sort(a, j + 1, high);
    }
    private static int partition(int[] a, int low, int high) {
        int i = low;
        int j = high + 1;
        int value = a[low];
        while (true) {
            while (a[++i] < value) {
                if (i == high) break;
            }
            while (a[--j] > value) {
                if (j == low) break;
            }
            if (i >= j) break;
            exch(a, i, j);
        }
        exch(a, low, j);
        return j;  
    }
    private static void exch(int[] a, int i, int j) {
        int swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
}",1,0,0,0,0,0,0,0,0
1022,"from random import shuffle
def quicksort(a):
    b = [*a]
    shuffle(b)
    _sort(b, 0, len(b)-1)
    return b
def _partition(srt, start, end):
    follower = leader = start
    while leader < end:
        if srt[leader] < srt[end]:
            srt[follower], srt[leader] = srt[leader], srt[follower]
            follower += 1
        leader += 1
    srt[follower], srt[end] = srt[end], srt[follower]
    return follower
def _sort(srt, start, end):
    if start >= end:
        return
    p = _partition(srt, start, end)
    _sort(srt, start, p-1)
    _sort(srt, p+1, end)
if __name__ == ""__main__"":
    import unittest
    class TestQuicksort(unittest.TestCase):
        def setUp(self):
            self.ordered = [x for x in range(20)]
            self.shuffled = [*self.ordered]
            while self.ordered == self.shuffled:
                shuffle(self.shuffled)
        def test_quicksort(self):
            self.assertEqual(self.ordered, quicksort(self.shuffled))
            self.assertNotEqual(self.ordered, self.shuffled)
    unittest.main()",1,0,0,0,0,0,0,0,0
1023,"package com.mehmetpekdemir.sort.quicksort;
public final class QuickSort {
	public static void sort(int[] array, int start, int end) {
		if (end - start < 2) {
			return;
		}
		final int pivotIndex = partition(array, start, end);
		sort(array, start, pivotIndex);
		sort(array, pivotIndex + 1, end);
	}
	private static int partition(int[] array, int start, int end) {
		final int pivot = array[start];
		int i = start;
		int j = end;
		while (i < j) {
			while (i < j && array[--j] >= pivot);
			if (i < j) {
				array[i] = array[j];
			}
			while (i < j && array[++i] <= pivot);
			if (i < j) {
				array[j] = array[i];
			}
		}
		array[j] = pivot;
		return j;
	}
}",1,0,0,0,0,0,0,0,0
1024,"import time 
def QuickSort(data, low, high, drawDataArray, sortSpeedTime):
    if low < high:
        partitionIndex = partition(data, low, high, drawDataArray, sortSpeedTime)
        QuickSort(data, low, partitionIndex-1, drawDataArray, sortSpeedTime)
        QuickSort(data, partitionIndex+1, high, drawDataArray, sortSpeedTime)
def partition(data, low, high, drawDataArray, sortSpeedTime):
    border = low
    pivot = data[high] 
    drawDataArray(data, getColorArray(len(data), low, high, border, border))
    time.sleep(sortSpeedTime)
    for j in range(low, high):
        if data[j] < pivot:
            drawDataArray(data, getColorArray(len(data), low, high, border, j, True))
            time.sleep(sortSpeedTime)
            data[border], data[j] = data[j], data[border]
            border += 1
        drawDataArray(data, getColorArray(len(data), low, high, border, j))
        time.sleep(sortSpeedTime)
    drawDataArray(data, getColorArray(len(data), low, high, border, high, True))
    time.sleep(sortSpeedTime)
    data[border], data[high] = data[high], data[border]
    return border 
def getColorArray(dataLength, low, high, border, currentIndex, isSwaping = False):
    colorArray = []
    for i in range(dataLength):
        if i >= low and i <= high:
            colorArray.append('gray') 
        else:
            colorArray.append('red') 
        if i == high:
            colorArray[i] = 'orange' 
        elif i == border:
            colorArray[i] = 'green' 
        elif i == currentIndex:
            colorArray[i] = 'yellow' 
        if isSwaping:
            if i == border or i == currentIndex:
                colorArray[i] = 'purple' 
    return colorArray",1,0,0,0,0,0,0,0,0
1025,"package sorting;
public class QuickSort<T extends Comparable<T>> implements Sort<T> {
    @Override
    public void sort(T[] items) {
        sort(items, 0, items.length - 1);
    }
    public void sort(T[] items, int left, int right) {
        int up = left;
        int down = right - 1;
        T t = items[right];
        do {
            while (items[up].compareTo(t) < 0) {
                up++;
            }
            while (items[down].compareTo(t) >= 0 && down > up) {
                down--;
            }
            if (up < down) {
                SortUtils.swap(items, up, down);
            }
        } while (up < down);
        SortUtils.swap(items, up, right);
        if (left < up - 1) {
            sort(items, left, up - 1);
        }
        if (right > up + 1) {
            sort(items, up + 1, right);
        }
    }
}",1,0,0,0,0,0,0,0,0
1026,"import time
from colors import *
def partition(data, start, end, drawData, timeTick):
    i = start + 1
    pivot = data[start]
    for j in range(start+1, end+1):
        if data[j] < pivot:
            data[i], data[j] = data[j], data[i]
            i+=1
    data[start], data[i-1] = data[i-1], data[start]
    return i-1
def quick_sort(data, start, end, drawData, timeTick):
    if start < end:
        pivot_position = partition(data, start, end, drawData, timeTick)
        quick_sort(data, start, pivot_position-1, drawData, timeTick)
        quick_sort(data, pivot_position+1, end, drawData, timeTick)
        drawData(data, [PURPLE if x >= start and x < pivot_position else YELLOW if x == pivot_position
                        else DARK_BLUE if x > pivot_position and x <=end else BLUE for x in range(len(data))])
        time.sleep(timeTick)
    drawData(data, [BLUE for x in range(len(data))])",1,0,0,0,0,0,0,0,0
1027,"package dev.jeffreybender.sort;
import java.util.Comparator;
public final class QuickSort {
    private QuickSort() {
    }
    public static <T> void sort(T[] array, Comparator<? super T> comparator) {
        if (array.length <= 1) {
            return;
        }
        if (comparator == null) {
            comparator = SortUtils.getDefaultComparator();
        }
        quickSort(array, 0, array.length - 1, comparator);
    }
    public static <T extends Comparable<? super T>> void sort(T[] array) {
        sort(array, null);
    }
    private static <T> void quickSort(T[] array, int low, int high, Comparator<T> comparator) {
        if (low < high) {
            int partitionIndex = partition(array, low, high, comparator);
            quickSort(array, low, partitionIndex, comparator);
            quickSort(array, partitionIndex + 1, high, comparator);
        }
    }
    private static <T> int partition(T[] array, int low, int high, Comparator<T> comparator) {
        T pivot = array[low + ((high - low) / 2)];
        int left = low - 1;
        int right = high + 1;
        while (left < right) {
            do {
                left++;
            } while (comparator.compare(array[left], pivot) < 0);
            do {
                right--;
            } while (comparator.compare(array[right], pivot) > 0);
            if (left < right) {
                SortUtils.swap(array, left, right);
            }
        }
        return right;
    }
}",1,0,0,0,0,0,0,0,0
1028,"import time
count = 0
def sort(bar, layout, num, colors):
    data = list(bar.y)
    quicksort(data, 0, num-1, bar, layout, colors)
    colors = ['blue',] * num
    bar.marker.color = colors
def quicksort(data, low, high, bar, layout, colors):
    if low < high: 
        pi = partition(data, low, high, bar, layout, colors)
        quicksort(data, low, pi-1, bar, layout, colors)
        quicksort(data, pi+1, high, bar, layout, colors)
def partition(data, low, high, bar, layout, colors):
    i = low - 1
    global count 
    pivot = data[high]
    colors[high] = 'yellow'
    bar.marker.color = colors
    for j in range(low, high):
        count += 1
        layout.xaxis.title.text = ""Number of operations: "" + str(count)
        if data[j] <= pivot: 
            i += 1
            data[i], data[j] = data[j], data[i]
            colors[i] = 'green'
            colors[j] = 'green'
            bar.marker.color = colors
            bar.y = data
            time.sleep(0.1)
            colors[i] = 'lightslategray'
            colors[j] = 'lightslategray'
            bar.marker.color = colors
        else:
            colors[i] = 'crimson'
            colors[j] = 'crimson'
            bar.marker.color = colors
            time.sleep(0.1)
            colors[i] = 'lightslategray'
            colors[j] = 'lightslategray'
            bar.marker.color = colors
    colors[high] = 'lightslategray'
    colors[i] = 'red'
    colors[j] = 'red'
    bar.marker.color = colors
    data[i+1], data[high] = data[high], data[i+1]
    count += 1
    layout.xaxis.title.text = ""Number of operations: "" + str(count)
    bar.y = data
    time.sleep(0.1)
    colors[i] = 'lightslategray'
    colors[j] = 'lightslategray'    
    bar.marker.color = colors
    return i+1",1,0,0,0,0,0,0,0,0
1029,"package Sorting;
import java.util.ArrayList;
import java.util.Scanner;
public class QuickSort {
    private static int elements_array[];
    public static void main(String[] args) {
        ArrayList<Integer> elements = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            elements.add(sc.nextInt());
        }
        sc.close();
        elements_array = new int[elements.size()];
        for (int i = 0; i < elements.size(); i++) {
            elements_array[i] = elements.get(i);
        }
       doQuickSort( elements.size() - 1,0);
        for (int anElement : elements_array) {
            System.out.println(anElement);
        }
    }
    private static void doQuickSort(int high, int low) {
        int pivot = elements_array[low + ((high - low) / 2)];
        int i = low;
        int j = high;
        while (i <= j) {
            while (elements_array[i] < pivot) {
                i++;
            }
            while (elements_array[j] > pivot) {
                j--;
            }
            if (i <= j) {
                doSwap(i, j);
                i++;
                j--;
            }
        }
        if(low < j){
            doQuickSort(low,j);
        }
        if(i< high){
            doQuickSort(i,high);
        }
    }
    private static void doSwap(int i, int j) {
        int temp = elements_array[i];
        elements_array[i] = elements_array[j];
        elements_array[j] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1030,"public class QuickSort {
    public static void sort(int[] a) {
        sort(a, 0, a.length - 1);
    }
    public static void sort(int[] a, int low, int high) {
        if (low >= high) return;
        int middle = partition(a, low, high);
        sort(a, low, middle - 1);
        sort(a, middle + 1, high);
    }
    private static int partition(int[] a, int low, int high) {
        int middle = low + (high - low) / 2;
        swap(a, middle, high);
        int storeIndex = low;
        for (int i = low; i < high; i++) {
            if (a[i] < a[high]) {
                swap(a, storeIndex, i);
                storeIndex++;
            }
        }
        swap(a, high, storeIndex);
        return storeIndex;
    }
    private static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1031,"require('../../../common/array-extensions');
const { isEmpty, isFunction } = require('../../../common/utils');
const quickSort = function(list) {
    if (isEmpty(list)) {
        return list;
    }
    if (list.length < 2) {
        return list;
    }
    const allItemsComparable = list.reduce(
        (acc, item) => (acc &= isFunction(item.compareTo)),
        true
    );
    sort(list, 0, list.length, allItemsComparable);
    return list;
};
const sort = (list, start, end, allItemsComparable) => {
    if (end - start < 2) {
        return;
    }
    let pivot = partition(list, start, end, allItemsComparable);
    sort(list, start, pivot, allItemsComparable);
    sort(list, pivot + 1, end, allItemsComparable);
};
const partition = (list, start, end, allItemsComparable) => {
    let pivot = list[start];
    let left = start;
    let right = end;
    while (left < right) {
        if (allItemsComparable) {
            while (left < right && list[--right].compareTo(pivot) >= 0) {}
        } else {
            while (left < right && list[--right] >= pivot) {}
        }
        if (left < right) {
            list[left] = list[right];
        }
        if (allItemsComparable) {
            while (left < right && list[++left].compareTo(pivot) <= 0) {}
        } else {
            while (left < right && list[++left] <= pivot) {}
        }
        if (left < right) {
            list[right] = list[left];
        }
    }
    list[right] = pivot;
    return right;
};
module.exports = { quickSort };",1,0,0,0,0,0,0,0,0
1032,"function swap(array, index1, index2){
    var temp = array[index1]
    array[index1] = array[index2]
    array[index2] = temp
}
function medianOfThree(array, low, high){
    var middle = (high - low) / 2 + low
    if ( array[low] > array[middle] )
        swap(array, low, middle)
    if ( array[low] > array[high] )
        swap(array, low, high)
    if ( array[middle] > array[high] )
        swap(array, middle, high)
    swap(array, middle, high-1)
    return high-1
}
function partition(array, low, high){
    var pivot = medianOfThree(array, low, high)
    while ( low < pivot )
    {
        if ( array[low] > array[pivot] )
        {
            let temp = array[low]
            array[low] = array[pivot-1]
            array[pivot-1] = array[pivot]
            array[pivot--] = temp
        }
        else
            low++
    }
    return pivot
}
function quickSort(array, low, high){
    if ( low < high )
    {
        let index = partition(array, low, high)
        quickSort(array, low, index - 1)
        quickSort(array, index + 1, high)
    }
}
function sort(array){
    quickSort(array, 0, array.length - 1)
}",1,0,0,0,0,0,0,0,0
1033,"package com.zhokhov.interview.sorting;
import static com.zhokhov.interview.util.Console.*;
public class QuickSort {
    private int COMPARISONS_COUNT;
    private int SWAPS_COUNT;
    public void sort(int array[]) {
        COMPARISONS_COUNT = 0;
        SWAPS_COUNT = 0;
        quickSort(array, 0, array.length - 1);
    }
    private void quickSort(int array[], int startIndex, int endIndex) {
        __grey(""\nquickSort, startIndex: "" + startIndex + "", endIndex: "" + endIndex + ""  ==> "");
        ____purple("""" + (endIndex - startIndex >= 1));
        COMPARISONS_COUNT++;
        if (endIndex - startIndex >= 1) {
            int rightIndex = partition(array, startIndex, endIndex);
            quickSort(array, startIndex, rightIndex - 1);
            quickSort(array, rightIndex + 1, endIndex);
        }
    }
    private int partition(int array[], int startIndex, int endIndex) {
        int leftIndex = startIndex;
        int rightIndex = endIndex;
        int pivot = array[startIndex];
        ____grey(""pivot: "" + pivot);
        while (rightIndex > leftIndex) {
            COMPARISONS_COUNT++;
            while (array[leftIndex] <= pivot && leftIndex <= endIndex && rightIndex > leftIndex) {
                COMPARISONS_COUNT++;
                leftIndex++;
                ____blue("" new leftIndex: "" + leftIndex);
            }
            while (array[rightIndex] > pivot && rightIndex >= startIndex && rightIndex >= leftIndex) {
                COMPARISONS_COUNT++;
                rightIndex--;
                ____blue("" new rightIndex: "" + rightIndex);
            }
            COMPARISONS_COUNT++;
            if (rightIndex > leftIndex) {
                swap(array, leftIndex, rightIndex);
            }
        }
        swap(array, startIndex, rightIndex);
        return rightIndex;
    }
    private void swap(int array[], int index1, int index2) {
        SWAPS_COUNT++;
        ____blue(""Swapping: "" + index1 + "" and "" + index2);
        int temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
        __red(""==> "");
        __dump(array);
        System.out.println("""");
    }
    public static void main(String[] args) {
        int array[] = {7, 1, 8, 2, 0, 12, 10, 6, 5, 3};
        __yellow(""\nNew array: "");
        __dump(array);
        System.out.println(""\nSorting"");
        QuickSort quickSort = new QuickSort();
        quickSort.sort(array);
        __green(""\nResult: "");
        __dump(array);
        ____grey(""\nStatistics"");
        __green(""  Comparisons: "");
        System.out.print(quickSort.COMPARISONS_COUNT);
        __green(""\n  Swaps: "");
        System.out.println(quickSort.SWAPS_COUNT);
    }
}",1,0,0,0,0,0,0,0,0
1034,"package ec;
import java.util.ArrayList;
public class QuickSort<T extends Comparable<T>> implements SortingAlgorithms{
	ArrayList<T> list = new ArrayList<T>();
	static long compareQuick = 0;
	static long swapsQuick = 0;
	static long runtime;
	static long start;
	static long end;
	public QuickSort() {
	}
	public int quickSort1(ArrayList<T> quick, int i, int j) {
		T turn = quick.get(j);
		int bottom = i - 1;
		for(int top = i ; top <= j - 1 ; top++) {
			compareQuick++;
			if(quick.get(top).compareTo(turn) <= 0) {
				bottom = bottom + 1;
				swapsQuick++;
				T q = quick.get(bottom);
				quick.set(bottom, quick.get(top));
				quick.set(top, q);
			}
		}
		swapsQuick++;
		T p = quick.get(bottom + 1);
		quick.set(bottom + 1, quick.get(j));
		quick.set(j, p);
		return bottom + 1;
	}
	public ArrayList<T> quickSort2(ArrayList<T> list2) {
		return quickSort3(list2, 0, list2.size() - 1);
	} 
	public ArrayList<T> quickSort3(ArrayList<T> quick, int i, int j) {
		if(i < j) {
			int sort = quickSort1(quick, i, j);
			quickSort3(quick, i, sort - 1);
			quickSort3(quick, sort + 1, j);
		}
		return quick;
	}
	@Override
	public void sortingAlgorithms() {
		quickSort2(list);		
	}
	public void euntime() {
		System.out.print(""Runtime: ""  + (runtime * 2) + "" ms"");
	}
	public ArrayList<T> quickSort4(ArrayList<T> quickList) {
		start = System.currentTimeMillis();
		quickSort2(quickList);
		end = System.currentTimeMillis();
		runtime = end - start;
		return quickList;
	}
	public ArrayList<T> print(ArrayList<T> bubble) {
		ArrayList<T> bs = new ArrayList<T>();
		for(int i = 0 ; i < bubble.size() ; i++) {
			bs.add(bubble.get(i));
		}
		return bs;
	}
	public static void compare() {
		System.out.print(""Comparisons: "" + compareQuick);
	}
	public static void swap() {
		System.out.print(""Swaps: "" + swapsQuick);
	}
	public void runtime() {
		System.out.print(""Runtime: ""  + runtime + "" ms"");
	}
}",1,0,0,0,0,0,0,0,0
1035,"import java.util.*;
public class QuickSort {
    public static void main (String[] args){
        int ar[] = {9,6,5,0,8,2,4,};
        printArray(ar);
        quickSort(ar,0,ar.length-1);
        printArray(ar);
    }
    public static void quickSort(int ar[],int p ,int r){
        if(p<r){
            int q= partition(ar ,p ,r);
            quickSort(ar,p,q-1);
            quickSort(ar,q+1,r);
        }
    }
    public static int partition(int ar[],int p ,int r){
        int x=ar[r];
        int i=p-1;
        for(int j=p  ; j<r ;j++){
            if(ar[j]<x){
                i=i+1;
                int temp= ar[i];
                ar[i]= ar[j];
                ar[j]=temp;
            }
        }
        int temp= ar[r];
        ar[r]= ar[i+1];
        ar[i+1]=temp;
        return (i+1);
    }
    public static void printArray(int[] ar){
        for(int g : ar){
            System.out.print(g+"" "");
        }
        System.out.println();
     }
}",1,0,0,0,0,0,0,0,0
1036,"import java.io.IOException;
import java.util.ArrayList;
public class QuickSort extends Sorts{
	public ArrayList<Integer> quickSort(ArrayList<Integer> unsortedList)
	{
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		if(unsortedList.size() <= 1)
		{
			return unsortedList;
		}
		int pivot = unsortedList.size()/2;
		int pivotData = unsortedList.get(pivot);
		unsortedList.remove(pivot);
		ArrayList<Integer> left = new ArrayList<Integer>();
		ArrayList<Integer> right = new ArrayList<Integer>();
		for(int i = 0; i < unsortedList.size(); i++)
		{
			if(unsortedList.get(i) > pivotData)
			{
				right.add(unsortedList.get(i));
			}
			else
			{
				left.add(unsortedList.get(i));
			}
		}
		sortedList = concatinate(quickSort(left), pivotData, quickSort(right));
		return sortedList;
	}
	public ArrayList<Integer> concatinate(ArrayList<Integer> left, int pivot, ArrayList<Integer> right)
	{
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		for(int i = 0; i < left.size(); i++)
		{
			sortedList.add(left.get(i));
		}
		sortedList.add(pivot);
		for(int i = 0; i < right.size(); i++)
		{
			sortedList.add(right.get(i));
		}
		return sortedList;
	}
	public void QuickTime(IOClass ioStream) throws IOException
	{
		ioStream.readFromFile();
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		long timeBefore = System.nanoTime();
		sortedList = quickSort(ioStream.getInputArray());
		long timeAfter = System.nanoTime();
		double rawTime = timeAfter - timeBefore;
		double timeInMilli = rawTime/1000000;
		if(isSorted(sortedList))
		{
			ioStream.setInputArray(sortedList);
			System.out.print(""QuickSort time (in Milli): ""); 
			System.out.println(timeInMilli);
		}
		else
		{
			System.out.println(""Not sorted!"");
		}
	}
}",1,0,0,0,0,0,0,0,0
1037,"import java.util.*;
class QuickSort{
  public static void main(String args[])
  {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    while(n!=0)
    {
      n--;
    }
  }
}",0,0,0,0,0,0,0,0,0
1038,"package ro.geo.sorting.quicksort;
public class QuickSort {
	public static void sort(Integer[] unsortedArray, int low, int high) {
		int p = 0;
		if (low < high) {
			p = partition(unsortedArray, low, high);
			sort(unsortedArray, low, p);
			sort(unsortedArray, p + 1, high);
		}
	}
	private static int partition(Integer[] array, int low, int high) {
		int pivot = array[low];
		int i = low - 1;
		int j = high;
		int x = 0;
		while (true) {
			while (array[i] < pivot) {
				i++;
			}
			while (array[j] > pivot) {
				j--;
			}
			if (i >= j) {
				return j;
			}
			x = array[i];
			array[i] = array[j];
			array[j] = x;
		}
	}
}",1,0,0,0,0,0,0,0,0
1039,"function median (arr, i, j, k) {
	if (arr[i] > arr[j] && arr[i] > arr[k]) {
		if (arr[k] > arr[j]) {
			return k;
		} else {
			return j;
		}
	} else if (arr[j] > arr[i] && arr[j] > arr[k]) {
		if (arr[k] > arr[i]) {
			return k;
		} else {
			return i;
		}
	} else {
		if (arr[i] > arr[j]) {
			return i;
		} else {
			return j;
		}
	}
}
function partition (arr, start, end) {
	let j = start - 1;
	let tmp;
	let pi = median(arr, start, end, parseInt((start + end) / 2));
	tmp = arr[pi];
	arr[pi] = arr[end];
	arr[end] = tmp;
	let pivot = arr[end];
	for (let i = start; i < end; i++) {
		if (arr[i] <= pivot) {
			j++;
			tmp = arr[i];
			arr[i] = arr[j];
			arr[j] = tmp;
		}
	}
	tmp = arr[j + 1];
	arr[j + 1] = arr[end];
	arr[end] = tmp;
	return j + 1;
}
function quickSort (arr, left = 0, right = arr.length - 1) {
	if (left < right) {
		let p = partition(arr, left, right);
		quickSort(arr, left, p - 1);
		quickSort(arr, p + 1, right);
	}
}
function main () {
	let arr = [2, 1, 6, 44, 8, 9, 10];
	quickSort(arr);
	console.log('Sorted data is', arr);
}
main();",1,0,0,0,0,0,0,0,0
1040,"""use strict"";
Array.prototype.quicksort = function(compare) {
    if (""function"" != typeof compare) {
        var desc = compare || false;
        compare = function(a, b) {
            return desc ? a < b : a > b;
        }
    }
    var that = this;
    function swap(i, j) {
        var temp = that[i];
        that[i] = that[j];
        that[j] = temp;
    }
    function partition(left, right) {
        var pivot = that[right + left >> 1], i = left, j = right;
        while (i <= j) {
            while (compare(pivot, that[i])) {
                i++;
            }
            while (compare(that[j], pivot)) {
                j--;
            }
            if (i <= j) {
                swap(i, j);
                i++;
                j--;
            }
        }
        return i;
    }
    function sort(left, right) {
        if (left < right) {
            var pivot = partition(left, right);
            sort(left, pivot - 1);
            sort(pivot, right);
        }
    }
    sort(0, this.length - 1);
    return this;
};",1,0,0,0,0,0,0,0,0
1041,"import random
def partition(a, low, high):
    i = low - 1  
    pivot = a[high]
    for j in range(low, high):
        if a[j] <= pivot:
            i += 1  
            a[i], a[j] = a[j], a[i]
    a[i + 1], a[high] = a[high], a[i + 1]
    return i + 1
def quicksort_inplace(a, low=0, high=None):
    if high is None:
        high = len(a) - 1
    if low < high:
        pivot = partition(a, low, high)
        quicksort_inplace(a, low, pivot - 1)
        quicksort_inplace(a, pivot + 1, high)
unordered_list = []
for i in range(100):
    unordered_list.append(i)
random.shuffle(unordered_list)
quicksort_inplace(unordered_list)
print(unordered_list)
success = True
for index in range(len(unordered_list) - 1):
    if unordered_list[index] > unordered_list[index + 1]:
        success = False
if success:
    print(""In-place Quicksort successful!"")",1,0,0,0,0,0,0,0,0
1042,"package Sorting;
import Comparing.BaseAreaCompare;
import Comparing.VolumeCompare;
import Objects.ThreeDGeoShape;
public class QuickSort {
	public ThreeDGeoShape[] sort(String sortBy, ThreeDGeoShape[] shapeArray, int begin, int end) {
		if (begin < end) {
			int partitionIndex = partition(sortBy, shapeArray, begin, end);
			sort(sortBy, shapeArray, begin, partitionIndex - 1);
			sort(sortBy, shapeArray, partitionIndex + 1, end);
		}
		return shapeArray;
	}
	private int partition(String sortBy, ThreeDGeoShape[] shapeArray, int begin, int end) {
		ThreeDGeoShape pivot = shapeArray[end];
		int i = (begin - 1);
		int result = 0;
		BaseAreaCompare ac = new BaseAreaCompare();
		VolumeCompare vc = new VolumeCompare();
		for (int j = begin; j < end; j++) {
			if (sortBy.equalsIgnoreCase(""h"")) {
				result = pivot.compareTo(shapeArray[j]);
			} else if (sortBy.equalsIgnoreCase(""a"")) {
				result = ac.compare(pivot, shapeArray[j]);
			} else if (sortBy.equalsIgnoreCase(""v"")) {
				result = vc.compare(pivot, shapeArray[j]);
			}
			if (result == -1) {
				i++;
				ThreeDGeoShape swapTemp = shapeArray[i];
				shapeArray[i] = shapeArray[j];
				shapeArray[j] = swapTemp;
			}
		}
		ThreeDGeoShape swapTemp = shapeArray[i + 1];
		shapeArray[i + 1] = shapeArray[end];
		shapeArray[end] = swapTemp;
		return i + 1;
	}
}",1,0,0,0,0,0,0,0,0
1043,"package io.github.marioluan.algorithms.sorting;
import edu.princeton.cs.algs4.StdRandom;
@SuppressWarnings(""rawtypes"")
public final class QuickSort extends Sortable {
    private static final int CUTOFF = 10;
    public static void sort(Comparable[] a) {
        StdRandom.shuffle(a);
        sort(a, 0, a.length - 1);
    }
    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo + CUTOFF - 1) {
            InsertionSort.sort(a, lo, hi);
            return;
        }
        int j = partition(a, lo, hi);
        sort(a, lo, j - 1);
        sort(a, j + 1, hi);
    }
    protected static int partition(Comparable[] a, int lo, int hi) {
        int i = lo;
        int j = hi + 1;
        while (true) {
            while (less(a[++i], a[lo]))
                if (i == hi)
                    break;
            while (less(a[lo], a[--j])) {
                if (j == lo)
                    break;
            }
            if (i >= j)
                break;
            swap(a, i, j);
        }
        swap(a, lo, j);
        return j;
    }
}",1,0,0,0,0,0,0,0,0
1044,"import java.util.Arrays;
public class QuickSortExample
{
    public static void main(String[] args)
    {
        Integer[] array = new Integer[] { 12, 13, 24, 10, 3, 6, 90, 70 };
        quickSort( array, 0, array.length - 1 );
        System.out.println(Arrays.toString(array));
    }
    public static void quickSort(Integer[] arr, int low, int high)
    {
        if (arr == null || arr.length == 0){
            return;
        }
        if (low >= high){
            return;
        }
        int middle = low + (high - low) / 2;
        int pivot = arr[middle];
        int i = low, j = high;
        while (i <= j)
        {
            while (arr[i] < pivot)
            {
                i++;
            }
            while (arr[j] > pivot)
            {
                j--;
            }
            if (i <= j)
            {
                swap (arr, i, j);
                i++;
                j--;
            }
        }
        if (low < j){
            quickSort(arr, low, j);
        }
        if (high > i){
            quickSort(arr, i, high);
        }
    }
    public static void swap (Integer array[], int x, int y)
    {
        int temp = array[x];
        array[x] = array[y];
        array[y] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1045,"class quickSort
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		quickSort ob = new quickSort();
		ob.sort(arr, 0, arr.length-1);
		for (int i : arr)
			System.out.print(i);
	}
	void sort(int [] arr, int l, int h){
		if (l < h){
			int j = 0, pivot = arr[h], temp = 0;
			for (int i=l;i<h;i++){
				if (arr[i] < pivot){
					temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
					j++;
				}
			}
			temp = arr[j+1];
			arr[j+1] = arr[h];
			arr[h] = temp;
			sort(arr, l, j);
			sort(arr, j+2, h);
		}
	}
}",1,0,0,0,0,0,0,0,0
1046,"import java.util.Arrays;
import java.util.Random;
public class QuickSort{
	public void quickSort(int[] A) {
		int low = 0;
		int high = A.length - 1;
		quickSort(A, low, high);
	}
	private void quickSort(int[] A, int low, int high) {
		if (low < high) {
			int pivotIdx = getPivot(low, high);
			swap(A, low, pivotIdx);  
			int partitionIdx = partition(A, low, high);
			quickSort(A, low, partitionIdx - 1);  
			quickSort(A, partitionIdx + 1, high);  
		}
	}
	private int getPivot(int low, int high) {
		Random random = new Random();
		return random.nextInt(high - low + 1) + low;  
	}
	private void swap(int[] A, int idx1, int idx2) {
		int tmp = A[idx1];
		A[idx1] = A[idx2];
		A[idx2] = tmp;
	}
	private int partition(int[] A, int low, int high) {
		int i = low, j = high;
		while (i != j) {
			while (A[j] >= A[low] && i < j) {
				j --;
			}
			while (A[i] <= A[low] && i < j) {
				i ++;
			}
			if (i < j) {
				swap(A, i, j);
			}
		}
		swap(A, low, i);
		return i;
	}
	public static void main(String[] args) {
		QuickSort qs = new QuickSort();
		int[] A = {4, 5, 9, 2, 0, 1, 6, 8, 3, 7};
		System.out.println(Arrays.toString(A));
		qs.quickSort(A);
		System.out.println(Arrays.toString(A));
	}
}",1,0,0,0,0,0,0,0,0
1047,"package sorting.algorithms;
public class QuickSort {
    private int[] inputArray;
    private int length;
    public int[] sort(int[] values) {
        if (values == null || values.length == 0) {
            return values;
        }
        this.inputArray = values;
        length = values.length;
        quicksort(0, length - 1);
        return values;
    }
    private void quicksort(int low, int high) {
        int i = low, j = high;
        int pivot = inputArray[low + (high - low) / 2];
        while (i <= j) {
            while (inputArray[i] < pivot) {
                i++;
            }
            while (inputArray[j] > pivot) {
                j--;
            }
            if (i <= j) {
                exchange(i, j);
                i++;
                j--;
            }
        }
        if (low < j)
            quicksort(low, j);
        if (i < high)
            quicksort(i, high);
    }
    private void exchange(int i, int j) {
        int temp = inputArray[i];
        inputArray[i] = inputArray[j];
        inputArray[j] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1048,"package com.intrafoundation;
public class QuickSort extends BaseSort {
    public void sort(int[] arr) {
        swaps = 0;
        quickSort(arr, 0, arr.length - 1);
    }
    public void quickSort(int[] arr, final int begin, final int end) {
        if (begin < end) {
            final int partitionIndex = partition(arr, begin, end);
            quickSort(arr, begin, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, end);
        }
    }
    private int partition(int[] arr, final int begin, final int end) {
        final int pivot = arr[end];
        int slidingIndex = (begin - 1);
        for (int loopIndex = begin; loopIndex < end; loopIndex++) {
            if (arr[loopIndex] <= pivot) {
                swap(arr, ++slidingIndex, loopIndex);
            }
        }
        swap(arr, ++slidingIndex, end);
        return slidingIndex;
    }
}",1,0,0,0,0,0,0,0,0
1049,"package project1.sorts;
import project1.ExperimentalResultsData;
public final class QuickSort<E extends Comparable<E>> implements Sort<E> {
    @Override
    public SortType sort(ExperimentalResultsData experimentalResultsData, E[] list) {
        sort(experimentalResultsData, list, 0, list.length - 1);
        return SortType.QUICK_SORT;
    }
    private void sort(ExperimentalResultsData experimentalResultsData, E[] list, int low, int high) {
        int i = low;
        int j = high;
        E pivot = list[low + (high - low) / 2];
        while (i <= j) {
            while (list[i].compareTo(pivot) < 0) {
                experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
                i++;
            }
            while (list[j].compareTo(pivot) > 0) {
                experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
                j--;
            }
            if (i <= j) {
                swap(list, i, j);
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
                i++;
                j--;
            }
        }
        if (low < j) {
            sort(experimentalResultsData, list, low, j);
        }
        if (i < high) {
            sort(experimentalResultsData, list, i, high);
        }
    }
    private void swap(E[] list, int i, int j) {
        E temp = list[i];
        list[i] = list[j];
        list[j] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1050,"package io.lenur.sort;
public class QuickSort implements Sortable {
    @Override
    public void sort(int[] data) {
        sort(data, 0, data.length-1);
    }
    private void sort(int[] data, int low, int high) {
        if (low < high) {
            int pi = partition(data, low, high);
            sort(data, low, pi - 1);
            sort(data, pi + 1, high);
        }
    }
    private int partition(int[] data, int low, int high) {
        int pivot = data[high];
        int i = (low - 1);
        for (int j = low; j < high; j++) {
            if (data[j] < pivot) {
                i++;
                int temp = data[i];
                data[i] = data[j];
                data[j] = temp;
            }
        }
        int temp = data[i + 1];
        data[i + 1] = data[high];
        data[high] = temp;
        return i + 1;
    }
}",1,0,0,0,0,0,0,0,0
1051,"package sortAlgorithms;
import helperUtils.Utility;
public class QuickSort {
  public static void main(String[] args) {
    int[] inputArr = { 10, -80, 5, 76, 92, 100, 52, 1, -10 };
    Utility.printArray(inputArr, true, ""Quick Sort"");
    quickSort(inputArr, 0, inputArr.length);
    Utility.printArray(inputArr, false, null);
  }
  public static void quickSort(int[] arr, int start, int end) {
    if (end - start < 2) {
      return;
    }
    int partitionIndex = partition(arr, start, end);
    quickSort(arr, start, partitionIndex);
    quickSort(arr, partitionIndex + 1, end);
  }
  public static int partition(int[] arr, int start, int end) {
    int i = start;
    int j = end;
    int pivot = arr[start];
    while (i < j) {
      while (i < j && arr[--j] >= pivot)
        ;
      if (i < j) {
        arr[i] = arr[j];
      }
      while (i < j && arr[++i] <= pivot)
        ;
      if (i < j) {
        arr[j] = arr[i];
      }
    }
    arr[j] = pivot;
    return j;
  }
}",1,0,0,0,0,0,0,0,0
1052,"exports.quickSort = ({ list }, { shouldSwap, swap }) => {
  const sortRecursively = (startIndex = 0, endIndex = list.length - 1) => {
    const pivotIndex = startIndex;
    let lowerIndex = startIndex;
    let higherIndex = endIndex;
    while (lowerIndex <= higherIndex) {
      while (shouldSwap(pivotIndex, lowerIndex) && lowerIndex < endIndex) {
        lowerIndex += 1;
      }
      while (!shouldSwap(pivotIndex, higherIndex) && higherIndex > startIndex) {
        higherIndex -= 1;
      }
      if (lowerIndex <= higherIndex) {
        swap(lowerIndex, higherIndex);
        lowerIndex += 1;
        higherIndex -= 1;
      }
    }
    if (startIndex < higherIndex) {
      sortRecursively(startIndex, higherIndex);
    }
    if (lowerIndex < endIndex) {
      sortRecursively(lowerIndex, endIndex);
    }
    return list;
  };
  return sortRecursively();
};",1,0,0,0,0,0,0,0,0
1053,"aij.quickSort = function(items) {
    var partition = function(arr, left, right) {
      if (right === left) {
        return;
      }
      var pivotIndex = (Math.random() * (right - left) + left) << 0,
          pivot = arr[pivotIndex];
      aij.swap(arr, left, pivotIndex);
      var partitionIndex = left + 1;
      for (var i = left + 1; i < right; i++) {
        if (arr[i] < pivot) {
          aij.swap(arr, partitionIndex, i)
          partitionIndex++;
        }
      };
      aij.swap(arr, partitionIndex - 1, left);
      partition(arr, left, partitionIndex - 1);
      partition(arr, partitionIndex, right);
    };
    return aij.isSortable(items) && partition(items, 0, items.length) || items;
};",1,0,0,0,0,0,0,0,0
1054,"class QuickSort:
  vec = [] 
  len = -1
  p = -1
  def __init__(self, arr):
        self.vec = arr
        self.len = len(self.vec)
  def get(self):
      return self.vec  
  def set(self,arr):
      self.vec = arr
  def sort(self):
      self._qs(0,self.len-1)
  def partition(self,li,ls):
      i = li
      j = ls
      i1 = 0
      j1 = -1
      aux = 0
      while i<j:
            if self.vec[i] > self.vec[j]:
               self._swap(i,j)  
               aux = i1
               i1 = -j1
               j1 = -aux
            i = i + i1
            j = j + j1
      self.p = i    
  def _qs(self,li,ls):
    if li<ls:
      self.partition(li,ls)  
      self._qs(li,self.p-1) 
      self._qs(self.p+1,ls)  
  def _swap(self,i,j):
      temp = self.vec[i]
      self.vec[i] = self.vec[j]
      self.vec[j] = temp   
arr=[9,8,7,6,5,4,3,2,1]
ob = QuickSort(arr)
ob.sort()
print ob.get()       ",1,0,0,0,0,0,0,0,0
1055,"package sortingalgorithms;
import cnode.CNode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javafx.animation.FillTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.Transition;
import javafx.scene.paint.Color;
import javafx.util.Duration;
public class QuickSort extends AbstractSort {
  private static final Color PIVOT_COLOR = Color.DARKMAGENTA;
  private ArrayList<Transition> transitions;
  public QuickSort() {
    this.transitions = new ArrayList<>();
  }
  private void quickSort(CNode[] arr, int lo, int hi) {
    if (lo < hi) {
      int q = partition(arr, lo, hi);
      quickSort(arr, lo, q - 1);
      quickSort(arr, q + 1, hi);
    }
  }
  private int partition(CNode[] arr, int lo, int hi) {
    int i = lo;
    transitions.add(colorCNode(arr, PIVOT_COLOR, hi)); 
    for (int j = lo; j < hi; j++) {
      transitions.add(colorCNode(arr, SELECT_COLOR, j));
      if (arr[j].getValue() < arr[hi].getValue()) {
        transitions.add(swap(arr, i, j));
        transitions.add(colorCNode(arr, START_COLOR, i));
        i++;
      } else {
        transitions.add(colorCNode(arr, START_COLOR, j));
      }
    }
    transitions.add(swap(arr, i, hi));
    transitions.add(colorCNode(arr, START_COLOR, i));
    return i;
  }
  @Override
  public ArrayList<Transition> startSort(CNode[] arr) {
    quickSort(arr, 0, arr.length - 1);
    transitions.add(colorCNode(Arrays.asList(arr), SORTED_COLOR));
    return transitions;
  }
}",1,0,0,0,0,0,0,0,0
1056,"package sorts;
import util.SortUtil;
import java.util.Random;
public class QuickSort {
    public static int[] sort(int[] arr) {
        shuffle(arr);
        quicksort(arr, 0, arr.length - 1);
        return arr;
    }
    private static void quicksort(int[] arr, int lowerIndex, int higherIndex) {
        int i = lowerIndex;
        int j = higherIndex;
        int pivot = arr[lowerIndex + (higherIndex - lowerIndex) / 2];
        while (i <= j) {
            while (arr[i] < pivot) {
                i++;
            }
            while (arr[j] > pivot) {
                j--;
            }
            if (i <= j) {
                SortUtil.swap(arr, i, j);
                i++;
                j--;
            }
        }
        if (lowerIndex < j)
            quicksort(arr, lowerIndex, j);
        if (i < higherIndex)
            quicksort(arr, i, higherIndex);
    }
    private static void shuffle(int[] arr) {
        Random rand = new Random();
        for(int i = 0; i < arr.length; i++) {
            SortUtil.swap(arr, i, rand.nextInt(arr.length));
        }
    }
}",1,0,0,0,0,0,0,0,0
1057,"import java.util.Scanner;
public class QuickSort
{
    public static void main(String[] args)
    {
        Scanner input = new Scanner(System.in);
        System.out.print(""enter array : "");
        char[] array = input.nextLine().toCharArray();
        quickSort(array);
        System.out.print(""sorted array : "");
        for(char x:array)
            System.out.print(x);
    }
    static void quickSort(char[] array)
    {
        if(array.length == 1)
            return;
        quickSort(array, 0, array.length-1);
    }
    static void quickSort(char[] array, int low, int high)
    {
        if(low < high)
        {
            int pi = partition(array, low, high);
            quickSort(array, low, pi-1);
            quickSort(array, pi+1, high);
        }
    }
    static int partition(char[] array, int low, int high)
    {
        int i = low - 1;
        int pivot = array[high];
        for(int j=low;j<high;j++)
        {
            if(array[j] <= pivot)
            {
                i++;
                swap(array, i, j);
            }
        }
        swap(array, i+1, high);
        return i+1;
    }
    static void swap(char[] array, int a, int b)
    {
        char t = array[a];
        array[a] = array[b];
        array[b] = t;
    }
}",1,0,0,0,0,0,0,0,0
1058,"import java.util.Arrays;
import java.util.Scanner;
public class Quicksort {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Quicksort Algorithm"");
        System.out.println(""Enter total number of elements:"");
        int lengthOfTheArray = input.nextInt();
        int[] arrayOfIntegersToSort = new int[lengthOfTheArray];
        System.out.printf(""Enter %d integers:%n"", lengthOfTheArray);
        for (int i = 0; i < lengthOfTheArray; i++) {
            arrayOfIntegersToSort[i] = input.nextInt();
        }
        int[] sortedArray = quicksort(arrayOfIntegersToSort);
        System.out.printf(""Sorted array using Quicksort Algorithm: %s%n"",
                Arrays.toString(sortedArray));
        input.close();
    }
    private static int[] quicksort(int[] arrayToSort) {
        if (arrayToSort == null || arrayToSort.length == 0) {
            return arrayToSort;
        }
        quicksortRecursive(0, arrayToSort.length - 1, arrayToSort);
        return arrayToSort;
    }
    private static void quicksortRecursive(int start, int end, int[] arrayToSort) {
        int i = start;
        int j = end;
        int pivot = arrayToSort[start + (end - start)/2];
        while (arrayToSort[i] < pivot) {
            i++;
        }
        while (arrayToSort[j] > pivot) {
            j--;
        }
        if (i <= j) {
            swap(arrayToSort, i, j);
            i++;
            j--;
        }
        if (start < j) {
            quicksortRecursive(start, j, arrayToSort);
        }
        if (i < end) {
            quicksortRecursive(i, end, arrayToSort);
        }
    }
    private static void swap(int[] array, int from, int to){
        int temp = array[from];
        array[from] = array[to];
        array[to] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1059,"package com.jwetherell.algorithms.sorts;
import java.util.Random;
public class QuickSort<T extends Comparable<T>> {
    private static final Random RAND = new Random();
    public static enum PIVOT_TYPE {
        FIRST, MIDDLE, RANDOM
    }
    public static PIVOT_TYPE type = PIVOT_TYPE.RANDOM;
    private QuickSort() { }
    public static <T extends Comparable<T>> T[] sort(PIVOT_TYPE pivotType, T[] unsorted) {
        int pivot = 0;
        if (pivotType == PIVOT_TYPE.MIDDLE) {
            pivot = unsorted.length/2;
        } else if (pivotType == PIVOT_TYPE.RANDOM) {
            pivot = getRandom(unsorted.length);  
        }
        sort(pivot, 0, unsorted.length - 1, unsorted);
        return unsorted;
    }
    private static <T extends Comparable<T>> void sort(int index, int start, int finish, T[] unsorted) {
        int pivotIndex = start + index;
        T pivot = unsorted[pivotIndex];
        int s = start;
        int f = finish;
        while (s <= f) {
            while (unsorted[s].compareTo(pivot) < 0)
                s++;
            while (unsorted[f].compareTo(pivot) > 0)
                f--;
            if (s <= f) {
                swap(s, f, unsorted);
                s++;
                f--;
            }
        }
        if (start < f) {
            pivotIndex = getRandom((f - start) + 1);
            sort(pivotIndex, start, f, unsorted);
        }
        if (s < finish) {
            pivotIndex = getRandom((finish - s) + 1);
            sort(pivotIndex, s, finish, unsorted);
        }
    }
    private static final int getRandom(int length) {
        if (type == PIVOT_TYPE.RANDOM && length > 0)
            return RAND.nextInt(length);
        if (type == PIVOT_TYPE.FIRST && length > 0)
            return 0;
        return length / 2;
    }
    private static <T extends Comparable<T>> void swap(int index1, int index2, T[] unsorted) {
        T index2Element = unsorted[index1];
        unsorted[index1] = unsorted[index2];
        unsorted[index2] = index2Element;
    }
}",1,0,0,0,0,0,0,0,0
1060,"package Sorting;
import java.util.Scanner;
public class QuickSort {
    private static void quickSort(int[] array,int lb,int ub) {
         if(lb < ub) {
             int end  = partition(array,lb,ub);
             quickSort(array,lb,end-1);
             quickSort(array,end+1,ub);
         }
    }
    private static int partition(int[] array , int lb , int ub) {
         int pivot = array[lb];
         int start = lb;
         int end = ub;
         while (start < end) {
             while (array[start] <= pivot && start < array.length - 1) {
                 start++;
             }
             while (array[end] > pivot) {
                 end--;
             }
             if(start < end) {
                 swap(array,start,end);
             }
         }
         swap(array,lb,end);
         return end;
    }
    private static void swap(int[] array , int i , int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    private static void print(int[] array) {
        for(int i : array) {
            System.out.print(i + "" "");
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i= 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        System.out.print(""Before Sorting : "");
        print(array);
        long startTime = System.nanoTime();
        quickSort(array,0,array.length-1);
        long endTime = System.nanoTime();
        System.out.print(""\nAfter Sorting : "");
        print(array);
        long totalTime = endTime - startTime;
        System.out.printf(""\nTime in seconds : %.6fs"",(totalTime/ 1000000000.0));
        sc.close();
    }
}",1,0,0,0,0,0,0,0,0
1061,"package Sorting;
public class QuickSort {
    public static void main(String[] args) {
        int[] arr={20,35,-15,7,55,1,-22};
        QS(arr,0,arr.length);
        for(int j=0;j<arr.length;j++) {
            System.out.print(arr[j] + "" "");
        }
    }
    public static void QS(int[] arr,int start,int end){
        if (end - start <2){
            return;
        }
        int pi = partition(arr,start,end);
        QS(arr,start,pi);  
        QS(arr,pi+1,end);  
    }
    public static int partition(int[] arr, int start, int end){
        int i=start;
        int j = end;
        int pivot = arr[start];
        while(i<j){
            while (i<j && arr[--j]>=pivot);
            if (i<j){
                arr[i] = arr[j];
            }
            while (i<j && arr[++i]<= pivot);
            if(i<j){
                arr[j]= arr[i];
            }
        }
        arr[j] = pivot;
        return j;
    }
}",1,0,0,0,0,0,0,0,0
1062,"class QuickSort 
{ 
	int partition(int arr[], int low, int high) 
	{ 
		int pivot = arr[high]; 
		int i = low-1; 
		for (int j=low; j<high; j++) 
		{ 
			if (arr[j] < pivot) 
			{ i++;
				int temp = arr[i]; 
				arr[i] = arr[j]; 
				arr[j] = temp; 
			} 
		} 
		int temp = arr[i+1]; 
		arr[i+1] = arr[high]; 
		arr[high] = temp; 
		return i+1; 
	} 
	void sort(int arr[], int low, int high) 
	{ 
		if (low < high) 
		{ 
            int pi = partition(arr, low, high); 
            QuickSort obj=new QuickSort();
            obj.printArray(arr);
			sort(arr, low, pi-1); 
			sort(arr, pi+1, high); 
		} 
	} 
	static void printArray(int arr[]) 
	{ 
		int n = arr.length; 
		for (int i=0; i<n; ++i) 
			System.out.print(arr[i]+"" ""); 
		System.out.println(); 
	} 
	public static void main(String args[]) 
	{ 
		int arr[] = {10, 7, 8, 9, 1, 5}; 
		int n = arr.length; 
		QuickSort ob = new QuickSort(); 
		ob.sort(arr, 0, n-1); 
		System.out.println(""sorted array""); 
		printArray(arr); 
	} 
} yeh ky	",1,0,0,0,0,0,0,0,0
1063,"package Java;
public class QuickSort extends Sort{
	public static void main(String[] args){
		int[] data = buildDataSet(5);
		timeSort(new QuickSort(), data);
	}
	public QuickSort(){ super(""Quick""); }
	private int medianOfThree(int[] data, int low, int high){
        int middle = ( low + high ) / 2;
        if( data[middle] < data[low] )
            swap(data, low, middle);
        if( data[high] <data[low] )
            swap(data, low, high);
        if( data[high] < data[middle] )
            swap(data, middle, high);
        swap(data, middle, high-1);  
        return high-1;
	}
	private int partition(int[] data, int low, int high){
		int pivot = medianOfThree(data, low, high);
		while (low < pivot)
		{
			if ( data[low] > data[pivot] )
			{
				int temp = data[low];
				data[low] = data[pivot - 1];
				data[pivot - 1] = data[pivot];
				data[pivot] = temp;
				pivot--;
			}
			else
				low++;
		}
		return pivot;
	}
	private void quickSort(int[] data, int low, int high){
		if ( low < high)
		{
			int index = partition(data, low, high);
			quickSort(data, low, index - 1);
			quickSort(data, index + 1, high);
		}
	}
	@Override
	public void sort(int[] data){
		quickSort(data, 0, data.length - 1);
	}
	private void swap(int[] data, int index1, int index2){
		int temp = data[index1];
		data[index1] = data[index2];
		data[index2] = temp;
	}
}",1,0,0,0,0,0,0,0,0
1064,"const quickSort = (arry = []) => {
    if (arry.length === 0)
        return [];
    let left = [], right =[], pivot = arry[0];
    for (let i=1; i< arry.length; i++) {
        if(arry[i] < pivot)
            left.push(arry[i]);
        else
            right.push(arry[i]);
    };
    return [...quickSort(left), pivot, ...quickSort(right)];
}",1,0,0,0,0,0,0,0,0
1065,"def quicksort(lis, start, end):
    assert 0 <= start <= end < len(lis)
    if start == end:
        return
    pivot = lis[start]  
    lis[start], lis[end] = lis[end], lis[start]  
    left_index = start
    iterator = start
    while iterator < end:  
        if lis[iterator] <= pivot:
            lis[left_index], lis[iterator] = lis[iterator], lis[left_index]
            left_index += 1
        iterator += 1
    lis[left_index], lis[end] = lis[end], lis[left_index]
    if left_index > start:
        quicksort(lis, start, left_index - 1)
    if end > (left_index + 1):
        quicksort(lis, left_index + 1, end)
def main():
    lis1 = [4, 1, 2, 3, 9]
    lis2 = [1]
    lis3 = [2, 2, 1, -1, 0, 4, 5, 2]
    quicksort(lis1, 0, 4)
    assert lis1 == [1, 2, 3, 4, 9]
    quicksort(lis2, 0, 0)
    assert lis2 == [1]
    quicksort(lis3, 0, 7)
    assert lis3 == [-1, 0, 1, 2, 2, 2, 4, 5]
if __name__ == '__main__':
    main()",1,0,0,0,0,0,0,0,0
1066,"package com.growingwiththeweb.sorting;
import java.util.Random;
public class Quicksort {
    public static <T extends Comparable<T>> void sort(T[] array) {
        sort(array, 0, array.length - 1);
    }
    private static <T extends Comparable<T>> void sort(
            T[] array, int left, int right) {
        if (left < right) {
            int pivot = partition(array, left, right);
            sort(array, left, pivot - 1);
            sort(array, pivot + 1, right);
        }
    }
    private static <T extends Comparable<T>> int partition(
            T[] array, int left, int right) {
        T pivot = array[right];
        int mid = left;
        for (int i = mid; i < right; i++) {
            if (array[i].compareTo(pivot) <= 0) {
                swap(array, i, mid++);
            }
        }
        swap(array, right, mid);
        return mid;
    }
    private static <T extends Comparable<T>> void swap(
            T[] array, int a, int b) {
        if (a != b) {
            T temp = array[a];
            array[a] = array[b];
            array[b] = temp;
        }
    }
    private static Random random = new Random();
    public static <T extends Comparable<T>> void randomSort(T[] array) {
        randomSort(array, 0, array.length - 1);
    }
    private static <T extends Comparable<T>> void randomSort(
            T[] array, int left, int right) {
        if (left < right) {
            int pivot = randomPartition(array, left, right);
            randomSort(array, left, pivot - 1);
            randomSort(array, pivot + 1, right);
        }
    }
    private static <T extends Comparable<T>> int randomPartition(
            T[] array, int left, int right) {
        int pivot = left + random.nextInt(right - left);
        swap(array, right, pivot);
        return partition(array, left, right);
    }
}",1,0,0,0,0,0,0,0,0
1067,"export default function QuickSort(items: Array<number>): Array<number> {
  const itemsCopy = [...items];
  QuickSortRecursive(itemsCopy, 0, itemsCopy.length - 1);
  return itemsCopy;
}
function QuickSortRecursive(items: Array<number>, p: number, r: number) {
  if (p < r) {
    const q = RandomizedPartition(items, p, r);
    QuickSortRecursive(items, p, q - 1);
    QuickSortRecursive(items, q + 1, r);
  }
}
function RandomizedPartition(
  items: Array<number>,
  p: number,
  r: number
): number {
  const i = getRandomInt(p, r);
  Swap(items, i, r);
  return Partition(items, p, r);
}
function Partition(items: Array<number>, p: number, r: number): number {
  const x = items[r];
  let i = p - 1;
  for (let j = p; j < r; j++) {
    if (items[j] <= x) {
      i++;
      Swap(items, i, j);
    }
  }
  Swap(items, i + 1, r);
  return i + 1;
}
function getRandomInt(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function Swap(arr: Array<any>, x: any, y: any) {
  const temp = arr[x];
  arr[x] = arr[y];
  arr[y] = temp;
}",1,0,0,0,0,0,0,0,0
1068,"def partition(arr, low, high):
  pivot = arr[high]
  lower = low - 1
  for i in range(low, high):
    if arr[i] < pivot:
      arr[i], arr[lower] = arr[lower], arr[i]
      lower += 1
  arr[high], arr[lower + 1] = arr[lower + 1], arr[high]
  return lower + 1
def quicksort(arr, low, high):
  if low < high:
    pi = partition(arr, low, high)
    quicksort(arr, low, pi - 1)
    quicksort(arr, pi + 1, low)
def main():
  my_arr = [10, 2, 5, 8, 1]
  quicksort(my_arr, 0, len(my_arr)-1)
  print(my_arr)
  print(""Hello World!"")
if __name__ == ""__main__"":
  main()",1,0,0,0,0,0,0,0,0
1069,"package sort;
import java.util.*;
public class Quicksort {
    static Random rnd = new Random();
    public static void quickSort(int[] a, int low, int high) {
        if (low >= high)
            return;
        int separator = a[low + rnd.nextInt(high - low + 1)];
        int i = low;
        int j = high;
        while (i <= j) {
            while (a[i] < separator) ++i;
            while (a[j] > separator) --j;
            if (i <= j) {
                int t = a[i];
                a[i] = a[j];
                a[j] = t;
                ++i;
                --j;
            }
        }
        quickSort(a, low, j);
        quickSort(a, i, high);
    }
    public static void main(String[] args) {
        int n = 10_000_000;
        int[] a1 = rnd.ints(n).toArray();
        int[] a2 = a1.clone();
        Arrays.sort(a2);
        long time = System.currentTimeMillis();
        quickSort(a1, 0, a1.length - 1);
        System.out.println(System.currentTimeMillis() - time);
        if (!Arrays.equals(a1, a2))
            throw new RuntimeException();
    }
}",1,0,0,0,0,0,0,0,0
1070,"function pivot(arr, start = 0, end = arr.length - 1) {
  const swap = (arr, idx1, idx2) => {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
  };
  let pivot = arr[start];
  let swapIdx = start;
  for (let i = start + 1; i <= end; i++) {
    if (pivot > arr[i]) {
      swapIdx++;
      swap(arr, swapIdx, i);
    }
  }
  swap(arr, start, swapIdx);
  return swapIdx;
}
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    let pivotIndex = pivot(arr, left, right);  
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}
quickSort([100, -3, 2, 4, 6, 9, 1, 2, 5, 3, 23]);",1,0,0,0,0,0,0,0,0
1071,"def quicksort(nums, start, end):
    if start < end:
        mid = partition(nums, start, end)
        quicksort(nums, start, mid - 1)
        quicksort(nums, mid + 1, end)
def partition(nums, start, end):
    pivot = nums[end]
    i = start - 1
    for j in range(start, end):
        if nums[j] < pivot:
            i += 1
            nums[i], nums[j] = nums[j], nums[i]
    i += 1
    nums[i], nums[end] = nums[end], nums[i]
    return i
if __name__ == ""__main__"":
    nums = [5, 2, 4, 6, 1, 3]
    quicksort(nums, 0, len(nums) - 1)
    print(nums)",1,0,0,0,0,0,0,0,0
1072,"package sort.quick;
import sort.Sort;
public class QuickSort extends Sort {
    public void sortMethod(Comparable[] a) {
        sort(a, 0, a.length - 1);
    }
    private void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j - 1);
        sort(a, j + 1, hi);
    }
    private int partition(Comparable[] a, int lo, int hi) {
        int i = lo, j = hi + 1;
        Comparable v = a[lo];
        while (true) {
            while (less(a[++i], v)) if (i == hi) break;
            while (less(v, a[--j])) if (j == lo) break;
            if (i >= j) break;
            exch(a, i, j);
        }
        exch(a, lo, j);
        return j;
    }
}",1,0,0,0,0,0,0,0,0
1073,"const myArray = [2, 4, 1, 6, -7, 8, 5, 9, 3, 4];
const quickSortV1 = arr => {
  if (arr.length <= 1) {
    return arr;
  }
  let pivot = arr.shift();
  let left = arr.filter(el => el < pivot);
  let right = arr.filter(el => el >= pivot);
  let leftSorted = quickSortV1(left);
  let rightSorted = quickSortV1(right);
  return [...leftSorted, pivot, ...rightSorted];
};
console.log(quickSortV1(myArray));",1,0,0,0,0,0,0,0,0
1074,"def quickSort(lst):
    if len(lst) <= 1:
        return lst
    smaller = [x for x in lst[1:] if x < lst[0]]
    larger = [x for x in lst[1:] if x >= lst[0]]
    return quickSort(smaller) + [lst[0]] + quickSort(larger)
if __name__ == '__main__':
    lst = [2, 4, 5, 1]
    print(quickSort(lst))",1,0,0,0,0,0,0,0,0
1075,"const array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function quicksortBasic(array) {
  if(array.length < 2) {
    return array;
  }
  const pivot = array[0];
  const lesser = [];
  const greater = [];
  for(let i = 1; i < array.length; i++) {
    if(array[i] < pivot) {
      lesser.push(array[i]);
    } else {
      greater.push(array[i]);
    }
  }
  return quicksortBasic(lesser).concat(pivot, quicksortBasic(greater));
}
console.log(quicksortBasic(array.slice()));  
function quicksort(array, left, right) {
  left = left || 0;
  right = right || array.length - 1;
  const pivot = partitionHoare(array, left, right);  
  if(left < pivot - 1) {
    quicksort(array, left, pivot - 1);
  }
  if(right > pivot) {
    quicksort(array, pivot, right);
  }
  return array;
}
function partitionLomuto(array, left, right) {
  const pivot = right;
  let i = left;
  let last = left;
  for(let j = left; j < right; j++) {
    if(array[j] <= array[pivot]) {
      [array[i], array[j]] = [array[j], array[i]];
      i = i + 1;
    }
    last = j + 1;
  }
  [array[i], array[last]] = [array[last], array[i]];
  return i;
}
function partitionHoare(array, left, right) {
  const pivot = Math.floor((left + right) / 2 );
  while(left <= right) {
    while(array[left] < array[pivot]) {
      left++;
    }
    while(array[right] > array[pivot]) {
      right--;
    }
    if(left <= right) {
      [array[left], array[right]] = [array[right], array[left]];
      left++;
      right--;
    }
  }
  return left;
}
console.log(quicksort(array.slice()));  ",1,0,0,0,0,0,0,0,0
1076,"public class QuickSort {
    private static int compare(int[] arr, int i, int j) {
        if (arr[i] > arr[j]) {
            return i;
        } else {
            return j;
        }
    }
    private static int median(int[] arr, int i, int j, int k) {
        if (arr[i] > arr[j] && arr[i] > arr[k]) {
            return compare(arr, k, j);
        } else if (arr[j] > arr[i] && arr[j] > arr[k]) {
            return compare(arr, k, i);
        } else {
            return compare(arr, i, j);
        }
    }
    private static int partition(int[] arr, int start, int end) {
        int l = median(arr, start, end, (start + end) / 2);
        int p_idx = start - 1;
        int tmp = arr[l];
        arr[l] = arr[end];
        arr[end] = tmp;
        int pivot = arr[end];
        for (int i = start; i < end; ++i) {
            if (arr[i] <= pivot) {
                p_idx++;
                tmp = arr[i];
                arr[i] = arr[p_idx];
                arr[p_idx] = tmp;
            }
        }
        p_idx++;
        tmp = arr[p_idx];
        arr[p_idx] = arr[end];
        arr[end] = tmp;
        return p_idx;
    }
    public static void quickSort(int[] a, int left, int right) {
        if (left < right) {
            int pi = partition(a, left, right);   
            quickSort(a, left, pi - 1);   
            quickSort(a, pi + 1, right);   
        }
    }
    public static void main(String[] args) {
        int[] arr = new int[] {2, 4, 2, 6, 7, -1};
        quickSort(arr, 0, arr.length - 1);
        for (int element : arr) {
            System.out.println(element);
        }
    }
}",1,0,0,0,0,0,0,0,0
1077,"export function quickSort(array, startIndex, endIndex) {
  const index = partition(array, startIndex, endIndex);
  if (startIndex < index - 1) {
    quickSort(array, startIndex, index - 1);
  }
  if (index < endIndex) {
    quickSort(array, index, endIndex);
  }
  return array;
}
function partition(array, startIndex, endIndex) {
  const pivotIndex = Math.floor((endIndex + startIndex) / 2);
  const pivot = array[pivotIndex];
  var leftIndex = startIndex;
  var rightIndex = endIndex;
  while (leftIndex <= rightIndex) {
    if (array[leftIndex] < pivot) {
      leftIndex++;
    } else if (array[rightIndex] > pivot) {
      rightIndex--;
    } else {
      if (leftIndex <= rightIndex) {
        swap(array, leftIndex, rightIndex);
      }
      leftIndex++;
      rightIndex--;
    }
  }
  return leftIndex;
}
function swap(array, index1, index2) {
  const val1 = array[index1];
  array[index1] = array[index2];
  array[index2] = val1;
}",1,0,0,0,0,0,0,0,0
1078,"function quickSort(array, left, right) {
    left = left || 0;
    right = right || array.length - 1;
    const pivot = partitionHoare(array, left, right);
    if(left < pivot - 1) {
        quickSort(array, left, pivot - 1);
    }
    if(right > pivot) {
        quickSort(array, pivot, right);
    }
    return array;
}
function partitionHoare(array, left, right) {
    const pivot = Math.floor((left + right) / 2);
    while(left <= right) {
        while(array[left] < array[pivot]) {
            left++;
        }
        while(array[right] > array[pivot]) {
            right--;
        }
        if (left <= right) {
            [array[left], array[right]] = [array[right], array[left]];
            left++;
            right--;
        }
    }
    return left;
}
(function test() {
    const testArray1 = [4, 5, 2, 1, 3, 8]
    const testArray2 = [5, 5, 6, 100, 3, 5, 2, 1, 5, 7, 8888, 4]
    const testArray3 = [2, 1]
    console.log(quickSort(testArray1))
})()",1,0,0,0,0,0,0,0,0
1079,"def partition(lista, esq, dir, pivot):
    while(esq <= dir):
        while(lista[esq] < pivot):
            esq+=1
        while(lista[dir] > pivot):
            dir-=1
        if(esq <= dir):
            lista[esq], lista[dir] = lista[dir], lista[esq] 
            esq+=1
            dir-=1
    return esq
def quick_sort(lista, esq, dir):
    if(esq >= dir):
        return
    pivot = lista[ (esq + dir) / 2]
    index = partition(lista, esq, dir, pivot)
    quick_sort(lista, esq, index-1)
    quick_sort(lista, index, dir)",1,0,0,0,0,0,0,0,0
1080,"package me.gilday.revision.sorting.quicksort;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Quicksort2 {
	private static Logger logger = LoggerFactory.getLogger(Quicksort2.class);
	public static void sort(int[] values) {
		sort(values, 0, values.length - 1);
	}
	private static void sort(int values[], int lo, int hi) {
		int h, l, pivot, temp;
		logger.trace(""-- New sort ---------"");
		logger.trace(""lo={}, high={}"", lo, hi);		
		logger.trace(Arrays.toString(values));
		if (lo < hi) {
			l = lo;
			h = hi;
			pivot = values[hi];
			System.out.println(""pivot is "" + pivot);
			do {
				while ((l < h) && (values[l] <= pivot)) {
					logger.trace(""Increasing l to {}"", l + 1);
					l = l + 1;
				}
				while ((h > l) && (values[h] >= pivot)) {
					logger.trace(""Reducing h to {}"", h - 1);
					h = h - 1;
				}
				if (l < h) {
					logger.trace(""l={},h={},Swapping {} and {}"", new Object[]{ l,h, values[l], values[h]});
					temp = values[l];
					values[l] = values[h];
					values[h] = temp;					
				}
			} while (l < h);
			logger.trace(""Values after loop {}"", Arrays.toString(values));
			values[hi] = values[l];
			logger.trace(""Values after loop b {}"", Arrays.toString(values));
			values[l] = pivot;
			logger.trace(""Values after loop c {}"", Arrays.toString(values));
			sort(values, lo, l - 1);
			sort(values, l + 1, hi);
		} else {
			logger.trace(""Not entering loop!"");
		}
	}
}",1,0,0,0,0,0,0,0,0
1081,"class QuickSort:
  vec = [] 
  len = -1
  def __init__(self, arr):
        self.vec = arr
        self.len = len(self.vec)
        self.sort() 
  def get(self):
      return self.vec  
  def set(self,arr):
      self.vec = arr
  def sort(self):
      self._qs(0,self.len-1)
  def partition(self,li,ls):
      i = li
      j = ls
      pivot = self.vec[(li+ls)/2]      
      while i<=j:
         while self.vec[i] < pivot:
               i = i + 1
         while self.vec[j] > pivot:
               j = j - 1
         if i<=j:
            self.swap(i,j)
            i = i + 1
            j = j - 1
      return i  
  def _qs(self,li,ls):
      p = self.partition(li,ls)
      if p-1 > li:
         self._qs(li,p-1)
      if p < ls:
         self._qs(p,ls)  
  def swap(self,i,j):
      temp = self.vec[i]
      self.vec[i] = self.vec[j]
      self.vec[j] = temp   
arr=[9,8,7,6,5,4,3,2,1,-1,-3]
ob = QuickSort(arr)
print ob.get()       ",1,0,0,0,0,0,0,0,0
1082,"class QuickSort:
  vec = [] 
  len = -1
  def __init__(self, arr):
        self.vec = arr
        self.len = len(self.vec)
        self.sort() 
  def get(self):
      return self.vec  
  def set(self,arr):
       self.vec = arr
  def sort(self):
      self._qs(0,self.len-1)
  def _qs(self,li,ls):
      p = self.partition(li,ls)
      if p+1<ls:
         self._qs(p+1,ls)
      if p-1>li:
         self._qs(li,p-1)
  def partition(self,li,ls):
      pivot = self.vec[ls]
      s = li - 1
      for i in range(li,ls+1):
          if self.vec[i] <= pivot:
             s = s + 1
             self.swap(s,i)
      return s
  def swap(self,a,b):
      temp = self.vec[a]
      self.vec[a] = self.vec[b]
      self.vec[b] = temp  
arr=[9,8,7,6,5,4,3,2,1,-1,-3]
ob = QuickSort(arr)
print ob.get()       ",1,0,0,0,0,0,0,0,0
1083,"package javaSorting;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public class QuickSortArrayList {
	private static int partition(List<Integer> data, Integer left, Integer right) {
		Integer pivot = data.get(right);
		int i = left - 1;
		for (int j = left; j < right; j++) {
			Integer elem1 = data.get(j);
			if (elem1 <= pivot) {
				i++;
				Integer elem2 = data.get(i);
				data.set(i, elem1);
				data.set(j, elem2);
			}
		}
		i++;
		Integer elem1 = data.get(i);
		Integer elem2 = data.get(right);
		data.set(i, elem2);
		data.set(right, elem1);
		return i;
	}
	public static void sort(List<Integer> data, Integer left, Integer right) {
		if (left < right) {
			int pivot = partition(data, left, right);
			sort(data, left, pivot - 1);
			sort(data, pivot + 1, right);
		}
	}
	public static void main(String[] args) {
		List<Integer> data = new ArrayList<Integer>();
		for (int i = 0; i < 1000; i++) {
			data.add(i);
		}
		Collections.shuffle(data);
		long start = System.currentTimeMillis();
		QuickSortArrayList.sort(data, 0, data.size() - 1);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		data.stream().forEach(System.out::println);
		System.out.println(elapsed);
	}
}",1,0,0,0,0,0,0,0,0
1084,"package sorting;
import java.util.*;
public class QuickSortClass
{
   static int qcount = 0;
   public static void main(String[] args)
   {
      Random gen=new Random(); int[] a=new int[32];
      int i; for (i=0; i<a.length; i++) a[i]=gen.nextInt(5000)+1;
      System.out.println(""Initial array:"");
      for (i=0; i<a.length; i++) System.out.println(a[i] + "" "");
      System.out.println();
      Quicksort(a, 0, a.length-1);
      System.out.println(""Sorted array:"");
      for (i=0; i<a.length; i++) System.out.println(a[i] + "" "");
      System.out.println(""Done!"");
      System.out.println("" qcount: ""+ qcount);
   }
   public static void Quicksort(int[] a, int left, int right) {
	   if(left >= right) {  
		   return;
	   }
	   int pivot = a[(left+right)/2];  
	   int index = partition(a, left, right, pivot);  
	   Quicksort(a, left, index - 1);  
	   Quicksort(a, index, right);  
   }
   public static int partition(int[] a, int left, int right, int pivot) {
	   while(left <= right) {  
		   while(a[left] < pivot) {  
			   left++;  
		   }
		   while(a[right] > pivot) {  
			   right--;  
		   }
		   if (left <= right) {  
			   int temp = a[left];  
			   a[left] = a[right];  
			   a[right] = temp;  
			   left++;  
			   right--;  
		   }
		   qcount++;  
	   }
	   return left;
   }   
}",1,0,0,0,0,0,0,0,0
1085,"import java.lang.Comparable;
import java.util.List;
public class QuickSortClassic<T extends Comparable<T>> implements SortingAlg<T> {
    @Override
    public void sort(List<T> elements) {
        if (elements == null)
            return;
        sort(elements, 0, elements.size() - 1); 
    }
    private void sort(List<T> elements, int left, int right) {
        if (left < right) {
            int p = partition(elements, left, right);
            sort(elements, left, p-1);
            sort(elements, p+1, right);
        }
    }
    private int partition(List<T> elements, int left, int right) {
        T pivot = elements.get(right);
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (isLessThan(elements.get(j), pivot)) {
                T greater = elements.get(++i);
                elements.set(i, elements.get(j));
                elements.set(j, greater);
            }
        }
        T temp = elements.get(i + 1);
        elements.set(i + 1, pivot);
        elements.set(right, temp);
        return i + 1;
    }
    private boolean isLessThan(T first, T second) {
        return (first.compareTo(second) < 0);
    }
    public static void main(String[] args) {
        SortingAlg<Integer> alg = new ClassicQuickSort<Integer>();
        List<Integer> elems = java.util.Arrays.asList(9,5,2,7,3,8,2,1,4,7,5,3,9);
        alg.sort(elems);
        for (int i = 0; i < elems.size() - 1; i++) {
            if (elems.get(i).compareTo(elems.get(i+1)) > 0) {
                throw new java.lang.RuntimeException(""Elems should be sorted."");
            }
        }
        System.out.println(""All tests passed."");
    }
}",1,0,0,0,0,0,0,0,0
1086,"const arrayRandom = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
const arrayOrdered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const arrayReversed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
let countOuter = 0;
let countInner = 0;
let countSwap = 0;
function resetCounters() {
  countOuter = 0;
  countInner = 0;
  countSwap = 0;
}
function quicksortBasic(array) {
  countOuter++;
  if(array.length < 2) {
    return array;
  }
  const pivot = array[0];
  const lesser = [];
  const greater = [];
  for(let i = 1; i < array.length; i++) {
    countInner++;
    if(array[i] < pivot) {
      lesser.push(array[i]);
    } else {
      greater.push(array[i]);
    }
  }
  return quicksortBasic(lesser).concat(pivot, quicksortBasic(greater));
}
quicksortBasic(arrayRandom.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
quicksortBasic(arrayOrdered.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
quicksortBasic(arrayReversed.slice());  
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
function quicksort(array, left, right) {
  countOuter++;
  left = left || 0;
  right = right || array.length - 1;
  const pivot = partitionHoare(array, left, right);  
  if(left < pivot - 1) {
    quicksort(array, left, pivot - 1);
  }
  if(right > pivot) {
    quicksort(array, pivot, right);
  }
  return array;
}
function partitionLomuto(array, left, right) {
  const pivot = right;
  let i = left;
  let last = left;
  for(var j = left; j < right; j++) {
    countInner++;
    if(array[j] <= array[pivot]) {
      countSwap++;
      [array[i], array[j]] = [array[j], array[i]];
      i = i + 1;
    }
    last = j + 1;
  }
  countSwap++;
  [array[i], array[last]] = [array[last], array[i]];
  return i;
}
function partitionHoare(array, left, right) {
  const pivot = Math.floor((left + right) / 2 );
  while(left <= right) {
    countInner++;
    while(array[left] < array[pivot]) {
      left++;
    }
    while(array[right] > array[pivot]) {
      right--;
    }
    if(left <= right) {
      countSwap++;
      [array[left], array[right]] = [array[right], array[left]];
      left++;
      right--;
    }
  }
  return left;
}
quicksort(arrayRandom.slice());
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
quicksort(arrayOrdered.slice());
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();
quicksort(arrayReversed.slice());
console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
resetCounters();",1,0,0,0,0,0,0,0,0
1087,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class QuickSortDoubleEnded extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new QuickSortDoubleEnded();
	public void sort(SortArray array) {
		sort(array, 0, array.length());
	}
	private static void sort(SortArray array, int start, int end) {
		if (start == end)
			return;
		array.setRange(start, end, SortArray.ElementState.ACTIVE);
		int left = start;
		int right = end - 1;
		int pivot = left;   
		while (left != right) {
			while (array.compare(right, pivot) >= 0 && left != right) {
				array.setElement(right, SortArray.ElementState.INACTIVE);
				right--;
			}
			if (left != right) {
				array.swap(left, right);
				pivot = right;
				array.setElement(left, SortArray.ElementState.INACTIVE);
				left++;
			}
			while (array.compare(left, pivot) <= 0 && left != right) {
				array.setElement(left, SortArray.ElementState.INACTIVE);
				left++;
			}
			if (left != right) {
				array.swap(right, left);
				pivot = left;
				array.setElement(right, SortArray.ElementState.INACTIVE);
				right--;
			}
		}
		array.setElement(pivot, SortArray.ElementState.DONE);
		sort(array, start, pivot);
		sort(array, pivot + 1, end);
	}
	private QuickSortDoubleEnded() {
		super(""Quick sort (double-ended)"");
	}
}",1,0,0,0,0,0,0,0,0
1088,"package com.ianramzy;
public class QuickSorter implements Sorter {
    private int list[];
    private int num;
    public void sort(int theNum, int theList[]) {
        num = theNum;
        list = theList;
        quickSort(0, num - 1);
    }
    public void quickSort(int left, int right) {
        int i, pivot, lastSmall;
        swap(left, (int) (left + right) / 2);
        lastSmall = left;
        for (i = left + 1; i <= right; i++) {
            if (list[i] < list[left]) {
                lastSmall++;
                swap(lastSmall, i);
            }
        }
        swap(left, lastSmall);
        pivot = lastSmall;
        if (left < pivot - 1) {
            quickSort(left, pivot - 1);
        }
        if (pivot + 1 < right) {
            quickSort(pivot + 1, right);
        }
    }
    private int temp;
    public void swap(int a, int b) {
        temp = list[a];
        list[a] = list[b];
        list[b] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1089,"package sorters;
import java.util.Comparator;
import java.util.List;
public class QuickSorter<E> extends AbstractSorter<E> {
	private Comparator<E> comp;
	public void sort(List<E> list, Comparator<E> comp) {
		this.comp = comp;
		quickSort(list, 0, list.size() - 1);
	}
	private void quickSort(List<E> list, int low, int high) {
		if (low < high) {
			int p = partition(list, low, high);
			quickSort(list, low, p);
			quickSort(list, p + 1, high);
		}
	}
	private int partition(List<E> list, int low, int high) {
		E pivot = list.get((high + low) / 2);
		int i = low - 1;
		int j = high + 1;
		while (true) {
			do {
				i++;
			} while (comp.compare(list.get(i), pivot) < 0);
			do {
				j--;
			} while (comp.compare(list.get(j), pivot) > 0);
			if (i >= j)
				return j;
			swap(list, i, j);
		}
	}
	public String getName() {
		return ""Quick Sort"";
	}
}",1,0,0,0,0,0,0,0,0
1090,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.method.*;
public class QuicksortImproved implements SortAlgorithm {
  private final int threshold;
  private final PartitioningAlgorithm quicksort;
  private final InsertionSort insertionSort;
  public QuicksortImproved(int threshold, PartitioningAlgorithm quicksort) {
    this.threshold = threshold;
    this.quicksort = quicksort;
    this.insertionSort = new InsertionSort();
  }
  @Override
  public String getName() {
    return this.getClass().getSimpleName() + ""(threshold: "" + threshold +
          "", partitioning: "" + quicksort.getName() + "")"";
  }
  @Override
  public void sort(int[] elements) {
    quicksort(elements, 0, elements.length - 1);
  }
  private void quicksort(int[] elements, int left, int right) {
    if (left >= right) return;
    if (right - left < threshold) {
      insertionSort.sort(elements, left, right + 1);
      return;
    }
    int pivotPos = quicksort.partition(elements, left, right);
    quicksort(elements, left, pivotPos - 1);
    quicksort(elements, pivotPos + 1, right);
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    quicksort(elements, 0, elements.length - 1, counters);
  }
  private void quicksort(int[] elements, int left, int right,
                         Counters counters) {
    if (left == right) return;
    if (right - left < threshold) {
      insertionSort.sort(elements, left, right + 1, counters);
      return;
    }
    int pivotPos = quicksort.partition(elements, left, right, counters);
    quicksort(elements, left, pivotPos - 1, counters);
    quicksort(elements, pivotPos + 1, right, counters);
  }
  @Override
  public boolean isSuitableForInputSize(int size) {
    return quicksort.isSuitableForInputSize(size);
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return quicksort.isSuitableForSortedInput(size);
  }
}",1,0,0,0,0,0,0,0,0
1091,"import java.util.*; 
class QuickSortIterative 
{ 
	static int partition(int arr[], int low, int high) 
	{ 
		int pivot = arr[high]; 
		int i = (low-1);  
		for (int j=low; j<=high-1; j++) 
		{ 
			if (arr[j] <= pivot) 
			{ 
				i++; 
				int temp = arr[i]; 
				arr[i] = arr[j]; 
				arr[j] = temp; 
			} 
		} 
		int temp = arr[i+1]; 
		arr[i+1] = arr[high]; 
		arr[high] = temp; 
		return i+1; 
	} 
	static void qSort(int arr[], int low, int high) 
	{ 
		if (low < high) 
		{ 
			int pi = partition(arr, low, high); 
			qSort(arr, low, pi-1); 
			qSort(arr, pi+1, high); 
		} 
	} 
	public static void main(String args[]) 
	{ 
		int n = 5; 
		int arr[] = {4, 2, 6, 9, 2}; 
		qSort(arr, 0, n-1); 
		for(int i =0;i<n;i++){ 
			System.out.print(arr[i]+"" ""); 
		} 
	} 
} ",1,0,0,0,0,0,0,0,0
1092,"function swap(items, leftItem, rightItem){
    const auxiliar = items[leftItem];
    items[leftItem] = items[rightItem];
    items[rightItem] = auxiliar;
}
function partition(items, left, right) {
    let pivot = items[Math.floor((right + left) / 2)];
    let leftCounter = left;
    let rightCounter = right;
    while (leftCounter <= rightCounter) {
        while (items[leftCounter] < pivot) {
            leftCounter++;
        }
        while (items[rightCounter] > pivot) {
            rightCounter--;
        }
        if (leftCounter <= rightCounter) {
            swap(items, leftCounter, rightCounter);
            leftCounter++;
            rightCounter--;
        }
    }
    return leftCounter;
}
function quickSort(items, left, right) {
    let index;
    if (items.length > 1) {
        index = partition(items, left, right);
        if (left < index - 1) {
            quickSort(items, left, index - 1);
        }
        if (index < right) {
            quickSort(items, index, right);
        }
    }
    return items;
}
let items = [2,4,9,5,8,1];
let sortedArray = quickSort(items, 0, items.length - 1);
console.log(sortedArray);",1,0,0,0,0,0,0,0,0
1093,"import java.lang.Comparable;
import java.util.List;
public class QuickSortMedian<T extends Comparable<T>> implements SortingAlg<T> {
    @Override
    public void sort(List<T> elements) {
        if (elements == null)
            return;
        sort(elements, 0, elements.size() - 1); 
    }
    private void sort(List<T> elements, int left, int right) {
        if (left < right) {
            int p = partition(elements, left, right);
            sort(elements, left, p-1);
            sort(elements, p+1, right);
        }
    }
    private int partition(List<T> elements, int left, int right) {
        int pivotIndex = getMedianIndex(elements, left, right);
        T pivot = elements.get(pivotIndex);
        T temp = elements.get(right);
        elements.set(right, pivot);
        elements.set(pivotIndex, temp);
        int i = left - 1;
        for (int j = left; j < right; j++) {
            if (isLessThan(elements.get(j), pivot)) {
                T greater = elements.get(++i);
                elements.set(i, elements.get(j));
                elements.set(j, greater);
            }
        }
        temp = elements.get(i + 1);
        elements.set(i + 1, pivot);
        elements.set(right, temp);
        return i + 1;
    }
    private boolean isLessThan(T first, T second) {
        return (first.compareTo(second) < 0);
    }
    private int getMedianIndex(List<T> elements, int left, int right) {
        T first = elements.get(left);
        T middle = elements.get((left + right) >> 1);
        T last = elements.get(right);
        if ((isLessThan(middle, first) && isLessThan(first, last))
                || (isLessThan(first, middle) && isLessThan(last, first)))
            return left;
        if ((isLessThan(last, first) && isLessThan(middle, last))
                || (isLessThan(first, last) && isLessThan(last, middle)))
            return right;
        return (left + right) >> 1;
    }
    public static void main(String[] args) {
        SortingAlg<Integer> alg = new MedianQuickSort<Integer>();
        List<Integer> elems = java.util.Arrays.asList(9,5,2,7,3,8,2,1,4,7,5,3,9);
        alg.sort(elems);
        for (int i = 0; i < elems.size() - 1; i++) {
            if (elems.get(i).compareTo(elems.get(i+1)) > 0) {
                throw new java.lang.RuntimeException(""Elems should be sorted."");
            }
        }
        System.out.println(""All tests passed."");
    }
}",1,0,0,0,0,0,0,0,0
1094,"package sorting;
public class QuickSortMedianOfThree<T extends Comparable<T>> implements Sort<T> {
    @Override
    public void sort(T[] items) {
        sort(items, 0, items.length - 1);
    }
    public void sort(T[] items, int left, int right) {
        int up = left;
        int down = right - 1;
        int tIndex = medianOfThree(items, left, right);
        T t = items[tIndex];
        SortUtils.swap(items, tIndex, right);
        do {
            while (items[up].compareTo(t) < 0) {
                up++;
            }
            while (items[down].compareTo(t) >= 0 && down > up) {
                down--;
            }
            if (up < down) {
                SortUtils.swap(items, up, down);
            }
        } while (up < down);
        SortUtils.swap(items, up, right);
        if (left < up - 1) {
            sort(items, left, up - 1);
        }
        if (right > up + 1) {
            sort(items, up + 1, right);
        }
    }
    private <E extends Comparable<E>> int medianOfThree(E items[], int left, int right) {
        int middle = left + ((right - left) / 2);
        E l = items[left];
        E m = items[middle];
        E r = items[right];
        if (l.compareTo(r) > 0 && l.compareTo(m) < 0 || l.compareTo(r) < 0 && l.compareTo(m) > 0) {
            return left;
        } else if (m.compareTo(r) > 0 && m.compareTo(l) < 0 || m.compareTo(r) < 0 && m.compareTo(l) > 0) {
            return middle;
        } else {
            return right;
        }
    }
}",1,0,0,0,0,0,0,0,0
1095,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.method.*;
import eu.happycoders.sort.utils.ArrayUtils;
public class QuicksortSimple implements SortAlgorithm, PartitioningAlgorithm {
  public void sort(int[] elements) {
    quicksort(elements, 0, elements.length - 1);
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return size <= 2 << 12;
  }
  private void quicksort(int[] elements, int left, int right) {
    if (left >= right) return;
    int pivotPos = partition(elements, left, right);
    quicksort(elements, left, pivotPos - 1);
    quicksort(elements, pivotPos + 1, right);
  }
  @Override
  public int partition(int[] elements, int left, int right) {
    int pivot = elements[right];
    int i = left;
    int j = right - 1;
    while (i < j) {
      while (elements[i] < pivot) {
        i++;
      }
      while (j > left && elements[j] >= pivot) {
        j--;
      }
      if (i < j) {
        ArrayUtils.swap(elements, i, j);
        i++;
        j--;
      }
    }
    if (i == j && elements[i] < pivot) {
      i++;
    }
    if (elements[i] != pivot) {
      ArrayUtils.swap(elements, i, right);
    }
    return i;
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    quicksort(elements, 0, elements.length - 1, counters);
  }
  private void quicksort(int[] elements, int left, int right,
                         Counters counters) {
    if (left >= right) return;
    int pivotPos = partition(elements, left, right, counters);
    quicksort(elements, left, pivotPos - 1, counters);
    quicksort(elements, pivotPos + 1, right, counters);
  }
  public int partition(int[] elements, int left, int right, Counters counters) {
    int pivot = elements[right];
    int i = left;
    int j = right - 1;
    while (i < j) {
      counters.incIterations();
      while (true) {
        counters.incComparisons();
        counters.incReads();
        if (!(elements[i] < pivot)) break;
        i++;
      }
      while (true) {
        counters.incComparisons();
        counters.incReads();
        if (!(j > left && elements[j] >= pivot)) break;
        j--;
      }
      if (i < j) {
        ArrayUtils.swap(elements, i, j);
        counters.addReadsAndWrites(2);
        i++;
        j--;
      }
    }
    if (i == j) {
      counters.incReads();
      counters.incComparisons();
      if (elements[i] < pivot) {
        i++;
      }
    }
    counters.incReads();
    counters.incComparisons();
    if (elements[i] != pivot) {
      ArrayUtils.swap(elements, i, right);
      counters.addReadsAndWrites(2);
    }
    return i;
  }
}",1,0,0,0,0,0,0,0,0
1096,"const quickSort = (arr) => {
  if (arr.length <= 1) return arr;
  const pivot = arr.splice(Math.floor(Math.random() * (arr.length - 1)), 1);
  const left = [];
  const right = [];
  arr.forEach(el => el < pivot ? left.push(el) : right.push(el));
  const sortedLeft = quickSort(left);
  const sortedRight = quickSort(right);
  return [...sortedLeft, ...pivot, ...sortedRight];
}",1,0,0,0,0,0,0,0,0
1097,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class QuickSortSliding extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new QuickSortSliding();
	public void sort(SortArray array) {
		sort(array, 0, array.length());
	}
	private static void sort(SortArray array, int start, int end) {
		if (start == end)
			return;
		array.setRange(start, end, SortArray.ElementState.INACTIVE);
		int partition = start;
		int pivot = end - 1;   
		for (int i = start; i < end - 1; i++) {
			if (array.compare(i, pivot) < 0) {
				array.swap(i, partition);
				array.setElement(partition, SortArray.ElementState.INACTIVE);
				partition++;
			}
		}
		array.swap(pivot, partition);
		pivot = partition;
		array.setElement(pivot, SortArray.ElementState.DONE);
		array.setRange(pivot + 1, end, SortArray.ElementState.INACTIVE);
		sort(array, start, pivot);
		sort(array, pivot + 1, end);
	}
	private QuickSortSliding() {
		super(""Quick sort (sliding)"");
	}
}",1,0,0,0,0,0,0,0,0
1098,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.method.Counters;
public class QuicksortVariant1 extends QuicksortSimple {
  private final PivotStrategy pivotStrategy;
  public QuicksortVariant1(PivotStrategy pivotStrategy) {
    this.pivotStrategy = pivotStrategy;
  }
  @Override
  public String getName() {
    return this.getClass().getSimpleName() + ""(pivot: "" + pivotStrategy + "")"";
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return (pivotStrategy != PivotStrategy.LEFT
          && pivotStrategy != PivotStrategy.RIGHT) || size <= 2 << 12;
  }
  @Override
  public int partition(int[] elements, int left, int right) {
    PivotHelper.findPivotAndMoveRight(elements, left, right, pivotStrategy);
    return super.partition(elements, left, right);
  }
  public int partition(int[] elements, int left, int right, Counters counters) {
    PivotHelper.findPivotAndMoveRight(elements, left, right, pivotStrategy);
    return super.partition(elements, left, right, counters);
  }
}",1,0,0,0,0,0,0,0,0
1099,"package eu.happycoders.sort.method.quicksort;
import eu.happycoders.sort.method.*;
import eu.happycoders.sort.utils.ArrayUtils;
public class QuicksortVariant2 implements SortAlgorithm, PartitioningAlgorithm {
  private final PivotStrategy pivotStrategy;
  public QuicksortVariant2(PivotStrategy pivotStrategy) {
    this.pivotStrategy = pivotStrategy;
  }
  @Override
  public String getName() {
    return this.getClass().getSimpleName() + ""(pivot: "" + pivotStrategy + "")"";
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return (pivotStrategy != PivotStrategy.LEFT
          && pivotStrategy != PivotStrategy.RIGHT) || size <= 2 << 12;
  }
  @Override
  public void sort(int[] elements) {
    quicksort(elements, 0, elements.length - 1);
  }
  private void quicksort(int[] elements, int left, int right) {
    if (left >= right) return;
    int pivotPos = partition(elements, left, right);
    quicksort(elements, left, pivotPos - 1);
    quicksort(elements, pivotPos + 1, right);
  }
  @Override
  public int partition(int[] elements, int left, int right) {
    int pivotPos =
          PivotHelper.findPivotPos(elements, left, right, pivotStrategy);
    int pivot = elements[pivotPos];
    int i = left;
    int j = pivotPos == right ? right - 1 : right;
    while (i < j) {
      while (elements[i] < pivot) {
        i++;
      }
      while (j > left && elements[j] >= pivot) {
        j--;
      }
      if (i < j) {
        ArrayUtils.swap(elements, i, j);
        if (i == pivotPos) pivotPos = j;
        else if (j == pivotPos) pivotPos = i;
        i++;
        j--;
      }
    }
    if (i == j && elements[i] < pivot) {
      i++;
    }
    if (elements[i] != pivot) {
      ArrayUtils.swap(elements, i, pivotPos);
    }
    return i;
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    quicksort(elements, 0, elements.length - 1, counters);
  }
  private void quicksort(int[] elements, int left, int right,
                         Counters counters) {
    if (left >= right) return;
    int pivotPos = partition(elements, left, right, counters);
    quicksort(elements, left, pivotPos - 1, counters);
    quicksort(elements, pivotPos + 1, right, counters);
  }
  public int partition(int[] elements, int left, int right, Counters counters) {
    int pivotPos =
          PivotHelper.findPivotPos(elements, left, right, pivotStrategy);
    int pivot = elements[pivotPos];
    int i = left;
    int j = pivotPos == right ? right - 1 : right;
    while (i < j) {
      counters.incIterations();
      while (true) {
        counters.incComparisons();
        counters.incReads();
        if (!(elements[i] < pivot)) break;
        i++;
      }
      while (true) {
        counters.incComparisons();
        counters.incReads();
        if (!(j > left && elements[j] >= pivot)) break;
        j--;
      }
      if (i < j) {
        ArrayUtils.swap(elements, i, j);
        counters.addReadsAndWrites(2);
        if (i == pivotPos) pivotPos = j;
        else if (j == pivotPos) pivotPos = i;
        i++;
        j--;
      }
    }
    if (i == j) {
      counters.incReads();
      counters.incComparisons();
      if (elements[i] < pivot) {
        i++;
      }
    }
    counters.incReads();
    counters.incComparisons();
    if (elements[i] != pivot) {
      ArrayUtils.swap(elements, i, pivotPos);
      counters.addReadsAndWrites(2);
    }
    return i;
  }
}",1,0,0,0,0,0,0,0,0
1100,"quickv2Sort = function(array) {
  var sorted = array.slice(0);
  return (function sort(left, right) {
    if (left < right) {
      var pivot = sorted[(left + right) >> 1];
      var lp = left,
          rp = right;
      while (lp < rp) {
        while (sorted[lp] < pivot) {
          lp++;
        }
        while (sorted[rp] > pivot) {
          rp--;
        }
        if (lp <= rp) {
          var temp = sorted[lp];
          sorted[lp] = sorted[rp];
          sorted[rp] = temp;
          lp++;
          rp--;
        }
      }
      sort(left, rp);
      sort(lp, right);
    }
    return sorted;
  })(0, sorted.length - 1);
};",1,0,0,0,0,0,0,0,0
1101,"from __future__ import print_function
from random import randint
from tempfile import TemporaryFile
import numpy as np
def _inPlaceQuickSort(A,start,end):  
    count = 0
    if start<end:
        pivot=randint(start,end)
        temp=A[end]
        A[end]=A[pivot]
        A[pivot]=temp
        p,count= _inPlacePartition(A,start,end)
        count += _inPlaceQuickSort(A,start,p-1)
        count += _inPlaceQuickSort(A,p+1,end)
    return count
def _inPlacePartition(A,start,end):
    count = 0
    pivot= randint(start,end)
    temp=A[end]
    A[end]=A[pivot]
    A[pivot]=temp
    newPivotIndex=start-1
    for index in range(start,end):
        count += 1
        if A[index]<A[end]:
            newPivotIndex=newPivotIndex+1
            temp=A[newPivotIndex]
            A[newPivotIndex]=A[index]
            A[index]=temp
    temp=A[newPivotIndex+1]
    A[newPivotIndex+1]=A[end]
    A[end]=temp
    return newPivotIndex+1,count
outfile = TemporaryFile()    
p = 100 
mu, sigma = 0, 1 
X = np.random.normal(mu, sigma, p)
np.save(outfile, X)
print('The array is')
print(X)
outfile.seek(0)  
M = np.load(outfile)
r = (len(M)-1)
z = _inPlaceQuickSort(M,0,r) 
print(""No of Comparisons for 100 elements selected from a standard normal distribution is :"")
print(z)",1,0,0,0,0,0,0,0,0
1102,"from __future__ import print_function
from random import randint
from tempfile import TemporaryFile
import numpy as np
def _inPlaceQuickSort(A,start,end):  
    count = 0
    if start<end:
        pivot=randint(start,end)
        temp=A[end]
        A[end]=A[pivot]
        A[pivot]=temp
        p,count= _inPlacePartition(A,start,end)
        count += _inPlaceQuickSort(A,start,p-1)
        count += _inPlaceQuickSort(A,p+1,end)
    return count
def _inPlacePartition(A,start,end):
    count = 0
    pivot= randint(start,end)
    temp=A[end]
    A[end]=A[pivot]
    A[pivot]=temp
    newPivotIndex=start-1
    for index in range(start,end):
        count += 1
        if A[index]<A[end]:
            newPivotIndex=newPivotIndex+1
            temp=A[newPivotIndex]
            A[newPivotIndex]=A[index]
            A[index]=temp
    temp=A[newPivotIndex+1]
    A[newPivotIndex+1]=A[end]
    A[end]=temp
    return newPivotIndex+1,count
outfile = TemporaryFile()    
p = 100 
mu, sigma = 0, 1 
X = np.random.normal(mu, sigma, p)
np.save(outfile, X)
print('The array is')
print(X)
outfile.seek(0)  
M = np.load(outfile)
r = (len(M)-1)
z = _inPlaceQuickSort(M,0,r) 
print(""No of Comparisons for 100 elements selected from a standard normal distribution is :"")
print(z)",1,0,0,0,0,0,0,0,0
1103,"import random
def partition(A, left_index, right_index):
    pivot = A[left_index]
    i = left_index + 1
    for j in range(left_index + 1, right_index):
        if A[j] < pivot:
            A[j], A[i] = A[i], A[j]
            i += 1
    A[left_index], A[i - 1] = A[i - 1], A[left_index]
    return i - 1
def quick_sort_random(A, left, right):
    if left < right:
        pivot = random.randint(left, right - 1)
        A[pivot], A[left] = A[left], A[pivot] 
        pivot_index = partition(A, left, right)
        quick_sort_random(A, left, pivot_index) 
        quick_sort_random(A, pivot_index + 1, right) 
def main():
    user_input = input('Enter numbers separated by a comma:\n').strip()
    arr = [int(item) for item in user_input.split(',')]
    quick_sort_random(arr, 0, len(arr))
    print(arr)
if __name__ == ""__main__"":
    main()",1,0,0,0,0,0,0,0,0
1104,"package quicksort;
import java.util.*;
public class Sort <T extends Comparable<T>> implements Comparator<T> {
	public ArrayList<T> list;
	public int compare(T a, T b) {
		return a.compareTo(b);
	}
	public Sort(){
		list = new ArrayList<T>();
	}
	@Override
	public String toString(){
		String listOut = """";
		listOut += ""-->"";
		for (int i = 0; i < list.size(); i++) {
			listOut += list.get(i) + "" "";
		}
		return listOut;
	}
	public void MainSort() {
		int length = list.size();
		if (length == 0) {
			return;
		}
		QuickSort(0, length - 1);
	}
	private void QuickSort(int left, int right) {
		int i = left;
		int j = right;
		T pivot = list.get((right + left)/2);
		while (i <= j) {
			while (compare(list.get(i), pivot) > 0) {
				i++;
			}
			while (compare(list.get(j), pivot) < 0) {
				j--;
			}
			if (i <= j) {
				swap(i, j);
				i++;
				j--;
			}
		}
		if (left < j) {
			QuickSort(left, j);
		}
		if (i < right) {
			QuickSort(i, right);
		}
	}
	private void swap(int a, int b){
		T holder = list.get(a);
		list.set(a, list.get(b));
		list.set(b, holder);
	}
}",1,0,0,0,0,0,0,0,0
1105,"import java.util.ArrayList;
import java.util.Random;
public class Sort {
	public static <T extends Comparable<T>> void insertionsort(T[] arr) {
		for (int i = 1; i<arr.length; i++){
			T temp = arr[i];
			int j;
			for (j = i-1; j>=0 && temp.compareTo(arr[j]) < 0; j-- ){
				arr[j+1] = arr[j];
			}
			arr[j+1] = temp;
		}
	}
	public static <T extends Comparable<T>> void quicksort(T[] arr, Random r) {
		quicksorthelper(arr, 0, arr.length-1, r);
	}
    private static <T> void quicksorthelper(T[] arr, int left, int right, Random r){
         if (left < right)
         {
              int pivot = randomizedPartition(arr, left, right, r);
              quicksorthelper(arr, left, pivot, r);
              quicksorthelper(arr, pivot + 1, right, r);
         }
    }
    private static <T> int randomizedPartition(T[] arr, int left, int right, Random r)
    {
         int swapIndex = left + r.nextInt(right - left) + 1;
         swap(arr, left, swapIndex);
         return partition(arr, left, right);
    }
    private static <T> int partition(T[] arr, int left, int right)
    {
         T pivot = arr[left];
         int i = left - 1;
         int j = right + 1;
         while (true)
         {
              do
                   j--;
              while (((Comparable)arr[j]).compareTo(pivot)>0);
              do
                   i++;
              while (((Comparable)arr[i]).compareTo(pivot)<0);
              if (i < j)
                   swap(arr, i, j);
              else
                   return j;
         }
    }
    private static <T> void swap(T[] arr, int i, int j)
    {
         T temp = arr[i];
         arr[i] = arr[j];
         arr[j] = temp;
    }
	public static <T extends Comparable<T>> T[] mergesort(T[] arr) {
		if (arr.length > 1){
			int half = arr.length/2;
			T[] left = (T[])new Comparable[half];
			T[] right =(T[])new Comparable[arr.length-half];;
			System.arraycopy(arr, 0, left, 0, half);
			System.arraycopy(arr, half, right, 0, arr.length-half);
			T[] newLeft = mergesort(left);
			T[] newRight = mergesort(right);
			T[] sorted = merge(arr, newLeft, newRight);
			return sorted;
		}
		else return arr;
	}
	private static <T> T[] merge(T[] arr, T[] left, T[] right){
		int total = left.length + right.length;
		int i=0, leftIndex=0, rightIndex=0;
		while(i<total){
			if (leftIndex<left.length && rightIndex< right.length){
				if(((Comparable)left[leftIndex]).compareTo(right[rightIndex]) <= 0){
					arr[i] = left[leftIndex];
					i++;
					leftIndex++;
				}
				else {
					arr[i] = right[rightIndex];
					i++;
					rightIndex++;
				}
			}
			else {
				if (leftIndex >= left.length) {
                    while (rightIndex < right.length) {
                        arr[i] = right[rightIndex];
                        i++;
                        rightIndex++;
                    }
                }
                if (rightIndex >= right.length) {
                    while (leftIndex < left.length) {
                        arr[i] = left[leftIndex];
                        leftIndex++;
                        i++;
                    }
                }
			}
		}
		return arr;
	}
	public static int[] radixsort(int[] arr) {
		int offset = findOffset(arr);
		for (int i = 0; i < arr.length; i++){
			arr[i] = arr[i] - offset;
		}
		int maxDigits = findMaxDigits(arr);
        int tenponent = 1;
        for(int i =0; i < maxDigits; i++){
            ArrayList<Integer>[] buckets = new ArrayList[10];
            for(int j=0; j < 10; j++){
                buckets[j] = new ArrayList();
            }
            for(int k =0; k < arr.length; k++){
                int number = (arr[k]/tenponent)%10;
                buckets[number].add(arr[k]);
            }
            tenponent *= 10;
            int index =0;         
            for(int l=0; l < 10; l++){
                for(int num: buckets[l]){
                    arr[index] = num;
                    index++;
                }
            }
        }
		for (int i = 0; i < arr.length; i++){
			arr[i] = arr[i] + offset;
		}
		return arr;
	}
	private static int findOffset(int arr[]){
		int j = 0;
		for (int i = 0; i < arr.length; i++){
			if (arr[i]<j){
				j = arr[i];
			}
		}
		return j;
	}
	private static int findMaxDigits(int arr[]){
		String largest ="""";
		int length = largest.length();
		for (int i = 0; i < arr.length; i++){
			if (length < Integer.toString(arr[i]).length()){
				largest = Integer.toString(arr[i]);
				length = largest.length();
			}
		}
		return length;
	}
}",1,1,0,1,0,0,0,0,0
1106,"class Sorting:
      arr = []
      k = 0
      def __init__(self,arr):
          self.arr = arr
          self.n = len(arr)  
      def bubblesort(self): 
              n = self.n
              j = n - 1
              while j >= 0: 
                 for i in range(0,j):
                     if(self.arr[i] >= self.arr[i+1]):
                        self.swap(i,i+1)
                 j=j-1
              return self.arr
      def swap(self,i,j):
          aux = self.arr[i]
          self.arr[i] = self.arr[j]
          self.arr[j] = aux
      def selectbymin(self):
          n = self.n
          for i in range(0,n):
              k = i
              for j in range(i+1,n):
                    if(self.arr[j] < self.arr[k]):
                       k = j
              if(k != i):
                 self.swap(i,k)
          return self.arr
      def quicksort(self):
          n = len(self.arr)
          self.quick(0,n-1)
          return self.arr
      def quick(self,li,ls):
          if li<ls:
             self.pos(li,ls)
             self.quick(li,self.k-1)
             self.quick(self.k+1,ls)
      def pos(self,li,ls):
              i = li
              j = ls
              i1 = 0
              j1 = -1
              while i < j: 
                if self.arr[i] >= self.arr[j]:
                   aux = self.arr[i]
                   self.arr[i] = self.arr[j]
                   self.arr[j] = aux
                   aux = i1
                   i1 = -j1
                   j1 = -aux
                i = i + i1
                j = j + j1
                self.k = li
      def mergesort(self): 
          n = self.n
          self.divimp(0,n-1)
          return self.arr  
      def divimp(self,li,ls):
          if ls-li <= 1:
             self.sortone(li,ls)
          else:
             middle = (li+ls)/2
             self.divimp(li,middle)
             self.divimp(middle+1,ls)
             self.merge(li,middle,ls)
      def sortone(self,li,ls):
          if self.arr[li] > self.arr[ls]:
             aux = self.arr[li]
             self.arr[li] = self.arr[ls]
             self.arr[ls] = aux
      def merge(self,li,m,ls): 
          i = li
          j = m+1
          c = []
          while i<=m and j<=ls:
                if self.arr[i] < self.arr[j]:
                   c.append(self.arr[i])
                   i += 1
                else:
                   c.append(self.arr[j])
                   j += 1 
          if i<=m:
             for x in range(i,m+1):
                 c.append(self.arr[x])
          else:
             for y in range(j,ls+1):
                 c.append(self.arr[y])
          k = 0
          for i in range(li,ls+1):
              self.arr[i] = c[k]
              k +=1
arr = [9,8,7,6,5,4,3,2,1,0,-1,123]
ob = Sorting(arr)
print ob.mergesort()",1,1,0,0,1,0,0,0,0
1107,"import time
def timing(f):
    def wrap(*args, **kwargs):
        time1 = time.time()
        ret = f(*args, **kwargs)
        time2 = time.time()
        print('{:s} function took {:.3f} ms'.format(f.__name__, (time2-time1)*1000.0))
        return ret
    return wrap
def swap(arr, a, b):
    arr_cp = arr
    temp = arr_cp[a]
    arr_cp[a] = arr_cp[b]
    arr_cp[b] = temp
    return arr_cp
@timing
def bubble_sort(arr):
    arr_cp = arr
    for i in range(len(arr_cp), 0, -1):
        for j in range(1, i):
            if (arr_cp[j-1] > arr[j]):
                arr_cp = swap(arr_cp, j-1, j)
    return arr_cp
@timing
def selection_sort(arr):
    arr_cp = arr
    length = len(arr_cp)
    for i in range(0, length):
        last_index = (length - 1) - i
        max_index = 0
        for j in range(0, last_index):
            if (arr_cp[j] > arr[max_index]):
                max_index = j
        arr_cp = swap(arr_cp, max_index, last_index)
    return arr_cp
@timing
def insertion_sort(arr):
    arr_cp = arr
    for i in range(0, len(arr_cp) - 1):
        for j in range(i+1, 0, -1):
            if (arr_cp[j-1] > arr_cp[j]):
                arr_cp = swap(arr_cp, j-1, j)
            else:
                break
    return arr_cp
@timing
def python_sort(arr):
    return sorted(arr)
l = [555,510,20,5,78,3,4557,23,467,12789,663,41,21, 20329, 3141219, ]
print(bubble_sort(l))
print(selection_sort(l))
print(insertion_sort(l))
print(python_sort(l));",0,0,1,1,1,0,0,0,0
1108,"public class ThreeWayQuickSort<T extends Comparable<T>> {
    public void sort(T[] array, int left, int right) {
        if (left < right) this.partition(array, left, right);
    }
    private void partition(T[] array, int left, int right) {
        if (left < right) {
            int start = left;
            int end = right;
            int i = left;
            T pivot = array[left];
            while (i <= end) {
                if (array[i].compareTo(pivot) < 0) {
                    this.swap(array, start, i);
                    start++;
                    i++;
                } else if (array[i].compareTo(pivot) > 0) {
                    this.swap(array, i, end);
                    end--;
                } else i++;
            }
            sort(array, left, start - 1);
            sort(array, end + 1, right);
        }
    }
    private void swap(T[] array, int i, int j){
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}",1,0,0,0,0,0,0,0,0
1109,"import java.awt.Font;
class Sort {
	static int delay;
	public static void swap(double [] a, int i, int j)
	{
		double tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
	public static void show(double [] a, double hi, int first, int second, String title)
	{
		int N = a.length;
		StdDraw.clear(StdDraw.WHITE);
		for (int i = 0; i < N; i++) {
			StdDraw.setPenColor(StdDraw.GRAY);
			if (i == first || i == second) {
				StdDraw.setPenColor(StdDraw.RED);
			}
			StdDraw.line(i, 0, i, hi * a[i]);
			StdDraw.text(i, -0.08, Double.toString(a[i]), 90);
		}
		StdDraw.setPenColor(StdDraw.BOOK_RED);
		StdDraw.text(- 1, 0, title);
		StdDraw.show(delay);
	}
	public static void initDraw(int N, int _delay)
	{
		StdDraw.show(2);
        StdDraw.setCanvasSize(1100, 900);
        StdDraw.setXscale(-2, N+1);
        StdDraw.setYscale(-1, 1.2);
        StdDraw.setFont(new Font(""SansSerif"", Font.PLAIN, 12));
        StdDraw.setPenRadius(.01);
        delay = _delay;
	}
}
class BubbleSort extends Sort{
	public static double [] sort (double [] a, double hi)
	{
		int N = a.length;
		double [] b = new double[N];
		for (int i = 0; i < N; i++) {
			b[i] = a[i];
		}
		for (int i = 0; i < N ; i ++ ) {
			for (int j = 1; j < N - i ; j ++ ) {
				if (b[j] > b[j - 1]) {
					Sort.swap(b, j, j - 1);
					show(b, hi, j, j - 1,  ""Bubble           "");
				}
			}
		}
		return b;
	}
}
class SelectionSort extends Sort{
	public static double [] sort (double [] a, double hi)
	{
		int N = a.length;
		double [] b = new double[N];
		for (int i = 0; i < N; i++) {
			b[i] = a[i];
		}
		for (int i = 0; i < N ; i ++ ) {
			for (int j = i + 1; j < N  ; j ++ ) {
				Sort.show(b, hi, i, j,  ""SELECTION           "");
				if (b[i] < b[j]) {
					Sort.swap(b, i, j);
					show(b, hi, j, j - 1,  ""Selection           "");
				}
			}
		}
		return b;
	}
}
class InsertionSort extends Sort{
	public static double [] sort (double [] a, double hi)
	{
		int N = a.length;
		double [] b = new double[N];
		for (int i = 0; i < N; i++) {
			b[i] = a[i];
		}
		for (int i = 1 ; i < N ; i++)
		{
			for (int j = i ; j > 0; j--)
			{
				if (b[j-1] < b[j] ) {
					Sort.swap(b, j, j - 1);
					Sort.show(b, hi, j, j - 1,  ""INSERTION           "");	
				} else 
				{	
					Sort.show(b, hi, j, j - 1,  ""INSERTION           "");	
					break;
				}
			}
		}
		return b;
	}
}
class QuickSort extends Sort{
	public static double [] sort (double [] a, double hi)
	{
		int N = a.length;
		double [] b = new double[N];
		for (int i = 0; i < N; i++) {
			b[i] = a[i];
		}
		QuickSort.sort(b, 0, N - 1, hi);
		return b;
	}
	private static void sort(double[] a, int lo, int hi, double hi2) { 
        if (hi <= lo) return;
        int j = QuickSort.partition(a, lo, hi, hi2);
        QuickSort.sort(a, lo, j-1, hi2);
        QuickSort.sort(a, j+1, hi, hi2);
    }
    private static int partition(double[] a, int lo, int hi, double hi2) {
        int i = lo;
        int j = hi + 1;
        double v = a[lo];
        while (true) { 
            while (a[++i] > v)
            {
                if (i == hi) break;
            }
            while (v > a[--j])
            {
                if (j == lo) break;
            }
            if (i >= j) break;
            Sort.swap(a, i, j);;
            Sort.show(a, hi2, j, i,  ""QUICK           "");
        }
        Sort.swap(a, lo, j);
        Sort.show(a, hi2, j, lo,  ""QUICK           "");
        return j;
    }
}
class MergeSort extends Sort{
	private static void merge(double[] a, double[] aux, int lo, int mid, int hi, double hi2) {
        for (int k = lo; k <= hi; k++) {
            aux[k] = a[k]; 
        }
        int i = lo, j = mid+1;
        for (int k = lo; k <= hi; k++) {
            if      (i > mid)
            {
            	a[k] = aux[j++];
            }
            else if (j > hi)
            {
            	a[k] = aux[i++];
            }
            else if (aux[j] > aux[i])
            {
            	a[k] = aux[j++];
            }
            else
        	{
        		a[k] = aux[i++];
        	}
        	Sort.show(a, hi2, k, -1,  ""MERGE           "");
        }
    }
    private static void sort(double[] a, double[] aux, int lo, int hi, double hi2) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;
        MergeSort.sort(a, aux, lo, mid, hi2);
        MergeSort.sort(a, aux, mid + 1, hi, hi2);
        merge(a, aux, lo, mid, hi, hi2);
    }
    public static double [] sort(double[] a, double hi) {
    	int N = a.length;
		double [] b = new double[N];
		for (int i = 0; i < N; i++) {
			b[i] = a[i];
		}
        double[] aux = new double[N];
        MergeSort.sort(b, aux, 0, N -1, hi);
        return b;
    }
}
class ShellSort extends Sort{
	public static double [] sort(double[] a, double hi) {
        int N = a.length;
		double [] b = new double[N];
		for (int i = 0; i < N; i++) {
			b[i] = a[i];
		}
        int k = 1;
        int h = 1;
        while (h < N/3) {
            h = 3*h + 1;
            k++;
        }
        while (h >= 1) { 
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h; j -= h) {
                    Sort.show(b, hi, j, j - h,  ""SHELL           "");
                    if (b[j] > b[j-h]) {
                    	Sort.swap(b, j, j-h);
                    } else break;
                }
            }
            h /= 3;
        }
        return b;
    }
}
class allSorts {
	public static void main(String[] args) {
		if (args.length == 0 || args.length == 1) {
			System.out.println(""Help: "");
			System.out.println(""java allSort [Algorithm Name] [Count] <delay>\n"");
			System.out.println(""Algorithm Names: "");
			System.out.println(""bubble:  Bubble Sort"");
			System.out.println(""selection: Selection Sort"");
			System.out.println(""insertion: Insertion Sort"");
			System.out.println(""quick: Quick Sort"");
			System.out.println(""merge: Merge Sort"");
			System.out.println(""shell: Shell Sort"");
			System.out.println(""\nDelay: "");
			System.out.println(""time for each compare to show graphics in milisecond "");
			return;
		}
		String sortName = args[0];
		int N = Integer.parseInt(args[1]);
		int delay = 50;
		if (args.length >= 3) {
			delay = Integer.parseInt(args[2]);
		}
        double [] unsortedArray = new double[N];
        double [] sortedArray;
        for (int i = 0; i < N; i++)
			unsortedArray[i] = StdRandom.uniform(10000);
		System.out.println(""Unsorted Array:"");
		for (int i = 0; i < N; i++) {
			System.out.print(unsortedArray[i] + ""\t"");
		}
		System.out.println("""");
		Sort.initDraw(N, delay);
		switch (sortName) {
			case ""bubble"":
				sortedArray = BubbleSort.sort(unsortedArray, 0.00008);
				break;
			case ""selection"": 
				sortedArray = SelectionSort.sort(unsortedArray, 0.00008);
				break;
			case ""insertion"":
				sortedArray = InsertionSort.sort(unsortedArray, 0.00008);
				break;
			case ""quick"":
				sortedArray = QuickSort.sort(unsortedArray, 0.00008);
				break;
			case ""merge"":
				sortedArray = MergeSort.sort(unsortedArray, 0.00008);
				break;
			case ""shell"":
				sortedArray = ShellSort.sort(unsortedArray, 0.00008);
				break;
			default:
				sortedArray = BubbleSort.sort(unsortedArray, 0.00008);
		}
		System.out.println(""Sorted Array:"");
		for (int i = 0; i < N; i++) {
			System.out.print(sortedArray[i] + ""\t"");
		}
		System.out.println("""");
	}
}",1,1,1,1,1,0,0,0,0
1110,"import random
import time
import copy
import sys
sys.setrecursionlimit(10000)
size2 = 10000
span = 1000000
threshold = 20
def insertion_sort1(A):
	for i in range(1, len(A)):
		for j in range(i-1, -1, -1):
			if A[j] > A[j+1]:
				A[j], A[j+1] = A[j+1], A[j]
   else:
				break
def insertion_sort2(A):
	for i in range(1, len(A)):
		j = i-1
  while A[j] > A[j+1] and j >= 0:
			A[j], A[j+1] = A[j+1], A[j]
   j -= 1
def insertion_sort3(A):
	for i in range(1, len(A)):
		curNum = A[i]
  k = 0
  for j in range(i-1, -2, -1):
			k = j
   if A[j] > curNum:
				A[j+1] = A[j]
   else:
				break
  A[k+1] = curNum
def selection_sort(A):
	for i in range (0, len(A) - 1):
		minIndex = i
  for j in range (i+1, len(A)):
			if A[j] < A[minIndex]:
				minIndex = j
  if minIndex != i:
			A[i], A[minIndex] = A[minIndex], A[i]
def bubble_sort1(A):
	for i in range (0, len(A) - 1):
		for j in range (0, len(A) - i - 1):
			if A[j] > A[j+1]:
				A[j], A[j+1] = A[j+1], A[j]
def bubble_sort2(A):
	for i in range (0, len(A) - 1):
		done = True
  for j in range (0, len(A) - i - 1):
			if A[j] > A[j+1]:
				A[j], A[j+1] = A[j+1], A[j]
    done = False
  if done:
			return
def merge_sort(A):
	merge_sort2(A, 0, len(A)-1)
def merge_sort2(A, first, last):
	if last-first < threshold and first < last:
		quick_selection(A, first, last)
 elif first < last:
		middle = (first + last)//2
  merge_sort2(A, first, middle)
  merge_sort2(A, middle+1, last)
  merge(A, first, middle, last)
def merge(A, first, middle, last):
	L = A[first:middle]
 R = A[middle:last+1]
 L.append(999999999)
 R.append(999999999)
 i = j = 0
 for k in range (first, last+1):
		if L[i] <= R[j]:
			A[k] = L[i]
   i += 1
  else:
			A[k] = R[j]
   j += 1
def quick_sort(A):
	quick_sort2(A, 0, len(A)-1)
def quick_sort2(A, low, hi):
	if hi-low < threshold and low < hi:
		quick_selection(A, low, hi)
 elif low < hi:
		p = partition(A, low, hi)
  quick_sort2(A, low, p - 1)
  quick_sort2(A, p + 1, hi)
def get_pivot(A, low, hi):
	mid = (hi + low) // 2
 s = sorted([A[low], A[mid], A[hi]])
 if s[1] == A[low]:
		return low
 elif s[1] == A[mid]:
		return mid
 return hi
def partition(A, low, hi):
	pivotIndex = get_pivot(A, low, hi)
 pivotValue = A[pivotIndex]
 A[pivotIndex], A[low] = A[low], A[pivotIndex]
 border = low
 for i in range(low, hi+1):
		if A[i] < pivotValue:
			border += 1
   A[i], A[border] = A[border], A[i]
 A[low], A[border] = A[border], A[low]
 return (border)
def quick_selection(x, first, last):
	for i in range (first, last):
		minIndex = i
  for j in range (i+1, last+1):
			if x[j] < x[minIndex]:
				minIndex = j
  if minIndex != i:
			x[i], x[minIndex] = x[minIndex], x[i]
def heapsort(a):
    heapify(a, len(a))
    end = len(a)-1
    while end > 0:
        a[end], a[0] = a[0], a[end]
        end -= 1
        sift_down(a, 0, end)
def heapify(a, count):
    start = int((count-2)/2)
    while start >= 0:
        sift_down(a, start, count-1)
        start -= 1
def sift_down(a, start, end):
    root = start
    while (root*2+1) <= end:
        child = root * 2 + 1
        swap = root
        if a[swap] < a[child]:
            swap = child
        if (child + 1) <= end and a[swap] < a[child+1]:
            swap = child+1
        if swap != root:
            a[root], a[swap] = a[swap], a[root]
            root = swap
        else:
            return
if __name__ == ""__main__"":
    import doctest
    doctest.testmod()
print("""")
start_time = time.time()
print(""Random\n---------------------------------"")
w = [random.randint(0, span) for a in range(0, size2)]
insertion_sort3(w)
print(""Insertion Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [random.randint(0, span) for a in range(0, size2)]
selection_sort(w)
print(""Selection Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [random.randint(0, span) for a in range(0, size2)]
bubble_sort2(w)
print(""Bubble Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [random.randint(0, span) for a in range(0, size2)]
merge_sort(w)
print(""Merge Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [random.randint(0, span) for a in range(0, size2)]
quick_sort(w)
print(""Quick Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [random.randint(0, span) for a in range(0, size2)]
heapsort(w)
print(""Heap Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
print(""\nAlready Sorted\n---------------------------------"")
w = [a for a in range(0, size2)]
insertion_sort3(w)
print(""Insertion Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
selection_sort(w)
print(""Selection Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
bubble_sort2(w)
print(""Bubble Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
merge_sort(w)
print(""Merge Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
quick_sort(w)
print(""Quick Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
heapsort(w)
print(""Heap Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
print(""\nReverse Sorted\n---------------------------------"")
w = [a for a in range(0, size2)]
w.reverse()
insertion_sort3(w)
print(""Insertion Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [a for a in range(0, size2)]
w.reverse()
selection_sort(w)
print(""Selection Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [a for a in range(0, size2)]
w.reverse()
bubble_sort2(w)
print(""Bubble Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [a for a in range(0, size2)]
w.reverse()
merge_sort(w)
print(""Merge Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [a for a in range(0, size2)]
w.reverse()
quick_sort(w)
print(""Quick Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
start_time = time.time()
w = [a for a in range(0, size2)]
w.reverse()
heapsort(w)
print(""Heap Sort(size=""+ str(size2)+""): "", round(time.time() - start_time, 11))
print("""")",1,1,1,1,1,0,0,0,0
1111,"import me.tongfei.progressbar.*;
public class BenchmarkingSortingAlgorithms
{
    public static void main(String[] args)
    {
        int[] unsortedArray = createArrayWithRandomInts(100000);
        bubbleSort(unsortedArray);
        selectionSort(unsortedArray);
        insertionSort(unsortedArray);
        benchmarkQuickSort(unsortedArray);
        benchmarkMergeSort(unsortedArray);
    }
    static int[] bubbleSort(int[] array)
    {
        int temp;
        boolean alreadySorted = true;
        long start = System.currentTimeMillis();
        try (ProgressBar pb  = new ProgressBar(""BubbleSort Progress"", array.length))
        {
            for (int i = 0; i < array.length; i++)
        {
            pb.step();
            for (int j = 0; j < array.length - 1; j++)
            {
                if (array[j] > array[j + 1])
                {
                    alreadySorted = false;
                    temp = array[j + 1];
                    array[j + 1] = array[j];
                    array[j] = temp;
                }
                pb.setExtraMessage(""Reading..."");
            }
            if (alreadySorted == true)
            {
                break;
            }
            pb.setExtraMessage(""Completed"");
        }
            long end = System.currentTimeMillis();
            System.out.println(""Array sorted with bubble sort in :"" + (end - start) + ""ms"");
        }
        return array;
    }
    static int[] selectionSort(int[] array)
    {
        int min;
        int pos = 0;
        long start = System.currentTimeMillis();
        try (ProgressBar pb  = new ProgressBar(""Selection Progress"", array.length))
        {
            for (int i = 0; i < array.length - 1; i++)
            {
                pb.step();
                min = array[i];
                for (int j = i + 1; j < array.length; j++)
                {
                    if (array[j] < min)
                    {
                        min = array[j];
                        pos = j;
                    }
                }
                array[pos] = array[i];
                array[i] = min;
            }
            pb.setExtraMessage(""Completed"");
        }
        long end = System.currentTimeMillis();
        System.out.println(""Array sorted with selection sort in :"" + (end - start) + ""ms"");
        return array;
    }
    static int[] insertionSort(int[] array)
    {
        long start = System.currentTimeMillis();
        int j;
        try (ProgressBar pb  = new ProgressBar(""Insertion Progress"", array.length))
        {
            for (int i = 1; i < array.length; i++)
            {
                pb.step();
                int key = array[i];
                for (j = i - 1; (j >= 0) && (key < array[j]); j--)
                {
                    array[j + 1] = array[j];
                }
                array[j + 1] = key;
            }
            pb.setExtraMessage(""Completed"");
        }
        long end = System.currentTimeMillis();
        System.out.println(""Array sorted with insertion sort in :"" + (end - start) + ""ms"");
        return array;
    }
    static void quickSort(int[] array, int low, int high)
    {
        int pivot = array[low + ((high - low) / 2)];
        int i = low;
        int j = high;
            while (i <= j)
            {
                while (array[i] < pivot)
                {
                    i++;
                }
                while (array[j] > pivot)
                {
                    j--;
                }
                if (i <= j)
                {
                    int temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                    i++;
                    j--;
                }
            }
            if (low < j)
            {
                quickSort(array, low, j);
            }
            if (i < high)
            {
                quickSort(array, i, high);
            }
        }
    static void benchmarkQuickSort(int[] array)
    {
        long start = System.currentTimeMillis();
        quickSort(array, 0, array.length - 1);
        long end = System.currentTimeMillis();
        System.out.println(""Array sorted with quick sort in :"" + (end - start) + ""ms"");
    }
    public static int[] mergeSort(int[] array)
    {
        if (array.length == 1)
        {
            return array;
        }
        int[] array1 = new int[(array.length/2)];
        int[] array2 = new int[(array.length-array1.length)];
        System.arraycopy(array, 0, array1, 0, array1.length);
        System.arraycopy(array, array1.length, array2, 0, array2.length);
        mergeSort(array1);
        mergeSort(array2);
        merge(array1, array2, array);
        return array;
    }
    static void merge(int[] array1, int[] array2, int[] mergedArray)
    {
        int array1Index = 0;
        int array2Index = 0;
        int pos = 0;
        while ((array1Index < array1.length) && (array2Index < array2.length))
        {
            if (array1[array1Index] < array2[array2Index])
            {
                mergedArray[pos] = array1[array1Index];
                array1Index++;
                pos++;
            } else
            {
                mergedArray[pos] = array2[array2Index];
                array2Index++;
                pos++;
            }
        }
        if (array1Index < array2Index)
        {
            System.arraycopy(array1, array1Index, mergedArray, pos, array1.length - array1Index);
        }
        else if (array2Index < array1Index) ;
        {
            System.arraycopy(array2, array2Index, mergedArray, pos, array2.length - array2Index);
        }
    }
    static void benchmarkMergeSort(int[] array)
    {
        long start = System.currentTimeMillis();
        mergeSort(array);
        long end = System.currentTimeMillis();
        System.out.println(""Array sorted with merge sort in :"" + (end - start) + ""ms"");
    }
    static int[] createArrayWithRandomInts(int size)
    {
        int[] array = new int[size];
        for (int i = 0; i < size; i++)
        {
            array[i] = (int) (Math.random() * Math.random() * 100000);
        }
        return array;
    }
    static void printArray(int[] array)
    {
        for (int i = 0; i < array.length; i++)
        {
            System.out.print(array[i] + "" "");
        }
        System.out.println();
    }
}",1,1,1,1,1,0,0,0,0
1112,"package com.sorting;
import java.util.Comparator;
public class Heap {
    private Heap() {
    }
    public static void sort(Comparable[] array) {
        if (array == null)
            throw new NullPointerException();
        heapify(array);
        for (int k = array.length; k >= 1; k--) {
            exch(array, 1, k);
            sink(array, 1, k - 1);
        }
    }
    public static void sort(Comparable[] array, Comparator c) {
        if (array == null)
            throw new NullPointerException();
        heapify(array, c);
        for (int k = array.length; k >= 1; k--) {
            exch(array, 1, k);
            sink(array, 1, k - 1, c);
        }
    }
    private static void heapify(Comparable[] A) {
        for (int k = A.length / 2; k >= 1; k--)
            sink(A, k, A.length);
    }
    private static void heapify(Comparable[] A, Comparator c) {
        for (int k = A.length / 2; k >= 1; k--)
            sink(A, k, A.length, c);
    }
    private static void sink(Comparable[] A, int indice, int len) {
        int j;
        while (indice <= len / 2) {
            j = 2 * indice;
            if ((j < len) && (less(A, j, j + 1, null)))
                j++;
            if (!less(A, indice, j, null))
                break;
            exch(A, indice, j);
            indice = j;
        }
    }
    private static void sink(Comparable[] A, int indice, int len, Comparator c) {
        int j;
        while (indice <= len / 2) {
            j = 2 * indice;
            if ((j < len) && (less(A, j, j + 1, c)))
                j++;
            if (!less(A, indice, j, c))
                break;
            exch(A, indice, j);
            indice = j;
        }
    }
    private static void exch(Object[] A, int i, int j) {
        i = getArrayIndex(i);
        j = getArrayIndex(j);
        Object k = A[i];
        A[i] = A[j];
        A[j] = k;
    }
    private static boolean less(Comparable[] A, int i, int j, Comparator c) {
        i = getArrayIndex(i);
        j = getArrayIndex(j);
        int compareValue;
        if (c == null)
            compareValue = A[i].compareTo(A[j]);
        else
            compareValue = c.compare(A[i], A[j]);
        if (compareValue < 0)
            return true;
        return false;
    }
    private static int getArrayIndex(int indice) {
        return --indice;
    }
    public static void show(Comparable[] array) {
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + "","");
        }
    }
}",0,0,0,0,0,0,0,0,0
1113,"package heapsort;
public class HeapSortClass
{
    public HeapSortClass()
    {
        int[] a = {30, 3, 7, 15, 20, 100, 25, 80, 10, 90, 17, 40, 5};
        int i; 
        for (i=0; i<a.length; i++)  System.out.println(a[i]);
        heapsort(a);
        System.out.println(""Sorted:"");
        for (i=0; i<a.length; i++) System.out.println(a[i]);
    }
    public static void main(String[] args)
    {
        HeapSortClass H=new HeapSortClass();
    }
    public void heapsort(int[] a)
    {
       int last=a.length; int i;
       for (i=last/2; i>0; i--) maxshift(a, i, last);
       for (i=1; i<a.length; i++)
       {
          int x=a[last-1]; a[last-1]=a[0]; a[0]=x;
          last--; maxshift(a, 1, last);
       }
    }
    public static void maxshift(int[] a, int i, int last)
    {
        int j=2*i; int x=a[i-1];
        if ((j<last)&&(a[j]>a[j-1])) j++;
        while((j<=last)&&(a[j-1]>x))
        {
            a[i-1]=a[j-1]; i=j; j=2*j;
            if ((j<last)&&(a[j]>a[j-1])) j++;
        }
        a[i-1]=x; 
    }
}",0,0,0,0,0,0,0,0,0
1114,"function selectionSortDescending(inputArray) {
  for (let i = 0; i < inputArray.length - 1; i++) {
    let maxIndex = i;
    for (let j = i + 1; j < inputArray.length; j++) {
      if (inputArray[maxIndex] < inputArray[j]) {
        maxIndex = j; 
      }
    }
    if (maxIndex != i) {
      const temp = inputArray[maxIndex];
      inputArray[maxIndex] = inputArray[i];
      inputArray[i] = temp;
    }
    console.log('In progress: ', inputArray);
  }
  return inputArray;
}
function selectionSort(items) {
  const length = items.length;
  for (let i = 0; i < length - 1; i++) {
    let min = i;  
    for (let j = i + 1; j < length; j++) {  
      if (items[j] < items[min]) {  
        min = j;  
      }
    }
    if (min != i) {
      const tmp = items[i];
      items[i] = items[min];
      items[min] = tmp;
    }
  }
}
module.exports = {selectionSort, selectionSortDescending};",0,0,1,0,0,0,0,0,0
1115,"var jssort = jssort || {};
(function (jss) {
    'use strict';
    jss.less = function (a1, a2, compare) {
        return compare(a1, a2) < 0; 
    };
    jss.exchange = function (a, i, j) {
        var temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    };
    jss.selectionSort = function (a, lo, hi, compare) {
        if (!lo) { lo = 0; }
        if (!hi) { hi = a.length - 1; }
        if (!compare) {
            compare = function (a1, a2) {
                return a1 - a2;
            };
        }
        for (var i=lo; i <= hi; ++i){
            var minValue = a[i];
            var J = -1;
            for (var j = i+1; j <= hi; ++j) {
                if (jss.less(a[j], minValue, compare)) {
                    J = j;
                    minValue = a[j];
                }
            }
            if(J != -1){
                jss.exchange(a, i, J);
            }
        }
    };
    jss.insertionSort = function(a, lo, hi, compare) {
        if (!lo) lo = 0;
        if (!hi) hi = a.length-1;
        if (!compare) {
            compare = function (a1, a2){
                return a1 - a2;
            };
        }
        for (var i = lo+1; i <= hi; ++i){
            for (var j = i; j > lo; --j){
                if (jss.less(a[j], a[j-1], compare)){
                    jss.exchange(a, j-1, j);
                } else {
                    break;
                }
            }
        }
    };
    jss.shellSort = function(a, lo, hi, compare) {
        if (!lo) lo = 0;
        if (!hi) hi = a.length-1;
        if (!compare) {
            compare = function (a1, a2) {
                return a1 - a2;
            };
        }
        var h = 0;
        while (h - lo < (hi - lo) / 3 ) {
            h = 3 * h + 1;
        }
        var step = h;
        while (step >= 1) {
            for (var i = lo + step; i <= hi; i++){
                for(var j = i; j >= lo + step; j -= step) {
                    if(jss.less(a[j], a[j-step], compare)){
                        jss.exchange(a, j, j-step);
                    } else {
                        break;
                    }
                }
            }
            step -= 1;
        }
    };
    jss.mergeSort = function (a, lo, hi, compare, aux) {
        if (!lo) lo = 0;
        if (!hi) hi = a.length-1;
        if (!compare) {
            compare = function (a1, a2){
                return a1 - a2;
            };
        }
        if(!aux) {
            aux = [];
            for (var i = 0; i < a.length; ++i) {
                aux.push(a[i]);
            }
        }
        if(lo >= hi) return;
        if(hi - lo <= 7) {
            jss.insertionSort(a, lo, hi, compare);
            return;
        }
        var mid = Math.floor(lo + (hi - lo) / 2);
        jss.mergeSort(a, lo, mid, compare, aux);
        jss.mergeSort(a, mid+1, hi, compare, aux);
        jss.merge(a, aux, lo, mid, hi, compare);
    };
    jss.merge = function (a, aux, lo, mid, hi, compare) {
        for (var k = lo; k <= hi; ++k) {
            aux[k] = a[k];
        }  
        var i = lo, j = mid+1;
        for (var k = lo; k <= hi; ++k) {
            if ( i > mid) {
                a[k] = aux[j++];
            }
            else if( j > hi) {
                a[k] = aux[i++];
            }
            else if (jss.less(aux[i], aux[j], compare)) {
                a[k] = aux[i++]; 
            } else {
                a[k] = aux[j++];
            }
        }
    };
    jss.quickSort = function (a, lo, hi, compare) {
        if (!lo) lo = 0;
        if (!hi) hi = a.length-1;
        if (!compare) {
            compare = function (a1, a2){
                return a1 - a2;
            };
        }
        if (lo >= hi) {
            return;
        }
        if (hi - lo <= 7) {
            jss.insertionSort(a, lo, hi, compare);
            return;
        }
        var j = jss.partition(a, lo, hi, compare);
        jss.quickSort(a, lo, j-1, compare);
        jss.quickSort(a, j+1, hi, compare);
    };
    jss.partition = function (a, lo, hi, compare) {
        var v = a[lo];
        var i = lo, j = hi+1;
        while (true) {
            while (jss.less(a[++i], v, compare)) {
                if (i >= hi) {
                    break;
                }
            }
            while (jss.less(v, a[--j], compare)) {
                if (j <= lo) {
                    break;
                }
            }
            if(i >= j) {
                break;
            }
            jss.exchange(a, i, j);
        }
        jss.exchange(a, lo, j);
        return j;
    };
    jss.threeWaysQuickSort = function (a, lo, hi, compare) {
        if (!lo) lo = 0;
        if (!hi) hi = a.length-1;
        if (!compare) {
            compare = function (a1, a2){
                return a1 - a2;
            };
        }
        if (lo >= hi) {
            return;
        }
        if (hi - lo <= 7) {
            jss.insertionSort(a, lo, hi, compare);
            return;
        }
        var i = lo, lt = lo, gt = hi;
        var v = a[lo];
        while (i <= gt) {
            if (jss.less(a[i], v, compare)) {
                jss.exchange(a, i++, lt++);
            } else if(jss.less(v, a[i], compare)) {
                jss.exchange(a, i, gt--);
            } else {
                i++;
            }
        }
        jss.threeWaysQuickSort(a, lo, lt-1, compare);
        jss.threeWaysQuickSort(a, gt+1, hi, compare);
    };
    jss.heapSort = function(a, compare) {
        if (!compare) {
            compare = function (a1, a2){
                return a1 - a2;
            };
        }
        var N = a.length;
        var N2 = Math.floor(N / 2);
        for (var k = N2; k >= 1; --k){
            jss.sink(a, k, N, compare);
        }
        while (N > 1) {
            jss.exchange(a, jss.heapIndex(1), jss.heapIndex(N));
            N--;
            jss.sink(a, 1, N, compare);
        }
    };
    jss.sink = function(a, k, N, compare) {
        while (k * 2 <= N) {
            var child =  k * 2;
            if(child < N && jss.less(a[jss.heapIndex(child)], a[jss.heapIndex(child+1)], compare)) {
                child++;
            }
            if(jss.less(a[jss.heapIndex(k)], a[jss.heapIndex(child)], compare)) {
                jss.exchange(a, jss.heapIndex(k), jss.heapIndex(child));
                k = child;
            } else {
                break;
            }
        }  
    };
    jss.heapIndex = function(i) {
        return i - 1;
    };
})(jssort);
var module = module || {};
if(module) {
	module.exports = jssort;
}",1,1,1,1,0,0,0,0,0
1116,"from typing import List
def selectionSort(array: List[int]) -> None:
    for i in range(len(array)):  
        index = array.index(min(array[i:]))  
        array[i], array[index] = array[index], array[i]  
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""SELECTION SORT"")
    shuffled_array = randomSequence(0, 1000)
    print(shuffled_array, ""\n"")
    selectionSort(shuffled_array)
    print(shuffled_array)",0,0,1,0,0,0,0,0,0
1117,"class Sorter:
    def __init__(self, list):
        self.list = list
    def selectionSort(self):
        unsortedList = self.list[:]
        sortedList = []
        indexSmallest = 0
        while len(unsortedList) > 0:
            for i in range(len(unsortedList)):
                if unsortedList[i] <= unsortedList[indexSmallest]:
                    indexSmallest = i
            sortedList.append(unsortedList[indexSmallest])
            unsortedList.pop(indexSmallest)
            indexSmallest = 0
        return sortedList
    def bubbleSort(self):
        list = self.list[:]
        notDone = True
        while notDone:
            print(list)
            notDone = False
            for i in range(len(list)):
                if(i != len(list) - 1):
                    if(list[i] > list[i + 1]):
                        temp = list[i]
                        list[i] = list[i + 1]
                        list[i + 1] = temp
                        notDone = True
        return list
    def insertionSort(self):
        list = self.list[:]
        for i in range(1, len(list)):
            while(i > 0 and list[i] < list[i - 1]):
                temp = list[i]
                list[i] = list[i - 1]
                list[i - 1] = temp
                i -= 1
        return list
    def quickSort(self):
        list = self.list[:]
        less = []
        equal = []
        greater = []
        if len(list) > 1:
            pivot = list[0]
            for x in list:
                if x < pivot:
                    less.append(x)
                elif x == pivot:
                    equal.append(x)
                elif x > pivot:
                    greater.append(x)
            return sorted(less) + equal + sorted(greater)
        else:
            return list
sorter = Sorter([68,12,34,8,16,78])
print(sorter.quickSort())",1,0,1,1,1,0,0,0,0
1118,"import timeit
from random import *
from copy import copy
import numpy as np
import matplotlib.pyplot as plt
def bubbleSort(A):
    for i in range(len(A)):
        for k in range(len(A) - 1, i, -1):
            if A[k] < A[k - 1]:
                swap(A, k, k - 1)
    return A
def selectionSort(array):
    for i in range(0, len(array) - 1):
        smallSub = i
        for j in range(i + 1, len(array) - 1):
            if array[j] < array[smallSub]:
                smallSub = j
        temp = array[i]
        array[i] = array[smallSub]
        array[smallSub] = temp
    return array
def insertionSort(aList):
    for i in range(1, len(aList)):
        tmp = aList[i]
        k = i
        while k > 0 and tmp < aList[k - 1]:
            aList[k] = aList[k - 1]
            k -= 1
        aList[k] = tmp
def mergeSort(array):
    if len(array) == 1:
        return array
    list1 = []
    list2 = []
    for i in range(0, len(array)):
        if i < len(array) / 2:
            list1.append(array[i])
        else:
            list2.append(array[i])
    list1 = mergeSort(list1)
    list2 = mergeSort(list2)
    return merge(list1, list2)
def qsort(a):
    if len(a) <= 1:
        return a
    else:
        q = choice(a)
        return qsort([elem for elem in a if elem < q]) + [q] * a.count(q) + qsort([elem for elem in a if elem > q])
def merge(array1, array2):
    array3 = []
    count1 = 0
    count2 = 0
    while count1 != len(array1) and count2 != len(array2):
        if array1[count1] > array2[count2]:
            array3.append(array2[count2])
            count2 += 1
        else:
            array3.append(array1[count1])
            count1 += 1
    while count1 != len(array1):
        array3.append(array1[count1])
        count1 += 1
    while count2 != len(array2):
        array3.append(array2[count2])
        count2 += 1
    return array3
def heapSort(aList):
    length = len(aList) - 1
    leastParent = length / 2
    for i in range(int(leastParent), -1, -1):
        moveDown(aList, i, length)
    for i in range(length, 0, -1):
        if aList[0] > aList[i]:
            swap(aList, 0, i)
            moveDown(aList, 0, i - 1)
    return aList
def moveDown(aList, first, last):
    largest = 2 * first + 1
    while largest <= last:
        if (largest < last) and (aList[largest] < aList[largest + 1]):
            largest += 1
        if aList[largest] > aList[first]:
            swap(aList, largest, first)
            first = largest
            largest = 2 * first + 1
        else:
            return 
def swap(A, x, y):
    tmp = A[x]
    A[x] = A[y]
    A[y] = tmp
def comparisonCountingSort(array):
    count = []
    sort = []
    for i in range(0, len(array) - 1):
        count.append(0)
        sort.append(0)
    for i in range(0, len(array) - 2):
        for j in range(i + 1, len(array) - 1):
            if array[i] < array[j]:
                count[j] += 1
            else:
                count[i] += 1
    for i in range(0, len(array) - 1):
        sortedArray[count[i]] = array[i]
    return sortedArray
randomArray = []
sortedArray = []
backwardsArray = []
stepsArray = []
upper = 10000
for ind in range(0, upper):
    randomArray.append(randint(0, 100))
    sortedArray.append(ind)
    backwardsArray.append(upper - ind)
    stepsArray.append(randint(0, 10) * 1000)
def wrapper(func, *args, **kwargs):
    def wrapped():
        return func(*args, **kwargs)
    return wrapped
def quickSortPrep(array):
    return qsort(array)
def listAppend(bubble, insertion, selection, merge, quick, heap, count, array, length):
    catArray = array[:length]
    bubbleWrap = wrapper(bubbleSort, copy(catArray))
    bubble.append(timeit.timeit(bubbleWrap, number=1))
    selectionWrap = wrapper(selectionSort, copy(catArray))
    selection.append(timeit.timeit(selectionWrap, number=1))
    insertionWrap = wrapper(insertionSort, copy(catArray))
    insertion.append(timeit.timeit(insertionWrap, number=1))
    mergeWrap = wrapper(mergeSort, copy(catArray))
    merge.append(timeit.timeit(mergeWrap, number=1))
    quickWrap = wrapper(quickSortPrep, copy(catArray))
    quick.append(timeit.timeit(quickWrap, number=1))
    heapWrap = wrapper(heapSort, copy(catArray))
    heap.append(timeit.timeit(heapWrap, number=1))
    countWrap = wrapper(comparisonCountingSort, copy(catArray))
    count.append(timeit.timeit(countWrap, number=1))
def resetLists(bubble, insertion, selection, merge, quick, heap, count):
    bubble[:] = []
    insertion[:] = []
    selection[:] = []
    merge[:] = []
    quick[:] = []
    heap[:] = []
    count[:] = []
def testSorts():
    bubbleTime = []
    insertionTime = []
    selectionTime = []
    mergeTime = []
    quickTime = []
    heapTime = []
    countTime = []
    times = []
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, randomArray, 10)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, sortedArray, 10)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, backwardsArray, 10)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, stepsArray, 10)
    times.append(
        [copy(bubbleTime),
        copy(insertionTime),
        copy(selectionTime),
        copy(mergeTime),
        copy(quickTime),
        copy(heapTime),
        copy(countTime)]
    )
    resetLists(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, sortedArray, 20)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, randomArray, 20)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, backwardsArray, 20)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, stepsArray, 20)
    times.append(
        [copy(bubbleTime),
        copy(insertionTime),
        copy(selectionTime),
        copy(mergeTime),
        copy(quickTime),
        copy(heapTime),
        copy(countTime)]
    )
    resetLists(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, sortedArray, 100)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, randomArray, 100)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, backwardsArray, 100)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, stepsArray, 100)
    times.append(
        [copy(bubbleTime),
        copy(insertionTime),
        copy(selectionTime),
        copy(mergeTime),
        copy(quickTime),
        copy(heapTime),
        copy(countTime)]
    )
    resetLists(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, sortedArray, 1000)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, randomArray, 1000)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, backwardsArray, 1000)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, stepsArray, 1000)
    times.append(
        [copy(bubbleTime),
        copy(insertionTime),
        copy(selectionTime),
        copy(mergeTime),
        copy(quickTime),
        copy(heapTime),
        copy(countTime)]
    )
    resetLists(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, sortedArray, 10000)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, randomArray, 10000)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, backwardsArray, 10000)
    listAppend(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime, stepsArray, 10000)
    times.append(
        [copy(bubbleTime),
        copy(insertionTime),
        copy(selectionTime),
        copy(mergeTime),
        copy(quickTime),
        copy(heapTime),
        copy(countTime)]
    )
    resetLists(bubbleTime, insertionTime, selectionTime, mergeTime, quickTime, heapTime, countTime)
def plotlogn(timeList):
    groups = 4
    fig, ax = plt.subplots()
    index = np.arange(groups)
    bar_width = .25
    mergeRect = plt.bar(
        index + bar_width * 3,
        timeList[3],
        bar_width,
        color='orange',
        label='Merge'
    )
    quickRect = plt.bar(
        index + bar_width * 4,
        timeList[4],
        bar_width,
        color='red',
        label='Quick'
    )
    heapRect = plt.bar(
        index + bar_width * 5,
        timeList[5],
        bar_width,
        color='purple',
        label='Heap'
    )
    plt.xlabel('Sorting Algorithm')
    plt.ylabel('Sorting Time')
    plt.title('Comparison of Log(n) Sorting Algorithms')
    plt.xticks(
        index + bar_width * 3,
        ('Random', 'Sorted', 'Backwards', 'Steps'))
    plt.legend()
    plt.tight_layout()
    plt.show()
def populateChart(timeList):
    groups = 4
    fig, ax = plt.subplots()
    index = np.arange(groups)
    bar_width = .125
    bubbleRect = plt.bar(
        index,
        timeList[0],
        bar_width,
        color='g',
        label='Bubble'
    )
    selectionRect = plt.bar(
        index + bar_width,
        timeList[1],
        bar_width,
        color='b',
        label='Selection'
    )
    insertionRect = plt.bar(
        index + bar_width * 2,
        timeList[2],
        bar_width,
        color='y',
        label='Insertion'
    )
    mergeRect = plt.bar(
        index + bar_width * 3,
        timeList[3],
        bar_width,
        color='orange',
        label='Merge'
    )
    quickRect = plt.bar(
        index + bar_width * 4,
        timeList[4],
        bar_width,
        color='red',
        label='Quick'
    )
    heapRect = plt.bar(
        index + bar_width * 5,
        timeList[5],
        bar_width,
        color='purple',
        label='Heap'
    )
    countRect = plt.bar(
        index + bar_width * 6,
        timeList[6],
        bar_width,
        color='black',
        label='Count'
    )
    plt.xlabel('Sorting Algorithm')
    plt.ylabel('Sorting Time')
    plt.title('Comparison of Sorting Algorithms')
    plt.xticks(
        index + bar_width * 3,
        ('Random', 'Sorted', 'Backwards', 'Steps'))
    plt.legend()
    plt.tight_layout()
    plt.show()
testSorts()",1,1,1,1,1,0,0,0,0
1119,"from typing import List
def insertionSort(array: List[int], start: int, end: int) -> None:
    for i in range(start + 1, end):  
        comparator = array[i]  
        section = i - 1
        while (
            section >= start and array[section] > comparator
        ):  
            array[section + 1] = array[
                section
            ]  
            section -= 1
        array[
            section + 1
        ] = comparator  
def merge(array: List[int], start: int, mid: int, end: int) -> int:
    start2 = mid + 1
    if array[mid] <= array[start2]:
        return
    while start <= mid and start2 <= end:
        if array[start] <= array[start2]:
            start += 1
        else:
            value = array[start2]
            index = start2
            while index != start:
                array[index] = array[index - 1]
                index -= 1
            array[start] = value
            start += 1
            mid += 1
            start2 += 1
def timSort(array: List[int], run: int = 32) -> None:
    for i in range(0, len(array), run):
        insertionSort(array, i, min(i + run, len(array)))
    size = run
    while size < len(array):
        for left in range(0, len(array), 2 * size):
            mid = left + size - 1
            right = min((left + 2 * size - 1), (len(array) - 1))
            merge(array, left, mid, right)
        size *= 2
if __name__ == ""__main__"":
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    print(""TIM SORT"")
    shuffledArray = randomSequence(0, 1000)
    print(shuffledArray, ""\n"")
    timSort(shuffledArray)
    print(shuffledArray)",0,1,0,1,0,0,0,0,0
1120,"import math, random
_defaultCompare = lambda x, y: x - y
_defaultKey = lambda a: a
def isSorted(l, compare=_defaultCompare, key=_defaultKey, ascending=False):   
    for i in range(len(l)-1):
        if 0 < compare(key(l[i]), key(l[i+1])) * (-1 if ascending else 1):
            return False
    return True
class _Template(object):
    def __init__(self, compare=_defaultCompare, key=_defaultKey, ascending=False):
        self._compare = compare
        self._key = key
        self._ascending = ascending
        self._sortingInput = None
        self._sortingList = []
    def _compareByIndex(self, a, b):
        return self._compareElements(self._sortingList[a], self._sortingList[b])
    def _compareElements(self, a, b):
        com = self._compare(self._key(a), self._key(b))
        if self._ascending: com *= -1
        return com
    def _exchangeByIndex(self, a, b):
        tmp = self._sortingList[a]
        self._sortingList[a] = self._sortingList[b]
        self._sortingList[b] = tmp
    def _copyList(self, fr):
        to = []
        for e in fr:
            to.append(e)
        return to
    def sort(self, o, cloneBeforeSort=True):
        self._sortingInput = o
        self._sortingList = self._copyList(o) if cloneBeforeSort else o
        self._do()
        return self._sortingList
    def _do(self):
        raise NotImplementedError
class BadAlgorithm(_Template):
    def _do(self):
        while not isSorted(self._sortingList, self._compare, self._key, self._ascending):
            random.shuffle(self._sortingList)
class BubbleSort(_Template):
    def _do(self):
        for i in range(0, len(self._sortingList)-1):
            changed = False
            for j in range(0, len(self._sortingList)-i-1):
                if self._compareByIndex(j, j+1) > 0:
                    self._exchangeByIndex(j, j+1)
                    changed = True
            if not changed:
                break
class SelectionSort(_Template):
    def _do(self):
        for sortedCounter in range(0, len(self._sortingList)):
            max = 0
            for i in range(1, len(self._sortingList)-sortedCounter):
                if self._compareByIndex(i, max) > 0:
                    max = i
            if max != len(self._sortingList)-sortedCounter-1:
                self._exchangeByIndex(max, len(self._sortingList)-sortedCounter-1)
class InsertSort(_Template):
    def _do(self):
        for i in range(1, len(self._sortingList)):
            j = i - 1
            tmp = self._sortingList[i]
            while j >= 0 and self._compareElements(self._sortingList[j], tmp) > 0:
                self._sortingList[j+1] = self._sortingList[j]
                j -= 1
            self._sortingList[j+1] = tmp
class QuickSort(_Template):
    def _do(self):
        self._rek(0, len(self._sortingList)-1)
    def _rek(self, links, rechts):
        li = links
        re = rechts
        vergl = self._sortingList[int((links + rechts) / 2)]
        first = True
        while first or li <= re:
            first = False
            while self._compareElements(self._sortingList[li], vergl) < 0:
                li += 1
            while self._compareElements(self._sortingList[re], vergl) > 0:
                re -= 1
            if li <= re:
                self._exchangeByIndex(li, re)
                li += 1
                re -= 1
        if links < re:
            self._rek(links, re)
        if rechts > li:
            self._rek(li, rechts)
class MergeSort(_Template):
    def _do(self):
        self._rek(1)
    def _rek(self, block):
        tmp = self._copyList(self._sortingList)
        if block < len(self._sortingList):
            for compNo in range(int(math.ceil(len(self._sortingList) / (2.0 * block)))):
                s1 = block * 2 * compNo
                s2 = s1 + block
                i1 = s1
                i2 = s2
                for c in range(2 * block):
                    i1AmLimit = i1 >= s2
                    i2AmLimit = i2 >= s2 + block
                    used = 1
                    if not (i1AmLimit or i2AmLimit):
                        used = 1 if self._compareByIndex(i1, i2) < 0 else 2
                    elif i1AmLimit:
                        used = 2
                    tmp[s1 + c] = self._sortingList[i1 if used == 1 else i2]
                    if used == 1:
                        i1 += 1
                    else:
                        i2 += 1
            self._sortingList = tmp    
            self._rek(block * 2)
class HeapSort(_Template):
    def drain(self, i, l, r):
        drainNeed = True
        tmp = self._sortingList[i]
        while 2*(i-l)+1+l <= r:
            j = 2 * (i - l) + 1 + l
            if j+1 <= r and self._compareByIndex(j, j+1) < 0:
                j += 1
            if self._compareElements(tmp, self._key(self._sortingList[j])) < 0:
                self._sortingList[i] = self._sortingList[j]
                i = j
            else:
                self._sortingList[i] = tmp
                i = r
                drainNeed = False
        if drainNeed:
            self._sortingList[i] = tmp
    def _do(self):
        for i in range(int((len(self._sortingList)+1)/2))[::-1]:
            self.drain(i, 0, len(self._sortingList)-1)
        for i in range(len(self._sortingList))[::-1]:
            self._exchangeByIndex(0, i)
            self.drain(0, 0, i-1)",1,1,1,1,1,0,0,0,0
1121,"package io.github.marioluan.algorithms.sorting;
import edu.princeton.cs.algs4.StdRandom;
@SuppressWarnings(""rawtypes"")
public final class QuickSelect extends Sortable {
    public static Comparable select(Comparable[] a, int k) {
        StdRandom.shuffle(a);
        return select(a, k, 0, a.length - 1);
    }
    private static Comparable select(Comparable[] a, int k, int lo, int hi) {
        if (hi <= lo)
            return a[k];
        int j = QuickSort.partition(a, lo, hi);
        if (j < k)
            lo = j + 1;
        else if (j > k)
            hi = j - 1;
        else
            return a[k];
        return select(a, k, lo, hi);
    }
}",0,0,0,0,0,0,0,0,0
1122,"class recursiveSelectionSort{
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		recSelectionSort(arr, 0, sizeofArr);
		print(arr);
	}
	static int minIndex (int [] arr, int a, int b){
		if (a == b) return a;
		int p = minIndex(arr, a, b - 1);
		if (arr[p] > arr[b]) return b;
		else return p;
	}
	static void recSelectionSort(int [] arr, int index, int n){
		int temp;
		if (index == n) return;
	   	int p = minIndex(arr, index, n - 1);
		if (p != index){
			temp = arr[index];
			arr[index] = arr[p];
			arr[p] = temp;
		}
		recSelectionSort(arr, index + 1, n);
	}
	static void print (int [] arr){
		for (int a : arr)
			System.out.print("" ""+a);
	}
}",0,0,1,0,0,0,0,0,0
1123,"public class Selection {
    public static void sort(int[] input) {
        for (int i = 0; i < input.length; i++) {
            int minIdx = i;
            for (int j = i + 1; j < input.length; j++) {
                if (input[j] < input[minIdx]) {
                    minIdx = j;
                }
            }
            swap(input, i, minIdx);
        }
    }
    private static void swap(int[] input, int a, int b) {
        if (a == b)
            return;
        int cache = input[a];
        input[a] = input[b];
        input[b] = cache;
    }
}",0,0,1,0,0,0,0,0,0
1124,"def selection(l: list):
    arr = l[::]
    for i in range(len(arr)):
        m = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[m]:
                m = j
        if i != m:
            arr[i], arr[m] = arr[m], arr[i]
    return arr",0,0,1,0,0,0,0,0,0
1125,"package piratezpdx.sortathon;
public class Selection extends ArrayBased {
    Selection(){
        super();
    }
    public int sort() throws ArrayIndexOutOfBoundsException{
        int count = 0;
        int focus_element = 0;
        int current_element = 0;
        int comparison_number = 0;
        int array_length = sortingArray.length;
        if (array_length < 1) {
            throw new ArrayIndexOutOfBoundsException();
        }
        while (focus_element < array_length){
            comparison_number = sortingArray[focus_element];
            current_element = focus_element +1;
            while (current_element < array_length){
                if(comparison_number > sortingArray[current_element]){
                    sortingArray[focus_element] = sortingArray[current_element];
                    sortingArray[current_element] = comparison_number;
                    comparison_number = sortingArray[focus_element];
                }  
                current_element++;
                count++;
            }  
            focus_element++;
        }  
        return count;                    
    }  
}",0,0,1,0,0,0,0,0,0
1126,"from structures.src.util.sort_util import swap
def sort(arr):
    out = list(arr)
    for i in range(0, len(out)):
        min_index = i
        for j in range(i, len(out)):
            if(out[j] < out[min_index]):
                min_index = j
        swap(out, i, min_index)
    return out",0,0,1,0,0,0,0,0,0
1127,"package Sorting;
public class Selection {
	public static <T extends Comparable<T>> void SelectionSort(T arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j].compareTo(arr[min_idx]) < 0)
                    min_idx = j;
            T temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(byte arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            byte temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(char arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            char temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(short arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            short temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(long arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            long temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(float arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            float temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
	public static void SelectionSort(double arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            double temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
}",0,0,1,0,0,0,0,0,0
1128,"import java.util.*;
class SelectionSort
{
    void selsort(int arr[])
    {
        int n = arr.length;
        int i,j,k;
        int min_index;
        for(i=0;i<n-1;i++)
        {
            min_index = i;
            for(j=i+1;j<n;j++)
            {
                if(arr[j]<arr[min_index])
                    min_index = j;
            }
            int temp = arr[min_index];
            arr[min_index] = arr[i];
            arr[i] = temp;
        }
        System.out.println(""The sorted array is:-"");
        for(i=0;i<n;i++)
        {
            System.out.println(arr[i]);
        }
    }
}
class Prog1
{
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        int arr[];
        int n;
        System.out.println(""Enter number of elements in array:-"");
        n = sc.nextInt();
        arr = new int[n];
        for(int i = 0;i<n;i++)
        {
            System.out.println(""Enter element ""+i);
            arr[i]= sc.nextInt();
        }
        SelectionSort s = new SelectionSort();
        s.selsort(arr);
    }
}",0,0,1,0,0,0,0,0,0
1129,"def swap(list , pos1 , pos2):
	list[pos1] , list [pos2] = list[pos2] , list [pos1]
 return list
def selection_sort(list):
	for i in range(0 , len(a)-1):
		k = i
  for j in range(i , len(a)):
			if list[j] < list[k]:
				k = j
  swap(list , k , i)
 return list
a = [2,7,4,1,5,3]
print(a)
selection_sort(a)
print(a)",0,0,1,0,0,0,0,0,0
1130,"package com.sorting;
import java.util.Comparator;
public class Selection {
	private Selection() {
	}
	public static void sort(Comparable[] array) {
		if(array == null)
			throw new NullPointerException();
		int size = array.length;
		int min;
		for (int i = 0; i < size; i++) {
			min = i;
			for (int j = i + 1; j < size; j++) {
				if (less(array[j], array[min]))
					min = j;
			}
			exchange(array, i, min);
		}
	}
	public static void sort(Object[] array, Comparator c) {
		if(array == null)
			throw new NullPointerException();
		int size = array.length;
		int min;
		for (int i = 0; i < size; i++) {
			min = i;
			for (int j = i + 1; j < size; j++) {
				if (less(c, array[j], array[min]))
					min = j;
			}
			exchange(array, i, min);
		}
	}
	private static boolean less(Comparable v, Comparable w) {
		return v.compareTo(w) < 0;
	}
	private static boolean less(Comparator c, Object v, Object w) {
		return c.compare(v, w) < 0;
	}
	private static void exchange(Object[] a, int i, int j) {
		Object temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
	public static void show(Comparable[] array) {
		int n = array.length;
		for (int i = 0; i < n; i++) {
			System.out.print(array[i] + "","");
		}
	}
}",0,0,1,0,0,0,0,0,0
1131,"__all__ = (""selection_sort"",)
from typing import List, TypeVar
T = TypeVar(""T"")
def selection_sort(
    data: List[T], *, reverse: bool = False, inplace: bool = False
) -> List[T]:
    if not inplace:
        data = data.copy()
    comparison_op: str = ""__lt__"" if reverse else ""__gt__""
    max_len: int = len(data)
    for i in range(max_len - 1):
        minmax_index: int = i
        for j in range(i + 1, max_len):
            if getattr(data[minmax_index], comparison_op)(data[j]):
                minmax_index = j
        data[i], data[minmax_index] = data[minmax_index], data[i]
    return data",0,0,1,0,0,0,0,0,0
1132,"from __future__ import print_function
def selection_sort(collection):
    length = len(collection)
    for i in range(length - 1):
        least = i
        for k in range(i + 1, length):
            if collection[k] < collection[least]:
                least = k
        collection[least], collection[i] = (
            collection[i], collection[least]
        )
    return collection
if __name__ == '__main__':
    try:
        raw_input          
    except NameError:
        raw_input = input  
    user_input = raw_input('Enter numbers separated by a comma:\n').strip()
    unsorted = [int(item) for item in user_input.split(',')]
    print(selection_sort(unsorted))",0,0,1,0,0,0,0,0,0
1133,"def selectionsort(lst):
    if len(lst) <= 1:
        return lst
    else:
        for i in range(len(lst)-1):
            for j in range(i, len(lst)):
                if lst[j] < lst[i]:
                    lst[j], lst[i] = lst[i], lst[j]
        return lst
lst = [7, 5, 3, 1, 5, 9, 8, 4, 6, 2, 10]
print(selectionsort(lst))",0,0,1,0,0,0,0,0,0
1134,"def selection_sort(arr):
    for k in range(len(arr)):
        min_index = k 
        for j in range(k + 1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
        arr[k], arr[min_index] = arr[min_index], arr[k]
nums = [85, 45, 12, 23, 41]
selection_sort(nums)
print(nums)",0,0,1,0,0,0,0,0,0
1135,"def selection_sort(arr):        
    for i in range(len(arr)):
        minimum = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[minimum]:
                minimum = j
        arr[minimum], arr[i] = arr[i], arr[minimum]
    return arr",0,0,1,0,0,0,0,0,0
1136,"def selection_sort(a):
    b = [*a]
    n = len(b)
    for i in range(n):
        min = i
        for j in range(i+1, n):
            if b[j] < b[min]:
                min = j
        b[i], b[min] = b[min], b[i]
    return b
if __name__ == ""__main__"":
    import unittest
    from random import shuffle
    class TestSelectionSort(unittest.TestCase):
        def setUp(self):
            self.ordered = [x for x in range(20)]
            self.shuffled = [*self.ordered]
            while self.ordered == self.shuffled:
                shuffle(self.shuffled)
        def test_selection_sort(self):
            self.assertEqual(self.ordered, selection_sort(self.shuffled))
            self.assertNotEqual(self.ordered, self.shuffled)
    unittest.main()",0,0,1,0,0,0,0,0,0
1137,"def SelectionSort(A,n):
    for i in range(0,n-1):
        iMin=i
        for j in range(i+1,n):
            if(A[j]<A[iMin]):
                iMin=j
        A[i],A[iMin]=A[iMin],A[i]
if __name__==""__main__"":
    A=[]
    print(""Enter the elements in array:"")
    A=list(map(int,input().split("" "")))
    n=len(A)
    print(n,A)
    SelectionSort(A,n)
    for j in range(0,n):
        print(A[j],end="" "")",0,0,1,0,0,0,0,0,0
1138,"package Sorting;
public class Selection_Sort {
    void Selection_Sort(int[] givenArr){
        int min;
        int index_min;
        int[] tmp;
        for(int i=0;i<givenArr.length;i++){
            tmp = find_min(givenArr,i);
            index_min = tmp[1];
            min = tmp[0];
            for(int j=index_min;j>i;j--){
                givenArr[j]=givenArr[j-1];
            }
            givenArr[i]=min;
        }
    }
    private int[] find_min(int[] givenArr,int start) {
        int min = givenArr[start];
        int index_min = start;
        for(int i=start+1;i<givenArr.length;i++){
            if(min>givenArr[i]){
                min = givenArr[i];
                index_min = i;
            }
        }
        return new int[]{min, index_min};
    }
    public static void main(String[] args) {
        int[] given_arr = new int[]{10,2,8,1,4,6,5,7,9};
        Selection_Sort selection_sort = new Selection_Sort();
        selection_sort.Selection_Sort(given_arr);
        selection_sort.printArr(given_arr);
    }
    private void printArr(int[] given_arr) {
        for(int i=0;i<given_arr.length;i++){
            System.out.print(given_arr[i]+"" "");
        }
    }
}",0,0,1,0,0,0,0,0,0
1139,"import copy
import sort_tools
def selection_sort(data, low, high):
    for i in range(low, high):
        min = i
        for j in range(i+1, high):
            if data[j] < data[min]:
                min = j
        temp = data[i]
        data[i] = data[min]
        data[min] = temp
@sort_tools.timeit('selection')            
def sort(data):
    selection_sort(data, 0, len(data))
def main():
    data = sort_tools.build_data_set(20)
    unsorted = copy.deepcopy(data)
    sort(unsorted)
    print(data)
    print(unsorted)
if __name__ == ""__main__"":
    main()",0,0,1,0,0,0,0,0,0
1140,"class selection_sort
{
    void sort(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n-1; i++)
        {
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
    void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i]+"" "");
        System.out.println();
    }
    public static void main(String args[])
    {
        selection_sort ob = new selection_sort();
        int arr[] = {64,25,12,22,11};
        ob.sort(arr);
        System.out.println(""Sorted array"");
        ob.printArray(arr);
    }
}",0,0,1,0,0,0,0,0,0
1141,"def sort(arr):
    alen = len(arr)
    for sort_index in range(0, alen):
        min_index = sort_index
        for i in range(sort_index, alen):
            if arr[i] < arr[min_index]:
                min_index = i
        arr[sort_index], arr[min_index] = arr[min_index], arr[sort_index]",0,0,1,0,0,0,0,0,0
1142,"public class selection_sort 
{
    static void selectionSort(int arr[]) {
        for(int k = 0; k < arr.length-1; k++) {
            int min_idx = k;
            for(int j = k+1; j < arr.length; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;
            int temp = arr[min_idx];  
            arr[min_idx] = arr[k];
            arr[k] = temp;
        }
    }
    static void printArray(int[] arr) {
        for(int i=0; i<arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
    }
    public static void main(String args[]) {
        int arr[] = {64,25,12,22,11};
        selectionSort(arr);
        printArray(arr);
    }
}",0,0,1,0,0,0,0,0,0
1143,"def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[min_idx] > arr[j]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr",0,0,1,0,0,0,0,0,0
1144,"package part2;
public class Selection_Sort {
	public static Comparable[] Selection_Sort(Comparable[] a) {
		for(int i=0; i<a.length; i++) {
			int min = i;
			for(int j=i+1; j<a.length; j++) {
				if(less(a[j],a[min]))
					min = j;
			}
			swap(a, i, min);
		}
		return a;
	}
	private static boolean less(Comparable a, Comparable b) {
		if(a.compareTo(b) < 0) {
			return true;
		}
		return false;
	}
	private static void swap(Comparable[] a, int i, int min) {
		Comparable temp = a[i];
		a[i] = a[min];
		a[min] = temp;
	}
}",0,0,1,0,0,0,0,0,0
1145,"def selection_sort(arr):
    for i in range(len(arr)):
        min = i
        for j in range(i+1,len(arr)):
            if arr[j] < arr[min]:
                min = j
        arr[i],arr[min] = arr[min],arr[i]
    return arr",0,0,1,0,0,0,0,0,0
1146,"from strategy import Order, BadOrderError
import sys
__author__ = ""Pablo Acereda""
__copyright__ = ""Copyright 2020""
__credits__ = [ ""Pablo Acereda"" ]
__license__ = ""Apache License 2.0""
__version__ = ""1.0""
__maintainer__ = ""Pablo Acereda""
__email__ = ""p.aceredag@gmail.com""
def sort(array:list, order:Order=Order.ASC) -> list:
    if (order not in [Order.ASC, Order.DESC]):
        raise BadOrderError(""Not Valid Ordering Preference"")
    for i in range (len(array)):
        idx = i
        for j in range(i + 1, len(array)):
            if   (order == Order.ASC):  
                if (array[idx] > array[j]): 
                    idx = j
            elif (order == Order.DESC): 
                if (array[idx] < array[j]):
                    idx = j
        array[i], array[idx] = array[idx], array[i]
    return array",0,0,1,0,0,0,0,0,0
1147,"import time
import random
def selection_sort(data):
	for i in range(len(data) - 1):
		for j in range(i+1, len(data)):
			if data[j] < data[i]:
				data[j],data[i] = data[i],data[j]
if __name__ == '__main__':
	lista = [_ for _ in range(1000)]
 random.shuffle(lista)
 start_time = time.time()
 selection_sort(lista)
 end_time = time.time()
 print(""Time: "", end_time - start_time)
 print(lista)",0,0,1,0,0,0,0,0,0
1148,"def with_length():
    flag = 1
    while(flag):
        print(""Length of array"")
        try:
            n = int(input())
            flag=0
        except:
            flag=1
    print(""It only store first "",n,"" elements."")
    print(""\nEnter your elements."")
    arr =[]
    while len(arr)<n:
        val = list(map(float,input().split()))
        length = n - len(arr)
        if len(val)>length:
            arr = arr+val[:length]
        else:
            arr = arr+val
    return arr
def without_length():
    print(""Array only takes integer or float inputs. Enter '$' to stop"")
    arr = list(map(float,input().split()))
    while(1):
        val = input().split()
        for x in val:
            try:
                x = float(x)
            except:
                return arr
            arr.append(float(x))
def list_input():
    ch =""""
    while ch not in ['y','n','Y','N']:
        print(""Want to specify the length of arry y/n "",end=' ')
        ch = input()
    if ch=='Y' or ch=='y':
        arr = with_length()
        return arr
    else:
        arr= without_length()
        return arr
def selection_sort(alist):
    for i in range(0, len(alist) - 1):         
        smallest = i                           
        for j in range(i + 1, len(alist)):     
            if alist[j] < alist[smallest]:     
                smallest = j                   
        alist[i], alist[smallest] = alist[smallest], alist[i]     
if __name__ == '__main__':
    arr = list_input()   
    print ('Given array is', end='\n')
    print(*arr)
    selection_sort(arr)
    print('Sorted array is:', end='\n')
    print(*arr)",0,0,1,0,0,0,0,0,0
1149,"def selection_sort (num_list):
	for items in range(len(num_list)-1,0,-1):
		max_pos = 0
  for item in range(1,items+1):
			if num_list[max_pos] < num_list[item]:
				max_pos = item
  temp = num_list[max_pos]
  num_list[max_pos] = num_list[item]
  num_list[item] = temp
 return num_list
print selection_sort([54,26,93,17,77,31,44,55,20])",0,0,1,0,0,0,0,0,0
1150,"function indexOfMin(list) {
    var minIndex = 0;
    for(var i = 0; i < list.length; i++) {
        if (list[i] < list[minIndex]) {
            minIndex = i;
        }
    }
    return minIndex;
}
function selectionSort(list) {
    var sortedList = [];
    while(list.length > 0) {
        var indexToMove = indexOfMin(list);
        sortedList.push(list.splice(indexToMove, 1)[0]);
    }
    return sortedList;
}
const testValues = [29, 100, 1, 2, 57, 28, 88, 3, 50, 67, 37, 1, 32, 20];
var sorted = selectionSort(testValues);
console.log(sorted);",0,0,1,0,0,0,0,0,0
1151,"def selection_sort(values):
    sorted_list = []
    for _idx in range(0, len(values)):
        index_to_move = index_of_min(values)
        sorted_list.append(values.pop(index_to_move))
    return sorted_list
def index_of_min(values):
    min_index = 0
    for i in range(1, len(values)):
        if values[i] < values[min_index]:
            min_index = i
    return min_index
numbers = [14, 3, 1, 9, 10, 4, 6, 2, 21, 13]
print(selection_sort(numbers))",0,0,1,0,0,0,0,0,0
1152,"public class Sorting {
	public static void InsertionSort(String[] words)
	{
		String key;
		int count;
		for (int i = 1; i < words.length; i++)
		{
			key = words[i];
			count = i-1;
			while (count >= 0 && words[count].compareToIgnoreCase(key) > 0)
			{
				words[count+1] = words[count];
				count = count-1;
			}
			words[count+1] = key;
		}
	}
	public static int[] SelectionSort(int[] A)
	{
		int temp = A[0];
		int largest = A[0];
		int [] sortedNumbers = new int[A.length];
		for (int a = 0; a < A.length; a++)
		{
			for (int i = 0; i < A.length; i++)
			{
				if (temp > (A[i]))
				{
					temp = A[i];
				}
				if (largest < A[i])
				{
					largest = A[i];
				}
			}
			sortedNumbers[a] = temp;
			for (int i = 0; i < A.length; i++)
			{
				if (A[i] == temp)
				{
					A[i] = largest + 1;
					break;
				}
			}
			temp = largest;
		}
		return sortedNumbers;	
	}
}",0,0,1,1,0,0,0,0,0
1153,"package sort.primary;
import sort.Sort;
public class SelectionSort extends Sort {
    @Override
    public void sortMethod(Comparable[] a) {
        for (int i = 0; i < a.length; i++) {
            int min = i;
            for (int j = i + 1; j < a.length; j++)
                if (less(a[j], a[min])) min = j;
            exch(a, i, min);
        }
    }
    public static void sort(Comparable[] a) {
        SelectionSort sort = new SelectionSort();
        sort.sortMethod(a);
    }
}",0,0,1,0,0,0,0,0,0
1154,"function selectionSort(A) {
    var len = array_length(A);
    for (var i = 0; i < len - 1; i = i + 1) {
        var j_min = i;
        for (var j = i + 1; j < len; j = j + 1) {
            if (A[j] < A[j_min]) {
                j_min = j;
            } else {}
        }
        if (j_min !== i) {
            swap(A, i, j_min);
        } else {}
    }
}
function swap(A, x, y) {
    var temp = A[x];
    A[x] = A[y];
    A[y] = temp;
}",0,0,1,0,0,0,0,0,0
1155,"def select_max(A,left,right):
    max_pos = left
    i= left
    while i<= right:
        if A[i] > A[max_pos]:
            max_pos = i
        i = i + 1
    return max_pos
def selection_sort(A):
    for i in range (len(A) -1, 0, -1):
        max_pos = select_max(A, 0, i)
        if max_pos != i:
            tmp = A[i]
            A[i] = A[max_pos]
            A[max_pos] = tmp
    print (i,A)
if __name__ == '__main__':
    list = [5, 10, 58, 23, 1, 2]
    selection_sort(list)",0,0,1,0,0,0,0,0,0
1156,"public class SelectionSort {
    public static int[] selectionSort(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            int min_index = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[min_index]) {
                    min_index = j;
                }
            }
            int temp = arr[min_index];
            arr[min_index] = arr[i];
            arr[i] = temp;
        }
        return arr;
    }
}",0,0,1,0,0,0,0,0,0
1157,"class SelectionSort:
    def sort(A):
        def swap(A, u, v):
            temp = A[u]
            A[u] = A[v]
            A[v] = temp
        a_len = len(A)
        for i in range(0, a_len - 1):
            curr_min = i
            for j in range(i+1, a_len):
                if(A[j] < A[curr_min]):
                   curr_min = j
            swap(A, i, curr_min)
        return A",0,0,1,0,0,0,0,0,0
1158,"package src.algorithms;
import src.strategy.Order;
public class SelectionSort<T> extends SortingAlgorithm<T> {
	@Override
	@SuppressWarnings(""hiding"")
	public <T extends Comparable<T>> T[] sort(T[] elements, Order order) {
		int numElements = elements.length;
		for (int i=0; i<numElements-1; i++) {
			int posEdgeElement = i;
			for (int j=i+1; j<numElements; j++) {
				if ((order == Order.ASC  && elements[posEdgeElement].compareTo(elements[j]) > 0)  ||
					(order == Order.DESC && elements[posEdgeElement].compareTo(elements[j]) < 0)) {
					posEdgeElement = j;
				}
			}
			swap(elements, i, posEdgeElement);
		}
		return elements;
	}
}",0,0,1,0,0,0,0,0,0
1159,"def selectionSort(list):
    for i in range(0, len(list) - 1):
        minimumIndex = i
        for j in range(i + 1, len(list)):
            if list[minimumIndex] > list[j]:
                minimumIndex = j
        list[i], list[minimumIndex] = list[minimumIndex], list[i]
    return list
myList = [43,54,15,13,45,87,545,435,63,245,15,753,45,2,534,15]
print(myList)
print(selectionSort(myList))",0,0,1,0,0,0,0,0,0
1160,"package javaSorting;
public class SelectionSort {
	public static void sort(int data[]) {
		for (int i = 0; i < data.length - 1; i++) {
			for (int j = i + 1; j < data.length; j++) {
				if (data[j] < data[i]) {
					int temp = data[j];
					data[j] = data[i];
					data[i] = temp;
				}
			}
		}
	}
	private static void printSortedArray(int data[]) {
		for (int i = 0; i < data.length; i++) {
			System.out.println(data[i]);
		}
	}
	public static void main(String[] args) {
		int SIZE = 1000;
		int[] data = new int[SIZE];
		for (int i = 0; i < SIZE; i++) {
			data[i] = i;
		}
		Shuffle.shuffleData(data);
		long start = System.currentTimeMillis();
		sort(data);
		float elapsed = (System.currentTimeMillis() - start) / 1000;
		printSortedArray(data);
		System.out.println(elapsed);
	}
}",0,0,1,0,0,0,0,0,0
1161,"def SelectionSort(list):
    n = len(list)
    for i in range(n):
        for j in range(i+1, n):
            if list[i] > list[j]:
                list[i], list[j] = list[j], list[i]",0,0,1,0,0,0,0,0,0
1162,"import java.util.Scanner;
public class SelectionSort {
    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the number of elements : "");
        int n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter "" + n + "" elements :"");
        for (int i = 0; i < n; i++)
            arr[i] = sc.nextInt();
        selectionSort(arr);
        System.out.println(""\nThe sorted array : ;"");
        for (int i = 0; i < n; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    static void selectionSort(int arr[]) {
        int len = arr.length, pos, tmp;
        for (int i = 0; i < len; i++) {
            pos = i;
            for (int j = i + 1; j < len; j++) {
                if (arr[j] < arr[pos])
                    pos = j;
            }
            tmp = arr[i];
            arr[i] = arr[pos];
            arr[pos] = tmp;
        }
    }
}",0,0,1,0,0,0,0,0,0
1163,"def selection_sort(nums):
    for i in range(len(nums)):
        lowest_value_index = i
        for j in range(i + 1, len(nums)):
            if nums[j] < nums[lowest_value_index]:
                lowest_value_index = j
        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]
random_list_of_nums = [12, 8, 3, 20, 11]
selection_sort(random_list_of_nums)
print(random_list_of_nums)",0,0,1,0,0,0,0,0,0
1164,"public class SelectionSort
{
    private int[] A;
    public SelectionSort(int[] data)
    {
        A = data;
    }
    public int[] sort()
    {
        int a_len = A.length;
        for(int i=0; i<a_len-1; i++)
        {
            int curr_min = i;
            for(int j=i+1; j<a_len; j++)
            {
                if(A[j] < A[curr_min])
                {
                    curr_min = j;
                }
            }
            swap(A, i, curr_min);
        }
        return A;
    }
    private void swap(int[] A, int u, int v)
    {
        int temp;
        temp = A[u];
        A[u] = A[v];
        A[v] = temp;
    }
}",0,0,1,0,0,0,0,0,0
1165,"def selectionSort(l):
    for start in range(len(l)):
        minpos=start
        for i in range(start,len(l)):
            if(l[i]<l[minpos]):
                minpos=i
        (l[start],l[minpos]) = (l[minpos],l[start])
if __name__ == ""__main__"":
    print('Enter sequence(separated by spaces): ')
    arr=[int(x) for x in input().split()]
    selectionSort(arr)
    print(arr)",0,0,1,0,0,0,0,0,0
1166,"public class SelectionSort {
	public static void sort(int arr[]) {
		int arrLen = arr.length;
		for (int i = 0; i < arrLen - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j < arrLen; j++) {
				if (arr[j] < arr[minIndex]) {
					minIndex = j;
				}
			}
			int temp = arr[minIndex];
			arr[minIndex] = arr[i];
			arr[i] = temp;
		}
	}
}",0,0,1,0,0,0,0,0,0
1167,"import time
from functools import partial
from operator import getitem
numbers = []
def selection_sort():
    n = len(numbers)
    for i in range (0, n-1):
        minI = min(range(i,n), key = partial(getitem, numbers))
        numbers[i], numbers[minI] = numbers[minI], numbers[i] 
def read_from_file(filepath):
    del numbers[:] 
    file = open(filepath, ""r"")
    for i in file:
        numbers.append(int(i))
def print_first_ten_number():
    print numbers[0:9]
def print_last_ten_number():
    print numbers[len(numbers)-10:len(numbers)]
def append_result_to_file(str):
    with open(""results.txt"", ""a"") as result:
        result.write(str+""\n"")
        result.close()
if __name__==""__main__"":                       
    read_from_file(""../test.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""1k = "" + str(end-start))
    read_from_file(""../10k.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""10k = "" + str(end-start))
    read_from_file(""../100k.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""100k = "" + str(end-start))
    read_from_file(""../1m.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""1m = "" + str(end-start))
    read_from_file(""../2m.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""2m = "" + str(end-start))     
    read_from_file(""../4m.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""4m = "" + str(end-start))
    read_from_file(""../8m.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""8m = "" + str(end-start))
    read_from_file(""../10m.lst"")
    start = time.clock()
    selection_sort()
    end = time.clock()
    append_result_to_file(""10m = "" + str(end-start))",0,0,1,0,0,0,0,0,0
1168,"package com.aokolnychyi.sorting;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
public class SelectionSort {
  public static <T extends Comparable<? super T>> void sort(List<T> elements) {
    for (int outerIndex = 0; outerIndex < elements.size(); outerIndex++) {
      int currentMinElementIndex = outerIndex;
      for (int innerIndex = outerIndex + 1; innerIndex < elements.size(); innerIndex++) {
        T currentMinElement = elements.get(currentMinElementIndex);
        T currentElement = elements.get(innerIndex);
        if (currentElement.compareTo(currentMinElement) < 0) {
          currentMinElementIndex = innerIndex;
        }
      }
      if (currentMinElementIndex != outerIndex) {
        Collections.swap(elements, currentMinElementIndex, outerIndex);
      }
    }
  }
  public static void main(String[] args) {
    final List<Integer> list = new ArrayList<>();
    list.add(4);
    list.add(1);
    list.add(5);
    list.add(3);
    list.add(9);
    list.add(10);
    list.add(1);
    sort(list);
    System.out.println(list);
  }
}",0,0,1,0,0,0,0,0,0
1169,"import time
from colors import *
def selection_sort(data, drawData, timeTick):
    for i in range(len(data)-1):
        minimum = i
        for k in range(i+1, len(data)):
            if data[k] < data[minimum]:
                minimum = k
        data[minimum], data[i] = data[i], data[minimum]
        drawData(data, [YELLOW if x == minimum or x == i else BLUE for x in range(len(data))] )
        time.sleep(timeTick)
    drawData(data, [BLUE for x in range(len(data))])",0,0,1,0,0,0,0,0,0
1170,"package sorting;
public class selectionSort {
    static int min(int a[],int start,int end){
        int minindex=start;
        for(int i=start;i<=end;i++){
            if(a[i]<a[minindex]){minindex=i;}
        }
        return minindex;
    }
    static void selectionsort(int a[]){
        for(int i=0;i<a.length-1;i++){
                int min = min(a,i,a.length-1);
                swap(a,i,min);
        }
    }
    static void swap(int a[],int p,int q){
                    int temp = a[p];
                    a[p]=a[q];
                    a[q]=temp;
    }
}",0,0,1,0,0,0,0,0,0
1171,"import time
def sort(bar, layout, num, colors):
    data = list(bar.y)
    count = 0
    for i in range(num): 
        min_index = i
        for j in range(i+1, num): 
            count += 1
            layout.xaxis.title.text = ""Number of operations: "" + str(count)
            if data[min_index] > data[j]:
                colors[j] = 'crimson'
                colors[min_index] = 'lightslategray'
                colors[i] = 'red'
                bar.marker.color = colors
                time.sleep(0.1)
                min_index = j
            else: 
                colors[j] = 'green'
                bar.marker.color = colors
                time.sleep(0.1)
            colors[j] = 'lightslategray'
            colors[min_index] = 'red'
            bar.marker.color = colors
        data[min_index], data[i] = data[i], data[min_index]
        count += 1
        layout.xaxis.title.text = ""Number of operations: "" + str(count)
        colors[min_index] = 'lightslategray'
        bar.y = data
        colors[i] = 'blue'
        bar.marker.color = colors",0,0,1,0,0,0,0,0,0
1172,"package main;
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr1 = {10, 34, 2, 56, 7, 67, 88, 42};
        doSelectionSort(arr1);
        for (int num : arr1) {
            System.out.print(num);
            System.out.print("", "");
        }
    }
    public static void doSelectionSort(int[] input) {
        for (int i = 0; i < input.length; i++) {
            int index = i;
            for (int j = i + 1; j < input.length; j++) {
                if (input[j] < input[index]) {
                    index = j;
                }
            }
            int tmp = input[index];
            input[index] = input[i];
            input[i] = tmp;
        }
    }
}",0,0,1,0,0,0,0,0,0
1173,"package eu.happycoders.sort.method;
public class SelectionSort implements SortAlgorithm {
  @Override
  public void sort(int[] elements) {
    int length = elements.length;
    for (int i = 0; i < length - 1; i++) {
      int minPos = i;
      int min = elements[minPos];
      for (int j = i + 1; j < length; j++) {
        if (elements[j] < min) {
          minPos = j;
          min = elements[minPos];
        }
      }
      if (minPos != i) {
        elements[minPos] = elements[i];
        elements[i] = min;
      }
    }
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    int length = elements.length;
    for (int i = 0; i < length - 1; i++) {
      counters.incIterations();
      int minPos = i;
      int min = elements[minPos];
      counters.incReads();
      counters.incLocalVariableAssignments();
      for (int j = i + 1; j < length; j++) {
        counters.incIterations();
        int numAtJ = elements[j];
        counters.incReads();
        counters.incComparisons();
        if (numAtJ < min) {
          minPos = j;
          min = numAtJ;
          counters.incLocalVariableAssignments();
        }
      }
      if (minPos != i) {
        elements[minPos] = elements[i];
        counters.incReads();
        elements[i] = min;
        counters.incWrites();
      }
    }
  }
}",0,0,1,0,0,0,0,0,0
1174,"require('../../../common/array-extensions');
const { isEmpty, isFunction } = require('../../../common/utils');
const selectionSort = function(list) {
    if (isEmpty(list)) {
        return list;
    }
    if (list.length < 2) {
        return list;
    }
    const allItemsComparable = list.reduce(
        (acc, item) => (acc &= isFunction(item.compareTo)),
        true
    );
    let maxValueIndex = 0;
    for (let lastUnsortedIndex = list.length - 1; lastUnsortedIndex > 0; lastUnsortedIndex--) {
        maxValueIndex = lastUnsortedIndex;
        for (let i = 0; i <= lastUnsortedIndex; i++) {
            if (allItemsComparable) {
                if (list[i].compareTo(list[maxValueIndex]) > 0) {
                    maxValueIndex = i;
                }
            } else {
                if (list[i] > list[maxValueIndex]) {
                    maxValueIndex = i;
                }
            }
        }
        list.swap(maxValueIndex, lastUnsortedIndex);
    }
    return list;
};
module.exports = { selectionSort };",0,0,1,0,0,0,0,0,0
1175,"function selectionSort(array) {
  for (let i = 0; i < array.length - 1; i++) {
    let min = array[i];
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < min) {
        min = array[j];
        array[j] = array[i];
        array[i] = min;
      }
    }
  }
}
let myArray = [3, 7, 5, 6, 4, 2];
selectionSort(myArray);
console.log(myArray);
myArray = [1, 2, 3, 4, 5];
selectionSort(myArray);
console.log(myArray);
myArray = [5, 4, 3, 2, 1];
selectionSort(myArray);
console.log(myArray);",0,0,1,0,0,0,0,0,0
1176,"def selectionSort(a):
    for i in range(len(a)):
        current_min = i
        for j in range(i+1,len(a)):
            if a[current_min] > a[j]:
                current_min = j
        a[i], a[current_min] = a[current_min], a[i]
a = [8, 3, 2, 7, 4, 6, 8]
print(""Before Sorting:"")
for i in range(0, len(a)):
    print(a[i], end = ' ')
print()
print(""After Sorting:"") 
selectionSort(a)
for i in range(0, len(a)):
    print(a[i], end = ' ')
print()",0,0,1,0,0,0,0,0,0
1177,"package Sorts;
public class SelectionSort implements SortAlgorithm {
    @Override
    public <T extends Comparable<T>> T[] sort(T[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            int min = i;
            for (int j = i +1 ; j < n; j++) {
                if (SortUtils.less(arr[j], arr[min])) {
                    min = j;
                }
            }
            if (min != i) {
                SortUtils.swap(arr, i , min);
            }
        }
        return arr;
    }
    public static void main(String[] args) {
        Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};
        SelectionSort selectionSort = new SelectionSort();
        Integer[] sorted = selectionSort.sort(arr);
        SortUtils.print(sorted);
        String[] strings = {""c"", ""a"", ""e"", ""b"",""d""};
        String[] sortedStrings = selectionSort.sort(strings);
        SortUtils.print(sortedStrings);
    }
}",0,0,1,0,0,0,0,0,0
1178,"package com.deepak.algorithms.Sorting;
import com.deepak.algorithms.Library.ArrayUtils;
public class SelectionSort {
	public static Integer[] performSelectionSort(Integer[] list) {
		for (int i = 0; i < list.length - 1; i++) {
			int min = list[i];
			for (int j = i + 1; j < list.length; j++) {
				if (list[j] < min) {
					min = list[j];
					ArrayUtils.swap(list, i, j);
				}
			}
		}
		return list;
	}
}",0,0,1,0,0,0,0,0,0
1179,"package sortvisualiser.algorithms;
import sortvisualiser.SortArray;
public class SelectionSort implements ISortAlgorithm {
    private long stepDelay = 120;
    @Override
    public void runSort(SortArray array) {
        int len = array.arraySize();
        for (int i = 0; i < len - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < len; j++) {
                if (array.getValue(j) < array.getValue(minIndex)) {
                    minIndex = j;
                }
            }
            array.swap(i, minIndex, getDelay(), true);
        }
    }
    @Override
    public String getName() {
        return ""Selection Sort"";
    }
    @Override
    public long getDelay() {
        return stepDelay;
    }
    @Override
    public void setDelay(long delay) {
        this.stepDelay = delay;
    }
}",0,0,1,0,0,0,0,0,0
1180,"package sorting;
import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
public class SelectionSort {
  public static void sort(Comparable[] a) {
    int N = a.length;  
    for (int i = 0; i < N; i++) {  
      int min = i;  
      for (int j = i+1; j < N; j++)
        if (less(a[j], a[min])) min = j;
      exch(a, i, min);
    }
  }
  private static boolean less(Comparable v, Comparable w) { 
    return v.compareTo(w) < 0;  
  }
  private static void exch(Comparable[] a, int i, int j) { 
    Comparable t = a[i]; 
    a[i] = a[j]; 
    a[j] = t; 
  }
  private static void show(Comparable[] a) {  
	  for (int i = 0; i < a.length; i++)
	    StdOut.print(a[i] + "" "");
	    StdOut.println();
	  }
  public static boolean isSorted(Comparable[] a) {  
	  for (int i = 1; i < a.length; i++)
	    if (less(a[i], a[i-1])) return false;
	  return true;
	}
  public static void main(String[] args) {  
	  String[] a = StdIn.readAllStrings();
	  sort(a);
	  assert isSorted(a);
	  show(a);
	}
}",0,0,1,0,0,0,0,0,0
1181,"package selection_sort;
public class SelectionSort {
    public void sort(int[] array) {
        int tmp, minIndex, n = array.length;
        for (int i = 0; i < n - 1; i++) {
            minIndex = i;  
            for (int j = i + 1; j < n; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                tmp = array[i];
                array[i] = array[minIndex];
                array[minIndex] = tmp;
            }
        }
    }
}",0,0,1,0,0,0,0,0,0
1182,"package Jacob.Sorts;
import Jacob.*;
public class SelectionSort implements Runnable{
	private Integer[] toBeSorted;
	private VisualizerFrame frame;
	private boolean fast;
	public SelectionSort(Integer[] toBeSorted, VisualizerFrame frame, boolean fast) {
		this.toBeSorted = toBeSorted;
		this.frame = frame;
		this.fast = fast;
	}
	public void run() {
		if (fast) {
			sortFast();
		} else {
			sortSlow();
		}
		SortingVisualizer.isSorting=false;
	}
	public void sortFast(){
		int temp = 0;
		int selected = 0;
		for(int i = 0; i<toBeSorted.length; i++){
			selected = i;
			for(int j = toBeSorted.length-1; j>i; j--){
				if (toBeSorted[j] <= toBeSorted[selected]){
					selected = j;
				}				
			}
			frame.reDrawArray(toBeSorted);
			try {
				Thread.sleep(SortingVisualizer.sleep);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			temp = toBeSorted[i];
			toBeSorted[i] = toBeSorted[selected];
			toBeSorted[selected]= temp;
		}
	}
	public void sortSlow() {
		int temp = 0;
		int selected = 0;
		for(int i = 0; i<toBeSorted.length; i++){
			selected = i;
			for(int j = toBeSorted.length-1; j>i; j--){
				if (toBeSorted[j] <= toBeSorted[selected]){
					selected = j;
				}
				frame.reDrawArray(toBeSorted, selected, j-1);
				try {
					Thread.sleep(SortingVisualizer.sleep);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}				
			}
			temp = toBeSorted[i];
			toBeSorted[i] = toBeSorted[selected];
			toBeSorted[selected]= temp;
		}
		frame.reDrawArray(toBeSorted);
	}
}",0,0,1,0,0,0,0,0,0
1183,"package com.mehmetpekdemir.sort.selectionsort;
import com.mehmetpekdemir.shared.Util;
public final class SelectionSort {
	public static void sort(int[] array) {
		for (int lastUnsortedIndex = array.length - 1; lastUnsortedIndex > 0; lastUnsortedIndex--) {
			int largest = 0;
			for (int i = 1; i <= lastUnsortedIndex; i++) {
				if (array[i] > array[largest]) {
					largest = i;
				}
			}
			Util.swap(array, largest, lastUnsortedIndex);
		}
	}
}",0,0,1,0,0,0,0,0,0
1184,"package sorting;
public class SelectionSort<T extends Comparable<T>> implements Sort<T> {
    @Override
    public void sort(T[] items) {
        for (int s = 0; s < items.length; s++) {
            int i = smallest(items, s, items.length - 1);
            SortUtils.swap(items, s, i);
        }
    }
    private int smallest(T[] items, int from, int to) {
        T smallest = items[from];
        int smallestIndex = from;
        for (int i = from; i <= to; i++) {
            if (items[i].compareTo(smallest) < 0) {
                smallest = items[i];
                smallestIndex = i;
            }
        }
        return smallestIndex;
    }
}",0,0,1,0,0,0,0,0,0
1185,"package dev.jeffreybender.sort;
import java.util.Comparator;
public final class SelectionSort {
    private SelectionSort() {
    }
    public static <T> void sort(T[] array, Comparator<? super T> comparator) {
        if (array.length <= 1) {
            return;
        }
        if (comparator == null) {
            comparator = SortUtils.getDefaultComparator();
        }
        for (int left = 0; left < array.length; left++) {
            int minIndex = left;
            for (int checkIndex = left + 1; checkIndex < array.length; checkIndex++) {
                if (comparator.compare(array[minIndex], array[checkIndex]) > 0) {
                    minIndex = checkIndex;
                }
            }
            if(minIndex != left) {
                SortUtils.swap(array, left, minIndex);
            }
        }
    }
    public static <T extends Comparable<? super T>> void sort(T[] array) {
        sort(array, null);
    }
}",0,0,1,0,0,0,0,0,0
1186,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class SelectionSort extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new SelectionSort();
	public void sort(SortArray array) {
		int length = array.length();
		for (int i = 0; i < length; i++) {
			int minIndex = i;
			for (int j = i + 1; j < length; j++) {
				if (array.compare(j, minIndex) < 0)
					minIndex = j;
			}
			array.swap(i, minIndex);
			array.setElement(i, SortArray.ElementState.DONE);
		}
	}
	private SelectionSort() {
		super(""Selection sort"");
	}
}",0,0,1,0,0,0,0,0,0
1187,"import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;
class Sort
{
    void selectionSort(int arr[])
    {
        int min, temp;
        for (int i = 0; i < arr.length - 1; ++i)
        {
            min = i;
            for (int j = i + 1; j < arr.length; ++j)
            {
                if (arr[j] < arr[min])
                {
                    min = j;
                }
            }
            temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
    } 
    void Display(int arr[])
    {
        for (int i : arr)
        {
            System.out.print(i + ""  "");
        }
    }
}
class Main
{
    public static void main(String[] args)throws IOException
    {
        Sort obj = new Sort();
        BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
        System.out.println(""\n\t---SELECTION SORT---"");
        System.out.print(""Enter the size of array = "");
        int n = Integer.parseInt(buf.readLine());
        int[] arr = new int[n];
        System.out.println(""Enter elements -"");
        for(int i = 0; i < n ; ++i)
        {
            System.out.print((i + 1) +"" : "");
            arr[i] = Integer.parseInt(buf.readLine());
        }
        System.out.println(""Elements in the array : "");
        obj.Display(arr);
        obj.selectionSort(arr);
        System.out.println(""\nElements in ascending order : "");
        obj.Display(arr);
    }
}",0,0,1,0,0,0,0,0,0
1188,"exports.selectionSort = ({ list }, { shouldSwap, swap }) => {
  for (let i = 0; i < list.length - 1; i += 1) {
    let selectedIndex = i;
    for (let j = i + 1; j < list.length; j += 1) {
      if (shouldSwap(selectedIndex, j)) {
        selectedIndex = j;
      }
    }
    if (selectedIndex !== i) {
      swap(selectedIndex, i);
    }
  }
  return list;
};",0,0,1,0,0,0,0,0,0
1189,"const swap = (array, i, j) => {
  let temp = array[i];
  array[i] = array[j];
  array[j] = temp;
};
const selectionSort = array => {
  for (let i = 0; i < array.length - 1; i++) {
    let smallest = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[j] < array[smallest]) {
        smallest = j;
      }
    }
    swap(array, i, smallest);
  }
};
const array = [4, 5, 1, 3, 2];
selectionSort(array);
console.log(array);",0,0,1,0,0,0,0,0,0
1190,"from typing import List, TypeVar
T = TypeVar(""T"")
def selection_sort(arr: List[T]) -> None:
    for i in range(len(arr)):
        min_idx = i
        for j in range(i + 1, len(arr)):
            if arr[min_idx] > arr[j]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
if __name__ == ""__main__"":
    a = [64, 25, 12, 22, 11]
    selection_sort(a)
    print(""Sorted array"", a)",0,0,1,0,0,0,0,0,0
1191,"package Sorting;
import java.util.ArrayList;
import java.util.Scanner;
public class SelectionSort {
    public static void main(String[] args) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            arrayList.add(sc.nextInt());
        }
        sc.close();
        int elements_array[] = new int[arrayList.size()];
        for (int i = 0; i < arrayList.size(); i++) {
            elements_array[i] = arrayList.get(i);
        }
        elements_array = doSelectionSort(elements_array);
        for (int element : elements_array) {
            System.out.println(element);
        }
    }
    private static int[] doSelectionSort(int[] elements_array) {
        int min;
        for (int i = 0; i < elements_array.length; i++) {
            min = i;
            for (int j = i + 1; j < elements_array.length; j++) {
                if (elements_array[j] < elements_array[min]) {
                    min = j;
                }
            }
            doSwap(elements_array, i, min);
        }
        return elements_array;
    }
    private static void doSwap(int[] elements_array, int i, int j) {
        int temp = elements_array[i];
        elements_array[i] = elements_array[j];
        elements_array[j] = temp;
    }
}",0,0,1,0,0,0,0,0,0
1192,"package com.zhokhov.interview.sorting;
import static com.zhokhov.interview.util.Console.*;
public class SelectionSort {
    private int COMPARISONS_COUNT;
    private int SWAPS_COUNT;
    private int LOOP_COUNT;
    public void sort(int array[]) {
        COMPARISONS_COUNT = 0;
        SWAPS_COUNT = 0;
        LOOP_COUNT = 0;
        for (int index = 0; index < array.length; index++) {
            LOOP_COUNT++;
            ____cyan(""\n--------\nindex: "" + index);
            int minIndex = findNextSmallestElement(index, array);
            ____grey(""found smallest element index: "" + minIndex);
            SWAPS_COUNT++;
            ____blue(""Swapping: "" + index + "" and "" + minIndex);
            int temp = array[minIndex];
            array[minIndex] = array[index];
            array[index] = temp;
            __red(""==> "");
            __dump(array);
        }
    }
    private int findNextSmallestElement(int startIndex, int array[]) {
        int minIndex = startIndex;
        int value = array[startIndex];
        for (int i = startIndex; i < array.length; i++) {
            LOOP_COUNT++;
            COMPARISONS_COUNT++;
            if (value > array[i]) {
                minIndex = i;
                value = array[minIndex];
            }
        }
        return minIndex;
    }
    public static void main(String[] args) {
        int array[] = {7, 1, 8, 2, 0, 12, 10, 6, 5, 3};
        __yellow(""\nNew array: "");
        __dump(array);
        System.out.println(""\nSorting"");
        SelectionSort selectionSort = new SelectionSort();
        selectionSort.sort(array);
        __green(""\nResult: "");
        __dump(array);
        ____grey(""\nStatistics"");
        __green(""  Comparisons: "");
        System.out.print(selectionSort.COMPARISONS_COUNT);
        __green(""\n  Swaps: "");
        System.out.print(selectionSort.SWAPS_COUNT);
        __green(""\n  Loops: "");
        System.out.println(selectionSort.LOOP_COUNT);
    }
}",0,0,1,0,0,0,0,0,0
1193,"package ec;
import java.util.ArrayList;
public class SelectionSort<T extends Comparable<T>> implements SortingAlgorithms {
	private ArrayList<T> blist = null
	public SelectionSort() {
		ArrayList<T> b = new ArrayList<T>();
		blist = b;
		sortingAlgorithms();
	}
	private long comparisons = 0;
	private long swaps = 0;
	private long runtime = 0;
	static long start;
	static long end; 
	public ArrayList<T> selectionSort(ArrayList<T> list) {
		long comparisons = 0;
		long swaps = 1;
		int n;
		start = System.currentTimeMillis();
		for(int i = 0 ; i < list.size() - 1 ; i++) {
			n = i;
			for(int j = i + 1 ; j < list.size() ; j++) {
				comparisons++;
				if(list.get(j).compareTo(list.get(n)) < 0) {
					n = j;
				}
			}
			swaps++;
			if(n != i) {
				T move = list.get(i);
				list.set(i, list.get(n));
				list.set(n, move);
		}
		}
		this.comparisons = comparisons;
		this.swaps = swaps;
		end = System.currentTimeMillis();
		long runtimes = end - start;
		this.runtime = runtimes;
		return list;
	}
	public ArrayList<T> print(ArrayList<T> bubble) {
		ArrayList<T> bs = new ArrayList<T>();
		for(int i = 0 ; i < bubble.size() ; i++) {
			bs.add(bubble.get(i));
		}
		return bs;
	}
	public void compare() {
		System.out.print(""Comparisons: "" + this.comparisons);
	}
	public void swap() {
		System.out.print(""Swaps: "" + this.swaps);
	}
	public void runtime() {
		System.out.print(""Runtime: ""  + runtime + "" ms"");
	}
	@Override
	public void sortingAlgorithms() {
		this.blist = selectionSort(this.blist);
	}
}",0,0,1,0,0,0,0,0,0
1194,"public class SelectionSort {
	public static void sort(int list[]) {
		for (int i = 0; i < list.length; i++) {
			int min = i;
			for (int j = i; j < list.length; j++) {
				if (list[j] <= list[min]) {
					min = j;
				}
			}
			Compare.swap(list, i, min);
		}
	}
}",0,0,1,0,0,0,0,0,0
1195,"package org.manoj.ds.sort;
import java.time.Duration;
import java.time.Instant;
import org.apache.log4j.Logger;
public class SelectionSort implements Sort {
    final static Logger logger = Logger.getLogger(SelectionSort.class);
    private SortingMetadata metadata = null;
    @Override
    public <E extends Comparable<E>> void sort(E[] elements) {
        sort(elements, true);
    }
    @Override
    public <E extends Comparable<E>> void sort(E[] elements, boolean ascending) {
        metadata = new SortingMetadata(elements.length);
        Instant start = Instant.now();
        for (int lastUnsortedIndex = elements.length - 1; lastUnsortedIndex > 0; lastUnsortedIndex--) {
            logger.info(""lastUnsortedIndex="" + lastUnsortedIndex + "":"");
            int selectedElementIndex = 0;
            for (int selectionIndex = 1; selectionIndex <= lastUnsortedIndex; selectionIndex++) {
                if (ascending) {
                    if ((elements[selectedElementIndex].compareTo(elements[selectionIndex])) < 0) {
                        selectedElementIndex = selectionIndex;
                    }
                } else {
                    if ((elements[selectedElementIndex].compareTo(elements[selectionIndex])) > 0) {
                        selectedElementIndex = selectionIndex;
                    }
                }
                metadata.incrementIterationByOne();
            }
            Sort.swap(elements, selectedElementIndex, lastUnsortedIndex);
            metadata.increamentSwapOperationByOne();
            logger.info(""\tselectedElementIndex="" + selectedElementIndex + "" | selectedElementValue=""
                    + elements[selectedElementIndex] + "":"");
            Sort.logInfo(logger, elements);
        }
        Instant finish = Instant.now();
        metadata.setTimeTakenToExecute(Duration.between(start, finish).toNanos());
    }
    @Override
    public SortingMetadata getMetadata() {
        return metadata;
    }
}",0,0,1,0,0,0,0,0,0
1196,"import java.util.*;
public class selectionSort {
    public static void main(String[] args)  {
       Scanner x = new Scanner(System.in);
       System.out.println(""Please enter the length of Numbers:"");
       int t = x.nextInt();
       int [] arr= new int [t];
       System.out.println(""Please enter the Numbers:"");
       for(int i=0; i<t ;i++){
           arr[i] = x.nextInt();
       }
       ans(arr );
       x.close();
    }
    public static void printArray(int ar[]){
       for(int g : ar){
           System.out.print(g+"" "");
       }
    }
    public static void ans(int ar[]){
        for(int i=0 ; i<ar.length-1 ; i++){
            int min= i;  
            for(int j=i+1 ; j<ar.length ;j++){
                 if(ar[j]<ar[min]){
                     min=j;
                 }
             }
             if(min!=i){
                 int temp= ar[min];
                 ar[min]=ar[i];
                 ar[i]=temp;
             }
             System.out.println(""\n After the iteration ""+ i );     
             printArray(ar);         
        }
        System.out.println(""\nAfter  all the iteration -Sorted Array-""); 
        printArray(ar);
     }
}",0,0,1,0,0,0,0,0,0
1197,"package com.srt.sort;
import java.util.Arrays;
import java.util.function.BiFunction;
@SuppressWarnings(""unused"")
public class SelectionSort<T extends Comparable> extends JSort<T>{
    @Override
    T[] Sort(T[] array, BiFunction<T, T, Boolean> compare) {
        T[] arr = Arrays.copyOf(array, array.length);
        for (int i = 0; i < arr.length - 1; i++) {
            T key = arr[i];
            int index = i;
            for (int j = i; j < arr.length; j++) {
                if(compare.apply(arr[j], key)){
                    key = arr[j];
                    index = j;
                }
            }
            T temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
        return arr;
    }
}",0,0,1,0,0,0,0,0,0
1198,"import java.io.IOException;
import java.util.ArrayList;
public class SelectionSort extends Sorts{
	public ArrayList<Integer> selectionSort(ArrayList<Integer> unsortedList)
	{
		for(int i = 0; i < unsortedList.size(); i++)
		{
			int index = i;
			for(int j = i + 1; j < unsortedList.size(); j++)
			{
				if(unsortedList.get(index) > unsortedList.get(j))
				{
					index = j;
				}
			}
			if(i != index)
			{
				int holder = unsortedList.get(index);
				unsortedList.set(index, unsortedList.get(i));
				unsortedList.set(i, holder);
			}
		}
		return unsortedList;
	}
	public void SelectionTime(IOClass ioStream) throws IOException
	{
		ioStream.readFromFile();
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		long timeBefore = System.nanoTime();
		sortedList = selectionSort(ioStream.getInputArray());
		long timeAfter = System.nanoTime();
		double rawTime = timeAfter - timeBefore;
		double timeInMilli = rawTime/1000000;
		if(isSorted(sortedList))
		{
			ioStream.setInputArray(sortedList);
			System.out.print(""SelectionSort time (in Milli): ""); 
			System.out.println(timeInMilli);
		}
		else
		{
			System.out.println(""Not sorted!"");
		}
	}
}",0,0,1,0,0,0,0,0,0
1199,"public class SelectionSort {
	public static void selectionSort(int[] arr) {
		int k, temp, min;
		int n = arr.length;
		for (int i = 0; i < n - 1; i++) {
			min = i;
			for (k = i + 1; k < n; k++) {
				if (arr[min] > arr[k])
					min = k;
			}
			if (i != min) {
				temp = arr[i];
				arr[i] = arr[min];
				arr[min] = temp;
			}
		}
	}
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.print(""Enter the size: "");
		int size = Integer.parseInt(scanner.next());
		int[] arr = new int[size];
		for(int i=0;i<size;i++) {
			System.out.print(""Enter the element "" + (i+1) + "": "");
			arr[i] = Integer.parseInt(scanner.next());
		}
		selectionSort(arr);
		System.out.println(""Array after sort:"");
		System.out.print(""[ "");
		for(int i=0;i<size;i++)
			System.out.print(arr[i] + ((i == size-1) ? """" : "", ""));
		System.out.println("" ]"");
		scanner.close();
	}
}",0,0,1,0,0,0,0,0,0
1200,"function selectionSort(arr) {
  let minIdx,
    aux,
    len = arr.length;
  for (let i = 0; i < len; i++) {
    minIdx = i;
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIdx]) {
        minIdx = j;
      }
    }
    aux = arr[i];
    arr[i] = arr[minIdx];
    arr[minIdx] = aux;
  }
  return arr;
}",0,0,1,0,0,0,0,0,0
1201,"function selectionSort(data, low, high){
    for (let i = low; i < high; i++){
        let min = i;
        for (let j = i + 1; j < high; j++)
            if ( data[j] < data[min] )
                min = j;
        let temp = data[i];
        data[i] = data[min];
        data[min] = temp;
    }
}
function sort(data){
    selection_sort(data, 0, data.length);
}",0,0,1,0,0,0,0,0,0
1202,"import random
def selection_sort(alist):
    for i in range(len(alist)):
        min_position = i
        for j in range (i + 1, len(alist)):
            if alist[min_position] > alist[j]:
                min_position = j
        alist[i], alist[min_position] = alist[min_position], alist[i]
unordered_list = []
for i in range(100):
    unordered_list.append(i)
random.shuffle(unordered_list)
selection_sort(unordered_list)
print(unordered_list)
success = True
for index in range(len(unordered_list) - 1):
    if unordered_list[index] > unordered_list[index + 1]:
        success = False
if success:
    print(""Selection Sort successful!"")",0,0,1,0,0,0,0,0,0
1203,"import java.util.*;
public class SelectionSort {
    int[] selection(int a[]) {
        int x = 0;
        for (int j = 0; j < a.length - 1; j++) {
            int min = a[j];
            for (int i = j; i < a.length; i++) {
                if (a[i] < min) {
                    min = a[i];
                    x = i;
                }
            }
            if (a[x] < a[j]) {
                int t = a[x];
                a[x] = a[j];
                a[j] = t;
            }
            for (int k = 0; k < a.length; k++)
                System.out.print(a[k] + ""\t"");
            System.out.println();
        }
        return a;
    }
    public static void main(String args[]) {
        SelectionSort s = new SelectionSort();
        int a[] = { 64, 25, 12, 22, 11, 17, 56, 47 };
        int ans[] = s.selection(a);
        System.out.println(""The Final Sorted Array:"");
        for (int i = 0; i < a.length; i++) {
            System.out.print(ans[i] + ""\t"");
        }
    }
}",0,0,1,0,0,0,0,0,0
1204,"package Sorting;
import Comparing.BaseAreaCompare;
import Comparing.VolumeCompare;
import Objects.ThreeDGeoShape;
public class SelectionSort {
	public ThreeDGeoShape[] sort(String sortBy, ThreeDGeoShape[] shapeArray) {
		BaseAreaCompare ac = new BaseAreaCompare();
		VolumeCompare vc = new VolumeCompare();
		int result = 0 ;
		for (int i = 0; i < shapeArray.length - 1; i++) {
			int max = i;
			for (int j = i + 1; j < shapeArray.length; j++) {
				ThreeDGeoShape shape1 = shapeArray[max];
				ThreeDGeoShape shape2 = shapeArray[j];
				if (sortBy.equalsIgnoreCase(""h"")) {
					result = shape2.compareTo(shape1);
				} else if (sortBy.equalsIgnoreCase(""a"")) {
					result = ac.compare(shape2, shape1);
				} else if (sortBy.equalsIgnoreCase(""v"")) {
					result = vc.compare(shape2, shape1);
				}
				if (result == 1) {
					max = j;
				}
			}
			ThreeDGeoShape temp = shapeArray[max];
			shapeArray[max] = shapeArray[i];
			shapeArray[i] = temp;
		}
		return shapeArray;
	}
}",0,0,1,0,0,0,0,0,0
1205,"package io.github.marioluan.algorithms.sorting;
public final class SelectionSort extends Sortable {
    private SelectionSort() {
    }
    @SuppressWarnings(""rawtypes"")
    public static void sort(Comparable[] a) {
        int n = a.length;
        for (int i = 0; i < n; i++) {
            int min = findMin(a, i, n);
            swap(a, i, min);
        }
    }
}",0,0,1,0,0,0,0,0,0
1206,"class SelectionSort {
    public static void main(String args[]){
        int[] arr1 ={27,18,54,43,55,96,37,2,0,4,5,10,1};
        System.out.println(""Before Selection Sort"");
        for(int i:arr1){
            System.out.print(i+"" "");
        }
        System.out.println();
        selectionSort(arr1);
        System.out.println(""After Selection Sort"");
        for(int i:arr1){
            System.out.print(i+"" "");
        }
        System.out.println();
    }
    public static void selectionSort(int[] arr){
        for (int i=0; i < arr.length - 1;i ++){
            int index = i;
            for (int j = i+ 1; j <arr.length;j++){
                if (arr[j] < arr[index]){
                    index = j;
                }
            }
            int smallerNumber = arr[index];
            arr[index]= arr[i];
            arr[i] = smallerNumber;
        }   
    }
}",0,0,1,0,0,0,0,0,0
1207,"class selectionSort{
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		int [] sortedArr = new int [sizeofArr];
		sortedArr = selectionSort(arr, sizeofArr);
		print(sortedArr);
	}
	static int [] selectionSort(int [] arr, int sizeofArr){
		int minIndex=0, temp=0;
		for (int i=0;i<sizeofArr;i++){
			minIndex = i;
			for (int k=i+1;k<sizeofArr;k++)
				if (arr[minIndex] > arr[k]) minIndex = k;
			if (minIndex != i){
				temp = arr[minIndex];
				arr[minIndex] = arr[i];
				arr[i] = temp;
			}
		}
		return arr;
	}
	static void print (int [] arr){
		for (int a : arr)
			System.out.print("" ""+a);
	}
}",0,0,1,0,0,0,0,0,0
1208,"import java.util.*;
public class SelectionSort{
    static int[] selectionsort(int[] a,int n){
       for(int i=0;i<n-1;i++){
           int min=a[i];
           for(int j=i+1;j<n;j++){
               if(a[j]<min){
                   int temp=a[i];
                   a[i]=a[j];
                   a[j]=temp;
               }
           }
       }
        return a;
    }
    public static void main (String args[]){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int arr[] =new int[n];
        for(int i=0;i<n;i++){
            arr[i]=sc.nextInt();
        }
        int[] sortedArray=selectionsort(arr,n);
        for(int i:sortedArray){
            System.out.print("" ""+i);
        }
        sc.close();
    }
}",0,0,1,0,0,0,0,0,0
1209,"import java.util.List;
import java.lang.Comparable;
public class SelectionSort<T extends Comparable<T>> implements SortingAlg<T> {
    @Override
    public void sort(List<T> elements) {
        if (elements == null) return;
        for (int i = 0; i < elements.size() - 1; i++) {
            int min = i;
            for (int j = i + 1; j < elements.size(); j++) {
                if (isLessThan(elements.get(j), elements.get(min)))
                    min = j;
            }
            T temp = elements.get(i);
            elements.set(i, elements.get(min));
            elements.set(min, temp);
        }
    }
    private boolean isLessThan(T first, T second) {
        return first.compareTo(second) < 0;
    }
    public static void main(String[] args) {
        SortingAlg<Integer> alg = new SelectionSort<Integer>();
        List<Integer> elems = java.util.Arrays.asList(9,5,2,7,3,8,2,1,4,7,5,3,9);
        alg.sort(elems);
        for (int i = 0; i < elems.size() - 1; i++) {
            if (elems.get(i).compareTo(elems.get(i+1)) > 0)
                throw new java.lang.RuntimeException(""Elems should be sorted."");
        }
        System.out.println(""All tests passed."");
    }
}",0,0,1,0,0,0,0,0,0
1210,"import java.util.Arrays;
public class SelectionSort {
	public void selectionSort(int[] A) {
		int len = A.length;
		int minIdx = 0;
		for (int i = 0; i < len; i ++) {
			minIdx = i;
			for (int j = i + 1; j < len; j ++) {
				if (A[j] < A[minIdx]) {
					minIdx = j;				
				}
			}
			swap(A, i, minIdx);
		}
	}
	private void swap(int[] A, int idx1, int idx2) {
		int tmp = A[idx1];
		A[idx1] = A[idx2];
		A[idx2] = tmp;
	}
	public static void main(String[] args) {
		SelectionSort ss = new SelectionSort();
		int[] A = {4, 5, 9, 2, 0, 1, 6, 8, 3, 7};
		System.out.println(""unsorted: "" + Arrays.toString(A));
		ss.selectionSort(A);
		System.out.println(""sorted: "" + Arrays.toString(A));
	}
}",0,0,1,0,0,0,0,0,0
1211,"export default function SelectionSort(elements: number[]): number[] {
  const { length } = elements;
  for (let i = 0; i < length; i++) {
    let lowestIndex = i;
    for (let k = i + 1; k < length; k++) {
      if (elements[k] < elements[lowestIndex]) {
        lowestIndex = k;
      }
    }
    if (lowestIndex !== i) {
      swap(elements, i, lowestIndex);
    }
  }
  return elements;
}
function swap(items: number[], firstIndex: number, secondIndex: number) {
  const temp = items[firstIndex];
  items[firstIndex] = items[secondIndex];
  items[secondIndex] = temp;
}",0,0,1,0,0,0,0,0,0
1212,"""use strict"";
Array.prototype.selectionsort = function(compare) {
    if (""function"" != typeof compare) {
        var desc = compare || false;
        compare = function(a, b) {
            return desc ? a < b : a > b;
        }
    }
    var that = this;
    function swap(i, j) {
        var temp = that[i];
        that[i] = that[j];
        that[j] = temp;
    }
    function minmax(start) {
        var m = that[start], p = start;
        for (var i = start + 1; i < that.length; i += 1) {
            if (compare(m, that[i])) {
                m = that[i];
                p = i;
            }
        }
        return p;
    }
    for (var i = 0; i < that.length; i += 1) {
        swap(i, minmax(i));
    }
    return this;
};",0,0,1,0,0,0,0,0,0
1213,"def selection_sort(numlist):        
    for i in range(len(numlist)):
        min = i
        for j in range(i + 1, len(numlist)):
            if numlist[j] < numlist[min]:
                min = j
        numlist[min], numlist[i] = numlist[i], numlist[min]
    return numlist",0,0,1,0,0,0,0,0,0
1214,"package sorting.algorithms;
public class SelectionSort {
    public int[] sort(int[] inputArray) {
        int arraylength = inputArray.length;
        int minIndex;  
        int temp;  
        for (int i = 0; i < arraylength - 1; i++) {
            minIndex = i;
            for (int j = i + 1; j < arraylength; j++) {
                if (inputArray[j] < inputArray[minIndex]) {
                    minIndex = j;  
                }
            }
            if (minIndex != i) {
                temp = inputArray[i];
                inputArray[i] = inputArray[minIndex];
                inputArray[minIndex] = temp;
            }
        }
        return inputArray;
    }
}",0,0,1,0,0,0,0,0,0
1215,"package com.intrafoundation;
public class SelectionSort extends BaseSort {
    public void sort(int[] arr) {
        if(arr.length <= 1) return;
        swaps = 0;
        final int end = arr.length - 1;
        int partition = 0;
        do {
            int minValue = arr[partition];
            int index = partition;
            for (int i = partition; i <= end; i++) {
                if (arr[i] < minValue) {
                    index = i;
                    minValue = arr[i];
                }
            }
            final int a = arr[partition];
            final int b = arr[index];
            if (a > b) {
                arr[partition] = b;
                arr[index] = a;
                swaps++;
            }
        } while (++partition < end);
    }
}",0,0,1,0,0,0,0,0,0
1216,"package project1.sorts;
import project1.ExperimentalResultsData;
public final class SelectionSort<E extends Comparable<E>> implements Sort<E> {
    @Override
    public SortType sort(ExperimentalResultsData experimentalResultsData, E[] list) {
        for (int i = 0; i < list.length - 1; i++) {
            E currentMin = list[i];
            int currentMinIndex = i;
            for (int j = i + 1; j < list.length; j++) {
                experimentalResultsData.setComparisons(experimentalResultsData.getComparisons() + 1);
                if (currentMin.compareTo(list[j]) > 0) {
                    currentMin = list[j];
                    currentMinIndex = j;
                }
            }
            if (currentMinIndex != i) {
                experimentalResultsData.setMovements(experimentalResultsData.getMovements() + 1);
                list[currentMinIndex] = list[i];
                list[i] = currentMin;
            }
        }
        return SortType.SELECTION_SORT;
    }
}",0,0,1,0,0,0,0,0,0
1217,"package io.lenur.sort;
public class SelectionSort implements Sortable {
    @Override
    public void sort(int[] data) {
        for (int i = 0; i < data.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < data.length; j++) {
                if (data[min] > data[j]) {
                    min = j;
                }
            }
            int temp = data[min];
            data[min] = data[i];
            data[i] = temp;
        }
    }
}",0,0,1,0,0,0,0,0,0
1218,"package sortingalgorithms;
import cnode.CNode;
import java.util.ArrayList;
import java.util.Arrays;
import javafx.animation.FillTransition;
import javafx.animation.ParallelTransition;
import javafx.animation.Transition;
import javafx.scene.paint.Color;
public class SelectionSort extends AbstractSort {
  private static final Color MININDX_COLOR = Color.ORANGE;
  private static final Color NEW_MININDX_COLOR = Color.LIGHTGREEN;
  private ParallelTransition colorCNode(CNode[] arr, int a, int b, Color colorA, Color colorB) {
    ParallelTransition pt = new ParallelTransition();
    pt.getChildren().addAll(colorCNode(arr, colorA, a), colorCNode(arr, colorB, b));
    return pt;
  }
  @Override
  public ArrayList<Transition> startSort(CNode[] arr) {
    ArrayList<Transition> transitions = new ArrayList<>();
    int minIndx;
    for (int i = 0; i < arr.length - 1; i++) {
      minIndx = i;
      transitions.add(colorCNode(arr, NEW_MININDX_COLOR, minIndx));
      for (int j = i + 1; j < arr.length; j++) {
        transitions.add(colorCNode(arr, SELECT_COLOR, j));
        if (arr[j].getValue() < arr[minIndx].getValue()) {
          if (minIndx == i) {
            transitions.add(colorCNode(arr, minIndx, j, MININDX_COLOR, NEW_MININDX_COLOR));
          } else {
            transitions.add(colorCNode(arr, minIndx, j, Color.CRIMSON, NEW_MININDX_COLOR));
          }
          minIndx = j;
        } else {
          transitions.add(colorCNode(arr, START_COLOR, j));
        }
      }
      if (minIndx != i) {
        transitions.add(swap(arr, i, minIndx));
      }
        transitions.add(colorCNode(arr, START_COLOR, i, minIndx));
    }
    transitions.add(colorCNode(Arrays.asList(arr), SORTED_COLOR));
    return transitions;
  }
}",0,0,1,0,0,0,0,0,0
1219,"package sorts;
import util.SortUtil;
public class SelectionSort {
    public static int[] sort(int[] arr) {
        for(int i = 0; i < arr.length; i++) {
            int min = i;
            for(int j = i; j < arr.length; j++) {
                if(arr[j] < arr[min]) {
                    min = j;
                }
            }
            SortUtil.swap(arr, i, min);
        }
        return arr;
    }
}",0,0,1,0,0,0,0,0,0
1220,"package rosberglinhares.datastructuresandalgorithms.algorithms.sorting;
public class SelectionSort {
    public <T extends Comparable<T>> void iterativeSelectionSort(T[] items) {
        for (int i = 0; i < items.length - 1; i++) {
            int minimumIndex = i;
            for (int j = i + 1; j < items.length; j++) {
                if (items[j].compareTo(items[minimumIndex]) < 0) {
                    minimumIndex = j;
                }
            }
            if (minimumIndex != i) {
                T temp = items[i];
                items[i] = items[minimumIndex];
                items[minimumIndex] = temp;
            }
        }
    }
    public <T extends Comparable<T>> void recursiveSelectionSort(T[] items) {
        this.recursiveSelectionSort(items, 0);
    }
    private <T extends Comparable<T>> void recursiveSelectionSort(T[] items, int lowerIndex) {
        if (lowerIndex < items.length - 1) {
            int minimumIndex = lowerIndex;
            for (int i = lowerIndex + 1; i < items.length; i++) {
                if (items[i].compareTo(items[minimumIndex]) < 0) {
                    minimumIndex = i;
                }
            }
            if (minimumIndex != lowerIndex) {
                T temp = items[lowerIndex];
                items[lowerIndex] = items[minimumIndex];
                items[minimumIndex] = temp;
            }
            recursiveSelectionSort(items, lowerIndex + 1);
        }
    }
}",0,0,1,0,0,0,0,0,0
1221,"public class SelectionSort{
     public static void main(String []args){
     int arr[] = {3,6,1,4,7,4,9};
     int len = arr.length;
     for (int i = 0;i<len-1;i++)
     {
         for(int j = i+1;j<len;j++)
         {
             if(arr[j] < arr[i] )
             {
                 int temp = arr[i];
                 arr[i] = arr[j];
                 arr[j] = temp;
             }
         }
     }
     for(int a = 0;a<len;a++)
     {
        System.out.print(arr[a] + "" "");
     }
         }
}",0,0,1,0,0,0,0,0,0
1222,"package sortAlgorithms;
import helperUtils.Utility;
public class SelectionSort {
  public static void main(String argd[]) {
    int[] inputArr = { 10, -80, 5, 76, 92, 100, 52, 1, -10 };
    Utility.printArray(inputArr, true, ""Selection Sort"");
    for (int sortedBoundary = inputArr.length - 1; sortedBoundary > 0; sortedBoundary--) {
      int largestValIndex = 0;
      for (int i = 1; i <= sortedBoundary; i++) {
        if (inputArr[i] > inputArr[largestValIndex]) {
          largestValIndex = i;
        }
      }
      Utility.swap(inputArr, largestValIndex, sortedBoundary);
    }
    Utility.printArray(inputArr, false, null);
  }
}",0,0,1,0,0,0,0,0,0
1223,"const swap = (arr, i, j) => {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
};
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let lowest = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[lowest]) {
        lowest = j;
      }
    }
    if (i !== lowest) {
      swap(arr, i, lowest);
    }
  }
  return arr;
}
selectionSort([34, 22, 10, 19, 17]);",0,0,1,0,0,0,0,0,0
1224,"var array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function swap(array, i, j) {
  var temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
function selectionSort(array) {
  for(var i = 0; i < array.length; i++) {
    var min = i;
    for(var j = i + 1; j < array.length; j++) {
      if(array[j] < array[min]) {
        min = j;
      }
    }
    if(i !== min) {
      swap(array, i, min);
    }
  }
  return array;
}
console.log(selectionSort(array));  ",0,0,1,0,0,0,0,0,0
1225,"def selection_sort(nums):
    for i in range(len(nums)):
        lowest_value_index = i
        for j in range(i + 1, len(nums)):
            if nums[j] < nums[lowest_value_index]:
                lowest_value_index = j
        nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]
random_list_of_nums = [12, 8, 3, 20, 11]
selection_sort(random_list_of_nums)
print(random_list_of_nums)",0,0,1,0,0,0,0,0,0
1226,"package Sorting;
import java.util.Scanner;
public class SelectionSort {
    private static void selectionSort(int[] array) {
        int n = array.length;
        for(int i = 0 ; i < n - 1 ; i++) {  
            int minIndex = i;
            for(int j = i + 1 ; j < n ; j++) {
               if(array[j] < array[minIndex]) {
                   minIndex = j;
               }
            }
            swap(array,i,minIndex);
        }
    }
    private static void swap(int[] array , int i , int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    private static void print(int[] array) {
        for(int i : array) {
            System.out.print(i + "" "");
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] array = new int[n];
        for(int i= 0 ; i < n ; i++) {
            array[i] = sc.nextInt();
        }
        System.out.print(""Before Sorting : "");
        print(array);
        long startTime = System.nanoTime();
        selectionSort(array);
        long endTime = System.nanoTime();
        System.out.print(""\nAfter Sorting : "");
        print(array);
        long totalTime = endTime - startTime;
        System.out.printf(""\nTime in seconds : %.6fs"",(totalTime/ 1000000000.0));
        sc.close();
    }
}",0,0,1,0,0,0,0,0,0
1227,"package Sorting;
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr={20,35,-15,7,55,1,-22};
        SS(arr);
    }
    public static void SS(int[] arr){
        for (int lui = arr.length-1; lui >0 ; lui--) {
            int largest = 0;
            for (int i = 0; i <= lui ; i++) {
                if(arr[i] > arr[largest]){
                    largest=i;
                }
            }
            swap(arr,largest,lui);
        }
        for(int j=0;j<arr.length;j++){
            System.out.print(arr[j]+"" "");
        }
    }
    public static void swap(int[] arr,int i,int j){
        if (i==j){
            return;
        }
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}",0,0,1,0,0,0,0,0,0
1228,"package Java;
public class SelectionSort extends Sort{
	public static void main(String[] args){
		int[] data = {5, 3, 2, 4, 1};
		timeSort(new SelectionSort(), data);
	}
	public SelectionSort(){ super(""Selection""); }
	private void selectionSort(int[] data, int low, int high){
	    for (int i = low; i < high; i++){
	        int min = i;
	        for (int j = i + 1; j < high; j++)
	            if ( data[j] < data[min] )
	                min = j;
	        int temp = data[i];
	        data[i] = data[min];
	        data[min] = temp;
	    }
	}
	@Override
	public void sort(int []data){
	    selectionSort(data, 0, data.length);
	}
}",0,0,1,0,0,0,0,0,0
1229,"function selectionSort (arrData) {
  'use strict'
  function _swap (arrData, numSrc, numTgt) {
    const swap = arrData[numSrc]
    arrData[numSrc] = arrData[numTgt]
    arrData[numTgt] = swap
  }
  const dataMax = arrData.length
  console.log('Initial:', arrData.join(), `[Count:${dataMax}]`)
  for (let indexA = 0; indexA < dataMax - 1; indexA++) {
    console.log(arrData.join())
    let indexB = indexA
    for (let indexC = indexA + 1; indexC < dataMax; indexC++) {
      if (arrData[indexC] < arrData[indexB]) {
        indexB = indexC
      }
    }
    if (indexA !== indexB) _swap(arrData, indexA, indexB)
    console.log('Cycle:', arrData.join())
  }
  console.log('Final:', arrData.join())
  return arrData
}",0,0,1,0,0,0,0,0,0
1230,"function selectionSort(items) {
	var length = items.length;
	var lowestValueIndex = null;
	for (var a = 0; a < length; a++) {
		lowestValueIndex = a; 
		for (var b = a + 1; b < length; b++) {
			if (items[b] < items[lowestValueIndex]) {
				lowestValueIndex = b;
			}
		}
		swap(items, a, lowestValueIndex);
	}
	return items;
};",0,0,1,0,0,0,0,0,0
1231,"from time import sleep
from typing import List
from tkinter import Tk
from animated import Animator
class SelectionSort(Animator):
    def min(self, array: List[int], start) -> int:
        smallest = array[start]
        for i in range(start, len(array)):
            self.modColour(i, color=""red"")
            self.modColour(i - 1, color=""white"")
            if array[i] < smallest:
                smallest = array[i]
        return smallest
    def sort(self, array: List[int]) -> None:
        self.render(array)
        sleep(0.01)
        for i in range(len(array)):  
            index = array.index(self.min(array, i))  
            array[i], array[index] = (
                array[index],
                array[i],
            )  
            self.render(array, cur=(i, index))
            sleep(0.01)
def main() -> int:
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    shuffledArray = randomSequence(0, 225)
    root = Tk()
    sorter = SelectionSort(
        root,
        background=""black"",
        width=root.winfo_screenwidth(),
        height=root.winfo_screenheight(),
    )
    sorter.pack()
    sorter.sort(shuffledArray)
    sorter.render(shuffledArray)
    sorter.finished()
    return 0",0,0,1,0,0,0,0,0,0
1232,"package com.growingwiththeweb.sorting;
public class SelectionSort {
    public static void sort(Integer[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                swap(array, i, minIndex);
            }
        }
    }
    private static void swap(Integer[] array, int a, int b) {
        Integer temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}",0,0,1,0,0,0,0,0,0
1233,"export function selectionsort ( compare, a, i, j ) {
	for ( ; i < j ; ++i ) {
		let k = i;
		let t = i;
		let o = a[t];
		while ( ++t < j ) {
			if ( compare( o, a[t] ) > 0 ) {
				o = a[t];
				k = t;
			}
		}
		if ( k > i ) {
			a[k] = a[i];
			a[i] = o;
		}
	}
}",0,0,1,0,0,0,0,0,0
1234,"def swap(array, i, j):
    tmp = array[i]
    array[i] = array[j]
    array[j] = tmp
def selectionsort(array):
    for i in range(0, len(array)):
        Ismallest = i
        for j in range(i+1, len(array)):
            if array[j] < array[Ismallest]:
                Ismallest = j
        swap(array, i, Ismallest)
if __name__ == ""__main__"":
    array = [17, 9, 13, 8, 7, -5, 6, 11, 3, 4, 1, 2]
    selectionsort(array)
    print array",0,0,1,0,0,0,0,0,0
1235,"public class SelectionSort {
    public static int[] sort(int[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            int min = i;
            for (int j = i + 1; j < array.length; j++) {
                if (array[min] > array[j]) min = j;
            }
            int temp = array[i];
            array[i] = array[min];
            array[min] = temp;
        }
        return array;
    }
}",0,0,1,0,0,0,0,0,0
1236,"import sys
A = [64, 25, 12, 22, 11]
for i in range(len(A)):
    min_idx = i
    for j in range(i+1, len(A)):
        if A[min_idx] > A[j]:
            min_idx = j
    A[i], A[min_idx] = A[min_idx], A[i]
print(""Sorted array"")
for i in range(len(A)):
    print(""%d"" % A[i]),",0,0,1,0,0,0,0,0,0
1237,"const array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
function selectionSort(array) {
  for(let i = 0; i < array.length; i++) {
    let min = i;
    for(let j = i + 1; j < array.length; j++) {
      if(array[j] < array[min]) {
        min = j;
      }
    }
    if(i !== min) {
      [array[i], array[min]] = [array[min], array[i]];
    }
  }
  return array;
}
console.log(selectionSort(array));  ",0,0,1,0,0,0,0,0,0
1238,"public class SelectionSort {
    public static void main(String[] args) {
        int[] input = {10, 9, 7, 101, 23, 44, 12, 78, 34, 23};
        int i, position, tmp;
        for (i = 0; i < 10; i++) {
            position = smallest(input, 10, i);
            tmp = input[i];
            input[i] = input[position];
            input[position] = tmp;
        }
        System.out.println(""Selection Sort : Sorted List"");
        for (i = 0; i < 10; i++) {
            System.out.println(input[i]);
        }
    }
    public static int smallest(int a[], int n, int i) {
        int small, position, j;
        small = a[i];
        position = i;
        for (j = i + 1; j < 10; j++) {
            if (a[j] < small) {
                small = a[j];
                position = j;
            }
        }
        return position;
    }
}",0,0,1,0,0,0,0,0,0
1239,"selectionSort = function(array) {
  var a = array.slice(0);
  var i, j, len, min;
  for (j = 0, len = a.length; j < len - 1; j++) {
    for (i = j + 1, min = j; i < len; i++) {
      if (a[i] < a[min]) {
        min = i;
      }
    }
    if (min !== j) {
      a[j] = a[min] + (a[min] = a[j], 0);
    }
  }
  return a;
};",0,0,1,0,0,0,0,0,0
1240,"aij.selectionSort = function(items) {
    var sort = function(arr) {
      var length = arr.length;
      for (var i = 0; i < length; i++) {
        var minIndex = i;
        for (var j = i; j < length; j++) {
          if (arr[j] < arr[minIndex]) {
            minIndex = j;
          }
        };
        var min = arr[minIndex];
        arr.splice(minIndex, 1);
        arr.splice(i, 0, min);
      };
      return arr;
    };
    return aij.isSortable(items) ? sort(items) : items;
};",0,0,1,0,0,0,0,0,0
1241,"def selection_sort(lista, n):
    i = 0
    while(i<n):
        j=i+1
        min = i
        while(j<n):
            if(lista[j] < lista[min]):
                min = j 
            j+=1
        lista[i], lista[min] = lista[min], lista[i]
        i+=1",0,0,1,0,0,0,0,0,0
1242,"import numpy as np
n = int(input('enter the size of the array '))
arr_str = input(""Enter the elements of array "").split("" "")
arr = [int(num) for num in arr_str]
print(""Original unsorted array "")
print(arr)
print(""\n"")
def selection_sort(x):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[min_idx] > arr[j]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    print(""Final sorted array using selection sort "")
    print(arr)
if __name__ == ""__main__"":
    selection_sort(arr)",0,0,1,0,0,0,0,0,0
1243,"const arrayRandom = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
const arrayOrdered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const arrayReversed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
function selectionSort(array) {
  let countOuter = 0;
  let countInner = 0;
  let countSwap = 0;
  for(let i = 0; i < array.length; i++) {
    countOuter++;
    let min = i;
    for(let j = i + 1; j < array.length; j++) {
      countInner++;
      if(array[j] < array[min]) {
        min = j;
      }
    }
    if(i !== min) {
      countSwap++;
      [array[i], array[min]] = [array[min], array[i]];
    }
  }
  console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
  return array;
}
selectionSort(arrayRandom.slice());  
selectionSort(arrayOrdered.slice());  
selectionSort(arrayReversed.slice());  ",0,0,1,0,0,0,0,0,0
1244,"var arrayRandom = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];
var arrayOrdered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arrayReversed = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
function swap(array, i, j) {
  var temp = array[i];
  array[i] = array[j];
  array[j] = temp;
}
function selectionSort(array) {
  var countOuter = 0;
  var countInner = 0;
  var countSwap = 0;
  for(var i = 0; i < array.length; i++) {
    countOuter++;
    var min = i;
    for(var j = i + 1; j < array.length; j++) {
      countInner++;
      if(array[j] < array[min]) {
        min = j;
      }
    }
    if(i !== min) {
      countSwap++;
      swap(array, i, min);
    }
  }
  console.log('outer:', countOuter, 'inner:', countInner, 'swap:', countSwap);
  return array;
}
selectionSort(arrayRandom.slice());  
selectionSort(arrayOrdered.slice());  
selectionSort(arrayReversed.slice());  ",0,0,1,0,0,0,0,0,0
1245,"package com.ianramzy;
public class SelectionSorter implements Sorter {
    public void sort(int num, int list[]) {
        int i, j, temp, small;
        for (i = 0; i < num; i++) {
            small = i;
            for (j = i + 1; j < num; j++) {
                if (list[j] < list[small]) {
                    small = j;
                }
            }
            temp = list[i];
            list[i] = list[small];
            list[small] = temp;
        }
    }
}",0,0,1,0,0,0,0,0,0
1246,"function selectionSort(a) {
	var l = a.length;
	for (var i = 0; i < (l - 1); i++) {
		var p = i;
		for (var j = i + 1; j < l; j++) {
			if (a[j] < a[p])
				p = j;
		}
		var t = a[p];
		a[p] = a[i];
		a[i] = t;
	}
	return a;
}
var arr = [5, 1, 3, 4, 2];
var sorted_arr = selectionSort(arr);
console.log('Before sorting');
console.log(arr);
console.log('After sorting');
console.log(sorted_arr);",0,0,1,0,0,0,0,0,0
1247,"public class sort {
	public void exchange (int[] numbers) {
		int temp;   
		for (int i = 0; i < numbers.length - 1; i++)  {
			for (int j = i + 1; j < numbers.length; j++) {
				if(numbers[i] > numbers[j])          
				{
					temp = numbers[i];    
					numbers[i] = numbers[j];
					numbers[j] = temp; 
				}           
			}
		}
	}	
	public void bubble(int[] numbers) {
		int i, temp;
		boolean flag = true;    
		while (flag) {
			flag = false;     
			for(i = 0; i < numbers.length -1; i++)
			{
				if(numbers[i] > numbers[i + 1]) {
					temp = numbers[i];                 
					numbers[i] = numbers[i + 1];
					numbers[i + 1] = temp;
					flag = true;               
				}
			}
		}
	}
	public int[] selection (int [] numbers) {
		int first, temp;
		for (int i = 0; i < numbers.length; i++) {
			first = 0;    
			for(int j = 1; j <= i; j ++) {
				if(numbers[j] > numbers[first]) first = j;
			}
			temp = numbers[first];  
			numbers[first] = numbers[i];
			numbers[i] = temp;
		}
		return numbers;
	}
	public void insertion(int [] numbers) {
		int j, i;
		int key;
		for (j = 1; j < numbers.length; j++) {
				key = numbers[j];
				for(i = j - 1; (i >= 0) && (numbers[i] < key); i--) {
					numbers[i + 1] = numbers[i];
			}
			numbers[i + 1] = key;     
		}
	}
}",0,0,1,1,1,0,0,0,0
1248,"Array.prototype.bubble = function(options) {
    var asc = options && options.order === 'asc';  
    var j = 0, i = 0;
    for (j=1; j<this.length; j++) {
        var swapped = false;
        for (i=1; i<this.length; i++) {
            var s = asc ? i-1 : i, t = asc ? i : i - 1;
            if(this[s] > this[t]) {
                this[t] = [this[s], this[s] = this[t]][0];
                swapped = true;
            }
        }
        if(!swapped) { break; }
    }
};
Array.prototype.quick = function(options) {
    var asc = options && options.order === 'asc';  
    var _quick = function(list, start, end) {
        var pivot = list[start], _start = start, _end = end;
        while (start < end) {
            while ((asc && (list[end] >= pivot) || !asc && (list[end] <= pivot)) && (start < end)) {
                end--;
            }
            if (start !== end) {
                list[start] = list[end];
                start++;
            }
            while (((asc && list[start] <= pivot) || (!asc && (list[start] >= pivot))) && (start < end)) {
                start++;
            }
            if(start !== end) {
                list[end] = list[start];
                end--;
            }
        }
        list[start] = pivot;
        pivot = start;
        if (_start < start) {
            _quick(list, _start, pivot - 1);
        }
        if (_end > start) {
            _quick(list, pivot + 1, _end);
        }
    };
    _quick(this, 0, this.length - 1);
};
Array.prototype.merge = function(options) {
    var asc = options && options.order === 'asc';  
    var _merge = function(part1, part2, list, start, end) {
        var data = [];
        var i = 0, j = 0;
        while(i < part1.length || j < part2.length) {
            if(j >= part2.length || (i < part1.length &&
                ((asc && part1[i] < part2[j]) || (!asc && part1[i] >= part2[j]))
                )) {
                data.push(part1[i++]);
            }else if(j < part2.length) {
                data.push(part2[j++]);
            }
        }
        for(i = start; i < end; ++i) {
            list[i] = data[i];
        }
        return data;
    };
    var _partitioning = function(list) {
        if(list.length > 1) {
            var len = list.length;
            var mid = Math.round(len / 2);
            var part1 = _partitioning(list.slice(0, mid));
            var part2 = _partitioning(list.slice(mid, len));
            return _merge(part1, part2, list, 0, len);
        }
        return list;
    };
    _partitioning(this);
};
Array.prototype.heap = function(options) {
    var asc = options && options.order === 'asc';  
    var _heap = function(list) {
        _put(list);
        var _ref, _results = [], end = list.length - 1;
        while(end > 0) {
            _ref = [list[end], list[0]];
            list[0] = _ref[0];
            list[end] = _ref[1];
            _shift(list, 0, end);
            _results.push(--end);
        }
        return _results;
    };
    var _put = function(list) {
        var i, _results;
        i = list.length / 2 - 1;
        i = Math.floor(i);
        _results = [];
        while(i >= 0) {
            _shift(list, i, list.length);
            _results.push(--i);
        }
        return _results;
    };
    var _shift = function(heap, i, max) {
        var c1, c2, _big, _ref;
        while(i < max) {
            _big = i;
            c1 = 2 * i + 1;
            c2 = c1 + 1;
            if(c1 < max && heap[c1] > heap[_big]) {
                _big = c1;
            }
            if(c2 < max && heap[c2] > heap[_big]) {
                _big = c2;
            }
            if(_big === i) {
                return;
            }
            _ref = [heap[_big], heap[i]];
            heap[i] = _ref[0];
            heap[_big] = _ref[1];
            i = _big;
        }
    };
    _heap(this);
    if(!asc) { this.reverse(); }
};
Array.prototype.insertion = function(options) {
    var asc = options && options.order === 'asc';  
    var i;
    for(i = 0; i < this.length; i++) {
        var k = this[i];
        for (var j = i; j > 0 && ((asc && k < this[j - 1]) || (!asc && k > this[j - 1])); j--) {
            this[j] = this[j - 1];
        }
        this[j] = k;
    }
};
Array.prototype.selection = function(options) {
    var asc = options && options.order === 'asc';  
    var i, j;
    for(i = 0; i < this.length-1; ++i) {
        var _find = this[i];
        var _findat = i;
        for(j = i; j < this.length; ++j) {
            if((asc && this[j] < _find) || (!asc && this[j] > _find)){
                _findat = j;
                _find = this[j];
            }
        }
        if(_findat !== i) {
            this[i] = [this[_findat], this[_findat] = this[i]][0];
        }
    }
};",1,1,1,1,1,0,0,0,0
1249,"import math
def bubble(nlist):
    nlist = list(nlist)
    size = len(nlist) - 1
    if size <= 1:
        return nlist
    swapped = True
    for i in range(size):
        if not swapped:
            break
        swapped = False
        for j in range(size - i):
            if nlist[j] > nlist[j + 1]:
                nlist[j + 1], nlist[j] = nlist[j], nlist[j + 1]
                swapped = True
    return nlist
def insertion(nlist):
    nlist = list(nlist)
    size = len(nlist) 
    if size <= 1:
        return nlist
    for i in range(size):
        key = nlist[i]
        j = i - 1
        while j >= 0 and key < nlist[j]:
            nlist[j + 1] = nlist[j]
            j -= 1
        nlist[j + 1] = key
    return nlist
def selection(nlist):
    nlist = list(nlist)
    size = len(nlist)
    if size < 1:
        return nlist
    for i in range(size - 1):
        lower = i
        for j in range(i + 1, size):
            if nlist[j] < nlist[lower]:
                lower = j
        nlist[i], nlist[lower] = nlist[lower], nlist[i]
    return nlist
def quick(nlist):
    nlist = list(nlist)
    size = len(nlist)
    if size <= 1:
        return nlist
    pivot = nlist[0]
    lr = [x for x in nlist if x < pivot]    
    gt = [x for x in nlist[1:] if x >= pivot]   
    return quick(lr) + [pivot] + quick(gt)
def merge(nlist):
    if len(nlist) < 2:
        return nlist
    result, mid = list(), len(nlist) // 2
    l = merge(nlist[:mid])  
    r = merge(nlist[mid:])  
    while (len(l) > 0) and (len(r) > 0):
        if l[0] > r[0]:
            result.append(r.pop(0))
        else: 
            result.append(l.pop(0))
    result.extend(l + r)
    return result
def shell(nlist):
    nlist = list(nlist)
    size = len(nlist)
    if size < 2:
        return nlist
    gap = size // 2
    while gap > 0:
        for i in range(gap, size):
            val = nlist[i]
            j = i
            while j >= gap and nlist[j - gap] > val:
                nlist[j] = nlist[j - gap]
                j -= gap
            nlist[j] = val
        gap //= 2
    return nlist
def heap(nlist):
    nlist = list(nlist)
    size = len(nlist)
    if size < 2:
        return nlist
    for start in range((size - 2) // 2, -1, -1):
        _max_heap(nlist, start, size - 1)
    for end in range(size - 1, 0, -1):  
        nlist[end], nlist[0] = nlist[0], nlist[end]
        _max_heap(nlist, 0, end - 1)
    return nlist
def _max_heap(nlist, root, end):
    while True:
        child = root * 2 + 1
        if child > end:
            break
        if child + 1 <= end and nlist[child] < nlist[child + 1]:
            child += 1
        if nlist[root] < nlist[child]:
            nlist[root], nlist[child] = nlist[child], nlist[root]
            root = child
        else:
            break
def counting(alist):
    nlist = list(alist)
    size = len(nlist)
    if size < 2:
        return nlist
    m = min(nlist) 
    k = max(nlist) - m
    counter = [0] * ( k + 1 )
    for i in nlist:
        counter[i - m] += 1
    ndx = 0;
    for i in range( len( counter ) ):
        while 0 < counter[i]:
            nlist[ndx] = i + m 
            ndx += 1
            counter[i] -= 1
    return nlist
def radix(aList):
    nlist = list(aList)
    size = len(nlist)
    if size < 2:
        return nlist
    RADIX = 10
    maxLength = False
    tmp, placement = -1, 1
    while not maxLength:
        maxLength = True
        buckets = [list() for i in range(RADIX)]
        for i in nlist:
            tmp = int(i / placement)
            buckets[int(tmp % RADIX)].append(i)
            if maxLength and tmp > 0:
                maxLength = False
        a = 0
        for b in range( RADIX ):
            buck = buckets[b]
            for i in buck:
                nlist[a] = i
                a += 1
        placement *= RADIX
    return nlist
def bucket(aList, bucketSize=5):
    nlist = list(aList)
    size = len(nlist)
    if size < 2:
        return nlist
    minValue = min(nlist)
    maxValue = max(nlist)
    bucketCount = math.floor((maxValue - minValue) / bucketSize) + 1
    buckets = []
    for i in range(0, bucketCount):
        buckets.append([])
    for i in range(0, size):
        buckets[math.floor((nlist[i] - minValue) / bucketSize)].append(nlist[i])
    nlist = []
    for i in range(0, len(buckets)):
        buckets[i] = insertion(buckets[i])
        for j in range(0, len(buckets[i])):
            nlist.append(buckets[i][j])
    return nlist
def gnome(aList):
    nlist = list(aList)
    size = len(nlist)
    if size < 2:
        return nlist
    pivot = 0
    nlist_length = len(nlist) 
    while pivot < nlist_length - 1:
        if nlist[pivot] > nlist[pivot + 1]:
            nlist[pivot + 1], nlist[pivot] = nlist[pivot], nlist[pivot + 1]
            if pivot > 0:
                pivot -= 2
        pivot += 1
    return nlist
def comb(aList):
    nlist = list(aList)
    size = len(nlist)
    if size < 2:
        return nlist
    gap = size
    swaps = True
    while gap > 1 or swaps:
        gap = max(1, int(gap / 1.25)) 
        swaps = False
        for i in range(size - gap):
            j = i + gap
            if nlist[i] > nlist[j]:
                nlist[i], nlist[j] = nlist[j], nlist[i]
                swaps = True
    return nlist
def cocktail(aList):
    nlist = list(aList)
    size = len(nlist)
    if size < 2:
        return nlist
    swapped = True
    i = 0
    j = size - 1
    while i < j and swapped:
        for k in range(i, j):
            if nlist[k] > nlist[k + 1]:
                nlist[k], nlist[k + 1] = nlist[k + 1], nlist[k]
                swapped = True
        j -= 1
        if swapped:
            swapped = False
            for k in range(j, i, -1):
                if nlist[k] < nlist[k - 1]:
                    nlist[k], nlist[k - 1] = nlist[k - 1], nlist[k]
                    swapped = True
        i += 1
        if not swapped:
            return nlist",1,1,1,1,1,0,0,0,0
1250,"package sorter;
public class Sort {
	public int[] bubble(int[] array) {
		for (int i = 0; i < array.length; i++) {
			for (int j = 1; j < array.length; j++) {
				if (array[j - 1] > array[j]) {
					int temp = array[j];
					array[j] = array[j - 1];
					array[j - 1] = temp;
				}
			}
		}
		return array;
	}
	public int[] selection(int[] array) {
		for (int i = array.length - 1; i > 0; i--) {
			int highest = array[0];
			int index = 0;
			for (int j = 0; j < i; j++) {
				if (array[j] > highest) {
					highest = array[j];
					index = j;
				}
			}
			int temp = array[i - 1] = highest;
			array[index] = temp;
		}
		return array;
	}
	public static int[] insertion(int[] array) {
		for (int i = 1; i < array.length; i++) {
			int index = array[i];
			int j = i;
			while ((j > 0) && (array[j - 1] > index)) {
				array[j] = array[j - 1];
				j = j - 1;
			}
			array[j] = index;
		}
		return array;
	}
}",0,0,1,1,1,0,0,0,0
1251,"Array.prototype.elem = function (index) {
  return this[index-1];
};
Array.prototype.elemSwap = function (index1, index2) {
  var temp = this[index1 - 1];
  this[index1 - 1] = this[index2 - 1];
  this[index2 - 1] = temp;
};
Array.prototype.swap = function (index1, index2) {
  var temp = this[index1];
  this[index1] = this[index2];
  this[index2] = temp;
};
Array.prototype.clone = function() {
  return this.slice(0);
};
var sort = function (algo, arr) {
  function selectionSort (arr) {
    for (var i = 0; i < arr.length; i++) {
      var min = arr[i];
      var minIndex = i;
      for (var j = i+1; j < arr.length; j++) {
        if (arr[j] < min) {
          min = arr[j];
          minIndex = j;
        }
      }
      arr.swap(i, minIndex);
    }
    return arr;
  }
  function insertSort (arr) {
    for (var i = 1; i <= arr.length; i++) {
      for (var j = i-1; j >= 0; j--) {
        if (arr[j+1] < arr[j]) {
          arr.swap(j, j+1);
        }
      }
    }
    return arr;
  }
  function mergeSort (arr) {
    if (arr.length <= 1) {
      return arr;
    }
    var middleIndex = Math.floor(arr.length/2);
    var leftSorted = mergeSort(arr.slice(0, middleIndex));
    var rightSorted = mergeSort(arr.slice(middleIndex));
    return merge(leftSorted, rightSorted);
  }
  function merge (left, right) {
    var sortedArr = [];
    var leftInd = 0;
    var rightInd = 0;
    while (leftInd < left.length || rightInd < right.length) {
      if (rightInd === right.length || left[leftInd] <= right[rightInd]) {
        sortedArr.push(left[leftInd]);
        ++leftInd;
      } else {
        sortedArr.push(right[rightInd]);
        ++rightInd;
      }
    }
    return sortedArr;
  }
  function Heap (arr) {
    this.heapArray = arr.clone();
    this.heapSize = this.heapArray.length;
    this.numberOfNonLeaveNodes = Math.ceil(this.heapSize/2);
    this.buildHeap();
    this.sortedArray = [];
  }
  Heap.prototype.buildHeap = function () {
    for(var i = this.numberOfNonLeaveNodes; i >= 1; --i) {
      this.heapifyNode(i);
    }
  };
  Heap.prototype.heapifyNode = function (index) {
    var leftIndex = 2 * index;
    var rightIndex = 2 * index + 1;
    var smallest = index;
    if (leftIndex <= this.heapSize && this.heapArray.elem(leftIndex) < this.heapArray.elem(smallest)) {
      smallest = leftIndex;
    }
    if (rightIndex <= this.heapSize && this.heapArray.elem(rightIndex) < this.heapArray.elem(smallest)) {
      smallest = rightIndex;
    }
    if (smallest != index) {
      this.heapArray.elemSwap(index, smallest);
      this.heapifyNode(smallest);
    }
  };
  Heap.prototype.sort = function () {
    if (this.sortedArray.length !== 0) {
      return this.sortedArray;
    } else {
      for (var i = 1; i <= this.heapSize; ++i) {
        this.heapArray.elemSwap(1, this.heapArray.length);
        this.sortedArray[i - 1] = this.heapArray.pop();
        this.heapifyNode(1);
      }
      return this.sortedArray;
    }
  };
  switch (algo) {
    case ""SELECTION"":
      return selectionSort(arr);
    case ""INSERT"":
      return insertSort(arr);
    case ""MERGE"":
      return mergeSort(arr);
    case ""HEAP"":
      return new Heap(arr).sort();
    default:
      throw ""Sorting algorithm not found"";
  }
};",0,1,1,1,0,0,0,0,0
1252,"def selection_sort(list):
    for fillslot in range(len(list)-1,0,-1):
       positionOfMax=0
       for location in range(1,fillslot+1):
           if list[location]>list[positionOfMax]:
               positionOfMax = location
       temp = list[fillslot]
       list[fillslot] = list[positionOfMax]
       list[positionOfMax] = temp
    return list
def merge_sort(list):
    if(len(list) > 1):
        mid = int(len(list)/2)
        left = list[:mid]
        right = list[mid:]
        merge_sort(left)
        merge_sort(right)
        i,j,k = 0,0,0
        while(i < len(left) and j < len(right)):
            if(left[i] < right[j]):
                list[k] = left[i]
                i+=1
            else:
                list[k] = right[j]
                j+=1
            k+=1
        while(i < len(left)):
            list[k]=left[i]
            i+=1
            k+=1
        while(j < len(right)):
            list[k]=right[j]
            j+=1
            k+=1
    return list 
def count_sort(arr,max): 
    count = [0] * (max+1)
    for i in range(0,max):
      count[arr[i]] +=1
    for j in range(0, max):
      count[j] += count[j-1]
    sorted = [0] * (len(arr)+1) 
    for v in arr:
      sorted[count[v]] = v
      count[v] -= 1
    return sorted[1:]",0,1,1,0,0,0,0,0,0
1253,"class SortComparison {
    static double [] insertionSort (double a[]){
         for (int i = 1; i < a.length; i++) {
             for(int j = i ; j > 0 ; j--){
                 if(a[j] < a[j-1]){
                     swap(a, j, j-1);
                 }
             }
         }
         return a;
    } 
    static double [] quickSort (double a[]){
		double[] arr = a;
    	quickSort(arr, 0, arr.length-1);
    	return arr;
    } 
    private static void quickSort(double[] array, int lowIndex, int highIndex) {
    	int i = lowIndex;
        int j = highIndex;
        double pivot = array[lowIndex+(highIndex-lowIndex)/2];
        while (i <= j) {
            while (array[i] < pivot) {
                i++;
            }
            while (array[j] > pivot) {
                j--;
            }
            if (i <= j) {
                swap(array, i, j); 
                i++;
                j--;
            }
        }
        if (lowIndex < j)
            quickSort(array, lowIndex, j);
        if (i < highIndex)
            quickSort(array, i, highIndex);
    }
    static double [] mergeSort (double a[]){
		double[] arr = a;
		int length = arr.length;
		double[] temp = new double[arr.length];
		return sort(arr, temp, 0, length-1);
    } 
    private static double[] sort(double[] arr, double[] temp, int lowIndex, int highIndex) {
    	if(lowIndex < highIndex) {
    		int middle = lowIndex + (highIndex - lowIndex)/2;
    		sort(arr, temp, lowIndex, middle);
    		sort(arr, temp, middle+1, highIndex);
    		merge(arr, temp, lowIndex, middle, highIndex);
    	}
    	return arr;
    }
    private static void merge(double[] arr, double[] temp, int lowIndex, int middle, int highIndex) {
    	for(int k= lowIndex; k<=highIndex; k++) {
    		temp[k] = arr[k];
    	}
    	int i = lowIndex, j = middle+1;
    	for(int k=lowIndex; k<=highIndex; k++) {
    		if(i>middle)
    			arr[k] = temp[j++];
    		else if(j>highIndex)
    			arr[k] = temp[i++];
    		else if(temp[j] < temp[i])
    			arr[k] = temp[j++];
    		else 
    			arr[k] = temp[i++];
    	}
    }
    static double [] shellSort (double a[]){
		 int h=1;
		 while(h < (a.length/3))
			 h = 3*h + 1;
		 while(h >= 1) {
			 for(int i=h; i<a.length; i++) {
				 for(int j=i; j>=h && ((a[j] < a[j-h])); j-=h) {
						 swap(a, j, j-h);	 
				 }
			 }
			 h = h/3;
		 }
    	return a;
    } 
    static double [] selectionSort (double a[]){
    	for(int i=0; i<a.length-1; i++) {
    		double smallest = a[i];
    		int smallestIndex = i;
    		for(int j=i+1; j<a.length; j++) {
    			if(a[j] < smallest) {
    				smallest = a[j];
    				smallestIndex = j;
    			}
    		}
    		swap(a, i, smallestIndex);
    	}
    	return a;
    } 
    static double [] bubbleSort (double a[]){
    	int l = a.length-1;
    	while(l>0) {
	         for(int i=0; i<l; i++) {
	        	 if(a[i+1] < a[i]) {
	        		 swap(a, i, i+1);
	        	 }
	         }
	         l--;
    	}
    	return a;
    } 
    private static void swap(double[] array, int i, int j) {
   	 	double temp = array[i];
        array[i] = array[j];
        array[j] = temp;
   }
 } ",1,1,1,1,1,0,0,0,0
1254,"module.exports = {
    mergeSort: (unsortedArray) => {
        function merge(left, right) {
            let resultArray = [], leftIndex = 0, rightIndex = 0;
            while (leftIndex < left.length && rightIndex < right.length) {
                if (left[leftIndex] < right[rightIndex]) {
                    resultArray.push(left[leftIndex]);
                    leftIndex++;
                } else {
                    resultArray.push(right[rightIndex]);
                    rightIndex++;
                }
            }
            return resultArray.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
        }
        if (unsortedArray.length <= 1) {
            return unsortedArray;
        }
        const middle = Math.floor(unsortedArray.length / 2);
        const left = unsortedArray.slice(0, middle);
        const right = unsortedArray.slice(middle);
        return merge(
            module.exports.mergeSort(left), module.exports.mergeSort(right)
        );
    },
    selectionSort: (unsortedArray) => {
        function swap(array, firstIndex, secondIndex) {
            let aux = array[firstIndex];
            array[firstIndex] = array[secondIndex];
            array[secondIndex] = aux;
        };
        for (let i = 0; i < unsortedArray.length; i++) {
            let min = i;
            for (let j = i + 1; j < unsortedArray.length; j++) {
                if (unsortedArray[j] < unsortedArray[min]) {
                    min = j;
                }
            }
            swap(unsortedArray, i, min);
        }
        return unsortedArray;
    },
    quickSort: (unsortedArray, left = 0, right = unsortedArray.length - 1) => {
        function swap(array, firstIndex, secondIndex) {
            const aux = array[firstIndex];
            array[firstIndex] = array[secondIndex];
            array[secondIndex] = aux;
        };
        function partition(items, left, right) {
            const pivot = items[Math.floor((right + left) / 2)];  
            let i = left,  
                j = right;  
            while (i <= j) {
                while (items[i] < pivot) {
                    i++;
                }
                while (items[j] > pivot) {
                    j--;
                }
                if (i <= j) {
                    swap(items, i, j);  
                    i++;
                    j--;
                }
            }
            return i;
        }
        let index;
        if (unsortedArray.length > 1) {
            index = partition(unsortedArray, left, right);  
            if (left < index - 1) {  
                module.exports.quickSort(unsortedArray, left, index - 1);
            }
            if (index < right) {  
                module.exports.quickSort(unsortedArray, index, right);
            }
        }
        return unsortedArray;
    },
    insertionSort: (unsortedArray) => {
        let length = unsortedArray.length;
        for (let i = 1; i < length; i++) {
            let key = unsortedArray[i];
            let j = i - 1;
            while (j >= 0 && unsortedArray[j] > key) {
                unsortedArray[j + 1] = unsortedArray[j];
                j = j - 1;
            }
            unsortedArray[j + 1] = key;
        }
        return unsortedArray;
    },
    bubbleSort: (unsortedArray) => {
        let len = unsortedArray.length;
        let swapped;
        do {
            swapped = false;
            for (let i = 0; i < len; i++) {
                if (unsortedArray[i] > unsortedArray[i + 1]) {
                    let tmp = unsortedArray[i];
                    unsortedArray[i] = unsortedArray[i + 1];
                    unsortedArray[i + 1] = tmp;
                    swapped = true;
                }
            }
        } while (swapped);
        return unsortedArray;
    }
}",1,1,1,1,1,0,0,0,0
1255,"import java.util.*;
public class Sorting {
    public static int[] countingSort(int[] a) {
        int k = a.length;
        int[] b = new int[k + 1];
        if (k == 0) {
            return a;
        }
        int x = a[0];
        for (int i = 1; i < k; i++) {
            if (a[i] > x)
                x = a[i];
        }
        int[] c = new int[x + 1];
        for (int i = 0; i < x; ++i) {
            c[i] = 0;
        }
        for (int i = 0; i < k; i++) {
            c[a[i]]++;
        }
        for (int i = 1; i <= x; i++) {
            c[i] += c[i - 1];
        }
        for (int i = k - 1; i >= 0; i--) {
            b[c[a[i]] - 1] = a[i];
            c[a[i]]--;
        }
        for (int i = 0; i < k; i++) {
            a[i] = b[i];
        }
        return a;
    }
    public static int[] insertionSort(int[] a) {
        for (int i = 1; i < a.length; i++) {
            int key = a[i];
            int j = i;
            while (j > 0 && a[j - 1] > key) {
                a[j] = a[j - 1];
                j--;
            }
            a[j] = key;
        }
        return a;
    }
    public static int[] radixSort(int[] a) {
        int k = a.length;
        if (k == 0) {
            return a;
        }
        int max = a[0];
        for (int i = 1; i < k; i++) {
            if (a[i] > max)
                max = a[i];
        }
        for (int j = 1; max / j > 0; j *= 10) {
            countingSort(a);
        }
        return a;
    }
    public final static int MAX_INPUT = 524287;
    public final static int MIN_INPUT = 0;
    private static int[] getInts(Scanner s) {
        ArrayList<Integer> a = new ArrayList<Integer>();
        while (s.hasNextInt()) {
            int i = s.nextInt();
            if ((i <= MAX_INPUT) && (i >= MIN_INPUT))
                a.add(i);
        }
        return toIntArray(a);
    }
    private static int[] toIntArray(ArrayList<Integer> a) {
        int[] ret = new int[a.size()];
        for (int i = 0; i < ret.length; i++)
            ret[i] = a.get(i);
        return ret;
    }
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        System.out.printf(""Enter the sorting algorithm to use ([c]ounting, [i]nsertion, [r]adix): "");
        char algo = s.next().charAt(0);
        System.out.printf(""Enter the integers that you would like sorted, followed by a non-integer character: "");
        int[] unsorted_values = getInts(s);
        int[] sorted_values = {};
        s.close();
        switch (algo) {
            case 'c':
                sorted_values = countingSort(unsorted_values);
                break;
            case 'i':
                sorted_values = insertionSort(unsorted_values);
                break;
            case 'r':
                sorted_values = radixSort(unsorted_values);
                break;
            default:
                System.out.println(""Invalid sorting algorithm"");
                System.exit(0);
                break;
        }
        System.out.println(Arrays.toString(sorted_values));
    }
}",0,0,0,1,0,0,0,0,0
1256,"def bubblesort(N):
    for possnum in range(len(N)-1,0,-1):
        for i in range(possnum):
            if N[i]> N[i+1]:
                N[i],N[i+1]=N[i+1],N[i]
N=[54,26,93,17,77,31,44,55,20]
bubblesort(N)
print(N)
def selectionsort(N):
    for i in range(len(N)-1,0,-1):
        positionofmax=0
        for location in range(1,i+1):
            if N[location]> N[positionofmax]:
                positionofmax=location
        temp=N[i]
        N[i]=N[positionofmax]
        N[positionofmax]=temp
N=[54,26,93,17,77,31,44,55,20]
selectionsort(N)
print(N)
def  shaker_sort(N):
    def swap(i, j):
        N[i], N[j] =N[j], N[i]
    upper = len(N) - 1
    lower = 0
    no_swap = False
    while (not no_swap and upper - lower > 1):
        no_swap = True
        for j in range(lower, upper):
            if N[j + 1] < N[j]:
                swap(j + 1, j)
                no_swap = False
        upper = upper - 1
        for j in range(upper, lower, -1):
            if N[j - 1] > N[j]:
                swap(j - 1, j)
                no_swap = False
        lower = lower + 1
N=[3,9,7,5,3,2,1,8,10]
shaker_sort(N)
print(N)",0,0,1,0,1,0,0,0,0
1257,"import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-sorter', help=""which sorting algorithm to use (quick, bubble, heap)"", required=True)
args = parser.parse_args()
from skimage import color
from scipy.misc import imsave
import numpy as np
import os
def partition(array, begin, end):
    pivot = begin
    swaps = []
    for i in range(begin + 1, end + 1):
        if array[i] <= array[begin]:
            pivot += 1
            array[i], array[pivot] = array[pivot], array[i]
            swaps.append([i, pivot])
    array[pivot], array[begin] = array[begin], array[pivot]
    swaps.append([pivot, begin])
    return pivot, swaps
def quicksort(array, begin=0, end=None):
    global swaps
    swaps = []
    if end is None:
        end = len(array) - 1
    def _quicksort(array, begin, end):
        global swaps
        if begin >= end:
            return
        pivot, newSwaps = partition(array, begin, end)
        swaps += newSwaps
        _quicksort(array, begin, pivot - 1)
        _quicksort(array, pivot + 1, end)
    return _quicksort(array, begin, end), swaps
def bubblesort(A):
    swaps = []
    for i in range(len(A)):
        for k in range(len(A) - 1, i, -1):
            if (A[k] < A[k - 1]):
                swaps.append([k, k - 1])
                tmp = A[k]
                A[k] = A[k - 1]
                A[k - 1] = tmp
    return A, swaps
def heapsort( aList ):
    global swaps
    swaps = []
    length = len( aList ) - 1
    leastParent = length // 2
    for i in range ( leastParent, -1, -1 ):
        moveDown( aList, i, length )
    for i in range ( length, 0, -1 ):
        if aList[0] > aList[i]:
            swaps.append([0, i])
            swap( aList, 0, i )
            moveDown( aList, 0, i - 1 )
    return aList, swaps
def moveDown( aList, first, last ):
    global swaps
    largest = 2 * first + 1
    while largest <= last:
        if ( largest < last ) and ( aList[largest] < aList[largest + 1] ):
            largest += 1
        if aList[largest] > aList[first]:
            swaps.append([largest, first])
            swap( aList, largest, first )
            first = largest;
            largest = 2 * first + 1
        else:
            return 
def swap( A, x, y ):
    tmp = A[x]
    A[x] = A[y]
    A[y] = tmp
img = np.zeros((200, 200, 3), dtype='float32') 
for i in range(img.shape[1]):
    img[:,i,:] = i / img.shape[0], .9, .9
in_rgb = color.convert_colorspace(img, 'HSV', 'RGB')
imsave('initial.png', in_rgb)
for i in range(img.shape[0]):
    np.random.shuffle(img[i,:,:])
in_rgb = color.convert_colorspace(img, 'HSV', 'RGB')
imsave('initial_shuffled.png', in_rgb)
maxMoves = 0
moves = []
for i in range(img.shape[0]):
    newMoves = []
    if args.sorter == 'bubble':
        _, newMoves = bubblesort(list(img[i,:,0]))
    elif args.sorter == 'quick':
        _, newMoves = quicksort(list(img[i,:,0]))
    elif args.sorter == 'heap':
        integer_version = img[i,:,0] * 10000
        integer_version = integer_version.astype(int)
        _, newMoves = heapsort(list(integer_version))
    if len(newMoves) > maxMoves:
        maxMoves = len(newMoves)
    moves.append(newMoves)
currentMove = 0
def swap_pixels(row, places):
    tmp = img[row,places[0],:].copy()
    img[row,places[0],:] = img[row,places[1],:]
    img[row,places[1],:] = tmp
movie_image_step = maxMoves // 120
movie_image_frame = 0
os.makedirs(args.sorter, exist_ok=True)
while currentMove < maxMoves:
    for i in range(img.shape[0]):
        if currentMove < len(moves[i]) - 1:
            swap_pixels(i, moves[i][currentMove])
    if currentMove % movie_image_step == 0:
        imsave('%s/%05d.png' % (args.sorter, movie_image_frame), color.convert_colorspace(img, 'HSV', 'RGB'))
        movie_image_frame += 1
    currentMove += 1",1,0,0,0,1,0,0,0,0
1258,"__author__ = ""streethacker""
def simpleBubbleSort(theRef):
    max = len(theRef) - 1
    for i in range(max):
        for j in range(max - i):
            if theRef[j] > theRef[j + 1]:
                exchange = theRef[j]
                theRef[j] = theRef[j + 1]
                theRef[j + 1] = exchange
    return
def advancedBubbleSort(theRef):
    max = len(theRef) - 1
    swapFlg = False
    for i in range(max):
        for j in range(max - i):
            if theRef[j] > theRef[j + 1]:
                swapFlg = True
                exchange = theRef[j]
                theRef[j] = theRef[j + 1]
                theRef[j + 1] = exchange
        if not swapFlg:
            break
    return
def selectionSort(theRef):
    max = len(theRef) - 1
    for i in range(max - 1):
        smallIdx = i
        for j in range(i + 1, len(theRef)):
            if theRef[j] < theRef[smallIdx]:
                smallIdx = j
        if smallIdx != i:
            exchange = theRef[i]
            theRef[i] = theRef[smallIdx]
            theRef[smallIdx] = exchange
    return
def insertionSort(theRef):
    for i in range(1, len(theRef)):
        key = theRef[i]
        insertIdx = i
        while insertIdx > 0 and key < theRef[insertIdx - 1]:
            theRef[insertIdx] = theRef[insertIdx - 1]
            insertIdx -= 1
        theRef[insertIdx] = key
    return
if __name__ == ""__main__"":
    testcase = [2, 3, 1, 10, 6, 30, 27]
    insertionSort(testcase)
    print ""Sorted list: %s"" % testcase",0,0,1,1,1,0,0,0,0
1259,"import math
import statistics
class InsertionSort():
    def __init__(self):
        self.name = ""insertion sort""
    @staticmethod
    def sort(array):
        for i in range(1, len(array)):
            key = array[i]
            j = i - 1
            while j >= 0 and key < array[j]:
                array[j + 1] = array[j]
                j -= 1
            array[j + 1] = key
        return array
class MergeSort():
    def __init__(self):
        self.name = ""merge sort""
    def sort(self, array):
        if len(array) == 1:
            return array
        middle = len(array) // 2
        left = self.sort(array[:middle])
        right = self.sort(array[middle:])
        return self.__merge(left, right)
    @classmethod
    def __merge(cls, left, right):
        array = []
        if left[-1] != math.inf and right[-1] != math.inf:
            left.append(math.inf)
            right.append(math.inf)
        i = 0
        j = 0
        for _ in range(len(left) - 1 + len(right) - 1):
            if left[i] <= right[j]:
                array.append(left[i])
                if i < len(left) - 1:
                    i += 1
            else:
                array.append(right[j])
                if j < len(right) - 1:
                    j += 1
        return array
class QuickSort():
    def __init__(self):
        self.name = ""quicksort""
    def sort(self, array):
        less = []
        pivot_list = []
        more = []
        if not array:
            return array
        pivot = statistics.median([array[0],
                                   array[len(array) // 2],
                                   array[-1]])
        for number in array:
            if number < pivot:
                less.append(number)
            elif number > pivot:
                more.append(number)
            else:
                pivot_list.append(number)
        less = self.sort(less)
        more = self.sort(more)
        return less + pivot_list + more
class HeapSort():
    def __init__(self):
        self.name = ""heapsort""
    def sort(self, array):
        heap_size = len(array)
        self.__build_heap(array, heap_size)
        for i in range(heap_size-1, 0, -1):
            array[0], array[i] = array[i], array[0]
            heap_size -= 1
            self.__max_heapify(array, heap_size, 0)
        return array
    def __build_heap(self, array, heap_size):
        for i in range((heap_size//2), -1, -1):
            self.__max_heapify(array, heap_size, i)
    def __max_heapify(self, array, heap_size, i):
        left = 2 * i + 1
        right = 2 * i + 2
        largest = i
        if left < heap_size and array[left] > array[largest]:
            largest = left
        if right < heap_size and array[right] > array[largest]:
            largest = right
        if largest != i:
            array[i], array[largest] = array[largest], array[i]
            self.__max_heapify(array, heap_size, largest)",1,1,0,1,0,0,0,0,0
1260,,0,0,0,0,0,0,0,0,0
1261,"import java.util.Scanner;
public class sortingAlgorithms {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		System.out.println(""Enter size of array"");
		int size = s.nextInt();
		int[] arr = new int[size];
		System.out.println(""Enter ""+size+"" elements:"");
		for(int i = 0;i<size;i++){
			arr[i] = s.nextInt();
		}
		System.out.println(""1 Sorting by bubble sort"");
		System.out.println(""2 Sorting by selection sort"");
		System.out.println(""3 Sorting by insertion sort"");
		System.out.println(""4 Sorting by quick sort"");
		System.out.println(""5 Sorting by merge sort"");
		int option = s.nextInt();
		int[] solution = new int[size];
		switch(option){
		case 1:
			bubbleSort(arr);
			break;
		case 2:
			selectionSort(arr);
			break;
		case 3:
			insertionSort(arr);
			break;
		case 4:
			quickSort(arr, 0, arr.length-1);
			showArray(arr);
			break;
		case 5:
			solution = mergeSort(arr);
			showArray(solution);
			break;
		}
	}
	private static void showArray(int[] solution) {
		System.out.println(""Sorted array is:"");
		for(int i = 0;i<solution.length;i++){
			System.out.print(solution[i]+"" "");
		}
		System.out.println();
	}
	public static void bubbleSort(int[] arr){
		int temp;	
		for(int j =1; j<(arr.length); j++){
			for(int i =0; i<(arr.length-1); i++){
				if(arr[i] > arr[i+1]){
					temp = arr[i];
					arr[i] = arr[i+1];
					arr[i+1] = temp;
				}
			}
		}
		showArray(arr);
	}
	public static void insertionSort(int[] arr){
		for(int i = 1; i<arr.length; i++){
			int position = i;
			int temp = arr[position];
			while(position>0&&arr[position-1]>temp){
				arr[position]=arr[position-1];
				position--;
			}
			arr[position] = temp;
		}
		showArray(arr);
	}
	public static void selectionSort(int[] arr){
		for(int i = 0;i<arr.length;i++){
			int  index = i, temp = arr[i], minimum = arr[i];
			for(int j = i+1;j<arr.length;j++){
				if(arr[j]<minimum){
					minimum = arr[j];
					index= j;
				}
			}
			arr[i] = arr[index];
			arr[index] = temp;
		}
		showArray(arr);
	}
	public static void quickSort(int[] arr, int begin_index, int end_index){
		if(begin_index>=end_index){
			return;
		}
		int index = findPivot(arr, begin_index, end_index);
		quickSort(arr, begin_index, index-1);
		quickSort(arr, index+1, end_index);
	}
	public static int findPivot(int[] arr, int begin_index, int end_index){
		int pivotIndex = begin_index;
		for(int i = begin_index+1;i<=end_index;i++){
			if(arr[i]<arr[begin_index]){
				pivotIndex++;
			}
		}
		int temp = arr[pivotIndex];
		arr[pivotIndex]= arr[begin_index];
		arr[begin_index]=temp;
		int i =begin_index,j = end_index;
		while(i<pivotIndex&&j>pivotIndex){
			if(arr[i]<arr[pivotIndex]){
				i++;
			}
			else if(arr[j]>arr[pivotIndex]){
				j--;
			}
			else{
				int temp2 = arr[i];
				arr[i] = arr[j];
				arr[j]= temp2;
				i++;
				j--;
			}
		}
		return pivotIndex;
	}
	public static int[] mergeSort(int[] arr){
		if(arr.length <= 1){
			return arr;
		}
		int[] arr1 = new int[(arr.length/2)];
		int[] arr2 = new int[arr.length-arr1.length];
		for(int i =0;i<arr1.length;i++){
			arr1[i] = arr[i];
		}
		for(int i =0;i<arr2.length;i++){
			arr2[i] = arr[arr1.length+i];
		}
		arr1 = mergeSort(arr1);
		arr2 = mergeSort(arr2);
		return merge(arr1, arr2);
	}
	public static int[] merge(int[] arr1, int[] arr2){
		int[] arr = new int[arr1.length+arr2.length];
		int first_index = 0,second_index = 0,combined_index = 0;
		while(first_index<arr1.length && second_index<arr2.length){
			if(arr1[first_index]<arr2[second_index]){
				arr[combined_index] = arr1[first_index];
				first_index++;
				combined_index++;
			}
			else if(arr2[second_index]<arr1[first_index]){
				arr[combined_index] = arr2[second_index];
				second_index++;
				combined_index++;
			}
		}
		while(first_index<=arr1.length-1){
			arr[combined_index] = arr1[first_index];
			first_index++;
			combined_index++;
		}
		while(second_index<=arr2.length-1){
			arr[combined_index] = arr2[second_index];
			second_index++;
			combined_index++;
		}
		return arr;
	}
}",1,1,1,1,1,0,0,0,0
1262,"package sortingalgorithms;
import java.util.ArrayList;
import java.util.List;
public class SortingAlgorithms {
    public static <T extends Comparable> void insertionSort(List<T> list) {
        if (list.isEmpty()) {
            return;
        }
        for (int i = 1; i < list.size(); i++) {
            int j = i;
            T aux = list.get(i);
            while (j > 0 && aux.compareTo(list.get(j - 1)) < 0) {
                list.set(j, list.get(j - 1));
                j--;
            }
            list.set(j, aux);
        }
    }
    public static <T extends Comparable> void bubbleSort(List<T> list) {
        if (list.isEmpty()) {
            return;
        }
        int size = list.size();
        for (int i = 1; i < size; i++) {
            for (int j = (size - 1); j >= i; j--) {
                if (list.get(j - 1).compareTo(list.get(j)) > 0) {
                    T aux = list.get(j);
                    list.set(j, list.get(j - 1));
                    list.set(j - 1, aux);
                }
            }
        }
    }
    public static <T extends Comparable> void quickSort(List<T> list) {
        int begin =0;
        int end = list.size()-1;
        quickSort(list, begin, end);
    }
    private static <T extends Comparable> void quickSort(List<T> list, int begin, int end) {
        T pivot = list.get((begin + end) / 2);
        int i = begin;
        int j = end;
        while (i < j) {
            while (list.get(i).compareTo(pivot) < 0) {
                i++;
            }
            while (list.get(j).compareTo(pivot) > 0) {
                j--;
            }
            if (i <= j) {
                T aux = list.get(i);
                list.set(i, list.get(j));
                list.set(j, aux);
                i++;
                j--;
            }
        }
        if (j > begin) {
            quickSort(list, begin, j);
        }
        if (i < end) {
            quickSort(list, i, end);
        }
    }
    public static <T extends Comparable> void mergeSort(List<T> list) {
        int size = list.size();
        if (size >= 2) {
            int middle = size / 2;
            List<T> leftList = new ArrayList<>();
            List<T> rigthList = new ArrayList<>();
            for (int i = 0; i < middle; i++) {
                T get = list.get(i);
                leftList.add(get);
            }
            for (int i = middle; i < size; i++) {
                T get = list.get(i);
                rigthList.add(get);
            }
            mergeSort(leftList);
            mergeSort(rigthList);
            merge(list, leftList, rigthList);
        }
    }
    private static <T extends Comparable> void merge(List<T> list, List<T> leftList, List<T> rigthList) {
        list.clear();
        while (!rigthList.isEmpty() && !leftList.isEmpty()) {
            if (rigthList.get(0).compareTo(leftList.get(0)) > 0) {
                list.add(leftList.get(0));
                leftList.remove(0);
            } else {
                T get = rigthList.get(0);
                list.add(get);
                rigthList.remove(0);
            }
        }
        while (!leftList.isEmpty()) {
            list.add(leftList.get(0));
            leftList.remove(0);
        }
        while (!rigthList.isEmpty()) {
            list.add(rigthList.get(0));
            rigthList.remove(0);
        }
    }
    public static void main(String[] args) {
        ArrayList<String> arrayList = new ArrayList<>();
        arrayList.add(""Zla"");
        arrayList.add(""Ala"");
        arrayList.add(""Gla"");
        arrayList.add(""Jla"");
        arrayList.add(""Bla"");
        arrayList.add(""Jla"");
        arrayList.add(""Bla"");
        arrayList.add(""Lla"");
        System.out.println(arrayList);
        System.out.println(arrayList);
    }
}",1,1,0,1,1,0,0,0,0
1263,"import random
class bintree(object):          
    def __init__(self):
        self.val=None
        self.left=None
        self.right=None
    def insert(self,val):
        if self.val==None:
            self.val=val
            self.left=bintree()
            self.right=bintree()
        else:
            if val<self.val:
                self.left.insert(val)
            else:
                self.right.insert(val)
        return
    def inorder(self):
        if self.val==None:
            return
        self.left.inorder()
        print self.val,
        self.right.inorder()
def insertion(ar):
    for i in range(len(ar)):
        j=i-1
        ch=i
        while j>=0:
            if (ar[ch]<ar[j]):
                ar[ch],ar[j]=ar[j],ar[ch]
                ch=j
            j-=1
        print ar
def selection(ar):
    for i in range(len(ar)):
        pos=i
        for j in range(i,len(ar)):
            if(ar[pos]>ar[j]):
                pos=j
        ar[i],ar[pos]=ar[pos],ar[i]
        print ar
def bubble(ar):
    for i in range(len(ar)):
        sorted=True
        for j in range(len(ar)-i-1):
            if(ar[j]>ar[j+1]):
                ar[j],ar[j+1]=ar[j+1],ar[j]
                sorted=False
        if sorted:
            break
        print ar
def quickSort(ar):          
    if len(ar)<=1:              
        return ar
    lf,rt=[],[]
    p=ar[0]
    for j in ar:
        if j>=p:
            rt.append(j)
        else:
            lf.append(j)
    l=quickSort(lf)
    r=quickSort(rt[1:])
    c=l+[rt[0]]+r
    for u in c:
        print u,
    print
    return c
def cocktailsort(ar):
    swapped=True
    while(swapped):
        swapped=False
        for i in range(len(ar)-1):
            if ar[i]>ar[i+1]:
                ar[i],ar[i+1]=ar[i+1],ar[i]
                swapped=True
        if swapped==False:
            break
        swapped=False
        print ar
        i=len(ar)-2
        while i>=0:
            if ar[i]>ar[i+1]:
                ar[i],ar[i+1]=ar[i+1],ar[i]
                swapped=True
            i-=1
        print ar
def oddeven(ar):
    sorted =False
    while(not sorted):
        sorted=True
        for i in range(1,len(ar)-1,2):
            if ar[i]>ar[i+1]:
                ar[i],ar[i+1]=ar[i+1],ar[i]
                sorted=False
        for i in range(0,len(ar)-1,2):
            if ar[i]>ar[i+1]:
                ar[i],ar[i+1]=ar[i+1],ar[i]
                sorted=False
        if not sorted:
            print ar
def combsort(ar):
    gap=len(ar)
    shrink=1.3
    swapped=False
    while not (gap==1 and not swapped):
        gap=int(gap/shrink)
        if gap<1:
            gap=1
        swapped=False
        for i in range(0,len(ar)-gap):
            if ar[i]>ar[i+gap]:
                ar[i],ar[i+gap]=ar[i+gap],ar[i]
                swapped =True
        print ar
def gnomesort(ar):
    pos=1
    last=0
    while pos<len(ar):
        if ar[pos]>=ar[pos-1]:
            if last:
                pos=last
                last=0
            pos+=1
        else:
            ar[pos],ar[pos-1]=ar[pos-1],ar[pos]
            if pos>1:
                if not last:
                    last=pos
                pos-=1
            else:
                pos+=1
        print ar
def stoogesort(ar,i=0,j=-1):
    if j==-1:
        j=len(ar)-1
    if ar[j]<ar[i]:
        ar[i],ar[j]=ar[j],ar[i]
    if (j-i+1)>=3:
        t=(j-i+1)/3
        stoogesort(ar, i  , j-t)
        stoogesort(ar, i+t, j  )
        stoogesort(ar, i  , j-t)
    return ar
def bogosort(ar):
    sorted=False
    while not sorted:
        sorted=True
        for i in range(len(ar)-1):
            if ar[i]>ar[i+1]:
                sorted=False
                break
        if sorted:
            break
        for i in range(1,len(ar)):
            j=random.choice(range(i+1))
            ar[i],ar[j]=ar[j],ar[i]
def heapsort(ar):
    heapify(ar)
    end=len(ar)-1
    while end>0:
        ar[end],ar[0]=ar[0],ar[end]
        end-=1
        siftdown(ar,0,end)
        print ar
def heapify(ar):
    start=(len(ar)-1)/2
    while start>=0:
        siftdown(ar,start,len(ar)-1)
        start-=1
def siftdown(ar,start,end):
    root=start
    while root*2+1<=end:
        child=root*2+1
        swap=root
        if ar[swap]<ar[child]:
            swap=child
        if child+1<=end and ar[swap]<ar[child+1]:
            swap=child+1
        if not (swap==root):
            ar[root],ar[swap]=ar[swap],ar[root]
            root=swap
        else:
            return
def shellsort(ar):
    gaps=[701,301,132,57,23,10,4,1]
    for gap in gaps:
        for i in range(gap,len(ar)):
            t=ar[i]
            j = i
            while j >= gap and ar[j - gap] > t:
                 ar[j] = ar[j - gap]
                 j -= gap
            ar[j]=t
            print ar
def treesort(ar):
    root=bintree()
    for i in ar:
        root.insert(i)
    root.inorder()
    print
def mergesort(ar):
    if len(ar)<=1:
        return ar
    middle=len(ar)/2
    left =ar[:middle]
    right=ar[middle:]
    left=mergesort(left)
    right=mergesort(right)
    res=merge(left,right)
    print res
    return res
def merge(left,right):
    res=[]
    while len(left)+len(right):
        if len(left)*len(right):
            if left[0]<=right[0]:
                res.append(left[0])
                left=left[1:]
            else:
                res.append(right[0])
                right=right[1:]
        elif len(left):
            res.append(left[0])
            left=left[1:]
        elif len(right):
            res.append(right[0])
            right=right[1:]
    return res
def strandsort(ar):
    items = len(ar)
    sortedBins = []
    while( len(ar) > 0 ):
        highest = float(""-inf"")
        newBin = []
        i = 0
        while( i < len(ar) ):
            if( ar[i] >= highest ):
                highest = ar.pop(i)
                newBin.append( highest )
            else:
                i=i+1
        sortedBins.append(newBin)
    sorted = []
    while( len(sorted) < items ):
        lowBin = 0
        for j in range( 0, len(sortedBins) ):
            if( sortedBins[j][0] < sortedBins[lowBin][0] ):
                lowBin = j
        sorted.append( sortedBins[lowBin].pop(0) )
        if( len(sortedBins[lowBin]) == 0 ):
            del sortedBins[lowBin]
    print sorted
    return sorted
if __name__=='__main__':                                            
    unsorted=[int(x) for x in raw_input().split("" "")]
    print ""Insertion Sort : ""
    insertion(unsorted[:])
    print ""Selection Sort : ""
    selection(unsorted[:])
    print ""Bubble Sort : ""
    bubble(unsorted[:])
    print ""Cocktail Sort : ""
    cocktailsort(unsorted[:])
    print ""Quicksort : ""
    quickSort(unsorted[:])
    print ""Odd-Even Sort : ""
    oddeven(unsorted[:])
    print ""Comb Sort : ""
    combsort(unsorted[:])
    print ""Gnome Sort : ""
    gnomesort(unsorted[:])
    print ""Stooge Sort : ""
    stoogesort(unsorted[:])
    print ""Bogosort : ""
    bogosort(unsorted[:])
    print ""Heapsort : ""
    heapsort(unsorted[:])
    print ""Shellsort : ""
    shellsort(unsorted[:])
    print ""Treesort : ""
    treesort(unsorted[:])
    print ""Mergsort : ""
    mergesort(unsorted[:])
    print ""Strand Sort : ""
    strandsort(unsorted[:])",1,1,1,1,1,0,0,0,0
1264,"public class Sorting {
	public static void SortStrings(String[] A)
	{
		boolean haveSwapped = true;
		String temp;
		while (haveSwapped == true)
		{
			haveSwapped = false;
			for (int i = 0; i < A.length - 1; i++)
			{
				if (A[i+1].compareToIgnoreCase(A[i]) < 0)
				{
					haveSwapped = true;
					temp = A[i];
					A[i] = A[i+1];
					A[i+1] = temp;
				}
			}
		}
	}
	public static int[] SelectionSort(int[] A)
	{
		int temp = A[0];
		int largest = A[0];
		int [] sortedNumbers = new int[A.length];
		for (int a = 0; a < A.length; a++)
		{
			for (int i = 0; i < A.length; i++)
			{
				if (temp > (A[i]))
				{
					temp = A[i];
				}
				if (largest < A[i])
				{
					largest = A[i];
				}
			}
			sortedNumbers[a] = temp;
			for (int i = 0; i < A.length; i++)
			{
				if (A[i] == temp)
				{
					A[i] = largest + 1;
					break;
				}
			}
			temp = largest;
		}
		return sortedNumbers;	
	}
}",0,0,1,0,0,0,0,0,0
1265,"package com.jwetherell.algorithms.sorts;
public class AmericanFlagSort {
    private static final int NUMBER_OF_BUCKETS = 10;  
    private AmericanFlagSort() { }
    public static Integer[] sort(Integer[] unsorted) {
        int numberOfDigits = getMaxNumberOfDigits(unsorted);  
        int max = 1;
        for (int i = 0; i < numberOfDigits - 1; i++)
            max *= 10;
        sort(unsorted, 0, unsorted.length, max);
        return unsorted;
    }
    public static void sort(Integer[] unsorted, int start, int length, int divisor) {
        int[] count = new int[NUMBER_OF_BUCKETS];
        int[] offset = new int[NUMBER_OF_BUCKETS];
        int digit = 0;
        for (int i = start; i < length; i++) {
            int d = unsorted[i];
            digit = getDigit(d, divisor);
            count[digit]++;
        }
        offset[0] = start + 0;
        for (int i = 1; i < NUMBER_OF_BUCKETS; i++) {
            offset[i] = count[i - 1] + offset[i - 1];
        }
        for (int b = 0; b < NUMBER_OF_BUCKETS; b++) {
            while (count[b] > 0) {
                int origin = offset[b];
                int from = origin;
                int num = unsorted[from];
                unsorted[from] = -1;
                do {
                    digit = getDigit(num, divisor);
                    int to = offset[digit]++;
                    count[digit]--;
                    int temp = unsorted[to];
                    unsorted[to] = num;
                    num = temp;
                    from = to;
                } while (from != origin);
            }
        }
        if (divisor > 1) {
            for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {
                int begin = (i > 0) ? offset[i - 1] : start;
                int end = offset[i];
                if (end - begin > 1)
                    sort(unsorted, begin, end, divisor / 10);
            }
        }
    }
    private static int getMaxNumberOfDigits(Integer[] unsorted) {
        int max = Integer.MIN_VALUE;
        int temp = 0;
        for (int i : unsorted) {
            temp = (int) Math.log10(i) + 1;
            if (temp > max)
                max = temp;
        }
        return max;
    }
    private static int getDigit(int integer, int divisor) {
        return (integer / divisor) % 10;
    }
}",0,0,0,0,0,0,0,0,0
1266,"package com.intrafoundation;
import java.util.Arrays;
public class BaseSort {
    protected int swaps = 0;
    public void sort(int[] arr) {
        swaps = 0;
        Arrays.sort(arr);
    }
    public int getSwaps() {
        return swaps;
    }
    protected void swap(int[] arr, int indexA, int indexB) {
        final int swapTemp = arr[indexA];
        arr[indexA] = arr[indexB];
        arr[indexB] = swapTemp;
        swaps++;
    }
}",0,0,0,0,0,0,0,0,0
1267,"public class BeadSort {
    public static void main(String[] args) {
        BeadSort now=new BeadSort();
        int[] arr = new int[(int)(Math.random() * 11) + 5];
        for(int i = 0;i < arr.length; i++)
            arr[i] = (int)(Math.random() * 10);
        System.out.print(""Unsorted: "");
        now.display1D(arr);
        int[] sort = now.beadSort(arr);
        System.out.print(""Sorted: "");
        now.display1D(sort);
    }
    int[] beadSort(int[] arr) {
        int max = arr[0];
        for(int i = 1; i < arr.length; i++)
            if(arr[i] > max)
                max = arr[i];
        char[][] grid = new char[arr.length][max];
        int[] levelcount = new int[max];
        for(int i = 0; i < max; i++) {
            levelcount[i] = 0;
            for(int j = 0; j < arr.length; j++)
                grid[j][i] = '_';
        }
        for(int i = 0; i < arr.length; i++) {
            int num = arr[i];
            for(int j = 0; num > 0; j++) {
                grid[levelcount[j]++][j] = '*';
                num--;
            }
        }
        System.out.println();
        display2D(grid);
        int[] sorted = new int[arr.length];
        for(int i = 0; i < arr.length; i++) {
            int putt = 0;
            for(int j = 0; j < max && grid[arr.length-1-i][j] == '*'; j++)
                putt++;
            sorted[i] = putt;
        }
        return sorted;
    }
    void display1D(int[] arr) {
        for(int i = 0; i < arr.length; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    void display1D(char[] arr) {
        for(int i = 0; i < arr.length; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    void display2D(char[][] arr) {
        for(int i = 0; i < arr.length; i++)
            display1D(arr[i]);
        System.out.println();
    }
}",0,0,0,0,0,0,0,0,0
1268,"public class BitonicSort
{
	void compAndSwap(int a[], int i, int j, int dir)
	{
		if ( (a[i] > a[j] && dir == 1) ||
			(a[i] < a[j] && dir == 0))
		{
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	void Merge(int a[], int low, int count, int dir)
	{
		if (cnt>1)
		{
			int k = count/2;
			for (int i=low; i<low+k; i++)
				compAndSwap(a,i, i+k, dir);
			Merge(a,low, k, dir);
			Merge(a,low+k, k, dir);
		}
	}
	void Sort(int a[], int low, int count, int dir)
	{
		if (cnt>1)
		{
			int k = count/2;
			Sort(a, low, k, 1);
			Sort(a,low+k, k, 0);
			Merge(a, low, cnt, dir);
		}
	}
	void sort(int a[], int N, int up)
	{
		Sort(a, 0, N, up);
	}
	static void printArray(int arr[])
	{
		int n = arr.length;
		for (int i=0; i<n; ++i)
			System.out.print(arr[i] + "" "");
		System.out.println();
	}
	public static void main(String args[])
	{
		int a[] = {3, 7, 4, 8, 6, 2, 1, 5};
		int up = 1;
		Sort ob = new Sort();
		ob.sort(a, a.length,up);
		System.out.println(""\nSorted array"");
		printArray(a);
	}
}",0,0,0,0,0,0,0,0,0
1269,"def compAndSwap(a, i, j, dir):
    if (dir==1 and a[i] > a[j]) or (dir==0 and a[i] < a[j]):
        a[i],a[j] = a[j],a[i]
def bitonicMerge(a, low, cnt, di):
    if cnt > 1:
        k = cnt/2
        for i in range(low , low+k):
            compAndSwap(a, i, i+k, dir)
        bitonicMerge(a, low, k, dir)
        bitonicMerge(a, low+k, k, dir)
def bitonicSort(a, low, cnt,dir):
    if cnt > 1:
          k = cnt/2
          bitonicSort(a, low, k, 1)
          bitonicSort(a, low+k, k, 0)
          bitonicMerge(a, low, cnt, dir)
def sort(a,N, up):
    bitonicSort(a,0, N, up)
a = [3, 7, 4, 8, 6, 2, 1, 5]
n = len(a)
up = 1
sort(a, n, up)
print (""\n\nSorted array is"")
for i in range(n):
    print(""%d"" %a[i]),",0,0,0,0,0,0,0,0,0
1270,"import java.util.Scanner;
public class BitonicSort {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print(""Enter the number of elements : "");
		int n = sc.nextInt();
		int[] arr = new int[n];
		System.out.println(""Enter "" + n + "" elements :"");
		for (int i = 0; i < n; i++)
			arr[i] = sc.nextInt();
		bitonicSort(arr, 0, arr.length, 1);
		System.out.println(""\nThe sorted array : ;"");
		for (int i = 0; i < n; i++)
			System.out.print(arr[i] + "" "");
		System.out.println();
	}
	public static void bitonicSort(int[] arr, int start, int length, int direction) {
		if (length > 1) {
			int mid = length/2;
			bitonicSort(arr, start, mid, 1);
			bitonicSort(arr, start+mid, mid, 0);
			bitonicMerge(arr, start, length, direction);
		}
	}
	private static void bitonicMerge(int[] arr, int start, int length, int direction) {
		if (length > 1) {
			int mid = length/2;
			for (int i = start; i < start+mid; i++) {
				if ((arr[i] > arr[i+mid] && direction == 1) ||
					 (arr[i] < arr[i+mid] && direction == 0)) {
					int temp = arr[i];
					arr[i] = arr[i+mid];
					arr[i+mid] = temp;
				}
			}
			bitonicMerge(arr, start, mid, direction);
			bitonicMerge(arr, start+mid, mid, direction);
		}
	}
}",0,0,0,0,0,0,0,0,0
1271,"import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
public class BitonicSort {
	void compAndSwap(int a[], int i, int j, int dir) {
		if ((a[i] > a[j] && dir == 1) || (a[i] < a[j] && dir == 0)) {
			int temp = a[i];
			a[i] = a[j];
			a[j] = temp;
		}
	}
	void bitonicMerge(int a[], int low, int cnt, int dir) {
		if (cnt > 1) {
			int k = cnt / 2;
			for (int i = low; i < low + k; i++)
				compAndSwap(a, i, i + k, dir);
			bitonicMerge(a, low, k, dir);
			bitonicMerge(a, low + k, k, dir);
		}
	}
	void bitonicSort(int a[], int low, int cnt, int dir) {
		if (cnt > 1) {
			int k = cnt / 2;
			bitonicSort(a, low, k, 1);
			bitonicSort(a, low + k, k, 0);
			bitonicMerge(a, low, cnt, dir);
		}
	}
	void sort(int a[], int N, int up) {
		bitonicSort(a, 0, N, up);
	}
	static void printArray(int arr[]) {
		int n = arr.length;
		for (int i = 0; i < n; ++i)
			System.out.print(arr[i] + "" "");
		System.out.println();
	}
	public static void main(String args[]) {
		Scanner sc = new Scanner(System.in);
		List<Integer> numberList = new ArrayList<Integer>();
		while (sc.hasNext()) {
			int number = sc.nextInt();
			numberList.add(number);
		}
		sc.close();
		int[] a = numberList.stream().mapToInt(i -> i).toArray();
		int up = 1;
		int size = a.length;
		System.out.println(size);
		boolean powerOfTwo = (size > 0) && ((size & (size - 1)) == 0);
		if (powerOfTwo == true) {
			BitonicSort ob = new BitonicSort();
			ob.sort(a, a.length, up);
			System.out.println(""\nThe sorted array is:"");
			printArray(a);
		} else {
			System.out.println(""\nThe size of the input must be a power of 2."");
		}
	}
}",0,0,0,0,0,0,0,0,0
1272,"public class BitonicSort 
{ 
	void compAndSwap(int a[], int i, int j, int dir) 
	{ 
		if ( (a[i] > a[j] && dir == 1) || 
			(a[i] < a[j] && dir == 0)) 
		{ 
			int temp = a[i]; 
			a[i] = a[j]; 
			a[j] = temp; 
		} 
	} 
	void bitonicMerge(int a[], int low, int cnt, int dir) 
	{ 
		if (cnt>1) 
		{ 
			int k = cnt/2; 
			for (int i=low; i<low+k; i++) 
				compAndSwap(a,i, i+k, dir); 
			bitonicMerge(a,low, k, dir); 
			bitonicMerge(a,low+k, k, dir); 
		} 
	} 
	void bitonicSort(int a[], int low, int cnt, int dir) 
	{ 
		if (cnt>1) 
		{ 
			int k = cnt/2; 
			bitonicSort(a, low, k, 1); 
			bitonicSort(a,low+k, k, 0); 
			bitonicMerge(a, low, cnt, dir); 
		} 
	} 
	void sort(int a[], int N, int up) 
	{ 
		bitonicSort(a, 0, N, up); 
	} 
	static void printArray(int arr[]) 
	{ 
		int n = arr.length; 
		for (int i=0; i<n; ++i) 
			System.out.print(arr[i] + "" ""); 
		System.out.println(); 
	} 
	public static void main(String args[]) 
	{ 
		int a[] = {3, 7, 4, 8, 6, 2, 1, 5}; 
		int up = 1; 
		BitonicSort ob = new BitonicSort(); 
		ob.sort(a, a.length,up); 
		System.out.println(""\nSorted array""); 
		printArray(a); 
	} 
} ",0,0,0,0,0,0,0,0,0
1273,"function bitonicSort (arrData) {
  'use strict'
  const ASCEND = true
  const DESCEND = false
  function _bitonicSort (order, arrData) {
    console.log('Cycle:', arrData.join())
    let dataMax = arrData.length
    if (dataMax <= 1) return arrData
    let dataSplit = Math.floor(dataMax / 2)
    let first = _bitonicSort(ASCEND, arrData.slice(0, dataSplit))
    let second = _bitonicSort(DESCEND, arrData.slice(dataSplit))
    return _bitonicMerge(order, first.concat(second))
  }
  function _bitonicMerge (order, arrData) {
    console.log('Merge:', arrData.join())
    let dataMax = arrData.length
    if (dataMax <= 1) return arrData
    _bitonicCompare(order, arrData)
    let dataSplit = Math.floor(dataMax / 2)
    let first = _bitonicMerge(order, arrData.slice(0, dataSplit))
    let second = _bitonicMerge(order, arrData.slice(dataSplit))
    return first.concat(second)
  }
  function _bitonicCompare (order, arrData) {
    console.log('Compare In:', arrData.join())
    let dataMax = arrData.length
    let dist = Math.floor(dataMax / 2)
    for (let i = 0; i < dist; i++) {
      if ((arrData[i] > arrData[i + dist]) === order) {
        let temp = arrData[i]
        arrData[i] = arrData[i + dist]
        arrData[i + dist] = temp
      }
    }
    console.log('Compare Out:', arrData.join())
  }
  console.log('Initial:', arrData.join())
  return _bitonicSort(ASCEND, arrData)
}",0,0,0,0,0,0,0,0,0
1274,"import numpy as np
def bogo_sort(arr):
    while (not is_sorted(arr)):
        np.random.shuffle(arr)
    return arr
def is_sorted(arr):
    for i in range(len(arr)-1):
        if arr[i+1] < arr[i]:
            return False
    return True",0,0,0,0,0,0,0,0,0
1275,"import java.util.Arrays;
import java.util.Random;
public class bogoSort {
    public static void main(String[] args) {
        int[] a = {4, 6, 1, 0, 5, 2};
        bogo_sort(a);
        System.out.println(Arrays.toString(a));
    }
    public static void bogo_sort(int[] a) {
        Random rand = new Random();
        while (!sort_check(a)) {
            for (int i = 0; i < a.length; i++) {
                int r = rand.nextInt(a.length);
                int temp = a[i];
                a[i] = a[r];
                a[r] = temp;
            }
        }
    }
    private static boolean sort_check(int[] a) {
        for (int i = 1; i < a.length; i++) {
            if (a[i] >= a[i - 1]) {
            } else {
                return false;
            }
        }
        return true;
    }
}",0,0,0,0,0,0,0,0,0
1276,"import random
def sort_check(a):
    n = len(a)
    for i in range(0,n-1):
        if (a[i] > a[i + 1]):
            return False
    return True
def bogosort(a):
    n = len(a)
    while (sort_check(a) == False):
        shuffle(a)
def shuffle(a):
    n = len(a)
    for i in range (0,n):
        r = random.randint(0,n-1)
        a[i], a[r] = a[r], a[i]
a = [7, 4, 0, 2, 8, 3, 6]
bogosort(a)
print(a)",0,0,0,0,0,0,0,0,0
1277,"import random
def bogoSort(a):
    n = len(a)
    while (is_sorted(a) is False):
         random.shuffle(a)
def is_sorted(a):
    n = len(a)
    for i in range(0, n-1):
        if (a[i] > a[i+1]):
            return False
    return True
def shuffle(a):
    n = len(a)
    for i in range(0, n):
        r = random.randint(0, n-1)
        a[i], a[r] = a[r], a[i]
a = [3, 2, 4, 1, 0, 5]
bogoSort(a)
print(""Sorted array :"")
for i in range(len(a)):
    print(""%d"" % a[i])",0,0,0,0,0,0,0,0,0
1278,"import java.util.*;
public class BogoSort {
   private static final Random RAN_OUTPUT = new Random();
    public static void bogoSort(int[] arr) {
      while (isSorted(arr) == false) {
         for (int i = 0; i < arr.length; i++) {
            int randomIndex = RAN_OUTPUT.nextInt(arr.length);
            int holder = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = holder;
         }
      }
    }
    private static boolean isSorted(int[] arr) {
      for (int i = 0; i < arr.length - 1; i++) {
         if (arr[i] > arr[i+1]) {
            return false;
         } 
      }
      return true;
    }
    public static void main(String[] args) {
      int[] arr = {3, 1, 2};
      System.out.println(""Before Sort: "" + Arrays.toString(arr));
      bogoSort(arr);
      System.out.println(""After Sort: "" + Arrays.toString(arr));
    }
}",0,0,0,0,0,0,0,0,0
1279,"function isSorted(arr) {
  if (arr.length == 0 || arr.length == 1) {
    return true;
  }
  for (let i=0;i<arr.length-1;i++) {
    if (arr[i] > arr[i+1]) {
      return false;
    }
  }
  return true;
}
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}
function bogoSort(data) {
  while (!isSorted(data)) {
    data = shuffleArray(data);
  };
  return data;
}",0,0,0,0,0,0,0,0,0
1280,"let array = [5,2,1,8,9]
shuffle = function(array) {
    for(var j, x, i = array.length; i; j = Math.floor(Math.random() * i), x = array[--i], array[i] = array[j], array[j] = x);
    return array;
};
isSorted = function(array){
    for(var i=1; i<array.length; i++) {
        if (array[i-1] > array[i]) {
            return false; 
        }
    }
    return true;
}
bogosort = function(array){
    var sorted = false;
    while(sorted == false){
        array = shuffle(array);
        sorted = isSorted(array);
    }
    return array;
}
console.log('before sort:', array)
console.log('after sort:',bogosort(array))",0,0,0,0,0,0,0,0,0
1281,"package eu.happycoders.sort.method.heapsort;
import eu.happycoders.sort.method.Counters;
public class BottomUpHeapsort extends Heapsort {
  @Override
  void heapify(int[] heap, int length, int rootPos) {
    int leafPos = findLeaf(heap, length, rootPos);
    int nodePos = findTargetNodeBottomUp(heap, rootPos, leafPos);
    if (rootPos == nodePos) return;
    int nodeValue = heap[nodePos];
    heap[nodePos] = heap[rootPos];
    while (nodePos > rootPos) {
      int parentPos = getParentPos(nodePos);
      int parentValue = heap[parentPos];
      heap[parentPos] = nodeValue;
      nodePos = getParentPos(nodePos);
      nodeValue = parentValue;
    }
  }
  int findLeaf(int[] heap, int length, int rootPos) {
    int pos = rootPos;
    int leftChildPos = pos * 2 + 1;
    int rightChildPos = pos * 2 + 2;
    while (rightChildPos < length) {
      if (heap[rightChildPos] > heap[leftChildPos]) {
        pos = rightChildPos;
      } else {
        pos = leftChildPos;
      }
      leftChildPos = pos * 2 + 1;
      rightChildPos = pos * 2 + 2;
    }
    if (leftChildPos < length) {
      pos = leftChildPos;
    }
    return pos;
  }
  int findTargetNodeBottomUp(int[] heap, int rootPos, int leafPos) {
    int parent = heap[rootPos];
    while (leafPos != rootPos && heap[leafPos] < parent) {
      leafPos = getParentPos(leafPos);
    }
    return leafPos;
  }
  int getParentPos(int pos) {
    return (pos - 1) / 2;
  }
  @Override
  void heapify(int[] heap, int length, int rootPos, Counters counters) {
    int leafPos = findLeaf(heap, length, rootPos, counters);
    int nodePos = findTargetNodeBottomUp(heap, rootPos, leafPos, counters);
    if (rootPos == nodePos) return;
    counters.incReads();
    int nodeValue = heap[nodePos];
    counters.incReadsAndWrites();
    heap[nodePos] = heap[rootPos];
    while (nodePos > rootPos) {
      counters.incIterations();
      int parentPos = getParentPos(nodePos);
      counters.incReadsAndWrites();
      int parentValue = heap[parentPos];
      heap[parentPos] = nodeValue;
      nodePos = parentPos;
      nodeValue = parentValue;
    }
  }
  private int findLeaf(int[] heap, int length, int rootPos, Counters counters) {
    int pos = rootPos;
    int leftChildPos = pos * 2 + 1;
    int rightChildPos = pos * 2 + 2;
    while (rightChildPos < length) {
      counters.incIterations();
      counters.addReads(2);
      counters.incComparisons();
      if (heap[rightChildPos] > heap[leftChildPos]) {
        pos = rightChildPos;
      } else {
        pos = leftChildPos;
      }
      leftChildPos = pos * 2 + 1;
      rightChildPos = pos * 2 + 2;
    }
    if (leftChildPos < length) {
      pos = leftChildPos;
    }
    return pos;
  }
  private int findTargetNodeBottomUp(int[] heap, int rootPos, int leafPos,
                                     Counters counters) {
    counters.incReads();
    int parentValue = heap[rootPos];
    int nodePos = leafPos;
    while (nodePos != rootPos && nodeSmallerThanParent(heap[nodePos],
          parentValue, counters)) {
      counters.incIterations();
      nodePos = getParentPos(nodePos);
    }
    return nodePos;
  }
  private boolean nodeSmallerThanParent(int nodeValue, int parentValue,
                                        Counters counters) {
    counters.incReads();
    counters.incComparisons();
    return nodeValue < parentValue;
  }
}",0,0,0,0,0,0,0,0,0
1282,"package eu.happycoders.sort.method.heapsort;
import eu.happycoders.sort.method.Counters;
public class BottomUpHeapsortSlowComparisons extends BottomUpHeapsort {
  @Override
  int findLeaf(int[] heap, int length, int rootPos) {
    int pos = rootPos;
    int leftChildPos = pos * 2 + 1;
    int rightChildPos = pos * 2 + 2;
    while (rightChildPos < length) {
      slowDown();
      if (heap[rightChildPos] > heap[leftChildPos]) {
        pos = rightChildPos;
      } else {
        pos = leftChildPos;
      }
      leftChildPos = pos * 2 + 1;
      rightChildPos = pos * 2 + 2;
    }
    if (leftChildPos < length) {
      pos = leftChildPos;
    }
    return pos;
  }
  @Override
  int findTargetNodeBottomUp(int[] heap, int rootPos, int leafPos) {
    int parent = heap[rootPos];
    while (leafPos != rootPos) {
      slowDown();
      if (!(heap[leafPos] < parent)) break;
      leafPos = getParentPos(leafPos);
    }
    return leafPos;
  }
  @Override
  public void sort(int[] elements, Counters counters) {
    throw new Error(""Not implemented"");
  }
  private void slowDown() {
    long nanos = System.nanoTime();
    while (nanos == System.nanoTime()) {
    }
  }
  @Override
  public boolean isSuitableForSortedInput(int size) {
    return false;
  }
}",0,0,0,0,0,0,0,0,0
1283,"def brick_sort(arr):
    n = len(arr)
    is_sorted = 0
    while is_sorted == 0:
        is_sorted = 1
        for i in range(1, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                is_sorted = 0
        for i in range(0, n-1, 2):
            if arr[i] > arr[i+1]:
                arr[i], arr[i+1] = arr[i+1], arr[i]
                is_sorted = 0
    return arr",0,0,0,0,0,0,0,0,0
1284,"const brickSort = (arr) => {
  const swapElements = (arr, i, j) => {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  };
  let sorted = false;
  while (!sorted) {
    sorted = true;
    for (let i = 1; i < arr.length - 1; i += 2)
      if (arr[i] > arr[i + 1]) {
        swapElements(arr, i, i + 1);
        sorted = false;
      }
    for (let i = 0; i < arr.length - 1; i += 2)
      if (arr[i] > arr[i + 1]) {
        swapElements(arr, i, i + 1);
        sorted = false;
      }
  }
  return arr;
};",0,0,0,0,0,0,0,0,0
1285,"import random
import time
def bucket_sort(data):
	bucket_array = [None] * len(data)
 for item in data:
		bucket_array[item] = item
 return bucket_array
if __name__ == '__main__':
	lista = [_ for _ in range(1000000)]
 random.shuffle(lista)
 start_time = time.time()
 lista = bucket_sort(lista)
 end_time = time.time()
 print(""Time: "", end_time - start_time)",0,0,0,0,0,0,0,0,0
1286,"package org.neeraj.algorithms.sorting.remaining;
import java.util.Random;
public class Bucket_Sort 
{
    static int[] sort(int[] sequence, int maxValue) 
    {
        int[] Bucket = new int[maxValue + 1];
        int[] sorted_sequence = new int[sequence.length];
        for (int i = 0; i < sequence.length; i++)
            Bucket[sequence[i]]++;
        int outPos = 0;
        for (int i = 0; i < Bucket.length; i++)
            for (int j = 0; j < Bucket[i]; j++)
                sorted_sequence[outPos++] = i;
        return sorted_sequence;
    }
    static void printSequence(int[] sorted_sequence) 
    {
        for (int i = 0; i < sorted_sequence.length; i++)
            System.out.print(sorted_sequence[i] + "" "");
    }
    static int maxValue(int[] sequence) 
    {
        int maxValue = 0;
        for (int i = 0; i < sequence.length; i++)
            if (sequence[i] > maxValue)
                maxValue = sequence[i];
        return maxValue;
    }
    public static void main(String args[]) 
    {
        System.out
                .println(""Sorting of randomly generated numbers using BUCKET SORT"");
        Random random = new Random();
        int N = 20;
        int[] sequence = new int[N];
        for (int i = 0; i < N; i++)
            sequence[i] = Math.abs(random.nextInt(100));
        int maxValue = maxValue(sequence);
        System.out.println(""\nOriginal Sequence: "");
        printSequence(sequence);
        System.out.println(""\nSorted Sequence: "");
        printSequence(sort(sequence, maxValue));
    }
}",0,0,0,0,0,0,0,0,0
1287,"public class BucketSort {
    static int[] sort(int[] nums, int max) {
        int[] bucket = new int[max + 1];
        int[] sortedNums = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            bucket[nums[i]]++;
        }
        int index = 0;
        for (int i = 0; i < bucket.length; i++) {
            for (int j = 0; j < bucket[i]; j++) {
                sortedNums[index++] = i;
            }
        }
        return sortedNums;
    }
    static int getMax(int[] nums) {
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > max) {
                max = nums[i];
            }
        }
        return max;
    }
    public static void main(String args[]) {
        int nums[] = {7, 3, 2, 1, 0, 4, 5};
        int maxValue = getMax(nums);
        System.out.println(""Unsorted Array:"");
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i] + "" "");
        }
        nums = sort(nums, maxValue);
        System.out.println();
        System.out.println(""Sorted Array:"");
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i] + "" "");
        }
    }
}",0,0,0,0,0,0,0,0,0
1288,"import java.util.Collections;
import java.util.*;
class bucketSort
	public static void main(String [] args){
		float [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		float [] sortedArr = new float [sizeofArr];
		sortedArr = bucketSort(arr, sizeofArr);
	}
	static float [] bucketSort(float [] arr, int sizeofArr){
		int j=0;
		arr = normaliseIt(arr, n);
		Vector<Int>[] buckets = new Vector[10];
		for (int i=0;i<10;i++) buckets[i] = new Vector<Int>();
		for (int i=0;i<n;i++) buckets[(int) arr[i]*10].add(arr[i]);
		for (int i=0;i<10;i++) Collections.sort(buckets[i]);
		for (int i=0;i<n;i++) for (int k=0;k<buckets[i].size();k++)
			arr[j++] = buckets[i].get(k);
		return deNormaliseIt(arr);
	}
	static float [] denormaliseIt(float [] arr, int n){
		float max = getMax(arr, n);
		for (int i=0;i<n;i++) arr[i] *= max;
		return arr;
	}
	static float [] normaliseIt(float [] arr, int n){
		float max = getMax(arr, n);
		for (int i=0;i<n;i++) arr[i] /= max;
		return arr;
	}
	static float getMax(float [] arr, int n){
		float max = 0;
		for (int i=0;i<n;i++) if (max < arr[i]) max = arr[i];
	}
}",0,0,0,0,0,0,0,0,0
1289,"import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
class BucketSort 
{
    static int[] bucketSort(int[] sequence, int maxValue) 
    {
        int[] Bucket = new int[maxValue + 1];
        int[] sortedSequence = new int[sequence.length];
        for (int i = 0; i < sequence.length; i++)
            Bucket[sequence[i]]++;
        int outPos = 0;
        for (int i = 0; i < Bucket.length; i++)
            for (int j = 0; j < Bucket[i]; j++)
                sortedSequence[outPos++] = i;
        return sortedSequence;
    }
    static void printSequence(int[] sortedSequence) 
    {
        for (int i = 0; i < sortedSequence.length; i++)
            System.out.print(sortedSequence[i] + "" "");
    }
    static int maxValue(int[] sequence) 
    {
        int maxValue = 0;
        for (int i = 0; i < sequence.length; i++)
            if (sequence[i] > maxValue)
                maxValue = sequence[i];
        return maxValue;
    }
    public static void main(String args[]) 
    {
        System.out.println(""Sorting of randomly generated numbers using BUCKET SORT"");
        Random random = new Random();
        int N = 20;
        int[] sequence = new int[N];
        for (int i = 0; i < N; i++)
            sequence[i] = Math.abs(random.nextInt(100));
        int maxValue = maxValue(sequence);
        System.out.println(""\nOriginal Sequence: "");
        printSequence(sequence);
        System.out.println(""\nSorted Sequence: "");
        printSequence(bucketSort(sequence, maxValue));
    }
}",0,0,0,0,0,0,0,0,0
1290,"package com.aokolnychyi.sorting;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
public class BucketSort {
  public static void sort(Double[] array, int numberOfBuckets) {
    final ArrayList<List<Double>> buckets = new ArrayList<>(numberOfBuckets);
    for (int bucketIndex = 0; bucketIndex < numberOfBuckets; bucketIndex++) {
      buckets.add(new ArrayList<>());
    }
    for (Double element : array) {
      final int bucketIndex = getBucketIndex(element, numberOfBuckets);
      buckets.get(bucketIndex).add(element);
    }
    buckets.forEach(Collections::sort);
    int currentOutputIndex = 0;
    for (int bucketIndex = 0; bucketIndex < numberOfBuckets; bucketIndex++) {
      final List<Double> bucket = buckets.get(bucketIndex);
      for (Double element : bucket) {
        array[currentOutputIndex] = element;
        currentOutputIndex++;
      }
    }
  }
  private static int getBucketIndex(Double element, int numberOfBuckets) {
    return (int) (element * numberOfBuckets);
  }
  public static void main(String[] args) {
    final Double[] doubles = new Double[]{0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};
    sort(doubles, 3);
    sort(new Double[]{}, 3);
    System.out.println(Arrays.toString(doubles));
  }
}",0,0,0,0,0,0,0,0,0
1291,"package main;
import java.util.ArrayList;
import java.util.List;
public class BucketSort {
    public static void main(String[] args) {
        int[] arr = {10, 34, 2, 56, 7, 674, 882, 42, 0, 100};
        bucketSort(arr);
        for (int num : arr) {
            System.out.print(num);
            System.out.print("", "");
        }
    }
    public static void bucketSort(int[] arr) {
        int bucketNum = 5;
        int minValue = arr[0];
        int maxValue = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > maxValue) maxValue = arr[i];
            if (arr[i] < minValue) minValue = arr[i];
        }
        int diff = maxValue - minValue;
        int range = diff / bucketNum;
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < bucketNum + 1; i++) {
            result.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < arr.length; i++) {
            result.get((arr[i] - minValue) / range).add(arr[i]);
        }
        int index = 0;
        for (int j = 0; j < result.size(); j++) {
            int[] subArr = new int[result.get(j).size()];
            for (int i = 0; i < subArr.length; i++) {
                subArr[i] = result.get(j).get(i);
            }
            int[] subArrSorted = doInsertionSort(subArr);
            for (int i = 0; i < subArrSorted.length; i++) {
                arr[index] = subArrSorted[i];
                index++;
            }
        }
    }
    public static int[] doInsertionSort(int[] input) {
        for (int i = 1; i < input.length; i++) {
            for (int j = i; j > 0; j--) {
                if (input[j] < input[j - 1]) {
                    int temp = input[j];
                    input[j] = input[j - 1];
                    input[j - 1] = temp;
                }
            }
        }
        return input;
    }
}",0,0,0,1,0,0,0,0,0
1292,"import java.io.IOException;
import java.util.ArrayList;
public class BucketSort extends Sorts{
	InsertionSort insertion = new InsertionSort();
	public ArrayList<Integer> bucketSort(ArrayList<Integer> unsortedList)
	{
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		ArrayList<ArrayList<Integer>> buckets = new ArrayList<ArrayList<Integer>>();
		for(int i = 0; i < 10; i++)
		{
			buckets.add(new ArrayList<Integer>());
		}
		for(int i = 0; i < unsortedList.size(); i++)
		{
			int check = 10;
			int arrayToPlace = 0;
			boolean greater = true;
			while(greater)
			{
				if(unsortedList.get(i) > check)
				{
					check = check * 10;
					arrayToPlace++;
				}
				else
				{
					buckets.get(arrayToPlace).add(unsortedList.get(i));
					greater = false;
				}
			}
		}
		for(int i = 0; i < buckets.size(); i++)
		{
			sortedList.addAll(insertion.insertionSort(buckets.get(i)));
		}
		return sortedList;
	}
	public void BucketTime(IOClass ioStream) throws IOException
	{
		ioStream.readFromFile();
		ArrayList<Integer> sortedList = new ArrayList<Integer>();
		long timeBefore = System.nanoTime();
		sortedList = bucketSort(ioStream.getInputArray());
		long timeAfter = System.nanoTime();
		double rawTime = timeAfter - timeBefore;
		double timeInMilli = rawTime/1000000;
		if(isSorted(sortedList))
		{
			ioStream.setInputArray(sortedList);
			System.out.print(""BucketSort time (in Milli): ""); 
			System.out.println(timeInMilli);
		}
		else
		{
			ioStream.setInputArray(sortedList);
			System.out.println(""Not sorted!"");
		}
	}
}",0,0,0,1,0,0,0,0,0
1293,"const insertionSort = bucket => {
    for(i=0; i < bucket.length; i++){
        const up = bucket[i]
        let j = i-1
        while(j >= 0 && bucket[j] > up){
            bucket[j+1] = bucket[j]
            j--
        }
        bucket[j+1] = up
    }
    return bucket
}
const bucketSort = initialArray => {
    const numBuckets = 10
    let array = []
    for(let i=0; i < numBuckets; i++){
        array.push([])
    }
    for(elem of initialArray){
        const bucketIndex = parseInt(numBuckets * elem)
        array[bucketIndex].push(elem)
    }
    for(let i=0; i < numBuckets; i++){
        array[i] = insertionSort(array[i])
    }
    let k = 0
    for(i=0; i < numBuckets; i++){
        for(elem of array[i]){
            initialArray[k] = elem
            k++
        }
    }
    return initialArray
}
const initialArray = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
const sortedArray = bucketSort(initialArray)
console.log(sortedArray)",0,0,0,1,0,0,0,0,0
1294,"def insertionSort(b):
    for i in range(1, len(b)):
        up = b[i]
        j = i - 1
        while j >= 0 and b[j] > up:
            b[j + 1] = b[j]
            j -= 1
        b[j + 1] = up    
    return b    
def bucketSort(x):
    arr = []
    slot_num = 10
    for i in range(slot_num):
        arr.append([])
    for j in x:
        index_b = int(slot_num * j)
        arr[index_b].append(j)
    for i in range(slot_num):
        arr[i] = insertionSort(arr[i])
    k = 0
    for i in range(slot_num):
        for j in range(len(arr[i])):
            x[k] = arr[i][j]
            k += 1
    return x
x = [0.897, 0.565, 0.656,
     0.1234, 0.665, 0.3434]
print(""Sorted Array is"")
print(bucketSort(x))",0,0,0,0,0,0,0,0,0
1295,"package Sorting.Challenges;
public class Challenge3 {
    public static void main(String[] args) {
        String[] arr={""bcdef"",""dbaqc"",""abcde"",""omadd"",""bbbbb""};
        rS(arr,26,5);
        for(int j=0;j<arr.length;j++){
            System.out.print(arr[j]+"" "");
        }
    }
    public static void rS(String[] arr,int radix,int width){
        for (int i = width-1; i >=0; i--) {
            rSS(arr,i,radix);
        }
    }
    public static void rSS(String[] arr, int pos, int radix){
        int numItems = arr.length;
        int[] c = new int[radix];
        for (String value: arr){
            c[getChar(pos,value)]++;
        }
        for (int j = 1; j < radix ; j++) {
            c[j] += c[j-1];
        }
        String[] temp = new String[numItems];
        for (int ti = numItems-1; ti >=0 ; ti--) {
            temp[--c[getChar(pos,arr[ti])]] = arr[ti];
        }
        for(int ti = 0; ti< numItems ;ti++){
            arr[ti] = temp[ti];
        }
    }
    public static int getChar(int pos, String value){
        return value.charAt(pos) - 'a';
    }
}",0,0,0,0,0,0,0,0,0
1296,"package sort;
import static sort.SortUtils.*;
class CocktailShakerSort implements SortAlgorithm {
    @Override
    public <T extends Comparable<T>> T[] sort(T[] array) {
        int length = array.length;
        int left = 0;
        int right = length - 1;
        int swappedLeft, swappedRight;
        while (left < right) {
            swappedRight = 0;
            for (int i = left; i < right; i++) {
                if (less(array[i + 1], array[i])) {
                    swap(array, i, i + 1);
                    swappedRight = i;
                }
            }
            right = swappedRight;
            swappedLeft = length - 1;
            for (int j = right; j > left; j--) {
                if (less(array[j], array[j - 1])) {
                    swap(array, j - 1, j);
                    swappedLeft = j;
                }
            }
            left = swappedLeft;
        }
        return array;
    }
	public static void main(String[] args) {
		Integer[] integers = { 4, 23, 6, 78, 1, 54, 231, 9, 12 };
		CocktailShakerSort shakerSort = new CocktailShakerSort();
		print(shakerSort.sort(integers));
		String[] strings = { ""c"", ""a"", ""e"", ""b"", ""d"" };
		print(shakerSort.sort(strings));
	}
}",0,0,0,0,0,0,0,0,0
1297,"import copy
import sort_tools
def counting_sort(data):
    output = data.copy()
    counts = []
    max_val = max(data)
    min_val = min(data)
    minAbs_val = abs(min_val)
    j = 0
    if ( min_val > 0 ):
        min_val = 0
        minAbs_val = 0
    for i in range(minAbs_val + max_val + 1):
        counts.append(0)
    for i in range(len(data)):
        counts[data[i] + minAbs_val] += 1
    for i in range(1, len(counts)):
        counts[i] += counts[i-1]
    for i in range(len(data)-1, -1, -1):
        output[counts[data[i] + minAbs_val] - 1] = data[i]
        counts[data[i] + minAbs_val] -= 1
    for i in range(len(data)):
        data[i] = output[i]
@sort_tools.timeit('counting')
def sort(data):
    counting_sort(data)
def main():
    data = sort_tools.build_data_set(5)
    unsorted = copy.deepcopy(data)
    sort(unsorted)
if __name__ == ""__main__"":
    main()",0,0,0,0,0,0,0,0,0
1298,"def counting_sort(arr):
    output = [0 for i in range(len(arr))]
    count = [0 for i in range(256)]
    res = [0 for _ in arr]
    for i in arr:
        count[i] += 1
    for i in range(256):
        count[i] += count[i-1]
    for i in range(len(arr)):
        output[count[arr[i]] - 1] = arr[i]
        count[arr[i]] -= 1
    for i in range(len(arr)):
        res[i] = output[i]
    return res",0,0,0,0,0,0,0,0,0
1299,"def countingSort(unsorted_arr):
    max_value = max(unsorted_arr)
    count = [0 for _ in range(max_value + 1)]
    for x in unsorted_arr:
        count[x] += 1
    sorted_arr = []
    for x in range(max_value+1):
        for y in range(count[x]):
            sorted_arr.append(x)
    return sorted_arr
unsorted_arr = list(map(int, input().strip().split()))
print(*countingSort(unsorted_arr))",0,0,0,0,0,0,0,0,0
1300,"package io.nayuki.sortalgodemo.algo;
import io.nayuki.sortalgodemo.core.AbstractSortAlgorithm;
import io.nayuki.sortalgodemo.core.SortAlgorithm;
import io.nayuki.sortalgodemo.core.SortArray;
public final class CycleSort extends AbstractSortAlgorithm {
	public static final SortAlgorithm INSTANCE = new CycleSort();
	public void sort(SortArray array) {
		int length = array.length();
		boolean[] done = new boolean[length];
		for (int i = 0; i < length; i++) {
			while (true) {
				int target = 0;
				for (int j = 0; j < length; j++) {
					if (array.compare(j, i) < 0)
						target++;
					if (done[i])
						array.setElement(i, SortArray.ElementState.DONE);
					if (done[j])
						array.setElement(j, SortArray.ElementState.DONE);
				}
				done[target] = true;
				if (target == i)
					break;
				array.swap(i, target);
				array.setElement(target, SortArray.ElementState.DONE);
			}
		}
	}
	private CycleSort() {
		super(""Cycle sort"");
	}
}",0,0,0,0,0,0,0,0,0
1301,"function cycleSort (arrData) {
  'use strict'
  const dataMax = arrData.length
  let pos
  let item
  let temp
  console.log('Initial:', arrData.join(), `[Count:${dataMax}]`)
  for (let cycleStart = 0; cycleStart < dataMax - 1; cycleStart++) {
    item = arrData[ cycleStart ]
    pos = cycleStart
    for (let i = cycleStart + 1; i < dataMax; i++) {
      if (arrData[ i ] < item) pos++
    }
    if (pos === cycleStart) continue
    while (item === arrData[ pos ]) pos++
    if (item !== arrData[ pos ]) {
      temp = arrData[ pos ]
      arrData[ pos ] = item
      item = temp
    }
    while (pos !== cycleStart) {
      pos = cycleStart
      for (let i = cycleStart + 1; i < dataMax; i++) {
        if (arrData[ i ] < item) pos++
      }
      while (item === arrData[ pos ]) pos++
      if (item !== arrData[ pos ]) {
        temp = arrData[ pos ]
        arrData[ pos ] = item
        item = temp
      }
    }
    console.log('Cycle:', arrData.join())
  }
  console.log('Final:', arrData.join())
  return arrData
}",0,0,0,0,0,0,0,0,0
1302,"package Sorting;
public class FactorialByR {
    public static void main(String[] args) {
        System.out.println(ifact(5));
        System.out.println(rfact(0));
    }
    public static int ifact(int n){
        if(n == 0){
            return 1;
        }
        int fact = 1;
        for (int i = 1; i <=n ; i++) {
            fact*=i;
        }
        return fact;
    }
    public static int rfact(int n){
        if(n == 0){
            return 1;
        }
        return n * rfact(n-1);
    }
}",0,0,0,0,0,0,0,0,0
1303,"package sortlab.algorithm;
import java.util.Comparator;
public final class FatefulSort<T> implements SortAlgorithmInterface<T> {
  private final Comparator<T> comparator;
  public FatefulSort(Comparator<T> comparator) {
    this.comparator = comparator;
  }
  public T[] sort(T[] input) {
    return input;
  }
}",0,0,0,0,0,0,0,0,0
1304,"package Java;
import java.util.Arrays;
public class GnomeSort {
    public static void main(String[] args){
        int[] arr = {1,6,23,5,8,2,43,35};
        System.out.println(Arrays.toString(arr));
        gnomeSort(arr);
        System.out.println(Arrays.toString(arr));
    }
    private static void gnomeSort(int[] arr){
        int pos = 0;
        int size = arr.length;
        while(pos < size){
            if(pos == 0 || arr[pos] >= arr[pos-1]){
                pos ++;
            }
            else{
                swap(arr, pos, pos - 1);
                pos--;
            }
        }
    }
    private static void swap(int[] arr, int p1, int p2){
        int temp = arr[p1];
        arr[p1] = arr[p2];
        arr[p2] = temp;
    }
}",0,0,0,0,0,0,0,0,0
1305,"class gnomeSort
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		int [] sortedArr = new int [sizeofArr];
		sortedArr = gnomeSort(arr, sizeofArr);
		print(sortedArr);
	}
	static int [] gnomeSort(int [] arr, int sizeofArr){
		int temp;
		for (int i=0;i<sizeofArr;i++){
			for (int k=0;k<sizeofArr-1-i;k++)
				if (arr[k] > arr[k+1]){
					temp = arr[k];
					arr[k] = arr[k+1];
					arr[k+1] = temp;
				}
			for (int k=sizeofArr-1-i;k>i;k--)
				if (arr[k-1] > arr[k]){
					temp = arr[k];
					arr[k] = arr[k-1];
					arr[k-1] = temp;
				}
		}
		return arr;
	}
	static void print (int [] arr){
		for (int a : arr)
		System.out.print("" ""+a);
	}
}",0,0,0,0,0,0,0,0,0
1306,"package com.growingwiththeweb.sorting;
public class GnomeSort {
    public static <T extends Comparable<T>> void sort(T[] array) {
        int i = 0;
        while (i < array.length) {
            if (i == 0 || array[i - 1].compareTo(array[i]) <= 0) {
                i++;
            } else {
                swap(array, i, i - 1);
                i--;
            }
        }
    }
    private static <T extends Comparable<T>> void swap(
            T[] array, int a, int b) {
        T temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}",0,0,0,0,0,0,0,0,0
1307,"from time import sleep
from typing import List
from tkinter import Tk
from animated import Animator
class GnomeSort(Animator):
    def sort(self, array: List[int]) -> None:
        i = 1
        while i < len(array):  
            if (
                array[i] > array[i - 1] or i == 0
            ):  
                self.render(array, cur=(i - 1, i - 2))
                sleep(0.01)
                i += 1
            else:
                array[i], array[i - 1] = (
                    array[i - 1],
                    array[i],
                )  
                self.render(array, cur=(i - 1, i - 2))
                sleep(0.01)
                i -= 1
def main() -> int:
    try:
        from utils import randomSequence
    except ModuleNotFoundError:
        import os, sys  
        dir_path = os.path.dirname(os.path.realpath(__file__))
        parent_dir_path = os.path.abspath(os.path.join(dir_path, os.pardir))
        sys.path.insert(0, parent_dir_path)
        from utils import randomSequence
    shuffledArray = randomSequence(0, 100)
    root = Tk()
    sorter = GnomeSort(
        root,
        background=""black"",
        width=root.winfo_screenwidth(),
        height=root.winfo_screenheight(),
    )
    sorter.pack()
    sorter.sort(shuffledArray)
    sorter.finished()
    return 0",0,0,0,0,0,0,0,0,0
1308,"package otros.algoritmos;
import java.util.Arrays;
public class GnomeSort {
	static void gnomeSort(int arr[], int x) {
		int cont = 0;
		while(cont < x) {
			if (cont == 0) {
				cont++;
			} else if (arr[cont] >= arr[cont - 1]) {
				cont++;
			} else {
				int tmp = 0;
				tmp = arr[cont];
				arr[cont] = arr[cont - 1];
				arr[cont - 1] = tmp;
				cont--;
			}
		}
		return;
	}
	public static void main(String[] args) {
		int arr[] = { 345, 123, 34, 45, -15, -89, 0, -124};
		gnomeSort(arr, arr.length);
		System.out.print(Arrays.toString(arr));
	}
}",0,0,0,0,0,0,0,0,0
1309,"import java.util.Scanner;
public class HeapSort
    {
        static public void sort(int arr[])
        {
            int n = arr.length;
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);
            for (int i=n-1; i>=0; i--)
            {
                int temp = arr[0];
                arr[0] = arr[i];
                arr[i] = temp;
                heapify(arr, i, 0);
            }
        }
       static void heapify(int arr[], int n, int i)
        {
            int largest = i;
            int l = 2*i + 1;
            int r = 2*i + 2;
            if (l < n && arr[l] > arr[largest])
                largest = l;
            if (r < n && arr[r] > arr[largest])
                largest = r;
            if (largest != i)
            {
                int swap = arr[i];
                arr[i] = arr[largest];
                arr[largest] = swap;
                heapify(arr, n, largest);
            }
        }
        static void printArray(int arr[])
        {
            int n = arr.length;
            for (int i=0; i<n; ++i)
                System.out.print(arr[i]+"" "");
            System.out.println();
        }
        public static void main(String args[])
        {
            Scanner sc = new Scanner(System.in);
            System.out.print(""Enter no of elements: "");
            int n = sc.nextInt();
            int arr[] = new int[n];
            System.out.print(""Enter elements: "");
            for(int i=0 ; i<n ; i++)
                arr[i]=sc.nextInt();
            HeapSort ob = new HeapSort();
            System.out.print(""Array before sort : "");
            printArray(arr);
            ob.sort(arr);
            System.out.print(""Array after sort : "");
            printArray(arr);
        }
    }",0,0,0,0,0,0,0,0,0
1310,"import MaxHeap from '../DataStructures/MaxHeap';
export default function HeapSort(items: Array<number>) {
  const heap = new MaxHeap();
  const list = [];
  items.forEach(item => {
    heap.insert(item);
  });
  heap.get().forEach(() => {
    const node = heap.deleteNodeIndex(0);
    list.push(node);
  });
  return list.reverse();
}",0,0,0,0,0,0,0,0,0
1311,"package com.dev.namhoai.sort;
public class HeapSort {
    public void sort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            heapAdd(arr, i);
        }
        for (int i = arr.length - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i - 1);
        }
    }
    private void heapify(int[] arr, int end) {
        int i = 0;
        int leftIndex;
        int rightIndex;
        while (i <= end) {
            leftIndex = 2 * i + 1;
            if (leftIndex > end) {
                break;
            }
            rightIndex = 2 * i + 2;
            if (rightIndex > end) {
                rightIndex = leftIndex;
            }
            if (arr[i] >= Math.max(arr[leftIndex], arr[rightIndex])) {
                break;
            }
            if (arr[leftIndex] >= arr[rightIndex]) {
                swap(arr, i, leftIndex);
                i = leftIndex;
            } else {
                swap(arr, i, rightIndex);
                i = rightIndex;
            }
        }
    }
    private void swap(int[] arr, int x, int y) {
        int temp = arr[x];
        arr[x] = arr[y];
        arr[y] = temp;
    }
    private void heapAdd(int[] arr, int end) {
        int i = end;
        while (i > 0) {
            if (arr[i] > arr[(i - 1) / 2]) {
                swap(arr, i, (i - 1) / 2);
                i = (i - 1) / 2;
            } else {
                break;
            }
        }
    }
    public static void main(String[] args) {
        HeapSort hs = new HeapSort();
        int[] arr = {-1, 5, 8, 2, -6, -8, 11, 5};
        hs.sort(arr);
        for (int a : arr) {
            System.out.println(a);
        }
    }
}",0,0,0,0,0,0,0,0,0
1312,"let array_length;
const heap_root = (input, i) => {
    var left = 2 * i + 1;
    var right = 2 * i + 2;
    var max = i;
    if (left < array_length && input[left] > input[max]) {
        max = left;
    }
    if (right < array_length && input[right] > input[max]) {
        max = right;
    }
    if (max != i) {
        swap(input, i, max);
        heap_root(input, max);
    }
}
const swap = (input, index_A, index_B) => {
    var temp = input[index_A];
    input[index_A] = input[index_B];
    input[index_B] = temp;
}
const heapSort = (input) => {
    array_length = input.length;
    for (var i = Math.floor(array_length / 2); i >= 0; i -= 1) {
        heap_root(input, i);
    }
    for (i = input.length - 1; i > 0; i--) {
        swap(input, 0, i);
        array_length--;
        heap_root(input, 0);
    }
}
let arr = [3, 0, 2, 5, -1, 4, 1];
heapSort(arr);
console.log(arr);",0,0,0,0,0,0,0,0,0
1313,"def heapify(arr, n, root):
    largest = root
    left = 2 * root + 1
    right = 2 * root + 2
    if left < n and arr[root] < arr[left]:
        largest = left
    if right < n and arr[largest] < arr[right]:
        largest = right
    if largest != root:
        arr[root], arr[largest] = arr[largest], arr[root]
        heapify(arr, n, largest)
def heap_sort(arr):
    n = len(arr)
    for i in range(n, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
if __name__ == '__main__':
    arr = [12, 11, 13, 5, 6, 7]
    heap_sort(arr)
    print(""Sorted array:"", arr)",0,0,0,0,0,0,0,0,0
1314,"function heapSort (arrData) {
  'use strict'
  let numTail = arrData.length - 1   
  const NEED_CHANGE = 1
  const NO_CHANGE = 0
  const LEFT_CHILD = 1
  const RIGHT_CHILD = 2
  function fnSwap (idx1, idx2) {
    let swap = arrData[idx1]
    arrData[idx1] = arrData[idx2]
    arrData[idx2] = swap
  }
  const fnChildId = (parentId, side) => {
    let childId = (parentId * 2) + side
    return (childId <= numTail) ? childId : NO_CHANGE
  }
  function fnBalanceTriad (parentIdx) {
    let numBalanced = NO_CHANGE
    let leftChild = fnChildId(parentIdx, LEFT_CHILD)
    if (leftChild) {
      let rightChild = fnChildId(parentIdx, RIGHT_CHILD)
      if (rightChild &&
        (arrData[parentIdx] < arrData[rightChild]) &&
        (arrData[leftChild] < arrData[rightChild])) {
        fnSwap(parentIdx, rightChild)
        numBalanced = RIGHT_CHILD
      } else if (arrData[parentIdx] < arrData[leftChild]) {
        fnSwap(parentIdx, leftChild)
        numBalanced = LEFT_CHILD
      }
    }
    return numBalanced
  }
  function fnBalanceHeap () {
    let idx
    let numBalanced = NEED_CHANGE
    while (numBalanced) {
      numBalanced = NO_CHANGE
      idx = numTail
      while (idx + 1) numBalanced += fnBalanceTriad(idx--)  
    }
  }
  function fnRemoveHead () {
    fnSwap(0, numTail--)   
    let numBalanced = NO_CHANGE
    let idx = 0  
    do {
      numBalanced = fnBalanceTriad(idx)
      idx += (idx + numBalanced)   
    } while (numBalanced)  
  }
  console.log('Initial:', arrData.join(), `[Count:${numTail}]`)
  fnBalanceHeap()  
  while (numTail) {
    fnRemoveHead()   
    console.log('Cycle:', arrData.join())
  }
  console.log('Final:', arrData.join())
  return arrData
}",0,0,0,0,0,0,0,0,0
1315,"package sorting;
import java.util.NoSuchElementException;
import edu.princeton.cs.algs4.StdOut;
public class IndexMaxPQ<Key extends Comparable<Key>> {
  private int N;  
  private int[] pq;  
  private int[] qp;  
  private Key[] keys;  
  public IndexMaxPQ(int maxN) {
    keys = (Key[]) new Comparable[maxN + 1];
    pq = new int[maxN + 1];
    qp = new int[maxN + 1];
    for (int i = 0; i <= maxN; i++) qp[i] = -1;
  }
  public boolean isEmpty() { return N == 0; }
  public int size() {return N;}  
  public void change(int k, Key key) {}  
  public boolean contains(int k) { return qp[k] != -1; }
  public void insert(int i, Key key) {
    if (contains(i)) throw new IllegalArgumentException(""index is already in the priority queue"");
    N++;
    qp[i] = N;
    pq[N] = i;
    keys[i] = key;
    swim(N);
  }
  public void delete(int i) {
    if (!contains(i)) throw new NoSuchElementException(""index is not in the priority queue"");
    int index = qp[i];
    exch(index, N--);
    swim(index);
    sink(index);
    keys[i] = null;
    qp[i] = -1;
  } 
  public Key max() { 
    if (N == 0) throw new NoSuchElementException(""Priority queue underflow"");
    return keys[pq[1]]; 
  }
  public int maxIndex() {
    if (N == 0) throw new NoSuchElementException(""Priority queue underflow"");
    return pq[1];
  }
  public int delMax() {
    int indexOfMax = pq[1];
    exch(1, N--);
    sink(1);
    keys[pq[N+1]] = null;
    qp[pq[N+1]] = -1;
    return indexOfMax;
  }
  private void swim(int k) {
    while (k > 1 && less(k/2, k)) {
      exch(k/2, k);
      k = k/2;
    }
  }
  private void sink(int k) {
    while (2*k <= N)  {
      int j = 2*k;
      if (j < N && less(j, j+1)) j++;
      if (!less(k, j)) break;
      exch(k, j);
      k = j;
    }
  }
  private boolean less(int i, int j) { 
    return keys[pq[i]].compareTo(keys[pq[j]]) < 0; 
  }
  private void exch(int i, int j) { 
    int swap = pq[i];
    pq[i] = pq[j];
    pq[j] = swap;
    qp[pq[i]] = i;
    qp[pq[j]] = j;
  }
  public static void main(String[] args) {
    String[] strings = { ""it"", ""was"", ""the"", ""best"", ""of"", ""times"", ""it"", ""was"", ""the"", ""worst"" };
    IndexMaxPQ<String> pq = new IndexMaxPQ<String>(strings.length);
    for (int i = 0; i < strings.length; i++) {
        pq.insert(i, strings[i]);
    }
    while (!pq.isEmpty()) {
        String key = pq.max();
        int i = pq.delMax();
        StdOut.println(i + "" "" + key);
    }
  }
}",0,0,0,0,0,0,0,0,0
1316,"import java.util.Random;
import java.util.Scanner;
public class IntroSort {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.print(""Enter the number of elements : "");
		int n = sc.nextInt();
		int arr[] = new int[n];
		System.out.println(""Enter "" + n + "" elements :"");
		for (int i = 0; i < n; i++)
			arr[i] = sc.nextInt();
		introSort(arr, 0, n - 1, calcDepth(arr));
		System.out.println(""\nThe sorted array : ;"");
		for (int i = 0; i < n; i++)
			System.out.print(arr[i] + "" "");
		System.out.println();
	}
	static void introSort(int arr[], int low, int high, int depth) {
		int p = partition(arr, low, high);
		if ((high - low) < 2) {
			return;
		} else if (p > depth) {
			HeapSort.heapSort(arr);
		} else {
			introSort(arr, low, p, depth - 1);
			introSort(arr, p + 1, high, depth - 1);
		}
	}
	private static int partition(int arr[], int low, int high) {
		int p = getPivot(arr, low, high), j = low;
		for (int i = low; i <= high; i++) {
			if (arr[i] < p) {
				swap(arr, i, j);
				j++;
			}
		}
		swap(arr, high, j);
		return j;
	}
	private static int getPivot(int arr[], int low, int high) {
		Random rd = new Random();
		return arr[rd.nextInt((high - low) + 1) + low];
	}
	private static void swap(int arr[], int x, int y) {
		int aux = arr[x];
		arr[x] = arr[y];
		arr[y] = aux;
	}
	static int calcDepth(int arr[]) {
		return ((int) Math.log(arr.length)) * 2;
	}
}",0,0,0,0,0,0,0,0,0
1317,"export default function KahnsTopologicalSort(nodes) {
  const ordering = [];
  const dfsQueue = [];
  const indegrees = new Array(nodes).fill(0);
  for (const outdegrees of Object.values(nodes)) {
    for (const outdegree of outdegrees) {
      indegrees[outdegree]++;
    }
  }
  if (!indegrees.includes(0)) {
    throw new Error('Cycle in graph');
  }
  for (let i = 0; i < indegrees.length; i++) {
    if (indegrees[i] === 0) {
      dfsQueue.push(nodes[i]);
    }
  }
  while (dfsQueue.length) {
    const node = dfsQueue.shift();
    ordering.push(node);
    for (const child of nodes[node]) {
      indegrees[child]--;
      if (indegrees[child] === 0) {
        dfsQueue.push(child);
      }
    }
  }
  if (ordering.length !== nodes.length) {
    throw new Error('Cycle in graph');
  }
  return ordering;
}",0,0,0,0,0,0,0,0,0
1318,"package de.ffoerg.sort;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
public final class LampSort {
	private LampSort() {
	}
	public static <T extends Comparable<? super T>> void sort(List<T> toSort) {
		if ((toSort == null) || (toSort.size() < 2)) {
			return;
		}
		Stack<Pair<Integer>> intervals = new Stack<Pair<Integer>>();
		intervals.add(new Pair<Integer>(0, toSort.size() - 1));
		do {
			Pair<Integer> curr = intervals.pop();
			int lo = curr.getFirst();
			int hi = curr.getSecond();
			int span = hi - lo;
			assert ((lo >= 0) && (lo < toSort.size()));
			assert ((hi >= 0) && (hi < toSort.size()));
			assert (lo <= hi);
			if (span >= 2) {
				int pivotIndex = lo;
				T pivot = toSort.get(hi);
				for (int i = lo; i < hi; i++) {
					if (toSort.get(i).compareTo(pivot) < 0) {
						Collections.swap(toSort, pivotIndex, i);
						pivotIndex++;
					}
				}
				Collections.swap(toSort, pivotIndex, hi);
				Pair<Integer> loPart = new Pair<Integer>(lo, Math.max(lo,
						pivotIndex - 1));
				Pair<Integer> hiPart = new Pair<Integer>(Math.min(
						pivotIndex + 1, hi), hi);
				intervals.add(loPart);
				intervals.add(hiPart);
			} else if (span == 1) {
				if (toSort.get(lo).compareTo(toSort.get(hi)) > 0) {
					Collections.swap(toSort, lo, hi);
				}
			}
		} while (!intervals.isEmpty());
	}
	private static class Pair<T> {
		private T fst;
		private T snd;
		public Pair(T fst, T snd) {
			this.fst = fst;
			this.snd = snd;
		}
		public T getFirst() {
			return fst;
		}
		public T getSecond() {
			return snd;
		}
	}
}",0,0,0,0,0,0,0,0,0
1319,"import java.util.*;
public class MaxHeap {
    public static void main (String[] args){
        int ar [] = {4,1,3,2,16,9,10,14,8,7};
        int size = ar.length;
        System.out.print(""Initial Array : "");
        printHeap(ar,size);
        for(int i=size/2; i>0 ; i--){
               MaxHeapify(ar,i ,size);
               if(i==1){
                   System.out.print(""Max Heap : "");
               }else{
                System.out.print(""MaxHeapify steps : "");
               }
               printHeap(ar,size);
        }
        System.out.println(""Max Value :""+ar[0]);
        int min=ar[(size/2)+1];
        for(int i=(size/2)+1 ; i<size ;i++){
            if(min>ar[i]){
                min=ar[i];
            }
        }
        System.out.println(""Min Value :""+min);
        HeapDelete(ar,10);
        size= size-1;
        System.out.print(""after  Delete Element : "");
        printHeap(ar,size);
        insertHeap(ar,15,size);
        size= size+1;
        System.out.print(""after Insert Element : "");
        printHeap(ar,size);
    }
    public static void MaxHeapify(int[] ar, int i, int n){
        int l = 2*i-1;
        System.out.println(""L :""+l);
        int r = 2*i;
        System.out.println(""R :""+r);
        int largest =i-1;
        System.out.println(""I :""+(i-1));
        if(l<n && ar[largest]<ar[l]){
            largest=l;
        }
        if(r<n && ar[largest]<ar[r]){
            largest=r;
        }
        if(i-1!=largest){
            int temp= ar[i-1];
            ar[i-1]=ar[largest];
            ar[largest] = temp;
            MaxHeapify(ar, largest+1 ,n);
        }
    }
    public static void HeapDelete(int[] ar,int a){
        int index =-1; 
        for(int i=0; i<ar.length ;i++){
            if (ar[i]==a){
                index=i;
            }
        }
        if(index==-1){
            System.out.println(""this element not at the array"");
        }
        else{
            ar[index]= ar[ar.length-1];
            MaxHeapify(ar, index+1 ,ar.length-1);
        }
    }
    public static void insertHeap (int arr[],int b, int n){
        arr[n-1]=b;
        while((n/2)>0){
            if(arr[(n/2)-1]<arr[n-1]){
                 int temp=arr[(n/2)-1];
                 arr[(n/2)-1]=arr[n-1];
                 arr[n-1]=temp;
            }
            n=n/2;
        }
    }
    public static void printHeap(int[] ar,int n){
        for(int i=0 ; i<n ; i++){
            System.out.print(ar[i]+"" "");
        }
        System.out.println();
    }
}",0,0,0,0,0,0,0,0,0
1320,"export function SlowMiddleShift(string: string, char: string): string {
  const middleIndex = Math.floor(string.length / 2);
  let formatted = string.substring(0, middleIndex);
  formatted += char;
  for (let i = middleIndex; i < string.length; i++) {
    formatted += string[i];
  }
  return formatted;
}
export default function FastMiddleShift(string: string, char: string): string {
  const middleIndex = Math.floor(string.length / 2);
  return (
    string.substring(0, middleIndex) + char + string.substring(middleIndex)
  );
}",0,0,0,0,0,0,0,0,0
1321,"package com.growingwiththeweb.sorting;
public class OddEvenSort {
    public static <T extends Comparable<T>> void sort(T[] array) {
        boolean sorted = false;
        while (!sorted) {
            sorted = innerSort(array, 1);
            sorted = innerSort(array, 0) && sorted;
        }
    }
    private static <T extends Comparable<T>> boolean innerSort(T[] array, Integer i) {
        boolean sorted = true;
        for (; i < array.length - 1; i += 2)
        {
            if (array[i].compareTo(array[i + 1]) > 0)
            {
                swap(array, i, i + 1);
                sorted = false;
            }
        }
        return sorted;
    }
    private static <T extends Comparable<T>> void swap(
            T[] array, int a, int b) {
        T temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }
}",0,0,0,0,0,0,0,0,0
1322,"public class OddEvenSort {
	public static void sort(int list[]) {
		if (list.length > 3) {
			boolean swapped = true;
			while(swapped) {
				swapped = false;
				for (int i = 1; i < list.length-1; i+=1) {
					if (list[i] > list[i+1]) {
						Compare.swap(list, i, i+1);
						swapped = true;
					}
				}
				for(int i = 0; i < list.length-1; i+=1) {
					if (list[i] > list[i+1]) {
						Compare.swap(list, i, i+1);
						swapped = true;
					}
				}
			}
		}
	}
}",0,0,0,0,0,0,0,0,0
1323,"class oddEvenSort
	public static void main(String [] args){
		int [] arr = {1, 3, 5, 6, 6, 1, 3, 5};
		int sizeofArr = arr.length;
		int [] sortedArr = new int [sizeofArr];
		sortedArr = oddEvenSort(arr, sizeofArr);
		print(sortedArr);
	}
	static int [] oddEvenSort(int [] arr, int sizeofArr){
		int temp, check;
		for (int i=0;i<sizeofArr;i++){
			check = 1;
			for (int k=0;k<sizeofArr-1-i;k++){
				if (arr[k] > arr[k+1]){
					temp = arr[k+1];
					arr[k+1] = arr[k];
					arr[k] = temp;
					temp = arr[k-1];
					arr[k-1] = arr[k];
					arr[k] = temp;
				}
				check = 0;
			}
			if (check) break;
		}
		return arr;
	}
	static void print (int [] arr){
		for (int a : arr)
		System.out.print("" ""+a);
	}
}",0,0,0,0,0,0,0,0,0
1324,"tutor = False
def pancakesort(data):
    if len(data) <= 1:
        return data
    if tutor: print()
    for size in range(len(data), 1, -1):
        maxindex = max(range(size), key=data.__getitem__)
        if maxindex+1 != size:
            if maxindex != 0:
                if tutor: print('With: %r doflip  %i'
                                % ( ' '.join(str(x) for x in data), maxindex+1 ))
                data[:maxindex+1] = reversed(data[:maxindex+1])
            if tutor: print('With: %r  doflip %i'
                                % ( ' '.join(str(x) for x in data), size ))
            data[:size] = reversed(data[:size])
    if tutor: print()
if __name__ == '__main__':
    import random
    tutor = True
    data = list('123456789')
    while data == sorted(data):
        random.shuffle(data)
    print('Original List: %r' % ' '.join(data))
    pancakesort(data)
    print('Pancake Sorted List: %r' % ' '.join(data)) ",0,0,0,0,0,0,0,0,0
1325,"def flip(arr,i):
    st = 0
    while st < i:
        temp = arr[st]
        arr[st]  = arr[i]
        arr[i] = temp
        st+=1
        i-=1
def maxx(arr,n):
    maxx=0
    for i in range(0,n):
        if arr[i]>arr[maxx]:
            maxx=i
    return maxx
def PancakeSoritng(arr,n):
    length = n
    while length > 1:
        i = maxx(arr,length)
        if i!=length-1:
            flip(arr,i)
            flip(arr,length-1)
        length-=1
user_input = input(""Enter input numbers separated by a comma\n"").strip()
arr= [int(elem) for elem in user_input.split(',')]
n=len(arr)
print('Length of array is {}'.format(n))
PancakeSoritng(arr,n)
print(""The Sorted array is \n{}"".format(arr))",0,0,0,0,0,0,0,0,0
1326,"def pancakesort(arr):
    cur = len(arr)
    while cur > 1:
        mi = arr.index(max(arr[0:cur]))
        arr = arr[mi::-1] + arr[mi+1:len(arr)]
        arr = arr[cur-1::-1] + arr[cur:len(arr)]
        cur -= 1
    return arr
print(pancakesort([0,10,15,3,2,9,14,13]))",0,0,0,0,0,0,0,0,0
1327,"const myArray = [2, 4, 1, 6, -7, 8, 5, 9, 3, 4];
const pancakeSort = (arr) => {
    for (var i = arr.length - 1; i >= 1; i--) {
        var max_idx = 0;
        var max = arr[0];
        for (var j = 1; j <= i; j++) {
            if (arr[j] > max) {
                max = arr[j];
                max_idx = j;
            }
        }
        if (max_idx == i)
            continue;  
        var new_slice;
        if (max_idx > 0) {
            new_slice = arr.slice(0, max_idx+1).reverse();
            for ( j = 0; j <= max_idx; j++)
                arr[j] = new_slice[j];
        }
        new_slice = arr.slice(0, i+1).reverse();
        for ( j = 0; j <= i; j++)
            arr[j] = new_slice[j];
    }
    return arr;
}
console.log(pancakeSort(myArray));",0,0,0,0,0,0,0,0,0
1328,"name=""hashMap""
class HashMap:
    def __init__(self, array_size):
        self.array_size = array_size
        self.array = [None for item in range(array_size)]
    def hasher(self, key, count_collisions=0):
        key_bytes = key.encode()
        hasher_code = sum(key_bytes)
        return hasher_code + count_collisions
    def array_index_compute(self, hasher_code):
        return hasher_code % self.array_size
    def key_after_collision(self, key, number_collisions=1):
        new_hasher_code = self.hasher(key, number_collisions)
        new_array_index = self.array_index_compute(new_hasher_code)
        return new_array_index
    def assign(self, key, value):
        array_index = self.array_index_compute(self.hasher(key))
        current_array_value = self.array[array_index]
        if current_array_value is None:
            self.array[array_index] = [key, value]
            return
        if current_array_value[0] == key:
          self.array[array_index] = [key, value]
          return
        number_collisions = 1
        while(current_array_value[0] != key):
            new_array_index = self.key_after_collision(key, number_collisions)
            current_array_value = self.array[new_array_index]
            if current_array_value is None:
                self.array[new_array_index] = [key, value]
                return
            if current_array_value[0] == key:
                self.array[new_array_index] = [key, value]
                return
            number_collisions += 1
            if(number_collisions>self.array_size):
                print(""Array Full"")
                return
        return
    def retrieve(self, key):
        array_index = self.array_index_compute(self.hasher(key))
        tentative_return_value = self.array[array_index]
        if tentative_return_value is None:
          return None
        if tentative_return_value[0] == key:
          return tentative_return_value[1]
        collision_count_retrieve = 1
        while (tentative_return_value != key):
          retrieving_array_index = self.key_after_collision(key, collision_count_retrieve)
          tentative_return_value = self.array[retrieving_array_index]
          if tentative_return_value is None:
            return None
          if tentative_return_value[0] == key:
            return tentative_return_value[1]
          collision_count_retrieve += 1
          return",0,0,0,0,0,1,0,0,1
1329,"from collections import OrderedDict
__all__ = ('BoundSizedDict',)
__version__ = '1.0'
class BoundSizedDict(OrderedDict):
    def __init__(self, max_size):
        self.max_size = max_size
    @property
    def max_size(self):
        return self._max_size
    @max_size.setter
    def max_size(self, value):
        if isinstance(value, int) and value >= 1:
            if len(self) > value:
                for _ in range(len(self) - value):
                    self.popfirst()
            self._max_size = value
        else:
            raise ValueError('max_size must be an instance of int and >= 1')
    def __setitem__(self, key, value):
        super().__setitem__(key, value)
        self.move_to_end(key)
        if len(self) > self.max_size:
            self.popfirst()
    def __str__(self):
        return f""{'  ' if len(self) == self.max_size else '   '}\x7B{'  '.join(f'{k!r}: {v!r}' for k, v in self.items())}\x7D  ""
    def __repr__(self):
        return f'{self.__class__.__name__}({self.max_size})'
    def popfirst(self):
        return self.popitem(last=False)
    def fromkeys(self, keys, value=None):
        for key in keys:
            self[key] = value
    def update(self, dict):
        raise DeprecationWarning(""nondetermenistic behaviour's achieved using this method"")",0,0,0,0,0,0,0,0,0
1330,"class Pair:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next_node = None
class BasicHashTable:
    def __init__(self, capacity):
        self.capacity = capacity
        self.storage = [None for i in range(capacity)]
def hash(string):
    tmp = 5381
    byte_array = string.encode('utf-8')
    for byte in byte_array:
        tmp = ((tmp * 33) ^ byte) % 0x100000000
    return tmp
def hash_table_insert(hash_table, key, value):
    hashed_key = hash(key)
    index = hashed_key % hash_table.capacity
    new_node = Pair(key, value)
    existing_node = hash_table.storage[index]
    if existing_node:
        if existing_node.key == key:
            print(""You are overwriting an existing key's value."")
            existing_node.value == value
        existing_node = existing_node.next_node
    else:
        hash_table.storage[index] = new_node
def hash_table_remove(hash_table, key):
    hashed_key = hash(key)
    index = hashed_key % hash_table.capacity
    existing_node = hash_table.storage[index]
    if existing_node:
        last_node = None
        while existing_node:
            if existing_node.key == key:
                if last_node:
                    last_node.next_node = existing_node.next_node
                else:
                    hash_table.storage[index] = existing_node.next_node
            last_node = existing_node
            existing_node = existing_node.next_node
    else:
        print(""Unable to remove item"")
        return None
def hash_table_retrieve(hash_table, key):
    hashed_key = hash(key)
    index = hashed_key % hash_table.capacity
    existing_node = hash_table.storage[index]
    if existing_node:
        return existing_node.value
def Testing():
    ht = BasicHashTable(16)
    hash_table_insert(ht, ""line"", ""Here today...\n"")
    hash_table_remove(ht, ""line"")
    if hash_table_retrieve(ht, ""line"") is None:
        print(""...gone tomorrow (success!)"")
    else:
        print(""ERROR:  STILL HERE"")
Testing()",0,0,0,0,0,0,0,0,1
1331,"class BiMap:
    def __init__(self, dictionary=None):
        self.key_to_value = dict()
        self.value_to_key = dict()
        if dictionary:
            for key in dictionary:
                self.add_key(key, dictionary[key])
    def __iter__(self):
        return self.key_to_value.__iter__()
    def __len__(self):
        return len(self.key_to_value)
    def add_key(self, key, value):
        self.key_to_value[key] = value
        self.value_to_key[value] = key
    def add_value(self, value, key):
        self.add_key(key, value)
    def update_by_key(self, dictionary):
        for key, value in dictionary.items():
            self.add_key(key, value)
    def update_by_value(self, dictionary):
        for value, key in dictionary.items():
            self.add_key(key, value)
    def get_key(self, key):
        return self.key_to_value[key]
    def get_value(self, value):
        return self.value_to_key[value]
    def remove_key(self, key):
        del self.value_to_key[self.key_to_value[key]]
        del self.key_to_value[key]
    def remove_value(self, value):
        self.remove_key(self.get_value(value))
    def clear(self):
        self.key_to_value.clear()
        self.value_to_key.clear()
    def pop_key(self, key):
        value = self.get_key(key)
        self.remove_key(key)
        return value
    def pop_value(self, value):
        key = self.get_value(value)
        self.remove_value(value)
        return key
    def get_key_to_value(self):
        return self.key_to_value
    def get_value_to_key(self):
        return self.value_to_key",0,0,0,0,0,0,0,0,0
1332,"package Mini_algorithms;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
public class ChainHashMap<K,V> extends AbstractHashMap<K,V> {
	private UnsortedTableMap<K,V>[] table;
	public ChainHashMap() { 
		super();
	}
	public ChainHashMap(int cap) {
		super(cap);
	}
	public ChainHashMap(int cap, int p){
		super(cap, p);
	}
	protected void createTable(){
		table = (UnsortedTableMap<K,V>[]) new UnsortedTableMap[capacity];
	}
	public Set<java.util.Map.Entry<K, V>> entrySet() {
		ArrayList<Entry<K,V>> buffer = new ArrayList<>();
		for(int h = 0; h < capacity; h++)
			if(table[h] != null)
				for(Entry<K,V> entry: table[h].entrySet())
					buffer.add(entry);
		Set<Entry<K,V>> set = new HashSet<Entry<K,V>>(buffer);
		return set;
	}
	protected V bucketGet(int h, K k) {
		UnsortedTableMap<K,V> bucket = table[h];
		if(bucket == null) return null;
		return bucket.get(k);
	}
	protected V bucketPut(int h, K k, V v) {
		UnsortedTableMap<K,V> bucket = table[h];
		if(bucket == null){
			bucket = table[h] = new UnsortedTableMap<>();
		}
		int oldSize = bucket.size();
		V answer = bucket.put(k, v);
		n += (bucket.size() - oldSize);
		return answer;
	}
	protected V bucketRemove(int h, K k) {
		UnsortedTableMap<K,V> bucket = table[h];
		if(bucket == null){
			bucket = table[h] = new UnsortedTableMap<>();
		}
		int oldSize = bucket.size();
		V answer = bucket.remove(k);
		n -= (oldSize - bucket.size());
		return answer;
	}
	public void clear() {}
	public boolean containsKey(Object key) {return false;}
	public boolean containsValue(Object value) {return false;}
	public void putAll(Map<? extends K, ? extends V> m) {}
}",0,0,0,0,0,0,0,0,0
1333,"import java.util.ArrayList;
import java.util.Map.Entry;
class Node {
    String key, value;
    Node next;
    public Node(String key, String value) {
        this.key = key;
        this.value = value;
    }
}
public class ChainHashMap extends AbstractMap {
    private ArrayList<Node> buckets;
    private int capacity;
    private int size;
    public ChainHashMap() {
        this.capacity = 10;
        initializeBuckets();
    }
    public ChainHashMap(int capacity) {
        this.capacity = capacity;
        initializeBuckets();
    }
    private void initializeBuckets() {
        buckets = new ArrayList<Node>(capacity);
        size = 0;
        for (int i = 0; i < capacity; i++) {
            buckets.add(null);
        }
    }
    public Double getLoadFactor() {
        return (double) this.size / (double) this.capacity;
    }
    private Node getHead(String key) {
        int index = getIndex(key);
        return buckets.get(index);
    }
    private int getIndex(String key) {
        int hash = key.hashCode();
        int index = compress(hash);
        return index < 0 ? index * -1 : index;
    }
    private int compress(long hash) {
        return (int) (hash % this.capacity);
    }
    private void doubleCapacity() {
        ArrayList<Node> tempList = buckets;
        capacity *= 2;
        initializeBuckets();
        for (Node item : tempList) {
            while (item != null) {
                put(item.key, item.value);
                item = item.next;
            }
        }
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public String get(String key) {
        Node head = getHead(key);
        while (head != null) {
            if (head.key.equals(key)) {
                return head.value;
            }
            head = head.next;
        }
        return null;
    }
    @Override
    public String put(String key, String value) {
        Node head = getHead(key);
        while (head != null) {
            if (head.key.equals(key)) {
                String lastValue = head.value;
                head.value = value;
                return lastValue;
            }
            head = head.next;
        }
        head = getHead(key);
        int indexInList = getIndex(key);
        Node newValue = new Node(key, value);
        newValue.next = head;
        buckets.set(indexInList, newValue);
        size++;
        if (getLoadFactor() >= 0.75) {
            doubleCapacity();
        }
        return null;
    }
    @Override
    public String remove(String key) {
        int index = getIndex(key);
        Node head = getHead(key);
        Node prev = null;
        while (head != null) {
            if (head.key.equals(key)) {
                size--;
                if (prev != null) {
                    prev.next = head.next;
                } else {
                    buckets.set(index, head.next);
                }
                return head.value;
            }
            prev = head;
            head = head.next;
        }
        return null;
    }
    @Override
    public Iterable<String> keySet() {
        ArrayList<String> keys = new ArrayList<String>();
        for (Node item : buckets) {
            while (item != null) {
                keys.add(item.key);
                item = item.next;
            }
        }
        return keys;
    }
    @Override
    public Iterable<String> values() {
        ArrayList<String> keys = new ArrayList<String>();
        for (Node item : buckets) {
            while (item != null) {
                keys.add(item.value);
                item = item.next;
            }
        }
        return keys;
    }
    @Override
    public Iterable<Entry<String, String>> entrySet() {
        ArrayList<Entry<String, String>> keys = null;
        return keys;
    }
}",0,0,0,0,0,1,0,0,1
1334,"from DS.Maps_Dictionaries.HashMapBase import HashMapBase
from DS.Maps_Dictionaries.UnsortedTableMap import UnsortedTableMap
class ChainHashMap(HashMapBase):
    def _bucket_getitem(self, j, k):
        bucket = self._table[j]
        if bucket is None:
            raise KeyError('Key Error: ' + repr(k))     
        return bucket[k]                                
    def _bucket_setitem(self, j, k, v):
        if self._table[j] is None:
            self._table[j] = UnsortedTableMap()         
        oldsize = len(self._table[j])
        self._table[j][k] = v
        if len(self._table[j]) > oldsize:               
            self._n += 1                                
    def _bucket_delitem(self, j, k):
        bucket = self._table[j]
        if bucket is None:
            raise KeyError('Key Error: ' + repr(k))     
        del bucket[k]                                   
    def __iter__(self):
        for bucket in self._table:
            if bucket is not None:                      
                for key in bucket:
                    yield key",0,0,0,0,0,0,0,0,0
1335,"from binarytree import *
class HashMap(object):
  def __init__(self, size):
    self.count = 0
    self.size = size
    self.stack = [BinarySearchTree() for i in range(size)]
  def hashme(self, key):
    return key.__hash__() % self.size
  def set(self, key, value):
    hashvalue = self.hashme(key)
    findNode = self.stack[hashvalue].search(key)
    if not findNode is None: 
      findNode.value = value
    else: 
      self.stack[hashvalue].insert(key, value)
      self.count += 1
    return True
  def get(self, key):
    hashvalue = self.hashme(key)
    findNode = self.stack[hashvalue].search(key)
    if not findNode is None:
      return findNode.value
    return None
  def delete(self, key):
    hashvalue = self.hashme(key)
    findNode = self.stack[hashvalue].search(key)
    if not findNode is None:
      retval = self.stack[hashvalue].delete(key)
      self.count -= 1
      return retval.value
    return None
  def load(self):
    if (self.count + self.size == 0): 
      return 0
    return self.count / float(self.size)
  def __getitem__(self, key):
    return self.get(key)
  def __setitem__(self, key, value):
    return self.set(key, value)
  def __repr__(self):
    return ""<HashMap, style:chaining-bst, size:%d>"" % self.size ",0,0,0,0,0,0,0,0,1
1336,"class HashMap(object):
  def __init__(self, size):
    self.count = 0
    self.size = size
    self.keys = [[] for i in range(size)]
    self.items = [[] for i in range(size)]
  def hashme(self, key):
    return key.__hash__() % self.size
  def set(self, key, value):
    hashvalue = self.hashme(key)
    if key in self.keys[hashvalue]: 
      index = self.keys[hashvalue].index(key)
      self.items[hashvalue][index] = value 
    else: 
      self.keys[hashvalue].append(key)
      self.items[hashvalue].append(value)
      self.count += 1
    return True
  def get(self, key):
    hashvalue = self.hashme(key)
    myitem = None
    if key in self.keys[hashvalue]:
      index = self.keys[hashvalue].index(key)
      myitem = self.items[hashvalue][index]
    return myitem
  def delete(self, key):
    hashvalue = self.hashme(key)
    returnValue = None
    if key in self.keys[hashvalue]:
      index = self.keys[hashvalue].index(key)
      returnValue = self.items[hashvalue][index]
      self.keys[hashvalue].pop(index)
      self.items[hashvalue].pop(index)
      self.count -= 1
    return returnValue
  def load(self):
    if (self.count + self.size == 0): 
      return 0
    return self.count / float(self.size)
  def __getitem__(self, key):
    return self.get(key)
  def __setitem__(self, key, value):
    return self.set(key, value)
  def __repr__(self):
    return ""<HashMap, style:chaining-list, size:%d>"" % self.size ",0,0,0,0,0,0,0,0,1
1337,"package org.joyfulmonster.util.concurrent;
import org.joyfulmonster.util.concurrent.internal.ConcurrentElasticHashMapImpl;
import org.joyfulmonster.util.concurrent.internal.MetricsSupport;
public class ConcurrentElasticHashMap<K, V> {
    private static final String ILLEGAL_ARGUMENT_EXPECTION_MSG = ""The key or value can not be null."";
    private ConcurrentElasticHashMapImpl<K, V> service;
    public ConcurrentElasticHashMap() {
        service = new ConcurrentElasticHashMapImpl<K, V>();
    }
    public ConcurrentElasticHashMap(int bucketSize, int initBucketCount, float loadFactor) {
        service = new ConcurrentElasticHashMapImpl<K, V>(bucketSize, initBucketCount, loadFactor);
    }
    public V put(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.put(key, value);
    }
    public V putIfAbsent(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.putIfAbsent(key, value);
    }
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.get(key);
    }
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.remove(key);
    }
    public boolean remove(K key, V val) {
        if (key == null || val == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.remove(key, val);
    }
    public V replace(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.replace(key, value);
    }
    public boolean replace(K key, V oldValue, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(ILLEGAL_ARGUMENT_EXPECTION_MSG);
        }
        return service.replace(key, oldValue, value);
    }
    public int size() {
        return service.size();
    }
    MetricsSupport getMetrics() {
        return service;
    }
}",0,0,0,0,0,0,0,0,0
1338,"from BitHash import BitHash, ResetBitHash
import string
import random
import time
class Node(object):
    def __init__(self, key, data):
        self.key = key
        self.data = data
class CuckooHash(object):
    def __init__(self, size):
        self.__hashArray1 = [None] * size
        self.__hashArray2 = [None] * size
        self.__numKeys = 0
    def __len__(self): return self.__numKeys    
    def __hashFunc(self, s):
        v1 = BitHash(s) 
        v2 = BitHash(s, v1)
        return v1 % len(self.__hashArray1), v2 % len(self.__hashArray1)    
    def find(self, key):
        bucket1, bucket2 = self.__hashFunc(key)
        if self.__hashArray1[bucket1] and self.__hashArray1[bucket1].key == key:
            return self.__hashArray1[bucket1].data
        elif self.__hashArray2[bucket2] and self.__hashArray2[bucket2].key == key:
            return self.__hashArray2[bucket2].data 
        return None
    def delete(self, key): 
        if self.find(key) == None:
            return False     
        bucket1, bucket2 = self.__hashFunc(key)        
        if self.__hashArray1[bucket1] and self.__hashArray1[bucket1].key == key:
            self.__hashArray1[bucket1] = None
            self.__numKeys -= 1
        elif self.__hashArray2[bucket2] and self.__hashArray2[bucket2].key == key:
            self.__hashArray2[bucket2] = None 
            self.__numKeys -= 1
        return True
    def insert(self, key, data, count = 0):
        if count == 10:
            print(""count is"", count)
            ResetBitHash()
            print(""resetting bit hash."")
            self.__copyHashTable()
        if self.__numKeys >= len(self.__hashArray1)/2:
            self.__growHash()
            print(""Grew hash table."")
        if self.find(key) != None:
            return False
        bucket1, bucket2 = self.__hashFunc(key)
        if not self.__hashArray1[bucket1]: 
            self.__hashArray1[bucket1] = Node(key, data)
            self.__numKeys += 1
        elif not self.__hashArray2[bucket2]: 
            self.__hashArray2[bucket2] = Node(key, data)  
            self.__numKeys += 1
        elif count % 2 == 0:
            pop = self.__hashArray1[bucket1]
            self.__hashArray1[bucket1] = Node(key, data)
            self.insert(pop.key, pop.data, count+1)
        elif count % 2 == 1:
            pop2 = self.__hashArray2[bucket2]
            self.__hashArray2[bucket2] = Node(key, data)
            self.insert(pop2.key, pop2.data, count+1)
        return True
    def __growHash(self):
        newSize = len(self.__hashArray1) * 2
        self.__copyHashTable(newSize)
    def __copyHashTable(self, newSize = ""newSize""):
        if newSize == ""newSize"":
            newSize = len(self.__hashArray1)
        newHashTable = CuckooHash(newSize)
        for i in range(len(self.__hashArray1)):
            node1 = self.__hashArray1[i]
            node2 = self.__hashArray2[i]
            if node1:
                newHashTable.insert(node1.key, node1.data)
            if node2:
                newHashTable.insert(node2.key, node2.data)            
        self.__hashArray1 = newHashTable.__hashArray1
        self.__hashArray2 = newHashTable.__hashArray2
        self.__numKeys = newHashTable.__numKeys   
def __test1():
    h = CuckooHash(100)          
    h.insert(""A"", ""0"")
    h.insert(""B"", ""1"")
    h.insert(""C"", ""2"")
    h.insert(""D"", ""3"")
    h.insert(""E"", ""4"")
    h.insert(""F"", ""5"")
    h.insert(""G"", ""6"")
    h.insert(""H"", ""77"")
    h.insert(""IIII"", ""888"")
    n = h.find(""IIII"")
    a = h.find(""A"")
    b = h.find(""B"")
    c = h.find(""C"")
    if n == ""888"":
        print(""Success!"")
    if a == ""0"":
            print(""Success!"")
    if b == ""1"":
            print(""Success!"")
    if c == ""2"":
            print(""Your search method was successful!"")      
def __test2():
    size = 91000
    t = time.time()
    h = CuckooHash(10)
    for i in range(size):
        h.insert(str(i+1000000000), i)
    t = time.time() - t
    print(t, ""seconds  "", size/t, ""inserts per second"")
def __test3():
    size = 20000
    missing = 0
    h = CuckooHash(100)
    for i in range(size): 
        h.insert(str(i)+""foobarbaz"", i)
    for i in range(size):
        ans = h.find(str(i)+""foobarbaz"")
        if ans == None or ans != i:
            print(i, ""Couldn't find key"", i+""foobarbaz"")
            missing += 1
    print(""There were"", missing, ""records missing from CuckooHashTab"")
def __test4():
    size = 1000
    c = CuckooHash(100)
    l = []
    for i in range(size):
        s = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for j in range(5))
        l += [s]
        print(s)
        print(""It is"", c.insert(s, i),""that the function inserted 1 item."")
        print(""There are"", len(c), ""items in the hash table."")
    deletionNumber = 53
    for i in range(deletionNumber):
        print(""It is"", c.delete(l[i]),""that the item"", l[i], ""has been deleted."")
    count = 0
    for item in l:
        n = random.randint(1, 100)
        if c.insert(item, n) == True:
            count += 1        
            print(""It is True that the function inserted 1 item."")
        else:
            print(""It is"", c.insert(s, i),""that the function inserted 1 item."")
    if count == deletionNumber:
        print(""Success! The duplicate keys weren't inserted."")
    else:
        print(""Faliure! Check your deletion method. Check your insertion method."")
def __main():
    __test1()
    __test2()
    __test3()
    __test4()
if __name__ == '__main__':
    __main()",0,0,0,0,0,0,0,0,1
1339,"from BitHash import BitHash, ResetBitHash
import random 
class Node(object):
    def __init__(self, k, d):
        self.key  = k 
        self.data = d
    def __str__(self):
        return ""("" + str(self.key) + "", "" + str(self.data) + "")""
class HashTab(object):
    def __init__(self, size):
        self.__hashArray1 = [None] * (size // 2)  
        self.__hashArray2 = [None] * (size // 2)
        self.__numRecords = 0               
        self.__size = size                  
    def __len__(self): return self.__numRecords
    def hashFunc(self, s):
        x = BitHash(s)          
        y = BitHash(s, x)
        size = self.__size // 2  
        return x % size, y % size
    def insert(self, k, d):
        if self.find(k) != None:  return False   
        n = Node(k, d)                           
        if self.__numRecords >= (self.__size // 2):
            self.__growHash() 
        position1, position2 = self.hashFunc(n.key)  
        pos = position1
        table = self.__hashArray1
        for i in range(5):
            if table[pos] == None:               
                table[pos] = n                   
                self.__numRecords += 1
                return True
            n, table[pos] = table[pos], n       
            if pos == position1:                            
                position1, position2 = self.hashFunc(n.key) 
                pos = position2                             
                table = self.__hashArray2                   
            else:                               
                position1, position2 = self.hashFunc(n.key) 
                pos == position1                            
                table = self.__hashArray1
        self.__growHash()               
        self.rehash(self.__size)                           
        self.insert(n.key, n.data)      
        return True
    def __str__(self):
        str1 = ""Table 1: [ "" + str(self.__hashArray1[0]) 
        str2 = "" Table 2: [ "" + str(self.__hashArray2[0]) 
        for i in range(1, self.__size):
            str1 += "", "" + str(self.__hashArray1[i])
        str1 += ""]""
        for i in range(1, self.__size):
           str2 += "", "" + str(self.__hashArray2[i]) 
        str2 += ""]""
        return str1 + str2 
    def rehash(self, size):
        ResetBitHash()          
        temp = HashTab(size)    
        for i in range(self.__size // 2):
            x = self.__hashArray1[i]
            y = self.__hashArray2[i]
            if x != None:
                temp.insert(x.key, x.data)
            if y != None:
                temp.insert(y.key, y.data)
        self.__hashArray1 = temp.__hashArray1
        self.__hashArray2 = temp.__hashArray2
        self.__numRecords = temp.__numRecords
        self.__size = temp.__size
    def __growHash(self):
        newSize = self.__size * 2
        self.rehash(newSize)
    def find(self, k):
        pos1, pos2 = self.hashFunc(k)               
        x = self.__hashArray1[pos1]                 
        y = self.__hashArray2[pos2]                 
        if x != None and x.key == k:  return x.data
        if y != None and y.key == k:  return y.data
        return None
    def delete(self, k):
        pos1, pos2 = self.hashFunc(k)  
        x = self.__hashArray1[pos1]
        y = self.__hashArray2[pos2]
        if  x != None and  x.key == k:  self.__hashArray1[pos1] = None
        elif y != None and y.key == k:  self.__hashArray2[pos2] = None
        else:   return False   
        self.__numRecords -= 1 
        return True
def test():
    size = 1000
    missing = 0
    found = 0 
    c = HashTab(100)
    inserted = 0
    for i in range(size): 
        if c.insert(str(i)+""foobarbaz"", i):
            inserted += 1
    print(""There were"", inserted, ""nodes successfully inserted"")
    for i in range(size):
        ans = c.find(str(i)+""foobarbaz"")
        if ans == None or ans != i:
            print(i, ""Couldn't find key"", str(i)+""foobarbaz"")
            missing += 1
    print(""There were"", missing, ""records missing from Cuckoo"")
    for i in range(size): 
        c.delete(str(i)+""foobarbaz"")
    for i in range(size): 
        ans = c.find(str(i)+""foobarbaz"") 
        if ans != None or ans == i: 
            print(i, ""Couldn't delete key"", str(i)+""foobarbaz"") 
            found += 1
    print(""There were"", found, ""records not deleted from Cuckoo"") 
def __main():
    test()
if __name__ == '__main__':
    __main()       ",0,0,0,0,0,0,0,0,1
1340,"class CuckooMap:
	maxKnockout = 2000
 def __init__(self, n):
		self.max_size = n
  self.bucket_size = 2*n
  self.curr_size = 0
  self.buckets = [None]*2*n
  self.hash_functions = [self.hash_one, self.has_two]
 def hash_one(self, key):
		return hash(key) % self.bucket_size
 def hash_two(self, key):
		return (hash(key) - id(key) - 7) % self.bucket_size
 def doesNotExceedKnockoutLimit(self, hash_node):
		i = 0
  curr_node = hash_node
  curr_index = self.hash_functions[hash_node.getFunction()](hash_node.getKey())
  while i < self.maxKnockout:
			next_index = self.hash_functions[1-curr_node.getFunction()](curr_node.getKey())
   next_node = self.buckets[next_index]
   if not next_node:
				return True
   i += 1
   curr_node = next_node
  return False
 def _set_helper(self, hash_node):
		other_hash_func = self.hash_functions[1 - hash_node.getFunction()]
  if self.buckets[other_hash_func(hash_node.getKey())]:
			other_node = self.buckets[other_hash_func(hash_node.getKey())]
   self.buckets[other_has_func(hash_node.getKey())] = hash_node
   _set_helper(other_node)
 def set(self, key, val):
		node1 = self.buckets[self.hash_one(key)]
  node2 = self.buckets[self.hash_two(key)]
  if self.curr_size >= self.max_size:
			if node1 and node1.getKey() == key:
				node1.setVal(val)
   elif node2 and node2.getKey() == key:
				node2.setVal(val)
   else:
				return False
  else:
			if node1:
				if node1.getKey() == key:
					node1.setVal(val)
    elif not node2:
					self.buckets[self.hash_two(key)] = Node(key, val, 1)
     self.curr_size += 1
    elif node2.getKey() == key:
					node2.setVal(val)
    elif self.doesNotExceedKnockoutLimit(node1):
					self._set_helper(node1)
     self.curr_size += 1
    else:
					return False
   else:
				self.buckets[self.hash_one(key)] = Node(key, val, 0)
    self.curr_size += 1
  return True
 def get(self, key):
		node_one = self.buckets[self.hash_one(key)]
  node_two = self.buckets[self.hash_two(key)]
  if node_one and node_one.getKey() == key:
			return self.buckets[self.hash_one(key)].getVal()
  elif node_two and node_two.getKey() == key:
			return self.buckets[self.hash_two(key)].getVal()
  else:
			return None
 def delete(self, key):
		node_one = self.buckets[self.hash_one(key)]
  node_two = self.buckets[self.hash_two(key)]
  if node_one and node_one.getKey() == key:
			self.buckets[self.hash_one(key)] = None
   self.curr_size -= 1
   return node_one
  elif node_two and node_two.getKey() == key:
			self.buckets[self.hash_two(key)] = None
   self.curr_size -= 1
   return node_two
  else:
			return None
 def load(self):
		return self.curr_size / self.max_size
 def __repr__(self):
		return str(self.buckets)
 class Node:
		def __init__(self, key, val, function_id):
			self.key = key
   self.val = val
   self.function = function_id
  def getKey(self):
			return self.key
  def getVal(self):
			return self.val
  def setVal(self, val):
			self.val = val
  def getFunction(self):
			return self.function
  def __repr__(self):
			return ""("" + self.key + "": "" + str(self.val) + "")""",0,0,0,0,0,0,0,0,1
1341,"class FixedHashMap(object):
	class HashItem(object):
		__slots__ = (""key"", ""value"")
  def __init__(self, key=None, value=None):
			self.key = key
   self.value = value
  def clear(self):
			self.key = None
   self.value = None
  def __nonzero__(self):
			return False if self.key == None else True
  def __repr__(self):
			return 'None' if self.key == None else '{}: {}'.format(self.key, self.value)
 __slots__ = (""capacity"", ""size"", ""data"")
 def __init__(self, capacity=1000):
		self.capacity = capacity
  self.size = 0
  self.data = [self.HashItem() for _ in range(self.capacity)]
 def _find_slot(self, key):
		i = hash(key) % self.capacity
  while self.data[i] and (self.data[i].key != key):
			i = (i+1) % self.capacity
  return i
 def set(self, key, value):
		if not isinstance(key, str):
			raise Exception(""KeyError: Key must be string"")
   return
  if self.size == self.capacity:
			raise Exception(""MemoryError: The hash map is full"")
   return
  i = self._find_slot(key)
  if self.data[i]:
			self.data[i].value = value
  else:
			self.data[i].key = key
   self.data[i].value = value
   self.size+=1
 def get(self, key):
		i = self._find_slot(key)
  if self.data[i]:
			return self.data[i].value
  else:
			raise Exception(""KeyError: Could not find key: {}"".format(key))
   return
 def delete(self, key):
		i = self._find_slot(key)
  if not self.data[i]:
			raise Exception(""KeyError: Could not find key: {}"".format(key))
   return
  j = i
  break_main = False
  while True:
			self.data[i].clear()
   while True:
				j = (j+1) % self.capacity
    if not self.data[j]:
					break_main = True
     break
    k = hash(self.data[j].key) % self.capacity
    if not ((i<k and k<=j) if (i <= j) else (i<k or k<=j)):
					break
   if break_main:
				break
   self.data[i] = self.data[j]
   i = j
  self.size-=1
 def load(self):
		return float(self.size) / float(self.capacity)
 def keys(self):
		return [i.key for i in self.data if i]
 def __setitem__(self, key, value):
		self.set(key, value)
 def __getitem__(self, key):
		return self.get(key)
 def __delitem__(self, key):
		return self.delete(key)
 def __repr__(self):
		data = [(k, str(self.get(k))) for k in self.keys()]
  return '{}' if not data else '{'+', '.join('{}: {}'.format(repr(k), v) for k,v in data)+'}'
if __name__ == ""__main__"":
	def print_stats(h):
		print 'fhm.load: {}'.format(fhm.load())
  print 'fhm: {}'.format(fhm)
  print ''
 test_size = 2
 fhm = FixedHashMap(test_size)
 print 'Initialize Hash map of size {}\n'.format(test_size)
 for i in range(test_size+1):
		print 'Try to add (\'{}\': {})'.format(str(i), i+1)
  try: fhm[str(i)] = i+1
  except Exception as e: print e
  print_stats(fhm)
 print ""\n\n""
 for i in range(test_size+1):
		print 'Try to delete key \'{}\''.format(str(i))
  try: del fhm[str(i)]
  except Exception as e: print e
  print_stats(fhm)",0,0,0,0,0,0,0,0,1
1342,"class HashTable(object):
    def __init__(self, n=128):
        self.hashed = [[] for i in range(n)]
        self.mask_size = n - 1
    def hash(self, item):
        if isinstance(item, basestring):
            hashed_item = []
            for el in item:
                hashed_item.append(ord(el))
        else:
            raise TypeError
        return self.mask_size & sum(hashed_item)
    def get(self, item):
        key = self.hash(item)
        for el in self.hashed[key]:
            if el == item:
                print ""we found it!""
                return el
        else:
            raise IndexError
    def set(self, item):
        key = self.hash(item)
        print key
        self.hashed[key].append(item)
        print self.hashed[key]
if __name__ == ""__main__"":
    our_hash = HashTable()
    our_hash.set(""alice"")
    our_hash.set(""elica"")
    print our_hash.get(""elica"")
    print our_hash.get(""muazzez"")",0,0,0,0,0,1,0,0,1
1343,"from utils import KeyValuePair, HashFunction
class HashMap(object):
    NUM_SLOTS = 127  
    BUFFER = 5  
    HASH_FUNCTION = HashFunction.base_alphabet
    def get_index(self, key):
        index = self.HASH_FUNCTION(key) % self.size
        while self.array[index] is not None:
            if self.array[index].key == key:
                break
            index = self.increment_index(index)
        return index
    def increment_index(self, index):
        index += 1
        if index >= self.size:
            index = 0
        return index
    def __init__(self, **kwargs):
        self.size = self.NUM_SLOTS
        self.array = [None for x in range(self.size)]
        for key in kwargs:
            self.__setitem__(key, kwargs[key])
    def __setitem__(self, key, value):
        item = KeyValuePair(key, value)
        index = self.get_index(item.key)
        self.array[index] = item
        if len(self) + self.BUFFER >= self.size:
            self.double()
    def __getitem__(self, item):
        index = self.get_index(item)
        stored_item = self.array[index]
        if stored_item is None:
            raise KeyError(item)
        return stored_item.value
    def __contains__(self, item):
        try:
            return self[item] is not None
        except KeyError:
            return False
    def __iter__(self):
        for item in filter(None, self.array):
            yield item.key
    def __delitem__(self, key):
        index = self.get_index(key)
        self.array[index] = None
        for item in filter(None, self.array):
            self[item.key] = item.value
    def __repr__(self):
        return '{%s}' % ', '.join(
            '""{}"": {}'.format(key, self[key])
            for key in self)
    def __len__(self):
        return self.size - self.array.count(None)
    def double(self):
        new_hash_map = HashMap()
        new_hash_map.size = self.size * 2
        new_hash_map.array = [None for x in range(new_hash_map.size)]
        for item in self:
            new_hash_map[item] = self[item]
        self.array = new_hash_map.array
        self.size = new_hash_map.size",0,0,0,0,0,1,0,0,1
1344,"class SLNode:
    def __init__(self, key, value):
        self.next = None
        self.key = key
        self.value = value
    def __str__(self):
        return '(' + str(self.key) + ', ' + str(self.value) + ')'
class LinkedList:
    def __init__(self):
        self.head = None
        self.size = 0
    def add_front(self, key, value):
        new_node = SLNode(key, value)
        new_node.next = self.head
        self.head = new_node
        self.size = self.size + 1
    def remove(self, key):
        if self.head is None:
            return False
        if self.head.key == key:
            self.head = self.head.next
            self.size = self.size - 1
            return True
        cur = self.head.next
        prev = self.head
        while cur is not None:
            if cur.key == key:
                prev.next = cur.next
                self.size = self.size - 1
                return True
            prev = cur
            cur = cur.next
        return False
    def contains(self, key):
        if self.head is not None:
            cur = self.head
            while cur is not None:
                if cur.key == key:
                    return cur
                cur = cur.next
        return None
    def __str__(self):
        out = '['
        if self.head != None:
            cur = self.head
            out = out + str(self.head)
            cur = cur.next
            while cur != None:
                out = out + ' -> ' + str(cur)
                cur = cur.next
        out = out + ']'
        return out
def hash_function_1(key):
    hash = 0
    for i in key:
        hash = hash + ord(i)
    return hash
def hash_function_2(key):
    hash = 0
    index = 0
    for i in key:
        hash = hash + (index + 1) * ord(i)
        index = index + 1
    return hash
class HashMap:
    def __init__(self, capacity, function):
        self._buckets = []
        for i in range(capacity):
            self._buckets.append(LinkedList())
        self.capacity = capacity
        self._hash_function = function
        self.size = 0
    def __str__(self):
        out = """"
        index = 0
        for bucket in self._buckets:
            out = out + str(index) + ': ' + str(bucket) + '\n'
            index = index + 1
        return out
    def put(self, key, value):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        if (hash_link.contains(key)):
            hash_link.remove(key)
            hash_link.add_front(key, value)
        else:
            hash_link.add_front(key, value)
            self.size += 1
    def clear(self):
        self._buckets.clear()
        for i in range(self.capacity):
            self._buckets.append(LinkedList())
    def get(self, key):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        cur = hash_link.head
        for i in range(hash_link.size):
            if (cur.key == key):
                return cur.value
            else:
                cur = cur.next
        return None
    def resize_table(self, capacity):
        _oldBuckets = self._buckets
        self._buckets = []
        self.size = 0
        self.capacity = capacity
        for i in range(capacity):
            self._buckets.append(LinkedList())
        for i in range(len(_oldBuckets)):
            if _oldBuckets[i].size != 0:
                cur = _oldBuckets[i].head
                while (cur != None):
                    self.put(cur.key, cur.value)
                    cur = cur.next
    def remove(self, key):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        if (hash_link.contains(key)):
            hash_link.remove(key)
    def contains_key(self, key):
        hash = self._hash_function(key)
        index = (hash % self.capacity)
        hash_link = self._buckets[index]
        if (hash_link.contains(key)):
            return True
        else:
            return False
    def empty_buckets(self):
        empty_count = 0
        for i in range(self.capacity):
            if (self._buckets[i].size == 0):
                empty_count += 1
        return empty_count
    def table_load(self):
        return self.size/self.capacity",0,0,0,0,0,1,0,1,1
1345,"import hashlib
from linked_list import LinkedList
class HashMap:
    def __init__(self, num_buckets = 8):
        self.store = self.initialize_store(num_buckets)
        self.count = 0
    def __getitem__(self, key):
        value = self.get_value(key)
        if value is not None:
            return value
        raise KeyError(""That key is not included"")
    def get(self, key, default_value = None):
        value = self.get_value(key)
        if value is not None:
            return value
        return default_value
    def get_value(self, key):
        bucket = self.bucket(key)
        return bucket.get(key)
    def __setitem__(self, key, value):
        bucket = self.bucket(key)
        if bucket.is_included(key):
            bucket.update(key, value)
        else:
            bucket.append(key, value)
            self.count += 1
        if self.count > self.num_buckets():
            self.resize()
        return value
    def delete(self, key):
        value = self.bucket(key).remove(key)
        if value is not None:
            self.count -= 1
            if self.count < self.num_buckets() / 4:
                self.resize(False)
        return value
    def has_key(self, key):
        bucket = self.bucket(key)
        return bucket.is_included(key)
    def update(self, other_hash_map):
        for key, value in other_hash_map.items():
            self[key] = value
        return self
    def resize(self, grow = True):
        new_num_buckets = self.num_buckets() * 2 if grow else self.num_buckets() / 2
        if new_num_buckets < 8:
            return
        old_store = self.store
        self.store = self.initialize_store(new_num_buckets)
        self.count = 0
        for bucket in old_store:
            item = bucket.head.next
            while item != bucket.tail:
                self[item.key] = item.value
                item = item.next
        return self
    def __len__(self):
        return self.count
    def is_empty(self):
        return self.count == 0
    def num_buckets(self):
        return len(self.store)
    def bucket(self, key):
        bucket_idx = hash(key) % self.num_buckets()
        return self.store[bucket_idx]
    def initialize_store(self, num_buckets):
        new_store = []
        if num_buckets < 8:
            num_buckets = 8
        while len(new_store) < num_buckets:
            new_store.append(LinkedList())
        return new_store
    def items(self):
        return self.get_subset()
    def keys(self):
        return self.get_subset(""keys"")
    def values(self):
        return self.get_subset(""values"")
    def get_subset(self, subset = ""items""):
        items = []
        for bucket in self.store:
            if subset == ""keys"":
                items += bucket.keys()
            elif subset == ""values"":
                items += bucket.values()
            else:
                items += bucket.items()
        return items
    def __str__(self):
        pretty_items = []
        for pair in self.items():
            pretty_pair  = "": "".join(self.format_pair(pair))
            pretty_items.append(pretty_pair)
        return ""{"" + "", "".join(pretty_items) + ""}""
    def pretty_string(self, string):
        return ""'%s'"" % string
    def format_pair(self, pair):
        pretty_pair = ()
        for item in pair:
            if isinstance(item, basestring):
                pretty_pair += (self.pretty_string(item), )
            else:
                pretty_pair += (str(item), )
        return pretty_pair",0,0,0,0,0,0,0,0,1
1346,"from linked_list import LinkedList
class MyHashMap(object):
    def __init__(self, buckets=10):
        self.size = 0
        self.num_buckets = buckets
        self.linked_lists = [LinkedList() for i in range(buckets)]
    def _get_bucket_index(self, key):
        hash_code = hash(key)
        index = hash_code % self.num_buckets
        return index
    def is_empty(self):
        return self.size == 0
    def add(self, key, value) -> None:
        bucket_index = self._get_bucket_index(key)
        node = self.linked_lists[bucket_index].put(key, value)
        self.size += 1
        if (1.0 * self.size) / self.num_buckets >= 0.7:
            self.resize(grow=True)
    def get(self, key):
        bucket_index = self._get_bucket_index(key)
        node = self.linked_lists[bucket_index].get_key(key)
        return node.value if node else None
    def remove(self, key) -> None:
        bucket_index = self._get_bucket_index(key)
        self.linked_lists[bucket_index].remove(key)
        self.size -= 1
    def update(self, key, value) -> None:
        bucket_index = self._get_bucket_index(key)
        node = self.linked_lists[bucket_index].get_key(key)
        if node:
            node.value = value
    def resize(self, grow=True):
        self.num_buckets = self.num_buckets * 2 if grow else self.num_buckets / 2
        old_lists = self.linked_lists
        self.linked_lists = [LinkedList() for i in range(self.num_buckets)]
        self.size = 0
        for llist in old_lists:
            item = llist.head
            while item:
                self.add(item.key, item.value)
                item = item.next",0,0,0,0,0,0,0,0,1
1347,"class HashMap(object):
    def __init__(self):
        self.hash = [[] for x in range(64)]
    def hashing(self, key):
        value = 0
        for char in key:
            value += ord(char)
        index = value % 64
        return index
    def find_val(self, key):
        index = self.hashing(key)
        position = self.hash[index]
        if position != []:
            for item in position:
                if item[0] == key:
                    return item[1]
            raise KeyError('Key does not exist.')
        else:
            raise KeyError('Key does not exist.')
    def update_or_add(self, key, val):
        index = self.hashing(key)
        position = self.hash[index]
        if position != []:
            for item in position:
                if item[0] == key:
                    item[1] = val
                    break
            position.append((key, value))
        else:
            position.append((key, value))
    def delete(self, key):
        index = self.hashing(key)
        position = self.hash[index]
        if position != []:
            for i, item in enumerate(position):
                if item[0] == key:
                    del position[i]
                    break
            raise KeyError('Key does not exist.')
        else:
            raise KeyError('Key does not exist.')",0,0,0,0,0,1,0,0,1
1348,"from linked_list import LinkedList
class HashMap(object):
    def __init__(self, num_buckets=None):
        if num_buckets is None:
            num_buckets = 8
        self.store = []
        while len(self.store) < num_buckets:
            self.store.append(LinkedList())
        self.count = 0
    def include(self, key):
        return self.bucket(key).include(key)
    def __getitem__(self, key):
        return self.bucket(key).get(key)
    def __setitem__(self, key, val):
        linked_list = self.bucket(key)
        if self.include(key):
            linked_list.update(key, val)
        else:
            if self.count == len(self.store):
                self.resize()
            linked_list.append(key, val)
            self.count = self.count + 1
    def set(self, key, val):
        self[key] = val
    def get(self, key, default=None):
        if self[key]:
            return self[key]
        else:
            return default
    def delete(self, key):
        linked_list = self.bucket(key)
        if linked_list.include(key):
            linked_list.remove(key)
            self.count -= 1
    def resize(self):
        old_store = self.store
        self.count = 0
        self.store = []
        while len(self.store) < len(old_store) * 2:
            self.store.append(LinkedList())
        for linked_list in old_store:
            link = linked_list.first()
            while link != linked_list.tail:
                self[link.key] = link.val
                link = link.next
    def bucket(self, key):
        return self.store[hash(key) % len(self.store)]
    def __str__(self):
        pairs = []
        i = 0
        while i < len(self.store):
            linked_list = self.store[i]
            if not linked_list.empty():
                pairs.append(str(linked_list))
            i = i + 1
        return "", "".join(pairs)
    def keys(self):
        key_items = []
        i = 0
        while i < len(self.store):
            linked_list = self.store[i]
            links = linked_list.keys()
            key_items = key_items + links
            i += 1
        return key_items",0,0,0,0,0,0,0,0,1
1349,"class LinkedListNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
class MyHashMap:
    def __init__(self, initial_size=15):
        self.bucket_array = [None for _ in range(initial_size)]
        self.p = 31
        self.num_entries = 0
        self.load_factor = 0.7
    def put(self, key, value):
        bucket_index = self.get_bucket_index(key)
        new_node = LinkedListNode(key, value)
        head = self.bucket_array[bucket_index]
        while head is not None:
            if head.key == key:
                head.value = value
                return
            head = head.next
        head = self.bucket_array[bucket_index]
        new_node.next = head
        self.bucket_array[bucket_index] = new_node
        self.num_entries += 1
        current_load_factor = self.num_entries / len(self.bucket_array)
        if current_load_factor > self.load_factor:
            self.num_entries = 0
            self._rehash()
    def get(self, key):
        bucket_index = self.get_hash_code(key)
        head = self.bucket_array[bucket_index]
        while head is not None:
            if head.key == key:
                return head.value
            head = head.next
        return -1
    def get_bucket_index(self, key):
        bucket_index = self.get_hash_code(key)
        return bucket_index
    def get_hash_code(self, key):
        key = str(key)
        num_buckets = len(self.bucket_array)
        current_coefficient = 1
        hash_code = 0
        for character in key:
            hash_code += ord(character) * current_coefficient
            hash_code = hash_code % num_buckets                       
            current_coefficient *= self.p
            current_coefficient = current_coefficient % num_buckets   
        return hash_code % num_buckets                                
    def size(self):
        return self.num_entries
    def _rehash(self):
        old_num_buckets = len(self.bucket_array)
        old_bucket_array = self.bucket_array
        num_buckets = 2 * old_num_buckets
        self.bucket_array = [None for _ in range(num_buckets)]
        for head in old_bucket_array:
            while head is not None:
                key = head.key
                value = head.value
                self.put(key, value)         
                head = head.next
    def remove(self, key):
        bucket_index = self.get_bucket_index(key)
        head = self.bucket_array[bucket_index]
        previous = None
        while head is not None:
            if head.key == key:
                if previous is None:
                    self.bucket_array[bucket_index] = head.next
                else:
                    previous.next = head.next
                self.num_entries -= 1
                return
            else:
                previous = head
                head = head.next",0,0,0,0,0,1,0,0,1
1350,"from linked_list import LinkedList
class HashMap(object):
    def __init__(self, num_buckets=None):
        if num_buckets is None:
            num_buckets = 8
        self.store = []
        while len(self.store) < num_buckets:
            self.store.append(LinkedList())
        self.count = 0
    def include(self, key):
        return self.bucket(key).include(key)
    def __getitem__(self, key):
        return self.bucket(key).get(key)
    def __setitem__(self, key, val):
        linked_list = self.bucket(key)
        if self.include(key):
            linked_list.update(key, val)
        else:
            if self.count == len(self.store):
                self.resize()
            linked_list.append(key, val)
            self.count = self.count + 1
    def set(self, key, val):
        self[key] = val
    def get(self, key, default=None):
        if self[key]:
            return self[key]
        else:
            return default
    def delete(self, key):
        linked_list = self.bucket(key)
        if linked_list.include(key):
            linked_list.remove(key)
            self.count -= 1
    def resize(self):
        old_store = self.store
        self.count = 0
        self.store = []
        while len(self.store) < len(old_store) * 2:
            self.store.append(LinkedList())
        for linked_list in old_store:
            link = linked_list.first()
            while link != linked_list.tail:
                self[link.key] = link.val
                link = link.next
    def bucket(self, key):
        return self.store[hash(key) % len(self.store)]
    def __str__(self):
        pairs = []
        i = 0
        while i < len(self.store):
            linked_list = self.store[i]
            if not linked_list.empty():
                pairs.append(str(linked_list))
            i = i + 1
        return "", "".join(pairs)
    def keys(self):
        key_items = []
        i = 0
        while i < len(self.store):
            linked_list = self.store[i]
            links = linked_list.keys()
            key_items = key_items + links
            i += 1
        return key_items",0,0,0,0,0,0,0,0,1
1351,"from linked_list import LinkedList
class HashTable(object):
    def __init__(self, size, hash_func):
        self.size = size
        self.hash_func = hash_func
        self.buckets = [LinkedList() for i in range(size)]
        if self.hash_func != 'add' and self.hash_func != 'exor' and self.hash_func != 'fnv':
            raise ValueError('Valid hash_func vals include add, exor, and fnv')
    def get(self, key):
        if self.hash_func == 'add':
            hashed_key = self._additive_hash(key)
        if self.hash_func == 'exor':
            hashed_key = self._exor_hash(key)
        if self.hash_func == 'fnv':
            hashed_key = self._fnv_hash(key)
        mapped_key = hashed_key % self.size
        current_node = self.buckets[mapped_key].head
        while current_node:
            if current_node.data == key:
                return current_node.next.data
            current_node = current_node.next
        raise KeyError(""Key not in HashTable"")
    def set(self, key, val):
        if isinstance(key, str):
            if self.hash_func == 'add':
                hashed_key = self._additive_hash(key)
            if self.hash_func == 'exor':
                hashed_key = self._exor_hash(key)
            if self.hash_func == 'fnv':
                hashed_key = self._fnv_hash(key)
            mapped_key = hashed_key % self.size
            self.buckets[mapped_key].push((val, key))
        else:
            raise ValueError('Keys should be strings.')
    def _additive_hash(self, key):
        hashed_key = 0
        for val in key:
            hashed_key += ord(val)
        return hashed_key
    def _exor_hash(self, key):
        hashed_key = 0
        for val in key:
            hashed_key ^= ord(val)
        return hashed_key
    def _fnv_hash(self, key):
        h = 2166136261
        for char in key:
            h = (h * 16777619) ^ ord(char)
        return h",0,0,0,0,0,1,0,0,1
1352,"from linked_list import Linked_List
from sys import maxsize as max_int
from random import randrange
from math import log
class Hash_Table:
    def __init__(self):
        self.table = [Linked_List() for _ in range(4)]
        self.hash_size = 2
        self.min_size = 1
        self.max_size = 4
        self.num_keys = 0
        self.rand = randrange(1, max_int)
        self.word_size = int(log(max_int,2))
        self.h = lambda key: (self.rand*key % max_int) >> (self.word_size - self.hash_size)
    def find(self, key):
        return self.table[self.h(key)].find(key)
    def insert(self, key, value):
        if self.find(key):
            return None
        if self.num_keys == self.max_size:
            self.expand()
        self.num_keys += 1
        return self.table[self.h(key)].insert(key, value)
    def delete(self, key):
        target = self.table[self.h(key)].delete(key)
        if target:
            self.num_keys -= 1
            if self.num_keys == self.min_size and self.hash_size > 2:
                self.contract()
        return target
    def update(self, key, value):
        target = self.find(key)
        if target:
            target.update(key)
        else:
            target = self.insert(key, value)
        return target
    def expand(self):
        self.hash_size += 1
        self.min_size *= 2
        self.max_size *= 2
        self.rehash()
    def contract(self):
        self.hash_size -= 1
        self.min_size //= 2
        self.max_size //= 2
        self.rehash()
    def rehash(self):
        self.num_keys = 0
        table = self.table
        self.table = [Linked_List() for slot in range(self.max_size)]
        for slot in table:
            element = slot.head
            while element:
                self.insert(element.key, element.value)
                element = element.next
    def __repr__(self):
        return ""\n"".join(""  {}: {}"".format(key, chain) for (key, chain) in enumerate(self.table))",0,0,0,0,0,0,0,0,1
1353,"__author__ = 'Thomaz Lago Santana'
import warnings
from copy import deepcopy
class HashTableMap(object):
    def __init__(self, **kwargs):
        self.warnings = kwargs.pop('warnings', False)
        self.auto_rehash = kwargs.pop('auto_rehash', True)
        self.load_factor = kwargs.pop('load_factor', 0.66)
        self.__list_size = 0
        self.__buckets = kwargs.pop('buckets', 211)
        self.__list = []
        for i in range(0, self.__buckets):
            self.__list.append([])
    def __check_load_factor(self):
        if self.auto_rehash:
            current_load = self.__list_size / float(self.__buckets)
            if current_load > self.load_factor and self.__list_size > 100:
                buckets = self.__list_size * 3 + 1
                self.rehash(buckets)
            elif current_load < self.load_factor / 7.0 and self.__list_size > 100:
                buckets = self.__list_size * 2 + 1
                self.rehash(buckets)
    def __generate_new_list(self):
        self.__list = []
        self.__list_size = 0
        for i in range(0, self.__buckets):
            self.__list.append([])
    def __hash_str(self, key):
        sum_ord = 0
        for letter in key:
            sum_ord += ord(letter)
        return sum_ord % self.__buckets
    def __hash_int(self, key):
        return key % self.__buckets
    def __get_hash_key(self, key):
        if type(key) is str:
            return self.__hash_str(key)
        elif type(key) is int:
            return self.__hash_int(key)
        elif type(key) is float:
            return self.__hash_str(str(key))
        else:
            if self.warnings:
                message = 'Key type has to be int or str or float. Key of type %s given.' % type(key)
                warnings.warn(message)
            return None
    def __get_index(self, key, hash_key):
        i = 0
        for b_list in self.__list[hash_key]:
            if b_list[0] == key:
                return i
            i += 1
        return None
    def __get(self, key, hash_key):
        index = self.__get_index(key, hash_key)
        if index is None:
            return None
        else:
            return self.__list[hash_key][index][1]
    def __add(self, key, value, hash_key):
        self.__list[hash_key].append([key, value])
        self.__list_size += 1
    def size(self):
        return self.__list_size
    def rehash(self, buckets):
        if type(buckets) is not int:
            pass
        else:
            temp_data = self.__list
            if self.warnings:
                print 'Rehashing from %s to %s buckets' % (self.__buckets, buckets)
            self.__buckets = buckets
            self.__generate_new_list()
            for bucket_list in temp_data:
                for key, value in bucket_list:
                    hash_key = self.__get_hash_key(key)
                    self.__add(key, value, hash_key)
    def get(self, key):
        hash_key = self.__get_hash_key(key)
        if hash_key is None:
            return None
        else:
            return self.__get(key, hash_key)
    def add(self, key, value):
        hash_key = self.__get_hash_key(key)
        if hash_key is None:
            pass
        elif self.__get(key, hash_key) is None:
            self.__add(key, value, hash_key)
            self.__check_load_factor()
        elif self.warnings:
            warnings.warn('Key already exists. Operation ignored.')
    def insert(self, key, value):
        hash_key = self.__get_hash_key(key)
        if hash_key is None:
            pass
        elif self.__get(key, hash_key) is None:
            self.__add(key, value, hash_key)
            self.__check_load_factor()
        else:
            for b_list in self.__list[hash_key]:
                if b_list[0] == key:
                    b_list[1] = value
    def get_all(self):
        list_copy = deepcopy(self.__list)
        for bucket_list in list_copy:
            for key_value in bucket_list:
                yield key_value
    def get_all_raw(self):
        raw_list = []
        for bucket_list in self.__list:
            for key_value in bucket_list:
                raw_list.append(key_value)
        return raw_list
    def delete(self, key):
        hash_key = self.__get_hash_key(key)
        if hash_key is None:
            pass
        else:
            index = self.__get_index(key, hash_key)
            if index is None:
                if self.warnings:
                    warnings.warn('Key does not exist. Operation ignored.')
            else:
                del self.__list[hash_key][index]
                self.__list_size -= 1
    def pop(self, key):
        hash_key = self.__get_hash_key(key)
        if hash_key is None:
            return None
        else:
            index = self.__get_index(key, hash_key)
            if index is None:
                if self.warnings:
                    warnings.warn('Key does not exist. Returned None.')
                return None
            else:
                value = self.__list[hash_key][index][1]
                del self.__list[hash_key][index]
                return value
    def get_num_buckets(self):
        return self.__buckets",0,0,0,0,0,0,0,0,1
1354,"class Hash_Table:
    def __init__(self):
        self.num = 0
        self.size = 8
        self.marked = 0
        self.num_min = 1
        self.size_min = 8
        self.marked_max = 4
        self.h1 = lambda k: k % self.size
        self.h2 = lambda k: 1 + 2*(k % self.marked_max)
        self.table = [None for _ in range(self.size)]
    def probing_sequence(self, key):
        slot = self.h1(key)
        step = self.h2(key)
        for access in range(self.size):
            yield (slot, self.table[slot])
            slot = self.h1(slot + step)
    def find(self, key):
        for (slot, element) in self.probing_sequence(key):
            if element == None or element[0] == key:
                return element
        return None
    def insert(self, key, value):
        probing_sequence = self.probing_sequence(key)
        for (slot, element) in probing_sequence:
            if element == None:
                if element == None:
                    self.num += 1
                    self.marked += 1
                    self.table[slot] = (key, value)
                    if self.marked > self.marked_max:
                        self.expand()
                return
            elif element == ""D"":
                self.table[slot] = (key, value)
                for (slot, element) in probing_sequence:
                    if element == None:
                        self.num += 1
                        return
                    elif element[0] == key:
                        self.table[slot] = ""D""
                        return
                return
            elif element[0] == key:
                self.table[slot][1] = value
                return
    def delete(self, key):
        for (slot, element) in self.probing_sequence(key):
            if element == None:
                return
            elif element[0] == key:
                self.num -= 1
                self.table[slot] = ""D""
                if self.num <= self.num_min and self.size > self.size_min:
                    self.contract()
                return
    def rehash(self):
        self.num = 0
        self.marked = 0
        table = self.table
        self.table = [None for slot in range(self.size)]
        for element in table:
            if element and element != ""D"":
                self.insert(*element)
    def expand(self):
        self.size *= 2
        self.num_min *= 2
        self.marked_max *= 2
        self.rehash()
    def contract(self):
        self.size //= 2
        self.num_min //= 2
        self.marked_max //= 2
        self.rehash()
    def __repr__(self):
        def showItem(item):
            return """" if item == None else ""DELETED"" if item == ""D"" else item
        return ""\n"".join(""  {}: [{}]"".format(key, showItem(item)) for (key, item) in enumerate(self.table))",0,0,0,0,0,1,0,0,1
1355,"class HashTable(object):
    def __init__(self, size):
        if int(size) != size:
            raise TypeError(u""size must be an integer"")
        self.size = size
        self.hlist = []
        for i in range(size):
            self.hlist.append([])
    def get(self, key):
        index = self.hash(key)
        index_list = self.hlist[index]
        for pair in index_list:
            if pair[0] == key:
                return pair[1]
    def set(self, key, val):
        if str(key) != key:
            raise TypeError(u""key must be a string."")
        index = self.hash(key)
        self.hlist[index].append((key, val))
    def hash(self, key):
        h_index = 0
        for char in key:
            h_index = (h_index + ord(char)) % self.size
        return h_index",0,0,0,0,0,1,0,0,1
1356,"import {sameValueZero, strictEquals, isFunction} from '../utils';
import {Option} from ""../option"";
export function hash(key, len = 0, seed = 0) {
    len = len > 0 ? Math.min(len, key.length) : key.length;
    seed |= 0;
    const remaining = len & 1;
    const doubleBytes = len - remaining;
    let hash = seed, k = 0, i = 0;
    while (i < doubleBytes) {
        k = (key.charCodeAt(i++) & 0xffff) |
            ((key.charCodeAt(i++) & 0xffff) << 16);
        k *= 0xcc9e2d51;
        k = (k << 15) | (k >>> 17);
        k *= 0x1b873593;
        hash ^= k;
        hash = (hash << 13) | (hash >>> 19);
        hash *= 5;
        hash += 0xe6546b64;
    }
    if (remaining) {
        k ^= (key.charCodeAt(i) & 0xffff);
        k *= 0xcc9e2d51;
        k = (k << 15) | (k >>> 17);
        k *= 0x1b873593;
        hash ^= k;
    }
    hash ^= len;
    hash ^= hash >>> 16;
    hash *= 0x85ebca6b;
    hash ^= hash >>> 13;
    hash *= 0xc2b2ae35;
    hash ^= hash >>> 16;
    return hash | 0;
}
export function hashCodeFor(key) {
    const keyType = typeof key;
    switch (keyType) {
        case 'undefined':
            return 0;
        case 'boolean':
            return key ? 1 : 0;
        case 'string':
            return hash(key);
        case 'number':
            if (!Number.isFinite(key)) {
                return 0;
            }
            if (Number.isSafeInteger(key)) {
                return key | 0;
            }
            return hash(key.toString());
        case 'bigint':
        case 'symbol':
        case 'function':
            return hash(key.toString());
        case 'object':
        default: {
            if (key === null) {
                return 0;
            }
            if (key.hashCode) {
                if (isFunction(key.hashCode)) {
                    return hashCodeFor(key.hashCode(key));
                }
                return hashCodeFor(key.hashCode);
            }
            if (key instanceof Date) {
                return key.getTime();
            }
            if (key instanceof RegExp) {
                return hash(key.toString());
            }
            if (key instanceof Option) {
                if (key.has) {
                    return 31 * hashCodeFor(key.value);
                }
                return 0;
            }
            if (Object.prototype.hasOwnProperty.call(key, '_mootable_hashCode')) {
                return hashCodeFor(key._mootable_hashCode);
            }
            const hashCode = HASH_COUNTER++;
            Object.defineProperty(key, '_mootable_hashCode', {
                value: hashCode
            });
            return hashCode;
        }
    }
}
let HASH_COUNTER = 0;
export function equalsFor(key) {
    switch (typeof key) {
        case 'object':
            if (key) {
                if (key instanceof RegExp) {
                    return (me, them) => {
                        if (them instanceof RegExp) {
                            return me.toString() === them.toString();
                        }
                        return false;
                    };
                } else if (key instanceof Date) {
                    return (me, them) => {
                        if (them instanceof Date) {
                            return me.getTime() === them.getTime();
                        }
                        return false;
                    };
                } else if (key instanceof Option) {
                    if (key.has) {
                        const valueEquals = equalsFor(key.value);
                        return (me, them) => {
                            if (them.has) {
                                return valueEquals(me.value, them.value);
                            }
                            return false;
                        };
                    } else {
                        return (me, them) => !them.has;
                    }
                } else if (isFunction(key.equals)) {
                    return (me, them) => me.equals(them, me);
                }
            }
            return strictEquals;
        case 'number':
        case 'bigint':
            return sameValueZero;
        default:
            return strictEquals;
    }
}
export function equalsAndHash(key, options) {
    if (options) {
        let hash = options.hash;
        let equals = options.equals;
        if (isFunction(hash)) {
            hash = hash(key);
        }
        if (!Number.isSafeInteger(hash)) {
            hash = hashCodeFor(key);
        }
        if (!isFunction(equals)) {
            equals = equalsFor(key);
        }
        return {hash, equals};
    }
    const toSetOn = {};
    const keyType = typeof key;
    switch (keyType) {
        case 'undefined':
            toSetOn.hash = 0;
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'boolean':
            toSetOn.hash = key ? 1 : 0;
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'string':
            toSetOn.hash = hash(key);
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'number':
            if (!Number.isFinite(key)) {
                toSetOn.hash = 0;
                toSetOn.equals = sameValueZero;
                return toSetOn;
            }
            if (Number.isSafeInteger(key)) {
                toSetOn.hash = key | 0;
                toSetOn.equals = sameValueZero;
                return toSetOn;
            }
            toSetOn.hash = hash(key.toString());
            toSetOn.equals = sameValueZero;
            return toSetOn;
        case 'bigint':
            toSetOn.hash = hash(key.toString());
            toSetOn.equals = sameValueZero;
            return toSetOn;
        case 'symbol':
        case 'function':
            toSetOn.hash = hash(key.toString());
            toSetOn.equals = strictEquals;
            return toSetOn;
        case 'object':
        default: {
            if (key === null) {
                toSetOn.hash = 0;
                toSetOn.equals = strictEquals;
                return toSetOn;
            }
            toSetOn.equals = equalsFor(key);
            if (key.hashCode) {
                if (isFunction(key.hashCode)) {
                    toSetOn.hash = hashCodeFor(key.hashCode(key));
                    return toSetOn;
                } else {
                    toSetOn.hash = hashCodeFor(key.hashCode);
                    return toSetOn;
                }
            }
            if (key instanceof Date) {
                toSetOn.hash = key.getTime();
                return toSetOn;
            }
            if (key instanceof RegExp) {
                toSetOn.hash = hash(key.toString());
                return toSetOn;
            }
            if (key instanceof Option) {
                if (key.has) {
                    toSetOn.hash = 31 * hashCodeFor(key.value);
                    return toSetOn;
                }
                toSetOn.hash = 0;
                return toSetOn;
            }
            if (Object.prototype.hasOwnProperty.call(key, '_mootable_hashCode')) {
                toSetOn.hash = hashCodeFor(key._mootable_hashCode);
                return toSetOn;
            }
            const hashCode = HASH_COUNTER++;
            Object.defineProperty(key, '_mootable_hashCode', {
                value: hashCode
            });
            toSetOn.hash = hashCode;
            return toSetOn;
        }
    }
}",0,0,0,0,0,0,0,0,0
1357,"def to_hash(key, length=10):
    try:
        return abs(hash(key)) % (10 ** length)
    except TypeError:
        return abs(hash(str(key))) % (10 ** length)
class Node:
    def __init__(self, key, value, next_node=None):
        self.key = key
        self.value = value
        self.next = next_node
    def __repr__(self):
        return f'Node {{{self.key}: {self.value}}}'
class LinkedList:
    def __init__(self, head=None):
        self.head = head
        self.current = self.head
    def __repr__(self):
        return f'LinkedList <{self.head}> -> ...'
    def __iter__(self):
        return self
    def __next__(self):
        if self.current is not None:
            node, self.current = self.current, self.current.next
            return node
        self.current = self.head
        raise StopIteration
    def __len__(self):
        count = 0
        for _ in self:
            count += 1
        return count
    def _append(self, key, value):
        node = self.head
        if node is None:
            self.head = Node(key, value)
            self.current = self.head
            return self.head
        else:
            while node.next:
                node = node.next
            node.next = Node(key, value)
            return node.next
    def get(self, key):
        node = self.head
        if node is None:
            return None
        if node.key == key:
            return node
        while node:
            if node.key == key:
                return node
            node = node.next
        return node
    def set(self, key, value):
        node = self.get(key)
        if node:
            node.value = value
        else:
            node = self._append(key, value)
        return node
class Hashtable:
    def __init__(self, size=100):
        self.size = size
        self._buckets = [None for i in range(size)]
        self._hash_map = {}
    def __repr__(self):
        return f'Hashtable <{len(self._hash_map)} key/val pairs>'
    def _get_list(self, index):
        try:
            return self._buckets[index]
        except IndexError:
            return None
    def get(self, *keys):
        values = []
        for key in keys:
            hash_key = to_hash(key)
            if hash_key not in self._hash_map:
                continue
            index = self._hash_map[hash_key]
            lst = self._get_list(index)
            if lst and lst.get(key):
                values.append(lst.get(key).value)
        return values[0] if len(values) == 1 else tuple(values) or None
    def set(self, key=None, value=None):
        if key is None:
            return None
        hash_key = to_hash(key)
        if hash_key in self._hash_map:
            lst = self._get_list(index=self._hash_map[hash_key])
            node = lst.set(key, value)
        else:
            index = hash_key % self.size
            if self._get_list(index) is None:
                self._buckets[index] = LinkedList()
            node = self._buckets[index].set(key, value)
            self._hash_map[hash_key] = index
        return node
    def keys(self):
        keys = []
        indices = set(self._hash_map.values())
        for i in indices:
            keys.extend([node.key for node in self._buckets[i] if node])
        return tuple(keys)",0,0,0,0,0,1,0,1,1
1358,"import java.util.*;
public class HashMap
{
   private int size;
   private int initializedSize;
   private int itemsInHashMap;
   private LinkedList<Object[]>[] map;
   public HashMap(){}
   public HashMap(int size)
   {
      this.initializedSize = size;
      this.size = size*4/3;  
      itemsInHashMap = 0;
      map = new LinkedList[this.size];
   }
   public float load()
   {
      return (float) itemsInHashMap / size;
   }
   public boolean set(String key, Object value)
   {
      int bucket = Math.abs(key.hashCode() % size);
      if(map[bucket] == null)
      {
         if(itemsInHashMap >= initializedSize)  
            return false; 
         LinkedList valueList = new LinkedList();
         Object[] valuePair = {key, value};
         valueList.add(valuePair);
         map[bucket] = valueList;
      }
      else
      {
         LinkedList valueList = map[bucket];       
         Iterator iter = valueList.iterator();
         Object[] newValuePair = {key, value};
         while(iter.hasNext())
         {
            Object[] temp = (Object[]) iter.next();
            if(temp[0] == key)  
            {
               iter.remove(); 
               itemsInHashMap--;
               break;
            }  
         }
         if(itemsInHashMap >= initializedSize)  
            return false; 
         valueList.add(newValuePair);
      }
      itemsInHashMap++;
      return true;   
   }
   public Object get(String key)
   {
      int bucket = Math.abs(key.hashCode() % size);
      if (map[bucket] != null)
      {
         LinkedList valueList = map[bucket];
         Iterator iter = valueList.iterator();
         while(iter.hasNext())
         {
            Object[] temp = (Object[]) iter.next();
            if(temp[0] == key)
               return temp[1];  
         }
      }
      return null;
   }
   public Object delete(String key)
   {
      int bucket = Math.abs(key.hashCode() % size);
      if (map[bucket] != null)
      {
         LinkedList valueList = map[bucket];
         Iterator iter = valueList.iterator();
         while(iter.hasNext())
         {
            Object[] temp = (Object[]) iter.next();
            if(temp[0] == key)
            {
               Object returnValue = temp[1];
               iter.remove();
               itemsInHashMap--;
               return returnValue;
            }
         }
      }
      return null;
   }
}",0,0,0,0,0,1,0,0,1
1359,"function HashMap() {
    this._buckets = {};
    this._len = 0;
}
HashMap.prototype.codeFor = function(obj) {
    if (typeof obj !== 'object') return new String(obj);
    return (typeof obj.hash === 'function') ? obj.hash() : obj.toString();
};
HashMap.prototype.equals = function(a, b) {
    return (typeof a === 'object' && typeof a.equals === 'function') ?
            a.equals(b) :
            a === b;
};
HashMap.prototype.put = function(key, value) {
    var code = this.codeFor(key);
    var bucket = this._buckets[code];
    if (!bucket) {
        bucket = this._buckets[code] = [];
    }
    var replaced = false;
    var pair, oldValue;
    for (var i = 0, len = bucket.length; i < len; i++) {
        pair = bucket[i];
        if (this.equals(pair.key, key)) {
            oldValue = pair.value;
            pair.value = value;
            replaced = true;
            break;
        }
    }
    if (!replaced) {
        pair = {key: key, value: value};
        bucket.push(pair);
        this._len++;
    }
    return oldValue;
};
HashMap.prototype.add = HashMap.prototype.put;
HashMap.prototype._bucketForKey = function(key) {
    var hashCode = this.codeFor(key);
    return this._buckets[hashCode] || null;
};
HashMap.prototype._assoc = function(key) {
    var bucket = this._bucketForKey(key);
    if (!bucket) return null;
    for (var i = 0, len = bucket.length; i < len; i++) {
        var pair = bucket[i];
        if (this.equals(pair.key, key)) return pair;
    }
    return null;
};
HashMap.prototype.get = function(key) {
    var pair = this._assoc(key);
    return pair ? pair.value : null;
};
HashMap.prototype.hasKey = function(key) {
    return !!this._assoc(key);
};
HashMap.prototype.containsKey = HashMap.prototype.hasKey;
HashMap.prototype.hasValue = function(value) {
    var has = false;
    this.forEach(function(k, v) {
        if (has) return;
        if (this.equals(value, v)) has = true;
    });
};
HashMap.prototype.remove = function(key) {
    var bucket = this._bucketForKey(key);
    if (!bucket) return null;
    for (var i = 0, len = bucket.length; i < len; i++) {
        var pair = bucket[i];
        if (this.equals(pair.key, key)) {
            bucket.splice(i, 1);
            this._len--;
            return pair.value;
        }
    }
    return null;
};
HashMap.prototype.size = function() {
    return this._len;
};
HashMap.prototype.isEmpty = function() {
    return this.size() <= 0;
};
HashMap.prototype.toString = function() {
    return 'HashMap(' + this._len + ')';
};
HashMap.prototype.forEach = function(block, context) {
    var code, bucket, i, pair;
    for (code in this._buckets) {
        if (!this._buckets.hasOwnProperty(code)) continue;
        bucket = this._buckets[code];
        i = bucket.length;
        while (i--) {
            pair = bucket[i];
            block.call(context || null, pair.key, pair.value);
        }
    }
};
HashMap.prototype.keys = function() {
    var keys = [];
    this.forEach(function(key, value) {
        keys.push(key);
    });
    return keys;
};
HashMap.prototype.values = function() {
    var values = [];
    this.forEach(function(key, value) {
        values.push(value);
    });
    return values;
};
function HashSet() {
    this._map = new HashMap();
    this._present = new Object();
}
HashSet.prototype.add = function(value) {
    this._map.put(value, this._present);
};
HashSet.prototype.remove = function(value) {
    return this._map.remove(value) === this._present;
};
HashSet.prototype.size = function() {
    return this._map.size();
};
HashSet.prototype.toString = function() {
    return 'HashSet(' + this.size() + ')';
};
HashSet.prototype.forEach = function(block, context) {
    this._map.forEach(function(key, value) {
        block.call(context || null, key);
    }, context || null);
};
HashSet.prototype.contains = function(value) {
    return this._map.hasKey(value);
};
HashSet.prototype.isEmpty = function() {
    return this._map.isEmpty();
};",0,0,0,0,0,0,0,0,1
1360,"from typing import List
INITIAL_BUCKET_COUNT = 16
DEFAULT_LOAD_FACTOR = .75
class HashMap:
    def __init__(self, load_factor=DEFAULT_LOAD_FACTOR):
        self.bucket_count = INITIAL_BUCKET_COUNT
        self.resize_threshold = INITIAL_BUCKET_COUNT
        self.load_factor = load_factor
        self.table: List[HashMap.NodeEntry] = [None] * self.bucket_count
        self.__size = 0
    def get(self, key):
        index = self.__index(self.bucket_count, hash(key))
        entry = self.__find_at(index, key)
        return entry.value if entry is not None else None
    def __find_at(self, index, key):
        entry: HashMap.NodeEntry = self.table[index]
        if entry is not None:
            if entry.key == key:
                return entry
            while entry.next is not None:
                entry = entry.next
                if entry.key == key:
                    return entry
    def put(self, key, value, only_if_absent=False):
        hash_code = hash(key)
        index = self.__index(self.bucket_count, hash_code)
        return self.__put_val(index, hash_code, key, value, only_if_absent)
    def compute(self, key, func, only_if_absent=False):
        hash_code = hash(key)
        index = self.__index(self.bucket_count, hash_code)
        entry = self.__find_at(index, key)
        if entry is None:
            value = func(key, None)
            self.__put_val(index, hash_code, key, value)
            return value
        elif only_if_absent is False:
            value = entry.value = func(key, entry.value)
            return value
        else:
            return entry.value
    def __put_val(self, index, hash_code, key, value, only_if_absent=False):
        entry = self.table[index]
        if entry is None:
            self.table[index] = HashMap.NodeEntry(hash_code, key, value)
        else:
            last_visited = entry
            while entry is not None:
                if entry.key == key:
                    old_value = entry.value
                    if only_if_absent is False:
                        entry.value = value
                    return old_value
                last_visited = entry
                entry = entry.next
            last_visited.next = HashMap.NodeEntry(hash_code, key, value)
        self.__size += 1
        if self.__size >= self.resize_threshold:
            self.__grow()
    def remove(self, key, value=None, match_value=False):
        entry: HashMap.Entry = self.__remove_entry(hash(key), key, value, match_value)
        return entry.value if entry is not None else None
    def __remove_entry(self, hash_code, key, value, match_value=False):
        index = self.__index(self.bucket_count, hash_code)
        entry = self.table[index]
        if entry is not None and entry.key == key and (not match_value or value == entry.value):
            self.table[index] = entry.next
            self.__size -= 1
        elif entry is not None:
            temp = entry
            while entry is not None:
                if entry.key == key and (match_value is False or value == entry.value):
                    temp.next = entry.next
                    self.__size -= 1
                    break
                elif entry is not None:
                    temp = entry
                    entry = entry.next
        return entry if entry is not None and entry.key == key else None
    def __grow(self):
        new_table_size = len(self.table) * 2
        new_table = [None] * new_table_size
        for i in range(0, self.bucket_count):
            entry = self.table[i]
            if entry is None:
                continue
            self.table[i] = None
            if entry.next is None:
                new_table[self.__index(new_table_size, entry.hash_code)] = entry
                continue
            low_head = low_tail = high_head = high_tail = None
            while entry is not None:
                if entry.hash_code & self.bucket_count == 0:
                    if low_tail is None:
                        low_head = entry
                    else:
                        low_tail.next = entry
                    low_tail = entry
                else:
                    if high_tail is None:
                        high_head = entry
                    else:
                        high_tail.next = entry
                    high_tail = entry
                entry = entry.next
            if low_tail is not None:
                low_tail.next = None
                new_table[i] = low_head
            if high_tail is not None:
                high_tail.next = None
                new_table[i + self.bucket_count] = high_head
        self.resize_threshold = new_table_size * self.load_factor
        self.table = new_table
        self.bucket_count = new_table_size
    def __len__(self):
        return self.__size
    @staticmethod
    def __index(table_size, hash_code):
        return hash_code & (table_size - 1)
    def __str__(self):
        return ', '.join(filter(lambda e: e != 'None', (map(str, self.table))))
    class Entry:
        def __init__(self, hash_code, key, value):
            self.hash_code = hash_code
            self.key = key
            self.value = value
        def __eq__(self, other):
            return self.hash_code == other.hash_code and self.value == other.value and self.key == other.key
        def __str__(self):
            return f'[{self.key}={self.value}]'
    class NodeEntry(Entry):
        def __init__(self, hash_code, key, value):
            super().__init__(hash_code, key, value)
            self.next = None
        def __str__(self):
            val = super().__str__()
            return val if self.next is None else "", "".join([val, str(self.next)])",0,0,0,0,0,0,0,0,1
1361,"import java.util.*;
public class HashMap<K,V>{
	static final int DEFAULT_CPAPCITY = 1 << 2;
	HashEntry<K,V>[] table;
	int size;
	int capacity;
	public HashMap() {
		capacity = DEFAULT_CPAPCITY;
	}
	public HashMap(int cap) {
		this.capacity = cap;
	}
	class HashEntry<K, V> {
		final int hash;
		final K key;
		V value;
		HashEntry<K,V> next;
		HashEntry(int hash, K key, V value, HashEntry<K,V> next) {
			this.hash = hash;
			this.key = key;
			this.value = value;
			this.next = next;
		}
		public K getKey() {
			return key;
		}
		public V getValue() {
			return value;
		}
		public final String toString() { return key + ""="" + value; }
		public final int hashCode() {
			return Objects.hashCode(key) ^ Objects.hashCode(value);
		}
	}
	static final int hash(Object key) {
		return (key == null) ? 0 : key.hashCode();
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0;
	}
	@SuppressWarnings(""unchecked"")
	public V put(K key, V value) {
		HashEntry<K, V> oldNode;  int hash = hash(key);
		if (table == null || table.length == 0) {
			table = (HashEntry<K, V>[]) new HashEntry[capacity];
		}
		int len = table.length;
		int index = (len - 1) & hash;
		if (table[index] == null) {
			table[index] = new HashEntry<K,V>(hash, key, value, null);
		} else {
			HashEntry<K, V> curNode;
			oldNode = table[index];
			if (oldNode.hash == hash && 
					oldNode.key == key || (key != null && oldNode.key.equals(key))){
				curNode = oldNode;
			} else {
				for (int count = 0; ; count++) {
					System.out.println(""LinkedList: Not "" + oldNode.key);
					curNode = oldNode.next;
					if (oldNode.next == null) {
						oldNode.next = new HashEntry(hash, key, value, null);
						break;
					}
					if (curNode.hash == hash &&
							(curNode.key == key || (key != null && curNode.key.equals(key)))) {
						break;
					}
					oldNode = curNode;
				}
			}
			if (curNode != null) {
				V oldValue = curNode.value;
				curNode.value = value;
				return oldValue;
			}
		}
		size++;
		return null;
	}
	public V get(Object key) {
		int hash = hash(key);
		int len = table.length;
		if (table != null && table.length > 0 && table[hash & (len - 1)] != null) {
			HashEntry<K, V> firstNode = table[hash & (len - 1)];
			if (firstNode.hash == hash && 
					firstNode.key == key || (key != null && firstNode.key.equals(key))) {
				return firstNode.value;
			}
			HashEntry<K, V> curNode = firstNode.next;
			if (firstNode.next != null) {
				do {
					if (curNode.hash == hash &&
							curNode.key == key || (curNode.key != null && curNode.key.equals(key))) {
						return curNode.value;
					} 
				}while ((curNode = curNode.next) != null);
			}
		}
		return null;
	}
	public boolean containsKey(Object key) {
		return get(key) != null;
	}
	public V remove(Object key) {
		int hash = hash(key);
		int len = table.length;
		int index = hash & (len - 1);
		if (table != null && table.length > 0 && table[index] != null) {
			HashEntry<K, V> prevNode = table[index];
			HashEntry<K, V> curNode = null; HashEntry<K, V> nodeRemoved = null;
			if (prevNode.hash == hash && 
					prevNode.key == key || (key != null && prevNode.key.equals(key))) {
				nodeRemoved = prevNode;
			}
			curNode = prevNode.next;
			if (prevNode.next != null) {
				do {
					if (curNode.hash == hash && 
							curNode.key == key || (key != null && curNode.key.equals(key))) {
						nodeRemoved = curNode;
						break;
					}
					prevNode = curNode;
				} while ((curNode = curNode.next) != null);
			}
			if (nodeRemoved != null) {
				if (nodeRemoved == prevNode) {
					table[index] = nodeRemoved.next;
				} else {
					prevNode.next = nodeRemoved.next;
				}
				size--;
				return nodeRemoved.value;
			}
		}
		return null;
	}
}",0,0,0,0,0,1,0,0,1
1362,"class Hashmap {
    constructor() {
      this._storage = [];
    }
    hashStr(str) {
      let finalHash = 0;
      for (let i = 0; i < str.length; i++) {
        const charCode = str.charCodeAt(i);
        finalHash += charCode;
      }
      return finalHash;
    }
    set(key, val) {
      let idx = this.hashStr(key);
      if (!this._storage[idx]) {
        this._storage[idx] = [];
      }
      this._storage[idx].push([key, val]);
    }
    get(key) {
      let idx = this.hashStr(key);
      if (!this._storage[idx]) {
        return undefined;
      }
      for (let keyVal of this._storage[idx]) {
        if (keyVal[0] === key) {
          return keyVal[1];
        }
      }
    }
  }
const m = new Hashmap();
m.set('name', 'Jake');
console.log(m.get('name'));",0,0,0,0,0,1,0,0,1
1363,"class Hashmap(object):
    def __init__(self, size=8):
        self.num_filled = 0  
        self.keys = [None] * size
        self.values = [None] * size
        self.size = size  
    @staticmethod
    def _hash(x):
        return hash(x)  
    def put(self, key, value):
        if key is None:
            raise TypeError('key cannot be None')
        index = self._hash(key) % self.size
        step = 0
        while self.keys[index] is not None and self.keys[index] != key and step < self.size - 1:
            step += 1
            index = (index + 1) % self.size
        if step == self.size - 1:
            raise Exception('all spaces occupied')  
        if self.keys[index] is None:
            self.num_filled += 1
        self.keys[index] = key
        self.values[index] = value
        if self.num_filled > self.size * 0.67:  
            self.expand()
    def get(self, key):
        index = self._hash(key) % self.size
        step = 0
        while self.keys[index] != key and step < self.size - 1:
            step += 1
            index = (index + 1) % self.size
        if step == self.size - 1:
            raise LookupError('key not found')
        return self.values[index]
    def __len__(self):
        return self.num_filled
    def __getitem__(self, key):
        return self.get(key)
    def __setitem__(self, key, value):
        self.put(key, value)
    def __contains__(self, key):
        try:
            if self.get(key):
                return True
            else:
                return False
        except LookupError:
            return False
    def __repr__(self):
        non_empty = [(k, v) for k, v in zip(self.keys, self.values) if k is not None]
        string_list = []
        for k, v in non_empty:
            string_list.append(repr(k) + ': ' + repr(v))
        return '{ ' + ', '.join(string_list) + ' }'
    def expand(self):
        old_keys, old_values = self.keys, self.values
        self.__init__(size=self.size * 2)  
        for k, v in zip(old_keys, old_values):
            if k is not None:
                self.put(k, v)
if __name__ == '__main__':
    print 'creating empty hash map...'
    hashmap = Hashmap()
    print hashmap
    print 'adding key value pairs...'
    hashmap['dog'] = '1'
    hashmap['cat'] = '2'
    hashmap['horse'] = '3'
    print hashmap
    print 'check for membership'
    print '""cat"" in hash map? ', 'cat' in hashmap
    print '""cow"" in hash map? ', 'cow' in hashmap
    print 'show that lookup is o(1)...'
    import timeit
    print 'creating hash map of 10 random keys...'
    setup = '''
import random, string
from hashmap import Hashmap
hashmap = Hashmap()
def random_string(length=10):
    return ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(length))
keys, values = map(random_string, [10] * 10), map(random_string, [5] * 10)
for k, v in zip(keys, values):
    hashmap[k] = v
    assert hashmap[k] == v
'''
    print 'time for million random lookups: ', timeit.timeit(""hashmap[random.choice(keys)]"", setup=setup)
    print 'creating hash map of 1000 random keys...'
    setup = '''
import random, string
from hashmap import Hashmap
hashmap = Hashmap()
def random_string(length=10):
    return ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(length))
keys, values = map(random_string, [10] * 1000), map(random_string, [5] * 1000)
for k, v in zip(keys, values):
    hashmap[k] = v
    assert hashmap[k] == v
'''
    print 'time for million random lookups: ', timeit.timeit(""hashmap[random.choice(keys)]"", setup=setup)",0,0,0,0,0,1,0,0,1
1364,"package com.company;
public class HashMap<T> {
    private int ARRAY_SIZE;
    private NodeLinkedList<T>[] buckets;
    int size;  
    public HashMap(int size){
        this.size = 0;
        if (size > 0){
            ARRAY_SIZE = size;
            buckets = new NodeLinkedList[ARRAY_SIZE];
        } else{
            throw new IllegalArgumentException(""Please set hash map size to be nonnegative"" + size);
        }
    }
    public boolean set(String key, T value){
        if (value == null || key == null){
            return false;
        }
        int hash = hash(key);
        if (this.load() == 1) {
            System.out.println(""You have exceeded the capacity of a hash map you declared. Use .delete() to remove elements"");
            return false;
        }
        if (buckets[hash] == null) {
            buckets[hash] = new NodeLinkedList<>();
            buckets[hash].set(key, value);
        } else {
            NodeLinkedList<T> NodeLinkedList = buckets[hash];
            NodeLinkedList.set(key, value);
        }
        return true;
    }
    public T get(String key){
        if (key == null){
            throw new IllegalArgumentException();
        }
        int hash = hash(key);
        if (buckets[hash] != null){
            return buckets[hash].get(key);
        }
        return null;
    }
    public T delete(String key) {
        if (key == null){
            throw new IllegalArgumentException();
        }
        int hash = hash(key);
        if (buckets[hash] != null) {
            return buckets[hash].delete(key);
        }
        return null;
    }
    public float load(){
        return (float) (size * 1.0 / buckets.length);
    }
    private int hash(String key){
        return Math.abs(key.hashCode() % ARRAY_SIZE);
    }
    private class NodeLinkedList<T> {
        Node<T> head;
        public Node<T> getHead() {
            return head;
        }
        public void setHead(Node<T> head) {
            this.head = head;
        }
        private boolean set(String key, T value){
            Node<T> input = new Node(key, value);
            if(head == null){
                size++;
                head = input;
            }else{
                Node<T> runner = head;
                while(runner != null){
                    if(runner.getKey().equals(key)){
                        runner.setValue(value);
                        return true;
                    }
                    runner = runner.getNext();
                }
                input.setNext(head);
                head = input;
                size++;
            }
            return true;
        }
        private T delete(String key){
            int hash = hash(key);
            Node<T> runner = head;
            if(runner.getKey().equals(key)){
                head = runner.getNext();
                size --;
                return runner.getValue();
            }
            while(runner.getNext() != null){
                Node<T> next = runner.getNext();
                if(next.getKey().equals(key)){
                    runner.setNext(next.getNext());
                    size--;
                    return next.getValue();
                }
                runner = runner.getNext();
            }
            return null;
        }
        private T get(String key){
            int hash = hash(key);
            Node<T> runner = head;
            while(runner != null){
                if(runner.getKey().equals(key)){
                    return runner.getValue();
                }
                runner = runner.getNext();
            }
            return null;
        }
    }
    private class Node<T> {
        private String key;
        private T value;
        private Node next;
        public Node(){
        }
        public Node(String key, T value){
            this.key = key;
            this.value = value;
        }
        public String getKey() {
            return key;
        }
        public void setKey(String key) {
            this.key = key;
        }
        public T getValue() {
            return value;
        }
        public void setValue(T value) {
            this.value = value;
        }
        public Node getNext() {
            return next;
        }
        public void setNext(Node next) {
            this.next = next;
        }
    }
}",0,0,0,0,0,1,0,0,1
1365,"class HashMap {
  constructor() {
    this.map = {};
  }
  hash(k) {
    return k % 10;
  }
  add(key, value) {
    let k = this.hash(key);
    if (!this.map[k]) {
      this.map[k] = [];
    }
    this.map[k].push(value);
  }
  get(key) {
    let k = this.hash(key);
    return this.map[k];
  }
}
let h = new HashMap();
h.add(10, ""hello"");
h.add(100001, ""world"");
h.add(1, ""this is a string"");
console.log(h);",0,0,0,0,0,0,0,0,1
1366,"import collections
__all__ = ['Hashmap']
MINSIZE = 8
PERTURB_SHIFT = 5
KeyValue = collections.namedtuple('KeyValue', ('key', 'value'))
class Hashmap:
    absent = object()
    def __init__(self, minsize=MINSIZE, perturb_shift=PERTURB_SHIFT):
        self._minsize = minsize
        self._perturb_shift = perturb_shift
        self._build(self._minsize)
    def __getitem__(self, key):
        _, kv_pair = self._lookup(key, self._backing)
        if kv_pair:
            return kv_pair.value
        else:
            return Hashmap.absent
    def __setitem__(self, key, value):
        i, kv_pair = self._lookup(key, self._backing)
        self._backing[i] = KeyValue(key, value)
        if kv_pair is None:
            self._used += 1
        size = len(self._backing)
        utilization = self._used/size
        if utilization > 0.67:
            self._resize(self._incr_size(size))
    def __contains__(self, key):
        _, kv_pair = self._lookup(key, self._backing)
        return kv_pair and not kv_pair.value is Hashmap.absent
    def __iter__(self):
        for kv_pair in self._backing:
            if kv_pair and not kv_pair.value is Hashmap.absent:
                yield kv_pair
    def __len__(self):
        return self._used - self._deleted
    def __delitem__(self, key):
        i, kv_pair = self._lookup(key, self._backing)
        if kv_pair and not kv_pair.value is Hashmap.absent:
            self._backing[i] = KeyValue(key, Hashmap.absent)
            self._deleted += 1
            size = len(self._backing)
            utilization = (self._used - self._deleted)/size 
            if utilization < 0.16:
                self._resize(self._decr_size(size))
        else:
            raise KeyError('no such item!')
    def _lookup(self, key, backing):
        for i in self._indices(key, len(backing)):
            value = backing[i]
            if value is None or value.key == key:
                return i, value
        assert False, 'should not reach this!'
    def _indices(self, key, size):
        j = perturb = hash(key)
        for _ in range(size):
            j %= size
            yield j
            j = 5 * j + 1 + perturb
            perturb >>= self._perturb_shift
    def _resize(self, new_size):
        if new_size != len(self._backing):
            old_backing = self._backing[:]
            self._build(new_size, old_backing)
    def _build(self, size, init=None):
        if not init:
            init = []
        self._backing = [None] * size
        self._used = 0
        self._deleted = 0
        for kv_pair in init:
            if kv_pair and not kv_pair.value is Hashmap.absent:
                self[kv_pair.key] = kv_pair.value
    def _incr_size(self, size):
        return size * 2
    def _decr_size(self, size):
        return max(self._minsize, size // 2)",0,0,0,0,0,1,0,0,1
1367,"import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
public class HashMap<K, V> implements HashMapInterface<K, V> {
    private MapEntry<K, V>[] table;
    private int size;
    public HashMap() {
        clear();
    }
    @Override
    public V add(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(""Argument cannot be null."");
        }
        if (this.getNextLoadFactor() > MAX_LOAD_FACTOR) {
            resize();
        }
        int index = this.getAddIndex(key);
        MapEntry<K, V> entry = this.table[index];
        V result = null;
        if (entry == null) {
            this.table[index] = new MapEntry<K, V>(key, value);
        } else if (entry.getKey().equals(key)) {
            if (!entry.isRemoved()) {
                result = entry.getValue();
            }
            entry.setValue(value);
            entry.setRemoved(false);
        } else {
            entry.setKey(key);
            entry.setValue(value);
            entry.setRemoved(false);
        }
        if (result == null) {
            size++;
        }
        return result;
    }
    @Override
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Argument cannot be null."");
        }
        int index = this.getAddIndex(key);
        MapEntry<K, V> entry = this.table[index];
        if (entry != null && entry.getKey().equals(key) && !entry.isRemoved()) {
            entry.setRemoved(true);
            size--;
            return entry.getValue();
        }
        return null;
    }
    @Override
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Argument cannot be null."");
        }
        int index = this.getAddIndex(key);
        MapEntry<K, V> entry = this.table[index];
        return (entry != null && !entry.isRemoved()
                && entry.getKey().equals(key) ? entry.getValue() : null);
    }
    @Override
    public boolean contains(K key) {
        return get(key) != null;
    }
    @SuppressWarnings(""unchecked"")
    @Override
    public void clear() {
        this.table = (MapEntry<K, V>[]) new MapEntry[STARTING_SIZE];
        this.size = 0;
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public Set<K> keySet() {
        HashSet<K> result = new HashSet<K>(size);
        for (int i = 0; i < this.table.length; i++) {
            MapEntry<K, V> entry = this.table[i];
            if (entry != null && !entry.isRemoved()) {
                result.add(entry.getKey());
            }
        }
        return result;
    }
    @Override
    public List<V> values() {
        ArrayList<V> result = new ArrayList<V>(size);
        for (int i = 0; i < this.table.length; i++) {
            MapEntry<K, V> entry = this.table[i];
            if (entry != null && !entry.isRemoved()) {
                result.add(entry.getValue());
            }
        }
        return result;
    }
    private double getNextLoadFactor() {
        return (double) (size + 1) / (double) this.table.length;
    }
    @SuppressWarnings(""unchecked"")
    private void resize() {
        MapEntry<K, V>[] temp = this.table;
        this.table = (MapEntry<K, V>[]) new MapEntry[temp.length * 2];
        this.size = 0;
        for (int i = 0; i < temp.length; i++) {
            MapEntry<K, V> entry = temp[i];
            if (entry != null && !entry.isRemoved()) {
                this.add(entry.getKey(), entry.getValue());
            }
        }
    }
    private int getAddIndex(K key) {
        int index = Math.abs(key.hashCode()) % this.table.length;
        MapEntry<K, V> curEntry = this.table[index];
        int firstRemoved = -1;
        int curIndex = index;
        boolean looped = false;
        while (curEntry != null && !curEntry.getKey().equals(key)
                && (!looped || curIndex != index)) {
            if (firstRemoved == -1 && curEntry.isRemoved()) {
                firstRemoved = index;
            }
            if (++curIndex >= this.table.length) {
                curIndex = 0;
                looped = true;
            }
            curEntry = this.table[curIndex];
        }
        if (curEntry != null && curEntry.getKey().equals(key)) {
            return curIndex;
        } else {
            return (firstRemoved == -1 ? curIndex : firstRemoved);
        }
    }
}",0,0,0,0,0,0,0,0,1
1368,"from linkedlist import LinkedList
class Hashmap(object):
  def __init__(self, length=100):
    listBuckets = []
    for i in range(length):
      listBuckets.append(LinkedList())
    self.buckets = listBuckets
    self.length = length
  def hashFunction(self, data):
    key = data % self.length + 1
    return key
  def insert(self, node):
    key = self.hashFunction(node.data)
    node.key = key
    pushOutput = self.buckets[key].push(node)
    return pushOutput
  def remove(self, data):
    key = self.hashFunction(data)
    removedOutput = self.buckets[key].remove(data)
    return removedOutput
  def __repr__(self):
        return '<Hashmap %r>' % self.buckets",0,0,0,0,0,0,0,0,1
1369,"package com.contactsunny.poc.HashMapImplementation.hashMap;
import com.contactsunny.poc.HashMapImplementation.exceptions.InvalidIndexException;
public class HashMap<K, V> {
    private static final int ARRAY_SIZE = 16;
    private Node<K, V>[] nodeList = new Node[ARRAY_SIZE];
    public void put(K key, V value) throws InvalidIndexException {
        long hashCode = this.getHashCode(key);
        int index = this.getIndex(hashCode);
        if (index > ARRAY_SIZE) {
            throw new InvalidIndexException(""Invalid key, please check again!"");
        }
        if (this.nodeList[index] != null) {
            Node<K, V> exitingNode = this.nodeList[index];
            while (exitingNode.getNext() != null) {
                exitingNode = exitingNode.getNext();
            }
            Node<K, V> newNode = new Node<>();
            newNode.setKey(key);
            newNode.setValue(value);
            newNode.setHashCode(hashCode);
            exitingNode.setNext(newNode);
        } else {
            Node<K, V> newNode = new Node<>();
            newNode.setKey(key);
            newNode.setValue(value);
            newNode.setHashCode(hashCode);
            this.nodeList[index] = newNode;
        }
    }
    private long getHashCode(K key) {
        String keyString = key.toString();
        return keyString.hashCode();
    }
    private int getIndex(long hashCode) {
        return Math.toIntExact(hashCode % ARRAY_SIZE);
    }
    public void printHashMap() {
        System.out.println(""=============================================="");
        System.out.println(""Printing map:"");
        int index = 0;
        while (index < ARRAY_SIZE) {
            Node<K, V> node = this.nodeList[index];
            if (node != null) {
                int listIndex = 0;
                while (node != null) {
                    if (listIndex > 0) {
                        System.out.print("" || "");
                    }
                    System.out.print(node.getKey().toString() + "" -> "");
                    System.out.print(node.getValue().toString());
                    node = node.getNext();
                    listIndex++;
                }
                System.out.println("""");
            }
            index++;
        }
        System.out.println(""=============================================="");
    }
}",0,0,0,0,0,0,0,0,0
1370,"class HashMap:
  def __init__(self):
    self.size = 11
    self.data = [None] * self.size
  def hashing_function(self, key):
    hash_val = key % self.size
    return hash_val
  def put(self, key, data):
    hash = self.hashing_function(key)
    if self.data[hash] == None:
      self.data[hash] = [[key, data]]
      return self.data
    elif self.data[hash] != None:
      sub_list = []
      old_val = []
      old_val = self.data[hash]
      for i in old_val:
        sub_list.append(i)
      if sub_list[0][0] == key:
        sub_list[0][1] = data
      else:
        sub_list.append([key, data])
        self.data[hash] = sub_list
      return self.data
  def get(self, key):
    hash = self.hashing_function(key)
    if self.data[hash] == -1:
      return False
    else:
      if self.data[hash] != None:
        for i in self.data[hash]:
          for j in i:
            if j == key:
              return i[1]
      else:
        return False
  def remove(self, key):
    hash = self.hashing_function(key)
    if self.data[hash] == None:
      return False
    else:
      for i in xrange(len(self.data[hash])):
        if key in self.data[hash][i]:
          del self.data[hash][i]
          print self.data
          return True
    return False
  def has(self, key):
    hash = self.hashing_function(key)
    if self.data[hash] == None:
      return False
    elif self.data[hash] != None:
      val = self.data[hash]
      for i in val:
        if key in i:
          return True
      return False
  def sizeof(self):
    tot_len = 0
    for i in self.data:
      if i != None:
        l = len(i)
        tot_len = tot_len + l
    return tot_len",0,0,0,0,0,1,0,0,1
1371,"import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.LinkedList;
public class HashMap<K, V> implements HashMapInterface<K, V> {
    private LinkedList<MapEntry<K, V>>[] backingTable;
    private int size;
    public HashMap() {
        backingTable = new LinkedList[INITIAL_CAPACITY];
        size = 0;
    }
    public HashMap(int initialCapacity) {
        backingTable = new LinkedList[initialCapacity];
        size = 0;
    }
    @Override
    public V put(K key, V value) {
        if (key == null || value == null) {
            throw new IllegalArgumentException(""Input data cannot be null."");
        }
        if ((double) (size + 1) / backingTable.length > MAX_LOAD_FACTOR) {
            resizeBackingTable(backingTable.length * 2 + 1);
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        if (backingTable[index] == null) {
            backingTable[index] = new LinkedList<>();
        } else {
            for (MapEntry<K, V> temp : backingTable[index]) {
                if (temp.getKey() == key) {
                    V returnValue = temp.getValue();
                    temp.setValue(value);
                    return returnValue;
                }
            }
        }
        backingTable[index].addFirst(new MapEntry<>(key, value));
        ++size;
        return null;
    }
    @Override
    public V remove(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Input key is null"");
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        MapEntry<K, V> curr;
        if (backingTable[index] != null) {
            Iterator<MapEntry<K, V>> it = backingTable[index].iterator();
            while (it.hasNext()) {
                curr = it.next();
                if (curr.getKey() == key) {
                    V returnValue = curr.getValue();
                    it.remove();
                    --size;
                    return returnValue;
                }
            }
        }
        throw new java.util.NoSuchElementException(""Key does not exist"");
    }
    @Override
    public V get(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Input key is null"");
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        MapEntry<K, V> curr;
        if (backingTable[index] != null) {
            Iterator<MapEntry<K, V>> it = backingTable[index].iterator();
            while (it.hasNext()) {
                curr = it.next();
                if (curr.getKey() == key) {
                    return curr.getValue();
                }
            }
        }
        throw new java.util.NoSuchElementException(""Key does not exist"");
    }
    @Override
    public boolean containsKey(K key) {
        if (key == null) {
            throw new IllegalArgumentException(""Input key is null"");
        }
        int index = Math.abs(key.hashCode()) % backingTable.length;
        MapEntry<K, V> curr;
        if (backingTable[index] != null) {
            Iterator<MapEntry<K, V>> it = backingTable[index].iterator();
            while (it.hasNext()) {
                curr = it.next();
                if (curr.getKey() == key) {
                    return true;
                }
            }
        }
        return false;
    }
    @Override
    public void clear() {
        backingTable = new LinkedList[INITIAL_CAPACITY];
        size = 0;
    }
    @Override
    public int size() {
        return size;
    }
    @Override
    public Set<K> keySet() {
        Set<K> returnSet = new HashSet<>();
        for (int i = 0; i < backingTable.length; ++i) {
            if (backingTable[i] != null) {
                for (MapEntry<K, V> temp : backingTable[i]) {
                    returnSet.add(temp.getKey());
                }
            }
        }
        return returnSet;
    }
    @Override
    public List<V> values() {
        List<V> returnList = new ArrayList<>();
        for (int i = 0; i < backingTable.length; ++i) {
            if (backingTable[i] != null) {
                for (MapEntry<K, V> temp : backingTable[i]) {
                    returnList.add(temp.getValue());
                }
            }
        }
        return returnList;
    }
    @Override
    public void resizeBackingTable(int length) {
        if (length <= 0) {
            throw new IllegalArgumentException(""Input length cannot be ""
                    + ""negative"");
        }
        LinkedList<MapEntry<K, V>>[] tempTable = new LinkedList[length];
        for (int i = 0; i < backingTable.length; ++i) {
            if (backingTable[i] != null) {
                for (MapEntry<K, V> temp : backingTable[i]) {
                    int index = Math.abs(temp.getKey().hashCode()) % length;
                    if (tempTable[index] == null) {
                        tempTable[index] = new LinkedList<>();
                    }
                    tempTable[index].addFirst(temp);
                }
            }
        }
        backingTable = tempTable;
    }
    @Override
    public LinkedList<MapEntry<K, V>>[] getTable() {
        return backingTable;
    }
}",0,0,0,0,0,1,0,0,1
1372,"from __future__ import division
class hashMap:
	def __init__(self, size):
		self.size = size
  global hashArray
  global count
  count = 0
  hashArray = [None] * size
 def string_hashcode(self,s):
		h = 0
  for c in s:
			h = (31 * h + ord(c)) & 0xFFFFFFFF
  return ((h + 0x80000000) & 0xFFFFFFFF) - 0x80000000
 def getSize(self):
		return self.size
 def set(self,key,value):
		length = self.size
  k = key
  v = value
  tup = (k,v)
  global hashArray
  global count
  h = self.string_hashcode(k)
  if( hashArray[self.hashFun1(h)] == None ):
			hashArray[self.hashFun1(h)] = tup
   count += 1
   return True
  else:
			for i in range(length):
				if( hashArray[self.hashFun2(h,i)] == None ):
					hashArray[self.hashFun2(h,i)] = tup
     count += 1
     return True
    else:
					continue
 def get(self,key):
		length = self.size
  k = key
  h = self.string_hashcode(k)
  if( hashArray[self.hashFun1(h)] != None ):
			if ( hashArray[self.hashFun1(h)][0] == k ):
				return hashArray[self.hashFun1(h)][1]
  else:
			for i in range(length):
				if( hashArray[self.hashFun2(h,i)] != None ):
					if( hashArray[self.hashFun2(h,i)][0] == k ):
						return hashArray[self.hashFun2(h,i)][1]
     else:
						continue
   return None
 def delete(self,key):
		length = self.size
  k = key
  h = self.string_hashcode(k)
  global count
  if( hashArray[self.hashFun1(h)] != None ):
			if ( hashArray[self.hashFun1(h)][0] == k ):
				temp = hashArray[self.hashFun1(h)][1]
    hashArray[self.hashFun1(h)] = None
    count -= 1
    return temp
  else:
			for i in range(length):
				if( hashArray[self.hashFun2(h,i)] != None ):
					if( hashArray[self.hashFun2(h,i)][0] == k ):
						temp =  hashArray[self.hashFun2(h,i)][1]
      hashArray[self.hashFun2(h,i)] = None
      count -= 1
      return temp
     else:
						continue
   return None
 def printMap(self):
		length = self.size
  for i in range(length):
			if (hashArray[i] != None):
				print hashArray[i]
    print """"
   else:
				continue
 def load(self):
		a = self.getCount() / self.size
  return a
 def getCount(self):
		self.count = count
  return count
 def hashFun1(self,num):
		return num % self.size
 def hashFun2(self,num,i):
		R = 31
  return (self.hashFun1(num) + i*(R-num%R)) % self.size",0,0,0,0,0,1,0,0,1
1373,"package com.halilcanm;
public class HashMap<K,V> {
    private Entry<K,V>[] table;
    private int size = 16;  
    static class Entry<K, V> {
        K key;
        V value;
        Entry <K, V> next;
        public Entry(K key, V value, Entry<K,V> next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    public HashMap(int initSize) {
        this.size = initSize;
        table = new Entry[size];
    }
    private int hashKey (K key) {
        return Math.abs(key.hashCode()) % size;
    }
    public boolean set (K key, V value) {
        if (key == null) {
            return false;
        }
        int hash = hashKey(key);
        Entry<K,V> newEntry = new Entry<K,V>(key, value, null);
        if(table[hash] == null) {
            table[hash] = newEntry;
        } else {
            Entry<K,V> previous = null;
            Entry<K,V> current = table[hash];
            while(current != null) {
                if (current.key.equals(key)) {
                    if(previous == null) {
                        newEntry.next = current.next;
                        table[hash] = newEntry;
                        return true;
                    } else {
                        newEntry.next = current.next;
                        previous.next = newEntry;
                        return true;
                    }
                }
                previous = current;
                current = previous.next;
            }
            previous.next = newEntry;
        }
        return false;
    }
    public V get(K key){
        int hash = hashKey(key);
        if(table[hash] == null) {
            return null;
        } else {
            Entry<K,V> scroll = table[hash];
            while(scroll != null) {
                if(scroll.key.equals(key)) {
                    return scroll.value;
                }
                scroll = scroll.next;
            }
            return null;
        }
    }
    public boolean delete(K key) {
        int hash = hashKey(key);
        if (table[hash] == null) {
            return false;
        } else {
            Entry<K,V> previous = null;
            Entry<K,V> current = table[hash];
            while (current != null) {
                if (current.key.equals(key)) {
                    if (previous == null) {
                        table[hash] = table[hash].next;
                        return true;
                    } else {
                        previous.next = current.next;
                        return true;
                    }
                }
            }
        }
        return false;
    }
    public float load() {
        float totalSize = (float)size;
        float fullBuckets = 0f;
        for (int i = 0; i < size; i++) {
            if (table[i] != null) {
                fullBuckets += 1.0f;
            }
        }
        return fullBuckets/totalSize;
    }
    public void quickDraw() {
        for (int i = 0; i < size; i++) {
            System.out.print("" Bucket# = "" + i + "" "");
            if (table[i] != null) {
                Entry<K,V> previous = null;
                Entry<K,V> current = table[i];
                while (current != null) {
                    System.out.print(""-{"" + current.key + ""="" + current.value + ""}"");
                    previous = current;
                    current = current.next;
                }
            }
            System.out.println();
        }
        System.out.println();
        System.out.println(""Note: The implementation accepts any primitive data type for both K or V"");
    }
}",0,0,0,0,0,1,0,0,1
1374,"class HashMap(object):
 def __init__(self, size,probing='quadratic',verbose=False):
  if probing not in ['linear','quadratic']:
			raise ValueError('probing can only be linear or quadratic not %s'%probing)
  self.size = size
  self.probing = probing
  self.ctr = 1
  self.values = [None] * self.size
  self.keys = [None] * self.size
  self.verbose = verbose
 def reset(self):
  self.ctr = 1
  self.values = [None] * self.size
  self.keys = [None] * self.size
 def hash_index(self,key):
  _hash = key.__hash__()
  _idx = _hash & (self.size - 1) 
  return _idx
 def sanity_check_key(self,key):
  if not isinstance(key,str):
			raise ValueError('Key should be of type string')
 def probe(self,old_idx):
  if self.probing == 'linear':
			new_idx = (old_idx + self.ctr) % self.size
   self.ctr += 1
  if self.probing == 'quadratic':
			new_idx = (old_idx + self.ctr ** 2) % self.size
   self.ctr += 1
  return new_idx
 def set(self,key,value):
  if self.probing == 'quadratic':
			if self.load() > 0.45: 
				if self.verbose:
					print('Overflow!')
    return False
  if self.probing == 'linear':
			if self.load() == 1: 
				if self.verbose:
					print('Overflow!')
    return False
  self.sanity_check_key(key)
  _idx = self.hash_index(key)
  if self.verbose:
			print('for key=%s Hashed_index = %d'%(key,_idx))
  if self.keys[_idx] == None or self.keys[_idx] == key:
			if self.verbose:
				print('set key=%s, value=%s, at _idx=%d'%(key,value,_idx))
   self.keys[_idx] = key
   self.values[_idx] =  value
   return True
  else:
			while(True):
				if self.verbose:
					print('%d already occupied, probing...'%(_idx,))
    _temp_idx = self.probe(_idx)
    if self.verbose:
					print(_temp_idx)
    if self.keys[_temp_idx] == None or self.keys[_temp_idx] == key:
					if self.verbose:
						print('set key=%s, value=%s, at _temp_idx=%d'%(key,value,_temp_idx))
     self.keys[_temp_idx] = key
     self.values[_temp_idx] = value
     self.ctr = 1
     return True
 def get(self,key,return_idx = False):
  if key in self.keys:
			self.sanity_check_key(key)
   _idx = self.hash_index(key)
   if self.verbose:
				print('key=%s, hash_index=%d'%(key,_idx))
   if self.keys[_idx] == key:
				if self.verbose:
					print(""(without probing) key = %s found at %d with value %s""%(key,_idx,self.values[_idx]))
    if return_idx:
					return self.values[_idx],_idx
    else:
					return self.values[_idx]
   else:
				while(True):
					_temp_idx = self.probe(_idx)
     if self.verbose:
						print('key=%s probing %d to %d'%(key,_idx,_temp_idx))
     if self.keys[_temp_idx] == key:
						if  self.verbose:
							print(""(After probing)key = %s found at %d with value %s""%(key,_temp_idx,self.values[_temp_idx]))
      self.ctr = 1
      if return_idx:
							return self.values[_temp_idx],_temp_idx
      else:
							return self.values[_temp_idx]
  else:
			raise KeyError(""could'nt find key! '%s'""%key)
 def delete(self,key):
  _,_idx = self.get(key,return_idx=True)
  self.keys[_idx] = None
  self.values[_idx] = None
 def load(self):
  not_none_values = sum(x is not None for x in self.values)
  return not_none_values / self.size",0,0,0,0,0,1,0,0,1
1375,"public class HashMap {
    public static void main(String[] args) {
        java.util.HashMap<Integer, String> hashMapOfString = new java.util.HashMap<Integer, String>();
        hashMapOfString.put(1, ""number one"");
        hashMapOfString.put(2, ""number two"");
        hashMapOfString.put(3, ""number three"");
        System.out.println(hashMapOfString);
        hashMapOfString.put(3, ""number threeeeee"");
        System.out.println(hashMapOfString);
        hashMapOfString.remove(1);
        System.out.println(hashMapOfString);
        System.out.println(""2 -> "" + hashMapOfString.get(2));
    }
}",0,0,0,0,0,0,0,0,0
1376,"class HashMap:
    def __init__(self, capacity):
        self.length = 0
        self.capacity = capacity
        self.HashMap = [None] * self.capacity
    def add(self, key, value):
        threshhold = self.capacity * 0.75
        if self.length >= threshhold:
            self._increase_size()
        hashkey = self._gethash(key)
        if not self.HashMap[hashkey]:
            value_to_store = [key, value]
            self.HashMap[hashkey] = value_to_store
            self.length += 1
        elif self.HashMap[hashkey] and key not in self.HashMap[hashkey]:
            self.HashMap[hashkey].extend([key, value])
            self.length += 1
        else:
            self.HashMap[hashkey] = [key, value]
    def get(self, key):
        hashkey = self._gethash(key)
        if type(self.HashMap[hashkey]) is list:
            if len(self.HashMap[hashkey]) > 2:
                idx = self._find_if_hashclash(key, hashkey, ""v"")
                if idx is not None:
                    return self.HashMap[hashkey][idx]
            elif self.HashMap[hashkey][0] == key:
                return self.HashMap[hashkey][1]
    def remove(self, key):
        thekey = self._gethash(key)
        if self.HashMap[thekey] is not None:
            if len(self.HashMap[thekey]) == 2:
                self.HashMap[
                    self._gethash(key)
                ] = None  
            else:
                hashkey = self._gethash(key)
                idx = self._find_if_hashclash(key, hashkey, ""i"")
                self.HashMap[hashkey].pop(idx)
                self.HashMap[hashkey].pop(idx)
            self.length -= 1
    def size(self):
        return self.length
    def _find_if_hashclash(self, key, location, key_or_value):
        idx = (
            self.HashMap[location].index(key) if key in self.HashMap[location] else None
        )
        if idx is not None:
            if key_or_value == ""v"":
                return idx + 1
            else:
                return idx
    def _gethash(self, invalue):
        return hash(invalue) % self.capacity
    def _increase_size(self):
        keys_vals_to_move = [item for item in self.HashMap if item]
        self.length = 0
        self.capacity = self.capacity * 2
        self.HashMap = [None] * self.capacity
        for item in keys_vals_to_move:
            while len(item) > 0:
                self.add(item[0], item[1])
                item.pop(0)
                item.pop(0)
    def __str__(self):
        return ""scapacity of hash: {}, current size of hash: {}"".format(
            self.capacity, self.length
        )
    def __repr__(self):
        return ""capacity of hash: {}, current size of hash: {}"".format(
            self.capacity, self.length
        )
    def __getitem__(self, key):
        return self.get(key)
    def __setitem__(self, key, val):
        return self.add(key, val)",0,0,0,0,0,0,0,0,1
1377,"def get_hashcode(string):
    h = 0
    for c in string:
        h = (31 * h + ord(c)) & 0xFFFFFFFF
    return ((h + 0x80000000) & 0xFFFFFFFF) - 0x80000000
class Node():
    def __init__(self):
        self.key = None
        self.value = None
        self.next = None
    def getKey(self):
        return self.key
    def getValue(self):
        return self.value
    def setKey(self, key):
        self.key = key
    def setValue(self, value):
        self.value = value
    def set_next(self, node):
        self.next = node
    def get_next(self):
        return self.next
class HashMap():
    def __init__(self, size):
        self.bucket_size = size
        self.bucket = [Node() for i in range(size)]
    def set(self, key, value):
        hash_val = get_hashcode(key) % self.bucket_size
        new_node = Node()
        new_node.setKey(key)
        new_node.setValue(value)
        if(self.bucket[hash_val].getKey() == None ):
            self.bucket[hash_val] = new_node
        else:
            current_node = self.bucket[hash_val]
            while(current_node.get_next() != None):
                if(current_node.getKey() == new_node.getKey()):
                    current_node.setValue(new_node.getValue())
                    return True
                current_node = current_node.next
            current_node.set_next(new_node)
            return True
    def get(self, key):
        hash_val = get_hashcode(key) % self.bucket_size
        node = self.bucket[hash_val]
        while(node.getKey() != None):
            if(node.getKey() == key):
                return node.getValue()
            node = node.next
        return None
    def delete(self, key):
        hash_val = get_hashcode(key) % self.bucket_size
        if(self.bucket[hash_val].getKey() == key ):
            self.bucket[hash_val].setKey(None)
            self.bucket[hash_val].setValue(None)
            return True
        else:
            current_node = self.bucket[hash_val]
            while(current_node.get_next() != None):
                tmp_node = current_node.next
                if(tmp_node.getKey() == key):
                    current_node.set_next(tmp_node.next)
                    return True
                current_node = current_node.next
            return False
    def load(self):
        count = 0
        for node in self.bucket:
            if node.getKey() is not None:
                count += 1
        return float(count) / self.bucket_size
obj = HashMap(20)
obj.set(""lakshya"", 10) 
obj.set(""kpcb"" , 20)
obj.set(""coding"" , 15)
print obj.get(""kpcb"")
obj.delete(""coding"")
print obj.load()",0,0,0,0,0,1,0,0,1
1378,"package org.epalrov.collections;
import java.util.Map;
import java.util.Set;
import java.util.Collection;
import java.util.Iterator;
public class HashMap<K,V>  implements Map<K,V>
{
	private Entry[] table;
	private int size;
	public HashMap(int capacity) {
		if (capacity <= 0)
			throw new IllegalArgumentException(
				""Illegal capacity: "" + capacity);
		table = new Entry[capacity];
		size = 0;
	}
	public HashMap() {
		this(16);
	}
	public HashMap(Map<? extends K, ? extends V> m) {
		throw new UnsupportedOperationException();	
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0 ? true : false;
	}
	public V get(Object key) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		for (Entry<K,V> e = table[index]; e != null; e = e.next) {
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key)))) {
				return e.value;
			}
		}
		return null;
	}
	public boolean containsKey(Object key) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		for (Entry<K,V> e = table[index]; e != null; e = e.next)
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key))))
				return true;
		return false;
	}
	public boolean containsValue(Object value) {
		for (int index = 0; index < table.length; index++)
			for (Entry<K,V> e = table[index]; e != null; e = e.next)
				if (value == e.value ||
				   (value != null && value.equals(e.value)))
					return true;
		return false;
	}
	public V put(K key, V value) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		for (Entry<K,V> e = table[index]; e != null; e = e.next) {
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key)))) {
				V oldValue = e.value;
				e.value = value;
				return oldValue;
			}
		}
		Entry<K,V> e = new Entry(hash, key, value, table[index]);
		table[index] = e;
		size++;
		return null;
	}
	public void putAll(Map<? extends K, ? extends V> m) {
		if (m.size() == 0)
			return;
		for (Iterator<? extends Map.Entry<? extends K, ? extends V>> i =
				m.entrySet().iterator(); i.hasNext(); ) {
			Map.Entry<? extends K, ? extends V> e = i.next();
			put(e.getKey(), e.getValue());
		}
	}
	public V remove(Object key) {
		int hash = key == null ? 0 : key.hashCode();
		int index = key == null ? 0 : hash % table.length;
		Entry<K,V> p = table[index];
		for (Entry<K,V> e = table[index]; e != null; e = e.next) {
			if (hash == e.hash && (key == e.key ||
			   (key != null && key.equals(e.key)))) {
				if (p == e)
					table[index] = e.next;
				else
					p.next = e.next;
                		size--;
				return e.value;
			}
			p = e;
		}
		return null;
	}
	public void clear() {
		for (int index = 0; index < table.length; index++)
			table[index] = null;
		size = 0;
	}
	static class Entry<K,V> implements Map.Entry<K,V> {
        	final int hash;
		final K key;
		V value;
	        Entry<K,V> next;
		Entry(int h, K k, V v, Entry<K,V> n) {
			hash = h;
			key = k;
			value = v;
			next = n;
		}
		public K getKey() {
			return key;
		}
		public V getValue() {
			return value;
		}
		public V setValue(V v) {
			V val = value;
            		value = v;
            		return val;
		}
		public boolean equals(Object o) {
			if (o == this)
				return true;
			if (!(o instanceof Map.Entry))
				return false;
			K k1 = getKey();
			V v1 = getValue();
			K k2 = ((Entry<K,V>)o).getKey();
			V v2 = ((Entry<K,V>)o).getValue();
			if ((k1 == k2 || (k1 != null && k1.equals(k2))) &&
				(v1 == v2 || (v1 != null && v1.equals(v2))))
					return true;
			return false;
		}
		public int hashCode() {
			 return (key == null ? 0 : key.hashCode()) ^
				(value == null ? 0 : value.hashCode());
		}
	}
	public Set<K> keySet() {
		return new KeySet();
	}
	private class KeySet extends java.util.AbstractSet<K> {
		public int size() {
			return size;
		}
		public Iterator<K> iterator() {
			return new KeySetIterator();
		}
	}
	private class KeySetIterator extends HashIterator<K> {
		public K next() {
			return nextEntry().getKey();
		}
	}
	public Collection<V> values() {
		return new Values();
	}
	private class Values extends java.util.AbstractCollection<V> {
		public int size() {
			return size;
		}
		public Iterator<V> iterator() {
			return new ValuesIterator();
		}
	}
	private class ValuesIterator extends HashIterator<V> {
		public V next() {
			return nextEntry().getValue();
		}
	}
	public Set<Map.Entry<K,V>> entrySet() {
		return new EntrySet();
	}
	private class EntrySet extends java.util.AbstractSet<Map.Entry<K,V>> {
		public int size() {
			return size;
		}
		public Iterator<Map.Entry<K,V>> iterator() {
			return new EntrySetIterator();
		}
	}
	private class EntrySetIterator extends HashIterator<Map.Entry<K,V>> {
		public Map.Entry<K,V> next() {
			return nextEntry();
		}
	}
	private abstract class HashIterator<T> implements Iterator<T> {
		private int index;	
		private Entry<K,V> currEntry;
		private Entry<K,V> nextEntry;
		public HashIterator() {
			index = 0;
			currEntry = null;
			nextEntry = null;
			for ( ; index < table.length; index++)
				if (table[index] != null)
					nextEntry = table[index];
		}
		public boolean hasNext() {
			return nextEntry != null ? true : false;
		}
		public abstract T next();
		public Entry<K,V> nextEntry() {
			currEntry = nextEntry;
			if (nextEntry.next != null) {
				nextEntry = nextEntry.next;
			} else {
				nextEntry = null;
				for ( ; index < table.length; index++)
					if (table[index] != null)
						nextEntry = table[index];
			}
			return currEntry;
		}
		public void remove() {
			HashMap.this.remove(nextEntry.getKey());
		}
	}
	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof Map))
			return false;		
		Map<K,V> m = (Map<K,V>)o;
		if (m.size() != size)
			return false;
		Set<Map.Entry<K,V>> s = entrySet();
		for (Iterator<Map.Entry<K,V>> i = s.iterator(); i.hasNext(); ) {
			Map.Entry<K,V> e = i.next();
			K key = e.getKey();
			V value = e.getValue();
			if (!m.containsKey(key))
				return false;
			if (!value.equals(m.get(key)))
				return false;
		}
		return true;
	}
	public int hashCode() {
		int hash = 0;
		Set<Map.Entry<K,V>> s = entrySet();
		for (Iterator<Map.Entry<K,V>> i = s.iterator(); i.hasNext(); )
			hash += i.next().hashCode();
		return hash;
	} 
}",0,0,0,0,0,1,0,0,1
1379,"import random
import string
class HashMap(object):
    def __init__(self):
        self._values = [None for item in xrange(256)] 
        self._keys = [] 
    def __getitem__(self,key):
        if self._values[self.hashfunc(key)] is not None: 
            return self._values[self.hashfunc(key)] 
        else:
            return self.__missing__(key) 
    def __setitem__(self,key,value):
        if value is None: 
            raise ValueError('None is not permitted as a value.') 
        if self._values[self.hashfunc(key)] is None: 
            self._keys.append(key) 
            self._values[self.hashfunc(key)] = value 
            if float(len(self._keys))/len(self._values) > 0.1: 
                self.__resize__()
        else: 
            if key in self._keys: 
                self._values[self.hashfunc(key)] = value 
            else:
                self.__resize__() 
                self.__setitem__(key,value) 
    def __missing__(self,not_key):
        raise KeyError('{0} is not a valid key'.format(not_key))
    def __repr__(self):
        list_repr = ['{0}:{1}'.format(key, self._values[self.hashfunc(key)]) for key in self._keys]
        return 'HashMap({0})'.format(list_repr)
    def __contains__(self,key):
        if key in self._keys:
            return True
        else:
            return False
    def __len__(self):
        return len(self._keys)
    def __iter__(self):
        return (key for key in self._keys)
    def hashfunc(self,key):
        return hash(key) % len(self._values)
    def __resize__(self,**kwargs):
        old_values = kwargs.get('values',[self._values[self.hashfunc(key)] for key in self._keys])
        self._values = [None for item in xrange(2*len(self._values))]
        for key, value in zip(self._keys,old_values):
            if self._values[self.hashfunc(key)] is None: 
                self._values[self.hashfunc(key)] = value
            else: 
                self.__resize__(values = old_values)
if __name__ == '__main__':
    s = HashMap()
    print(s)
    s['Hello'] = 'World'
    s['Lettuce'] = 'orange' 
    print(s)
    for key in s: 
        print(key, s[key])
    if 'Lettuce' in s: 
        print(""Thanks!"")
    s['Hellow'] = ""WORLD!"" 
    print(s) ",0,0,0,0,0,0,0,0,1
1380,"from linklist import LinkList
class HashMap:
    def __init__(self, size=100):
        self._entry_count = 0
        self._entry_load_limit = 1
        self._size = size
        self._buckets = [None] * self._size
    def _get_load_ratio(self):
        return self._entry_count / self._size
    def put(self, key, value):
        self._entry_count += 1
        if self._get_load_ratio() >= self._entry_load_limit:
            self._resize_bucket_list()
            self.put(key, value)
        else:
            bucket_index = self._calculate_bucket_index(key)
            if self._buckets[bucket_index] is None:
                self._buckets[bucket_index] = self._new_hash_entry(key, value)
            else:
                self._update_bucket_entries(bucket_index, key, value)
    def _resize_bucket_list(self):
        new_bucket_size = self._entry_count * 2
        new_bucket = [None] * new_bucket_size
        for entry_list in self._buckets:
            if entry_list is None:
                continue
            current_node = entry_list.first_node
            while current_node is not None:
                self._rehash_entries(current_node, new_bucket, new_bucket_size)
                current_node = current_node.next
        self._buckets = new_bucket
        self._size = new_bucket_size
    def _rehash_entries(self, current_node, new_bucket, new_buket_size):
        hash_key = hash(current_node.key)
        rehashed_index = hash_key % new_buket_size
        if new_bucket[rehashed_index] is None:
            new_bucket[rehashed_index] = self._new_hash_entry(current_node.key, current_node.value)
        else:
            self._update_bucket_entries(rehashed_index, current_node.key, current_node.value)
    def get(self, key):
        bucket_index = self._calculate_bucket_index(key)
        current_node = self._buckets[bucket_index].first_node
        while current_node.next is not None:
            current_node = current_node.next
        return current_node.value if current_node else None
    def _calculate_bucket_index(self, key):
        return hash(key) % self._size
    @staticmethod
    def _new_hash_entry(key, value):
        bucket_list = LinkList()
        bucket_list.add_node(key, value)
        return bucket_list
    def _update_bucket_entries(self, bucket_index, key, value):
        value_list = self._buckets[bucket_index]
        if value_list.contains_value(value):
            return
        else:
            value_list.add_node(key, value)
    def remove(self, key):
        bucket_index = self._calculate_bucket_index(key)
        current_link_list = self._buckets[bucket_index]
        current_link_list.delete_node_with_key(key)
    def size(self):
        return self._entry_count
    def clear(self):
        self.__init__()
    def contains(self, key):
        bucket_index = self._calculate_bucket_index(key)
        current_list = self._buckets[bucket_index]
        return current_list.contains_key(key)",0,0,0,0,0,0,0,0,1
1381,"from types import *
class hashmap(object):
    def __init__(self, size):
        if not(type(size) is IntType):
            raise TypeError('Size must be an int')
        if size < 1:
            raise ValueError('Invalid HashMap size')
        buckets = 1
        while buckets < size:
            buckets <<= 1
        self.size = size
        self.buckets = buckets
        self.items = 0
        self.hashmap = [[] for i in xrange(buckets)]
    """""" 
        Set
        Inserts a key/value pair into the hashmap. Deals with collisions
        by using separate chaining. If a key is already in the hashmap,
        the value is overwritten and the number of items is not incremented.
        Returns False if hashmap is full
        Returns True if key/value pair is successfully added
    """"""
    def set(self, key, value):
        if self.items == self.size:
            return False
        else:
            bucket = self.hashmap[key.__hash__() % self.buckets]
            for idx, (k, v) in enumerate(bucket):
                if k == key:
                    bucket[idx] = (key, value) 
                    return True
            bucket.append((key, value))
            self.items += 1
            return True
    """"""
        Get
        Gets the value associated with the key that is stored in the hashmap
        Returns the value if the key is in the hashmap.
        Returns None if the key is not in the hashmap or the value is not set.
    """"""
    def get(self, key):
        for k, v in self.hashmap[key.__hash__() % self.buckets]:
            if k == key:
                return v
        return None
    """"""
        Delete
        Deletes the value associated with a key in a hashmap
        Returns the value if the key was in the hashmap with a value.
        Returns None if the key was not in the hashmap or had no value
    """"""
    def delete(self, key):
        bucket = self.hashmap[key.__hash__() % self.buckets]
        for idx, (k, v) in enumerate(bucket):
            if k == key:
                bucket[idx] = (k, None)
                return v
        return None
    """"""
        Load
        Returns the load factor of the hashmap
    """"""
    def load(self):
        return float(self.items) / self.buckets",0,0,0,0,0,1,0,0,1
1382,"from arrays import Array
class HashMap:
    UNUSED = None
    EMPTY = _MapEntry( None, None)
    def __init__( self):
        self._table = Array(7)
        self._count = 0
        self._maxCount = len(self._table) - (len(self._table) // 3)
    def __len__(self):
        return self._count
    def __contains__(self, key):
        slot = self._findSlot(key, False)
        return slot is not None
    def add(self, key, value):
        if key in self:
            slot = self._findSlot(key, False)
            self._table[slot].value = value
            return False
        else:
            slot = self._findSlot(key, True)
            self._table[slot] = _MapEntry(key, value)
            self._count += 1
            if self._count == self._maxCount:
                self._rehash()
            return True
    def valueOf(self, key):
        slot = self._findSlot(key, False)
        assert slot is not None, ""Invalid map key""
        return self._table[slot].value
    def remove(self, key):
        slot = self._findSlot(key, False)
        if slot is not None:
            self._table[slot] = EMPTY
            self._count -= 1
            return True
        return False
    def __iter__(self):
        return self
    def __next__(self):
        pass
    def _findSlot(self, key, forInsert):
        slot = self._hash1(key)
        step = self._hash2(key)
        M = len(self._table)
        while self._table[slot] is not UNUSED:
            if forInsert and                (self._table[slot] is EMPTY):
                return slot
            elif not forInsert and                (self._table[slot] is not EMPTY and self._table[slot].key == key):
                return slot
            else:
                slot = (slot + step) % M
        if forInsert and self._table[slot] is UNUSED:
            return slot
    def _rehash(self):
        origTable = self._table
        newSize = len(self._table) * 2 + 1
        self._table = Array(newSize)
        self._count = 0
        self._maxCount = newSize - (newSize // 3)
        for entry in origTable:
            if entry is not UNUSED and entry is not EMPTY:
                slot = self._findSlot(entry.key, True)
                self._count += 1
                self._table[slot] = entry
    def _hash1(self, key):
        return abs(hash(key)) % len(self._table)
    def _hash2(self, key):
        return 1 + abs(hash(key)) % (len(self._table) - 2)
    def tableSize(self):
        return len(self._table)
    def getTable(self):
        return self._table
class _MapEntry:
    def __init__( self, key, value):
        self.key = key
        self.value = value
class _HashMapIter:
    def __init__(self, hashMap):
        self.hashMap = hashMap
        self.idx = 0
    def __next__(self):
        table = self.hashMap.getTable()
        while self.idx < len(table):
            if table[self.idx] is not UNUSED or table[self.idx] is not EMPTY:
                self.idx += 1
                return table[self.idx - 1].key
            self.idx += 1
        raise StopIteration",0,0,0,0,0,0,0,0,1
1383,"import math
import xxhash
class HashMap:
    def __init__(self, size=32, load_factor=0.75, grow=True):
        self.table = [EntryList() for _ in range(size)]
        self.nentries = 0
        self.load_factor = load_factor
        self.grow = grow
    def put(self, k, v):
        bkt_idx = self._get_bucket_idx(k, len(self.table))
        self.table[bkt_idx].append(k, v)
        self.nentries += 1
        if self.grow and self._comput_load_factor() > self.load_factor:
            self._grow()
    def get(self, k):
        bkt_idx = self._get_bucket_idx(k, len(self.table))
        for entry in self.table[bkt_idx]:
            if entry.key == k:
                return entry.value
    def _comput_load_factor(self):
        return self.nentries / (3 * len(self.table))
    def _get_bucket_idx(self, k, size):
        return xxhash.xxh64(k).intdigest() % size
    def _grow(self):
        newsize = len(self.table) * 2
        new_table = [EntryList() for _ in range(newsize)]
        for bucket in self.table:
            for e in bucket:
                bucket_idx = self._get_bucket_idx(e.key, newsize)
                new_table[bucket_idx].append(e.key, e.value)
        self.table = new_table
class LinearHashMap(HashMap):
    def __init__(self, size=32, load_factor=0.75):
        super().__init__(size, load_factor)
        self.i = int(math.log2(size))
        self.split_idx = 0
    def _grow(self):
        split_idx = self.split_idx
        self.split_idx += 1
        old_bucket = self.table[split_idx]
        new_bucket = EntryList()
        self.table.append(new_bucket)
        if len(self.table) > (1 << self.i):
            self.i += 1
        if self.split_idx * 2 == len(self.table):
            self.split_idx = 0
        prev_e = old_bucket
        for e in old_bucket:
            new_bucket_id = self._get_bucket_idx(e.key, len(self.table))
            if new_bucket_id != split_idx:
                new_bucket.append(e.key, e.value)
                prev_e.next = e.next
            else:
                prev_e = e
    def _get_bucket_idx(self, k, size):
        h = xxhash.xxh64(k).intdigest()
        bkt_idx = h & ((1 << self.i) - 1)
        if bkt_idx < size:
            return bkt_idx
        return bkt_idx ^ (1 << (self.i - 1))
class EntryList:
    def __init__(self):
        self.head = None
    def append(self, k, v):
        if self.head is None:
            self.head = Entry(k, v)
            return
        self.head.append(k, v)
    def __iter__(self):
        next = self.head
        while next:
            yield next
            next = next.next
class Entry:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
    def append(self, k, v):
        new_entry = Entry(k, v)
        new_entry.next = self.next
        self.next = new_entry",0,0,0,0,0,1,0,0,1
1384,"import sys
class HashMap(object):
    def __init__(self, size: int):
        self.size = size
        self.key_list = [None] * self.size
        self.value_list = [None] * self.size
        self.num_items = 0
        self.lengths = [None] * self.size
    def set(self, key: str, value):
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] is None:
                self.key_list[hash_index], self.value_list[hash_index], self.num_items = key, value, self.num_items + 1
                self.lengths[hash_index] = probe_length
                return True
            elif self.key_list[hash_index] == key:
                self.value_list[hash_index] = value
                return True
            else:
                hash_index = self._increment_hash(hash_index)
        return False
    def get(self, key: str):
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] == key:
                return self.value_list[hash_index]
            else:
                hash_index = self._increment_hash(hash_index)
        return None
    def delete(self, key):
        if self.load() == 0:
            return None
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] == key:
                value = self.value_list[hash_index]
                self.key_list[hash_index], self.value_list[hash_index], self.num_items = None, None, self.num_items - 1
                return value
            else:
                hash_index = self._increment_hash(hash_index)
        return None
    def load(self):
        return self.num_items / self.size
    def clear(self):
        self.key_list.clear()
        self.value_list.clear()
        self.num_items = 0
    def _process_key(self, key: str):
        key = sys.intern(key)
        return key, hash(key) % self.size
    def _increment_hash(self, index: int):
        return (index + 1) % self.size
    @property
    def probe_lengths(self):
        return [length for length in self.lengths if length is not None]",0,0,0,0,0,1,0,0,1
1385,"class HashMap:
	def __init__(self):
		self.size = 6
  self.map = [None] * self.size
 def _get_hash(self, key):
		hash = 0
  for char in str(key):
			hash += ord(char)
  return hash % self.size
 def add(self, key, value):
		key_hash = self._get_hash(key)
  key_value = [key, value]
  if self.map[key_hash] is None:
			self.map[key_hash] = list([key_value])
   return True
  else:
			for pair in self.map[key_hash]:
				if pair[0] == key:
					pair[1] = value
     return True
   self.map[key_hash].append(key_value)
   return True
 def get(self, key):
		key_hash = self._get_hash(key)
  if self.map[key_hash] is not None:
			for pair in self.map[key_hash]:
				if pair[0] == key:
					return pair[1]
  return None
 def delete(self, key):
		key_hash = self._get_hash(key)
  if self.map[key_hash] is None:
			return False
  for i in range (0, len(self.map[key_hash])):
			if self.map[key_hash][i][0] == key:
				self.map[key_hash].pop(i)
    return True
  return False
 def print(self):
		print('---PHONEBOOK----')
  for item in self.map:
			if item is not None:
				print(str(item))
h = HashMap()
h.add('Bob', '567-8888')
h.add('Ming', '293-6753')
h.add('Ming', '333-8233')
h.add('Ankit', '293-8625')
h.add('Aditya', '852-6551')
h.add('Alicia', '632-4123')
h.add('Mike', '567-2188')
h.add('Aditya', '777-8888')
h.print()
h.delete('Bob')
h.delete('Ming')
h.print()
print('Ankit: ' + h.get('Ankit'))",0,0,0,0,0,1,0,0,1
1386,"class HashTable:
    def __init__(self, size):
        self.size = size
        self.hash_table = self.create_buckets()
    def create_buckets(self):
        return [[] for _ in range(self.size)]
    def set_val(self, key, val):
        hashed_key = hash(key) % self.size
        bucket = self.hash_table[hashed_key]
        found_key = False
        for index, record in enumerate(bucket):
            record_key, record_val = record
            if record_key == key:
                found_key = True
                break
        if found_key:
            bucket[index] = (key, val)
        else:
            bucket.append((key, val))
    def get_val(self, key):
        hashed_key = hash(key) % self.size
        bucket = self.hash_table[hashed_key]
        found_key = False
        for index, record in enumerate(bucket):
            record_key, record_val = record
            if record_key == key:
                found_key = True
                break
        if found_key:
            return record_val
        else:
            return ""No record found""
    def delete_val(self, key):
        hashed_key = hash(key) % self.size
        bucket = self.hash_table[hashed_key]
        found_key = False
        for index, record in enumerate(bucket):
            record_key, record_val = record
            if record_key == key:
                found_key = True
                break
        if found_key:
            bucket.pop(index)
        return
    def __str__(self):
        return """".join(str(item) for item in self.hash_table)
hash_table = HashTable(50)
hash_table.set_val('gfg@example.com', 'some value')
print(hash_table)
print()
hash_table.set_val('portal@example.com', 'some other value')
print(hash_table)
print()
print(hash_table.get_val('portal@example.com'))
print()
hash_table.delete_val('portal@example.com')
print(hash_table)",0,0,0,0,0,1,0,0,1
1387,"class HashMap():
    def __init__(self, size=1024):
        self.size = size
        self.map = [None] * size
    def add(self, key, value):
        self._check_size()
        map_val = self.map[hash(key) % self.size]
        if map_val is not None and (key, value) not in map_val:
            self.map[hash(key) % self.size].append((key, value))
        elif map_val is not None and (key, value) in map_val:
            return self
        else:
            self.map[hash(key) % self.size] = [(key, value)]
        return self
    def get(self, key):
        self._check_size()
        map_val = self.map[hash(key) % self.size]
        if map_val is None:
            raise ValueError('Invalid key!')
        else:
            for k, v in map_val:
                if k == key:
                    return v
        raise ValueError('Invalid key!')
    def _check_size(self):
        if None in self.map:
            return
        else:
            new_size = self.size * 2
            temp_map = [None] * new_size
            for hashed_key in self.map:
                for k, v in hashed_key:
                    new_map_val = temp_map[hash(k) % new_size]
                    if new_map_val is not None and v not in new_map_val:
                        temp_map[hash(k) % new_size].append((k, v))
                    elif new_map_val is not None and v in new_map_val:
                        continue
                    else:
                        temp_map[hash(k) % new_size] = [(k, v)]
            self.map = temp_map
            self.size = new_size
    def __getitem__(self, key):
        return self.get(key)
    def __setitem__(self, key, value):
        return self.add(key, value)",0,0,0,0,0,1,0,0,1
1388,"class HashMap:
        def __init__(self):
                self.size = 6
                self.map = [None] * self.size
        def _get_hash(self, key):
                hash = 0
                for char in str(key):
                        hash += ord(char)
                return hash % self.size
        def add(self, key, value):
                key_hash = self._get_hash(key)
                key_value = [key, value]
                if self.map[key_hash] is None:
                        self.map[key_hash] = list([key_value])
                        return True
                else:
                        for pair in self.map[key_hash]:
                                if pair[0] == key:
                                        pair[1] = value
                                        return True
                        self.map[key_hash].append(key_value)
                        return True
        def get(self, key):
                key_hash = self._get_hash(key)
                if self.map[key_hash] is not None:
                        for pair in self.map[key_hash]:
                                if pair[0] == key:
                                        return pair[1]
                return None
        def delete(self, key):
                key_hash = self._get_hash(key)
                if self.map[key_hash] is None:
                        return False
                for i in range (0, len(self.map[key_hash])):
                        if self.map[key_hash][i][0] == key:
                                self.map[key_hash].pop(i)
                                return True
                return False
        def keys(self):
                arr = []
                for i in range(0, len(self.map)):
                        if self.map[i]:
                                arr.append(self.map[i][0])
                return arr
        def print(self):
                print('---PHONEBOOK----')
                for item in self.map:
                        if item is not None:
                                print(str(item))
h = HashMap()
h.add('Bob', '567-8888')
h.add('Ming', '293-6753')
h.add('Ming', '333-8233')
h.add('Ankit', '293-8625')
h.add('Aditya', '852-6551')
h.add('Alicia', '632-4123')
h.add('Mike', '567-2188')
h.add('Aditya', '777-8888')
h.print()  
h.delete('Bob')
h.print()
print('Ming: ' + h.get('Ming'))
print(h.keys())",0,0,0,0,0,1,0,0,1
1389,"from linkedlist import LinkedList
class Hashmap(object):
  def __init__(self, length=100):
    listBuckets = []
    for i in range(length):
      listBuckets.append(LinkedList())
    self.buckets = listBuckets
    self.length = length
  def hashFunction(self, data):
    key = data % self.length + 1
    return key
  def insert(self, node):
    key = self.hashFunction(node.data)
    node.key = key
    pushOutput = self.buckets[key].push(node)
    return pushOutput
  def remove(self, data):
    key = self.hashFunction(data)
    removedOutput = self.buckets[key].remove(data)
    return removedOutput
  def __repr__(self):
        return '<Hashmap %r>' % self.buckets",0,0,0,0,0,0,0,0,1
1390,"public class HashMap<K, V> {
    private List<Pair<K, V>>[] values;
    private int numberOfValues;
    public HashMap() {
        this.values = new List[32];
        this.numberOfValues = 0;
    }
    public void add(K key, V value) {
        List<Pair<K, V>> valuePairList = getValuePairList(key);
        int index = findIndexByKey(valuePairList, key);
        if (index < 0) {
            valuePairList.add(new Pair<>(key, value));
            this.numberOfValues++;
        } else {
            valuePairList.get(index).setValue(value);
        }
        if (1.0 * this.numberOfValues / this.values.length > 0.75) {
            doubleArraySize();
        }
    }
    public V get(K key) {
        int hash = Math.abs(key.hashCode() % this.values.length);
        if (this.values[hash] == null) {
            return null;
        }
        List<Pair<K, V>> valuePairsList = this.values[hash];
        for (int i = 0; i < valuePairsList.size(); i++) {
            if (valuePairsList.get(i).getKey().equals(key)) {
                return valuePairsList.get(i).getValue();
            }
        }
        return null;
    }
    public V remove(K key) {
        List<Pair<K, V>> values = getValuePairList(key);
        if (values.size() == 0) {
            return null;
        }
        int index = findIndexByKey(values, key);
        if (index < 0) {
            return null;
        }
        Pair<K, V> pair = values.get(index);
        values.remove(pair);
        return pair.getValue();
    }
    private void doubleArraySize() {
        List<Pair<K, V>>[] temp = new List[this.values.length * 2];
        for (int i = 0; i < this.values.length; i++) {
            copyValues(temp, i);
        }
        this.values = temp;
    }
    private void copyValues(List<Pair<K, V>>[] temp, int fromIndex) {
        for (int i = 0; i < this.values[fromIndex].size(); i++) {
            Pair<K, V> value = this.values[fromIndex].get(i);
            int hash = Math.abs(value.getKey().hashCode() % temp.length);
            if (temp[hash] == null) {
                temp[hash] = new List<>();
            }
            temp[hash].add(value);
        }
    }
    private List<Pair<K, V>> getValuePairList(K key) {
        int hash = Math.abs(key.hashCode() % this.values.length);
        if (this.values[hash] == null) {
            this.values[hash] = new List<>();
        }
        return this.values[hash];
    }
    private int findIndexByKey(List<Pair<K, V>> list, K key) {
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i).getKey().equals(key)) {
                return i;
            }
        }
        return -1;
    }
}",0,0,0,0,0,1,0,0,1
1391,"'use strict';
var HashMap = {
init: function( hashFn, equalsFn ){
  var object_array = [],
      count = 0;
  var add_value, get_value, replace_value, add_node, check_key,
      replace_node, return_value, return_true, return_false,
      remove_node, remove_value, find_node;
  replace_value = function( new_value, node ){
    var old_value = node.value;
    node.value = new_value;
    return old_value;
  };
  return_value = function( ignored, node ){
    return node.value;
  };
  return_true  = function(){ return true; };
  return_false = function(){ return false; };
  remove_node = function( ignored, node, previous_node, index ){
    if( previous_node ){
      previous_node.next = node.next;
    }
    else{
      object_array[ index ] = node.next;
    }
    count -= 1;
    return node.value;
  };
  var collision_count = 0;
  add_node = function( key, value, index, previous_node ){
    var node = { key: key, value: value, next: null };
    if( previous_node ){
      previous_node.next = node;
      collision_count += 1;
    }
    else{
      object_array[ index ] = node;
    }
    count += 1;
    return null;
  };
  find_node = function( on_found,
                        on_not_found,
                        previous_node,
                        value,
                        index,
                        node,
                        key ){
    var result = null;
    if( !node ){
      if( on_not_found ){
        result = on_not_found( key , value, index, previous_node );
      }
    }
    else if( equalsFn( node.key, key ) ){
      if( on_found ){
        result = on_found( value, node, previous_node, index );
      }
    }
    else{
      result = find_node( on_found,
                          on_not_found,
                          node,
                          value,
                          index,
                          node.next,
                          key );
    }
    return result;
  };
  add_value    = find_node.bind( null, replace_value, add_node,     null );
  get_value    = find_node.bind( null, return_value,  null,         null, null );
  check_key    = find_node.bind( null, return_true,   return_false, null, null );
  remove_value = find_node.bind( null, remove_node,   null,         null, null );
  return {
    set: function( key, value ){
      var index = hashFn( key ),
          node = object_array[ index ];
      return add_value( value, index, node, key );
    },
    get: function( key ){
      var index = hashFn( key ),
          node = object_array[ index ];
      return get_value( index, node, key );
    },
    remove: function( key ){
      var index = hashFn( key ),
          node = object_array[ index ];
      return remove_value( index, node, key );
    },
    count: function(){
      return count;
    },
    _get_collision_count: function(){
      return collision_count;
    },
    clear: function(){
      object_array = [];
      count = 0;
    },
    contains: function( key ){
      var index = hashFn( key ),
          node = object_array[ index ];
      return check_key( index, node, key );
    },
    forEach: function( onEach ){
      var handle_node = function( node ){
        if( node ){
          onEach( node.value );
          handle_node( node.next );
        }
      };
      object_array.forEach( handle_node );
    },
  };
}
};
if( module ){
  module.exports = HashMap.init;
  }",0,0,0,0,0,0,0,0,1
1392,"from hashmaplinkedlist import HashMapLinkedList
class HashMap(object):
    def __init__(self):
        self.capacity = 17
        self.size = 0
        self.array = [None] * self.capacity
    def _djb2_hash(self, data):
        hash = 5381
        for char in data:
            hash += ((hash << 5) + hash) + ord(char)
        return hash
    def _get_index(self, key):
        return self._djb2_hash(key) % self.capacity
    def __getitem__(self, key):
        index = self._get_index(key)
        linked_list = self.array[index]
        if linked_list is None:
            raise KeyError(key)
        result = linked_list.search(key)
        if result is None:
            raise KeyError(key)
        return result
    def __setitem__(self, key, value):
        index = self._get_index(key)
        linked_list = self.array[index]
        if linked_list is None:
            linked_list = HashMapLinkedList()
            self.array[index] = linked_list
        linked_list.add_node(key, value)
        self.size += 1
    def __len__(self):
        return self.size
    def remove(self, key):
        index = self._get_index(key)
        linked_list: HashMapLinkedList = self.array[index]
        if linked_list is None:
            raise KeyError(key)
        else:
            value = linked_list.remove_node(key)
            self.size -= 1
            if linked_list.root == None:
                del(linked_list)
                self.array[index] = None
            return value",0,0,0,0,0,0,0,0,1
1393,"from DS.Maps_Dictionaries.MapBase import MapBase
from random import randrange
class HashMapBase(MapBase):
    def __init__(self, cap=11, p=109345121):
        self._table = cap * [None]
        self._n = 0                         
        self._prime = p                     
        self._scale = 1 + randrange(p-1)    
        self._shift = randrange(p)          
    def _hash_function(self, k):
        return (hash(k)*self._scale + self._shift) % self._prime % len(self._table)
    def __len__(self):
        return self._n
    def __getitem__(self, k):
        j = self._hash_function(k)
        return self._bucket_getitem(j,k)        
    def __setitem__(self, k, v):
        j = self._hash_function(k)
        self._bucket_setitem(j,k,v)             
        if self._n > len(self._table) // 2:     
            self._resize(2*len(self._table) - 1)
    def __delitem__(self, k):
        j = self._hash_function(k)
        self._bucket_delitem(j,k)               
        self._n -= 1
    def _resize(self, c):                       
        old = list(self.items())                
        self._table = c * [None]                
        self._n = 0                             
        for (k,v) in old:
            self[k] = v",0,0,0,0,0,0,0,0,0
1394,"from hashmapnode import HashMapNode
class HashMapLinkedList(object):
    def __init__(self):
        self.root = None
    def search(self, key):
        if self.root is None:
            return None
        if self.root.key == key:
            return self.root.value
        temp_node = self.root.next
        while temp_node is not None:
            if temp_node.key == key:
                return temp_node.value
            temp_node = temp_node.next
        return None
    def add_node(self, key, value):
        new_node = HashMapNode(key, value)
        if self.root is None:
            self.root = new_node
            return
        if self.root.key == key:
            self.root.value = value
            return
        if self.root.next is None:
            self.root.next = new_node
            return
        temp = self.root.next
        while temp is not None:
            if temp.key == key:
                temp.value = value
                return
            if temp.next is None:
                temp.next = new_node
                return
            temp = temp.next
    def remove_node(self, key):
        if self.root is None:
            raise KeyError(key)
        if self.root.key == key:
            temp = self.root
            self.root = temp.next
            temp_value = temp.value
            del(temp)
            return temp_value
        previous = self.root
        current = self.root.next
        while current is not None:
            if current.key == key:
                previous.next = current.next
                temp_value = current.value
                del(current)
                return temp_value
            previous = current
            current = current.next
        raise KeyError(key)
    def all_nodes(self):
        all_nodes = []
        temp = self.root
        while temp is not None:
            all_nodes.append(temp)
            temp = temp.next
        return all_nodes",0,0,0,0,0,1,0,1,0
1395,"var Hashmapper = function () {
  this._map = Object.create(null);
  this._index = [];
};
Hashmapper.prototype = {
  add: function (name, value) {
    if (!name) {
      return false;
    }
    this._map[name] = value;
    this._index.push(name);
    return this;
  },
  get: function (name) {
    return name ? this._map[name] : false;
  },
  remove: function (name) {
    var value = this.get(name);
    if (value) {
      delete this._map[name];
      var index = this._index.indexOf(name);
      if (-1 !== index) {
        this._index.splice(index, 1);
      }
    }
    return value;
  },
  last: function () {
    return this.get(this._index[this._index.length - 1]);
  },
  range: function (name1, name2, options) {
    var index1 = 0;
    var index2;
    index2 = name2 ? this._index.indexOf(name2) : this._index.length - 1;
    if (-1 === index2) {
      index2 = this._index.length - 1;
    }
    index1 = name1 ? this._index.indexOf(name1) : 0;
    if (-1 === index1) {
      index1 = 0;
    }
    if (index1 > index2) {
      var temp = index1;
      index1 = index2;
      index2 = temp;
    }
    index1 = 0 >= index1 ? 0 : index1;
    index2 = index2 >= this._index.length - 1 ? undefined : index2;
    var excludeStart = options && true === options.excludeStart;
    var excludeEnd = options && true === options.excludeEnd;
    index1 = excludeStart ? index1 + 1 : index1;
    index2 = excludeEnd ? undefined === index2 ? this._index.length : index2 - 1 : index2;
    var indexes = this._index.slice(index1, index2);
    var keys = Object.keys(this._map);
    var index = 0;
    var length = keys.length;
    var range = [];
    var key;
    for (; length > index; index += 1) {
      key = keys[index];
      if (-1 !== indexes.indexOf(key)) {
        range.push(this._map[key]);
      }
    }
    return range;
  },
  invertedRange: function (name1, name2, options) {
    var range = this.range(name1, name2, options);
    var newRange = [];
    var length = range.length;
    var index = length - 1;
    for (; 0 <= index; index -= 1) {
      newRange.push(range[index]);
    }
    return newRange;
  },
  at: function (index) {
    var len = this._index.length;
    if (!len) {
      return null;
    }
    if (0 > index) {
      return len >= -index ? this.get(this._index[len + index]) : null;
    }
    return 0 <= index && len > index ? this.get(this._index[index]) : null;
  },
  length: function () {
    return this._index.length;
  },
  isEmpty: function () {
    return this._index.length === 0;
  },
  iter: function (fn, ctx) {
    var index = 0;
    var length = this._index.length;
    for (; length > index; index += 1) {
      fn.call(ctx, index, this._index[index]);
    }
  },
  iterDown: function (fn, ctx) {
    var length = this._index.length;
    var index = length - 1;
    for (; 0 <= index; index -= 1) {
      fn.call(ctx, index, this._index[index]);
    }
  },
  loop: function (fn) {
    var self = this;
    this.iter(function (index, name) {
      fn(self.get(name));
    });
  },
  loopDown: function (fn) {
    var self = this;
    this.iterDown(function (index, name) {
      fn(self.get(name));
    });
  },
  loopDownUntil: function (fn, predicate) {
    var item;
    var result;
    var self = this;
    this.iterDown(function (index, name) {
      item = self.get(name);
      result = fn(item);
      return typeof predicate === 'function' ? predicate(result) : predicate === result;
    });
    return result;
  }
};",0,0,0,0,0,0,0,0,1
1396,"import sys
class HashMap(object):
    def __init__(self, size: int):
        self.size = size
        self.key_list = [None] * self.size
        self.value_list = [None] * self.size
        self.num_items = 0
    def set(self, key: str, value):
        key, hash_index = self._process_key(key)
        probe_length = 0
        elem_to_swap, elem_to_swap_found, new_probe_length = None, False, 0
        while probe_length < self.size:
            if self.key_list[hash_index] is None:
                self.key_list[hash_index] = key, probe_length
                self.value_list[hash_index] = value
                self.num_items += 1
                if elem_to_swap_found:
                    self._swap_elements(elem_to_swap, hash_index, new_probe_length)
                return True
            elif self.key_list[hash_index][0] == key:
                self.value_list[hash_index] = value
                return True
            else:
                if elem_to_swap_found is False and self.key_list[hash_index][1] < probe_length:
                    elem_to_swap, elem_to_swap_found, new_probe_length = hash_index, True, probe_length
                hash_index = self._increment_hash(hash_index)
            probe_length += 1
        return False
    def get(self, key: str):
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] is not None and self.key_list[hash_index][0] == key:
                return self.value_list[hash_index]
            else:
                hash_index = self._increment_hash(hash_index)
        return None
    def delete(self, key: str):
        if self.load() == 0:
            return None
        key, hash_index = self._process_key(key)
        for probe_length in range(self.size):
            if self.key_list[hash_index] is not None and self.key_list[hash_index][0] == key:
                value = self.value_list[hash_index]
                self.key_list[hash_index], self.value_list[hash_index] = None, None
                self.num_items -= 1
                return value
            else:
                hash_index = self._increment_hash(hash_index)
        return None
    def load(self):
        return self.num_items / self.size
    def clear(self):
        self.key_list.clear()
        self.value_list.clear()
        self.num_items = 0
    def _process_key(self, key: str):
        key = sys.intern(key)
        return key, hash(key) % self.size
    def _increment_hash(self, index: int):
        return (index + 1) % self.size
    def _swap_elements(self, existing_index: int, new_index: int, new_probe_length: int):
        delta = new_index - existing_index
        if delta < 0:
            delta = self.size - existing_index + new_index
        self.key_list[existing_index] = self.key_list[existing_index][0], self.key_list[existing_index][1] + delta
        self.key_list[new_index] = self.key_list[new_index][0], new_probe_length
        self.key_list[existing_index], self.key_list[new_index] =            self.key_list[new_index], self.key_list[existing_index]
        self.value_list[existing_index], self.value_list[new_index] =            self.value_list[new_index], self.value_list[existing_index]
    @property
    def probe_lengths(self):
        return [probe_length[1] for probe_length in self.key_list if probe_length is not None]",0,0,0,0,0,1,0,0,1
1397,"package cassandratest;
public class HashMapSeparateChaining<Key, Value>
{
	private static final int INIT_BUCKETS_SIZE = 888;
	private int capacity;
	private int chains;  
	private Node[] ht;
	private static class Node
	{
		private Object key;
		private Object val;
		private Node next;
		public Node(Object key, Object val, Node next)
		{
			this.key = key;
			this.val = val;
			this.next = next;
		}
	}
	public HashMapSeparateChaining()
	{
		this(INIT_BUCKETS_SIZE);
	}
	public HashMapSeparateChaining(int chains)
	{
		this.chains = chains;
		ht = new Node[chains];
	}
	private int hash(Key key)
	{
		int hash = 0;
		for (int i = 0; i < key.toString().length(); i++)
		{
			hash = hash + (int) key.toString().charAt(i);
		}
		hash %= INIT_BUCKETS_SIZE;
		return hash;		
	}
	@SuppressWarnings(""unchecked"")
	public Value get(Key key)
	{
		int h = hash(key);
		for (Node x = ht[h]; x != null; x = x.next)
		{
			if (key.equals(x.key)) 
			{
				return (Value) x.val;
			}
		}
		return null;
	}
	public void put(Key key, Value val)
	{
		int h = hash(key);
		for (Node x = ht[h]; x != null; x = x.next)
		{
			if (key.equals(x.key))
			{
				x.val = val;
				return;
			}
		}
		capacity++;
		ht[h] = new Node(key, val, ht[h]);
	}	
}",0,0,0,0,0,1,0,0,1
1398,"package hashMapX;
import java.util.HashMap;
import java.util.Stack;
public class HashMapX {
	private HashMap<String,String> map_;
	private Stack<TransactionObj> activeXActions_;
	public HashMapX(){
		map_ = new HashMap<>();
		activeXActions_ = new Stack<>();
	}
	public void parseCommand(String command){
		String[] parsedCommand =  command.split("" "");
		if (parsedCommand[0].compareTo(""SET"")==0 && parsedCommand.length==3){
			if (activeXActions_.isEmpty()){
				if (parsedCommand[2]==null){
					System.out.println(""Cannot set null values"");
					return;
				}
				this.set(parsedCommand[1], parsedCommand[2]);
			}else {
				activeXActions_.peek().addSetCommand(parsedCommand);
			}
			return;
		}
		if (parsedCommand[0].compareTo(""GET"")==0){
			System.out.println(map_.get(parsedCommand[1]));
			return;
		}
		if (parsedCommand[0].compareTo(""UNSET"")==0){
			if (activeXActions_.isEmpty()){
				this.unset(parsedCommand[1]);
			}else {
				activeXActions_.peek().addUnsetCommand(parsedCommand);
			}
			return;
		}
		if (parsedCommand[0].compareTo(""BEGIN"")==0){
			this.startXaction();
			return;
		}
		if (parsedCommand[0].compareTo(""ROLLBACK"")==0){
			this.rollback();
			return;
		}
		if (parsedCommand[0].compareTo(""COMMIT"")==0){
			this.commit();
			return;
		}
		else {
			System.out.println(""Invalid command"");
		}
	}
	public String set(String key, String value){
		String old = null;
		if (map_.containsKey(key)){
			old = map_.get(key);
		} 
		map_.put(key, value);
		return old;
	}
	public String unset(String key){
		String value = null;
		if (map_.containsKey(key)){
			value = map_.get(key);
			map_.remove(key);
		}
		return value;
	}
	public String get(String key){
		return map_.get(key);
	}
	public void startXaction(){
		activeXActions_.push(new TransactionObj(this));
	}
	public void rollback(){
		if (activeXActions_.isEmpty()){
			System.out.println(""NO TRANSACTIONS IN PROGRESS"");
			return;
		}
		activeXActions_.pop().rollback();
	}
	public void commit(){
		if (activeXActions_.isEmpty()){
			System.out.println(""NO TRANSACTIONS IN PROGRESS"");
			return;
		}
		activeXActions_.clear();
	}
}",0,0,0,0,0,0,0,0,0
1399,"import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
public class HashTable extends Hashable implements Table {
	private HashBucket[] table;
	private int depth, size;
	public HashTable() {
		this.depth = initialDepth;
		this.size = 1<<depth;
		this.table = new HashBucket[size];
	}
	@Override
	public void insert(String word) {
		word = word.toLowerCase();  
		this.insert(word, 1);
	}
	private void insert(String word, int count) {  
		int key = hash(word)%size;
		if(table[key] == null) {  
			table[key] = new HashBucket();
		}
		if(table[key].isFull()) {  
			if(this.depth - table[key].getDepth() == 0) {  
				doublingSize();
				insert(word, count);
			}else if(this.depth - table[key].getDepth() > 0) {  
				int localKey = key % (1<<table[key].getDepth());  
				int depthDifference = this.depth - table[key].getDepth();  
				table[key].incrementDepth();  
				HashBucket newBucket = new HashBucket(table[key].getDepth());  
				for (int i = localKey; i < size; i+=(size>>depthDifference)) {  
					if(i%(1<<table[key].getDepth()) != key%(1<<table[key].getDepth())) {  
						table[i] = newBucket;
					}
				}
				table[key].transfer(newBucket, key);  
				insert(word, count);  
			}else {
				System.out.println(""Error #1\nLocal depth is higher than global depth!"");
			}
		}else {
			table[key].insert(word, count);
		}
	}
	@Override
	public boolean search(String word) {
		word = word.toLowerCase();  
		int key = hash(word)%size;
		HashBucket bucket = table[key];
		if(table[key] == null) {  
			System.out.println(word + "" bulunamad."");
			return false;  
		}
		WordNode node = bucket.find(word);
		if(node == null) {  
			System.out.println(word + "" bulunamad."");
			return false; 
		}
		bucket.print(node);
		System.out.println(""Global Depth: "" + depth);
		System.out.println();
		return true;
	}
	@Override
	public void loadFromFile(String fileName)  {
		BufferedReader br = null;
		FileReader fr = null;
		try {
			fr = new FileReader(fileName);
			br = new BufferedReader(fr);
			String sCurrentLine;
			while ((sCurrentLine = br.readLine()) != null) {
				sCurrentLine = sCurrentLine.trim();
				String words[] = sCurrentLine.split("" "");
				for(String word:words) {
					word = word.trim();
					if(word.equals("""")) continue;
					insert(word);
				}
			}
		} catch (FileNotFoundException e) {  
			e.printStackTrace();
		} catch (IOException e) {  
			e.printStackTrace();
		}
	}
	private void doublingSize() {  
		int size = 1<<depth;
		this.depth++;
		this.table = Arrays.copyOf(table, size*2);  
		for (int i = 0; i < size; i++) {  
			table[size+i] = table[i];
		}
		this.size = 1<<depth;
	}
	public int getDepth() {
		return depth;
	}
	public void print() {
		System.out.println(""----------Extendible Hashing----------"");
		System.out.println(""Global Depth: "" + depth);
		for (int i = 0; i < size; i++) {
			if(table[i] != null) {
				System.out.println("""");
				table[i].print();
			}
		}
	}
}",0,0,0,0,0,0,0,0,1
1400,"import sys
sys.path.insert(0, '../linked_list')
from link_list import LinkList  
import json  
class HashTable():
    _data = []
    def __init__(self, hashtableSize=1024):
        self._data = [None] * hashtableSize
    def _makePayload(self, name, value) -> dict:
        return({'name': name, 'value': value})
    def _makeHash(self, name) -> int:
        char_sum = sum([ord(char) for char in name])
        prime_number = 599
        hash = char_sum * prime_number
        return hash
    def _getHashIndex(self, hash: int) -> int:
        return hash % len(self._data)
    def _hashtable_compare_func(self, payload1, payload2) -> bool:
        if isinstance(payload2, dict):
            retVal = payload1.get('name') == payload2.get('name')
        else:
            retVal = payload1.get('name') == payload2
        return retVal
    def add(self, name, value):
        hash = self._makeHash(name)
        hashIdx = self._getHashIndex(hash)
        elem = self._data[hashIdx]
        payload = self._makePayload(name, value)
        if elem is None:
            elem = LinkList(self._hashtable_compare_func)
            elem.insert(payload)
            self._data[hashIdx] = elem
        else:
            if not elem.includes(payload):
                elem.insert(payload)
            else:
                raise ValueError('Already added to hashtable')
    def get(self, name):
        hash = self._makeHash(name)
        hashIdx = self._getHashIndex(hash)
        elem = self._data[hashIdx]
        if elem is None:
            raise ValueError('Not found')
        try:
            payload_dict = elem.get(name)
            return payload_dict.get('value')
        except Exception:
            raise ValueError('Not found')
    def delete(self, name):
        found = False
        try:
            found = self.contains(name)
        except ValueError:
            raise ValueError(f'Name:[{name}] does not exist.')
        if found:
            hash = self._makeHash(name)
            hashIdx = self._getHashIndex(hash)
            elem = self._data[hashIdx]
            if elem is None:
                raise ValueError(f'Name:[{name}] entry into HashTable is None.')
            b = elem.remove(name)
    def update(self, name, value):
        if not self.contains(name):
            raise ValueError(f'Name:[{name}] does not exist.')
        self.delete(name)
        self.add(name, value)
    def contains(self, name) -> bool:
        try:
            _ = self.get(name)
            return True
        except ValueError:
            return False
    def export_keys(self) -> list:
        retArr = []
        def touch_node(value):
            retArr.append(value)
        for linklist in self._data:
            if linklist:
                linklist.traverse(touch_node)
        return retArr",0,0,0,0,0,0,0,0,1
1401,"import java.util.*;
public class HashTable <T> {
	private ArrayList <LinkedList <T>> table;
	public int size, maxSize;
	public double maxLoad;
	public HashTable () {
		size = 0;
		maxSize = 10;
		maxLoad = 0.6;
		table = newList(10);
	}
	private ArrayList <LinkedList <T>> newList (int size) {
		ArrayList <LinkedList <T>> tmp = new ArrayList <LinkedList <T>> ();
		for (int i = 0; i < size; i ++) {
			tmp.add(null);
		}
		return tmp;
	}
	public void add (T val) {
		int pos = Math.abs(val.hashCode()) % maxSize;
		if (table.get(pos) == null) {
			table.set(pos, new LinkedList <T> ());
		}
		table.get(pos).add(val);
		size += 1;
		if (getLoad() - maxLoad > 0.01) {
			resize();
		}
	}
	public void remove (T val) {
		int pos = Math.abs(val.hashCode()) % maxSize;
		if (table.get(pos) != null) {
			if (table.get(pos).size() == 1) {
				table.set(pos, null);
			}
			else {
				table.get(pos).remove(val);
			}
		}
	}
	public T get (int key) {
		int pos = Math.abs(key) % maxSize;
		if (table.get(pos) != null) {
			for (T val: table.get(pos)) {
				if (val.hashCode() == key) {
					return val;
				}
			}
		}
		return null;
	}
	public LinkedList<T> getList (int key) {
		int pos = Math.abs(key) % maxSize;
		LinkedList<T> list = table.get(pos);
        if (list != null && list.size() > 0) {
            return list;
        }
        return null;
	}
	public void resize (double load) {
		ArrayList <LinkedList <T>> tmp = table;
		maxSize = (int) ((double) size/load);
		System.out.println(maxSize);
		size = 0;
		table = newList(maxSize);
		for (LinkedList <T> entry : tmp) {
			if (entry != null) {
				for (T val : entry) {
					add(val);
				}
			}
		}
	}
  	public void resize () {
	    ArrayList <LinkedList <T>> tmp = table;
	    maxSize *= 10;
	    size = 0;
	    table = newList(maxSize);
	    for (LinkedList <T> entry : tmp) {
	        if (entry != null) {
	        	for (T val : entry) {
	          		add(val);
	        	}
	      	}
	    }
	}
	public double getLoad () {
        return (double)size / (double)maxSize;
	}
	public void setMaxLoad (double load) {
		if (load >= 0.1 && load <= 0.8) {
            maxLoad = load;
        }
	}
	public void setLoad (double load) {
		if (load >= 0.1 && load <= 0.8) {
			if (load >= maxLoad) {
				maxLoad = load;
			}
			else {
				maxLoad = load;
				resize(maxLoad);
			}
		}
	}
	public ArrayList <T> toArrayList () {
		ArrayList <T> out = new ArrayList <T> ();
		for (int i = 0; i < maxSize; i ++) {
			if (table.get(i) != null) {
				for (int j = 0; j < table.get(i).size(); j ++) {
					out.add(table.get(i).get(j));
				}
			}
		}
		return out;
	}
	public String toString () {
		if (size > 0) {
			String ans = ""["";
			for (int i = 0; i < maxSize; i ++) {
				if (table.get(i) != null) {
					for (int j = 0; j < table.get(i).size(); j ++) {
						ans += table.get(i).get(j) + "", "";
					}
				}
			}
			ans = ans.substring(0, ans.lastIndexOf("","")) + ""]"";
			return ans;
		}
		else {
			return ""[]"";
		}
	}
}",0,0,0,0,0,1,0,0,1
1402,"class HashTable:
    def __init__(self):
        self.size = 10
        self.hashmap = [[] for i in range(0, self.size)]
        self.enable_rehash = False
        self.__DIVIDE_FACTOR = 3
        self.__MULTIPLIER = 3
        self.__KEYERROR = ""Key {} not found in hash table""
    def hash_func(self, key):
        hashed_key = hash(key) % self.size
        return hashed_key
    def set(self, key, value):
        if self.__get_size() >= (self.size-(self.size//self.__DIVIDE_FACTOR)):
            self.__rehash()
        hashed_key = self.hash_func(key)
        key_exists = False
        slot = self.hashmap[hashed_key]
        i = 0
        for i, kv in enumerate(slot):
            k = kv[0]
            if key == k:
                key_exists = True
                break
        if key_exists:
            slot[i] = (key, value)
        else:
            slot.append((key, value))
    def get(self, key):
        hashed_key = self.hash_func(key)
        slot = self.hashmap[hashed_key]
        for kv in slot:
            k, v = kv
            if key == k:
                return v
        raise KeyError(self.__KEYERROR.format(key))
    def delete_key(self, key):
        hashed_key = self.hash_func(key)
        slot = self.hashmap[hashed_key]
        for i, kv in enumerate(slot):
            k, v = kv
            if k == key:
                slot.pop(i)
                return True
        raise KeyError(self.__KEYERROR.format(key))
    def is_keyExists(self, key):
        hashed_key = self.hash_func(key)
        slot = self.hashmap[hashed_key]
        if slot is not None:
            for kv in slot:
                k = kv[0]
                if k == key:
                    return True
        return False
    def __rehash(self):
        self.size = self.size*self.__MULTIPLIER
        temp_hashmap = [[] for i in range(0, self.size)]
        for slot in self.hashmap:
            if slot is not None:
                for kv in slot:
                    key, value = kv
                    hashed_key = self.hash_func(key)
                    key_exists = False
                    new_slot = temp_hashmap[hashed_key]
                    i = 0
                    for i, kv in enumerate(new_slot):
                        k = kv[0]
                        if key == k:
                            key_exists = True
                            break
                    if key_exists:
                        new_slot[i] = (key, value)
                    else:
                        new_slot.append((key, value))
        self.hashmap = temp_hashmap
    def __get_size(self):
        occup_size = 0
        for slot in self.hashmap:
            if slot is not None:
                occup_size += len(slot)
        return occup_size
    def __setitem__(self, key, value):
        return self.set(key, value)
    def __getitem__(self, key):
        return self.get(key)",0,0,0,0,0,1,0,0,1
1403,"package algos;
import java.util.Iterator;
public class HashTable<K, V> implements Iterable<K>
{
    private static class Element<K, V>
    {
        private final K key;
        private V       value;
        public Element(K _key, V _value)
        {
            key = _key;
            value = _value;
        }
        public K getKey()
        {
            return key;
        }
        public V getValue()
        {
            return value;
        }
        public void setValue(V _value)
        {
            this.value = _value;
        }
    }
    private static class ElementList<K, V> implements Iterable<Element<K, V>>
    {
        private final LinkedList<Element<K, V>> elements = new LinkedList<Element<K, V>>();
        public void setValue(K key, V value)
        {
            for (Element<K, V> e : elements) {
                if (e.getKey().equals(key)) {
                    e.setValue(value);
                    return;
                }
            }
            elements.insert(new Element<K, V>(key, value));
        }
        public V getValue(K key, V def)
        {
            for (Element<K, V> e : elements) {
                if (e.getKey().equals(key)) {
                    return e.getValue();
                }
            }
            return def;
        }
        public boolean hasKey(K key)
        {
            for (Element<K, V> e : elements) {
                if (e.getKey().equals(key)) {
                    return true;
                }
            }
            return false;
        }
        public void removeKey(K key)
        {
            Iterator<Element<K, V>> itr = elements.iterator();
            while (itr.hasNext()) {
                if (itr.next().getKey().equals(key)) {
                    itr.remove();
                    return;
                }
            }
        }
        @Override
        public Iterator<Element<K, V>> iterator()
        {
            return elements.iterator();
        }
        public int size()
        {
            return elements.size();
        }
    }
    private final ElementList<K, V>[] data;
    @SuppressWarnings(""unchecked"")
    public HashTable(int size)
    {
        data = new ElementList[size];
        for (int ii = 0; ii < size; ii++) {
            data[ii] = new ElementList<K, V>();
        }
    }
    private int hash(K key)
    {
        return key.hashCode() % data.length;
    }
    public void set(K key, V value)
    {
        data[hash(key)].setValue(key, value);
    }
    public V get(K key, V def)
    {
        return data[hash(key)].getValue(key, def);
    }
    public V get(K key)
    {
        return get(key, null);
    }
    public boolean hasKey(K key)
    {
        return data[hash(key)].hasKey(key);
    }
    public void delete(K key)
    {
        data[hash(key)].removeKey(key);
    }
    @Override
    public Iterator<K> iterator()
    {
        return new Iterator<K>()
        {
            private int                     bucket  = 0;
            private Iterator<Element<K, V>> itr     = null;
            private Iterator<Element<K, V>> previtr = null;
            private boolean findNextBucket()
            {
                for (; bucket < data.length; bucket++) {
                    if (data[bucket].size() > 0) {
                        itr = data[bucket].iterator();
                        return true;
                    }
                }
                itr = null;
                return false;
            }
            @Override
            public boolean hasNext()
            {
                if (itr != null) {
                    return itr.hasNext();
                }
                return findNextBucket();
            }
            @Override
            public K next()
            {
                if (itr == null) {
                    if (!hasNext()) {
                        return null;
                    }
                }
                Element<K, V> elt = itr.next();
                previtr = itr;
                if (!itr.hasNext()) {
                    bucket++;
                    findNextBucket();
                }
                if (elt == null) {
                    return null;
                }
                return elt.getKey();
            }
            @Override
            public void remove()
            {
                if (previtr != null) {
                    previtr.remove();
                }
            }
        };
    }
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder(""{"");
        boolean isFirst = true;
        for (K key : this) {
            if (isFirst) {
                isFirst = false;
            }
            else {
                sb.append("", "");
            }
            sb.append(""("");
            sb.append(key);
            sb.append("", "");
            sb.append(get(key));
            sb.append("")"");
        }
        sb.append(""}"");
        return sb.toString();
    }
}",0,0,0,0,0,1,0,0,0
1404,"class HashItem:
    def __init__(self, key, value):
        self.key = key
        self.value = value
class HashTable:
    def __init__(self):
        self.size = 256
        self.slots = [None for i in range(self.size)]
        self.count = 0
    def _hash(self, key):
        mult = 1
        hv = 0
        for ch in key:
            hv += mult * ord(ch)
            mult += 1
        return hv % self.size
    def put(self, key, value):
        item = HashItem(key, value)
        h = self._hash(key)
        while self.slots[h] is not None:
            if self.slots[h].key is key:
                break
            h = (h + 1) % self.size
        if self.slots[h] is None:
            self.count += 1
        self.slots[h] = item
    def get(self, key):
        h = self._hash(key)
        while self.slots[h] is not None:
            if self.slots[h].key is key:
                return self.slots[h].value
            h = (h+ 1) % self.size
        return None
    def __setitem__(self, key, value):
        self.put(key, value)
    def __getitem__(self, key):
        return self.get(key)
ht = HashTable()
ht[""good""] = ""eggs""
ht[""better""] = ""ham""
ht[""best""] = ""spam""
ht[""ad""] = ""do not""
ht[""ga""] = ""collide""
ht[""data""] = ""value""
for key in (""good"", ""better"", ""best"", ""worst"", ""ad"", ""ga""):
    v = ht[key]
    print(v)
print(""The number of elements is: {}"".format(ht.count))",0,0,0,0,0,1,0,0,1
1405,"import java.util.Vector;
public class HashTable<K, V>
{
	private static class HashEntry<K, V>
	{
		private K key;
		private Vector<V> value = new Vector<V>();
		private boolean isTombstone = false;
		private HashEntry(K insertKey, V insertValue)
		{
			key = insertKey;
			value.add(insertValue);
		}
		public void makeTombstone()
		{
			isTombstone = true;
		}
	}
	private final int[] SIZES = { 1019, 2027, 4079, 8123, 16267, 32503, 65011,
		130027, 260111, 520279, 1040387, 2080763, 4161539, 8323151, 16646323 };
	private int sizeIdx = 0;
	private HashEntry<K, V>[] table;
	private int numEntries = 0;
	private int numFilledSlots = 0;
	private int numProbes = 0;
	@SuppressWarnings(""unchecked"")
	public HashTable()
	{
		table = new HashEntry[SIZES[sizeIdx]];
	}
	@SuppressWarnings(""unchecked"")
	private void increaseCapacity()
	{
		HashEntry<K, V>[] oldTable = table;
		try
		{
			table = new HashEntry[SIZES[++sizeIdx]];
		}
		catch (ArrayIndexOutOfBoundsException e)
		{
			System.out.println(""Too many entries in hash table.  Exiting."");
			System.exit(4);
		}
		for (int i = 0; i < oldTable.length; ++i)
		{
			if (oldTable[i] != null && !oldTable[i].isTombstone)
			{
				for (V value : oldTable[i].value)
				{
					insert(oldTable[i].key, value);
				}
			}
		}
	}
	public boolean insert(K key, V value)
	{
		int size = SIZES[sizeIdx];
		int i;
		numProbes = 0;
		if (numFilledSlots >= 0.7 * size)
		{
			increaseCapacity();
			size = SIZES[sizeIdx];
		}
		for (i = 0; i < size; ++i)
		{
			int index = probe(key, i, size);
			if (table[index] == null || table[index].isTombstone)
			{
				table[index] = new HashEntry<K, V>(key, value);
				++numEntries;
				++numFilledSlots;
				numProbes = i;
				return true;
			}
			else if (table[index].key.equals(key) && !table[index].isTombstone)
			{
				table[index].value.add(value);
				++numEntries;
				numProbes = i;
				return true;
			}
		}
		numProbes = i - 1;
		return false;
	}
	private int probe(K key, int i, int size)
	{
		return (hash(key) + ((int) (Math.pow(i, 2) + i) >> 2)) % size;
	}
	public int getNumProbes()
	{
		return numProbes;
	}
	public Vector<V> find(K key)
	{
		int size = SIZES[sizeIdx];
		for (int i = 0; i < size; ++i)
		{
			int index = probe(key, i, size);
			if (table[index] == null)
			{
				return null;
			}
			else if (table[index].key.equals(key) && !table[index].isTombstone)
			{
				return table[index].value;
			}
		}
		return null;
	}
	public boolean delete(K key)
	{
		int size = SIZES[sizeIdx];
		for (int i = 0; i < size; ++i)
		{
			int index = probe(key, i, size);
			if (table[index] == null)
			{
				return false;
			}
			else if (table[index].key.equals(key) && !table[index].isTombstone)
			{
				table[index].isTombstone = true;
				return true;
			}
		}
		return false;
	}
	private int hash(K key)
	{
		String toHash = key.toString();
		int hashValue = 0;
		for (int pos = 0; pos < toHash.length(); ++pos)
		{
			hashValue = (hashValue << 4) + toHash.charAt(pos);
			int highBits = hashValue & 0xF0000000;
			if (highBits != 0)
			{
				hashValue ^= highBits >> 24;
			}
			hashValue &= ~highBits;
		}
		return hashValue;
	}
	public void debug()
	{
		float entriesPerSlot = (float) numEntries / (float) numFilledSlots;
		String result = ""Format of display is\n"";
		result += ""Slot number: data record\n\n"";
		result += ""Current table size:\t\t\t\t\t\t"" + table.length + ""\n"";
		result += ""Number of elements in table:\t\t\t"" + numEntries + ""\n"";
		result += ""Number of filled slots in table:\t\t"" + numFilledSlots + ""\n"";
		result += ""Average number of entries per slot is:\t"" + entriesPerSlot + ""\n"";
		System.out.println(result);
		for (int i = 0; i < table.length; i++)
		{
			if (table[i] != null && !table[i].isTombstone)
			{
				result = ""\n"" + i + "":\t"" + ((i < 100) ? ""\t"" : """") + ""["" + table[i].key.toString() + "", "";
				for (V entry : table[i].value)
				{
					result += ""("" + entry.toString() + ""), "";
				}
				result = result.substring(0, result.length() - 2) + ""]"";
				System.out.println(result);
			}
		}
	}
}",0,0,0,0,0,1,0,0,1
1406,"class node:
    key = """"
    value = 0
    def __init__(self, key, value):
        self.key = key
        self.value = value
    def set(self, value):
        self.value = value
    def output(self):
        print(""'"" + self.key + ""' : '"" + self.value + ""'"")
class hashTable:
    bucket = []
    keys = set([])
    size = 0
    __loadSum = 0
    __loadFactor = 0.0
    def __init__(self, size):
        self.keys = set([])
        self.size = size
        self.bucket = [None] * size
        self.__loadCalc();
    def __loadCalc(self):
        if (self.size == 0):
            self.__loadFactor = 0
        else:
            self.__loadFactor = self.__loadSum/self.size
    def get(self, k):
        k = str(k);
        if (k in self.keys):
            i = 0
            hashed = (hash(k) + i) % self.size
            while(self.bucket[hashed] != None):
                if(self.bucket[hashed].key != k):
                    hashed = (hash(k) + i) % self.size
                    i += 1
                else:
                    return self.bucket[hashed].value
            return None
        else:
            return None
    def set(self, k, v):
        k = str(k);
        if (k in self.keys):
            i = 0
            hashed = (hash(k) + i) % self.size
            while(self.bucket[hashed] != None):
                if(self.bucket[hashed].key != k):
                    hashed = (hash(k) + i) % self.size
                    i += 1
                else:
                    self.bucket[hashed].value = v
                    return True
        elif (self.__loadFactor == 1.0):
            return False
        else:
            newNode = node(k, v)
            i = 0;
            hashed = (hash(k) + i) % self.size;
            while(self.bucket[hashed] != None):
                hashed = (hash(k) + i) % self.size
                i += 1
            self.bucket[hashed] = newNode
            self.keys.add(k)
            self.__loadSum += 1
            self.__loadCalc()
            return True
    def delete(self, k):
        k = str(k);
        if (k in self.keys):
            i = 0
            hashed = (hash(k) + i) % self.size
            while(self.bucket[hashed] != None):
                if(self.bucket[hashed].key != k):
                    hashed = (hash(k) + i) % self.size
                    i += 1
                else:
                    tmp = self.bucket[hashed].value
                    self.bucket[hashed] = None
                    self.keys.remove(k)
                    self.__loadSum -= 1
                    self.__loadCalc()
                    return tmp;
            return None
        else:
            return None
    def load(self):
        return self.__loadFactor",0,0,0,0,0,1,0,0,1
1407,"package com.roche.andy.datastructures;
import java.util.ArrayList;
public class HashTable<K, V> {
    private class HashNode {
        K key;
        V value;
        HashNode next;
        HashNode(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
    @SuppressWarnings(""FieldCanBeLocal"")
    private static final double loadThreshold = 0.7;
    private ArrayList<HashNode> bucketArray;
    private int numBuckets;
    private int size;
    public HashTable() {
        bucketArray = new ArrayList<>();
        numBuckets = 10;
        size = 0;
        for (int i = 0; i < numBuckets; i++) {
            bucketArray.add(null);
        }
    }
    public int size() {
        return size;
    }
    public boolean isEmpty() {
        return size() == 0;
    }
    public V get(K key) {
        int bucketIndex = getBucketIndex(key);
        HashNode head = bucketArray.get(bucketIndex);
        while (head != null) {
            if (head.key.equals(key)) {
                return head.value;
            }
            head = head.next;
        }
        return null;
    }
    public void add(K key, V value) {
        int bucketIndex = getBucketIndex(key);
        HashNode head = bucketArray.get(bucketIndex);
        while (head != null) {
            if (head.key.equals(key)) {
                head.value = value;
                return;
            }
            head = head.next;
        }
        size++;
        head = bucketArray.get(bucketIndex);
        HashNode newNode = new HashNode(key, value);
        newNode.next = head;
        bucketArray.set(bucketIndex, newNode);
        if ((1.0 * size) / numBuckets >= loadThreshold) {
            ArrayList<HashNode> temp = bucketArray;
            bucketArray = new ArrayList<>();
            numBuckets = 2 * numBuckets;
            size = 0;
            for (int i = 0; i < numBuckets; i++) {
                bucketArray.add(null);
            }
            for (HashNode headNode : temp) {
                while (headNode != null) {
                    add(headNode.key, headNode.value);
                    headNode = headNode.next;
                }
            }
        }
    }
    public V remove(K key) {
        int bucketIndex = getBucketIndex(key);
        HashNode head = bucketArray.get(bucketIndex);
        HashNode prev = null;
        while (head != null) {
            if (head.key.equals(key)) {
                break;
            }
            prev = head;
            head = head.next;
        }
        if (head == null) {
            return null;
        }
        size--;
        if (prev != null) {
            prev.next = head.next;
        } else {
            bucketArray.set(bucketIndex, head.next);
        }
        return head.value;
    }
    private int getBucketIndex(K key) {
        int hashCode = key.hashCode();
        return hashCode % numBuckets;
    }
}
class HTTest {
    public static void main(String[] args) {
        HashTable<String, Integer> hashTable = new HashTable<>();
        hashTable.add(""this"", 1);
        hashTable.add(""coder"", 2);
        hashTable.add(""this"", 4);
        hashTable.add(""hi"", 5);
        System.out.println(""Hash table size: "" + hashTable.size());
        System.out.println(""Key for \""this\"": "" + hashTable.get(""this""));
        System.out.println(""Remove \""this\"": "" + hashTable.remove(""this""));
        System.out.println(""Remove \""this\"": "" + hashTable.remove(""this""));
        System.out.println(""Hash table size: "" + hashTable.size());
        System.out.println(""Is hash table empty: "" + hashTable.isEmpty());
    }
}",0,0,0,0,0,1,0,0,1
1408,"class Hashmap:
    def __init__(self):
        self.size = 6
        self.map = [None] * self.size
    def gethash(self, key):
        hash = 0
        for char in key:
            hash += ord(char)
        return hash % self.size
    def add(self, key, value):
        hash_key = self.gethash(key)
        key_value_pairs = [key, value]
        if self.map[hash_key] is None:
            self.map[hash_key] = list([key_value_pairs])
            return True
        else:
            for pair in self.map[hash_key]:
                if pair[0] == key:
                    pair[1] = value
                    return True
            self.map[hash_key].append(key_value_pairs)
            return True
    def get(self, key):
        hash_key = self.gethash(key)
        cell_data = self.map[hash_key]
        if cell_data != None:
            for pair in cell_data:
                if pair[0] == key:
                    return pair[1]
        return False
    def delete(self, key):
        hash_key = self.gethash(key)
        if self.map[hash_key] is None:
            return False
        else:
            for i in range(len(self.map[hash_key])):
                if self.map[hash_key][i][0] == key:
                    self.map[hash_key].pop(i)
                    return True
        return False
    def existing_key(self):
        arr = []
        for i in range(len(self.map)):
            if self.map[i]:
                for j in range(len(self.map[i])):
                    arr.append(self.map[i][j][0])
        return arr
    def print(self):
        print(""--phone data--"")
        for item in self.map:
            print(str(item))
h = Hashmap()
h.add('Bob', '5670383')
h.add('Ming', 'jjjjj')
h.add('Bob', '567038')
h.print()
print(h.existing_key())",0,0,0,0,0,1,0,0,1
1409,"package hash_table;
import java.util.TreeMap;
public class HashTable<K, V> {
    private final int[] capacity
            = {53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593,
            49157, 98317, 196613, 393241, 786433, 1572869, 3145739, 6291469,
            12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741};
    public static final int UPPER_TOL = 10;
    public static final int LOWER_TOL = 2;
    public int capacity_index;
    private TreeMap<K, V>[] hashTable;
    private int size;
    private int M;
    public HashTable() {
        this.M = capacity[capacity_index];
        hashTable = new TreeMap[M];
        for (int i = 0; i < M; i++) {
            hashTable[i] = new TreeMap<>();
        }
    }
    private int hash(K k) {
        return (k.hashCode() & 0x7fffffff) % M;
    }
    public int getSize() {
        return size;
    }
    public boolean contains(K k) {
        return hashTable[hash(k)].containsKey(k);
    }
    public void add(K k, V v) {
        TreeMap<K, V> treeMap = hashTable[hash(k)];
        if (treeMap.containsKey(k)) {
            treeMap.put(k, v);
        } else {
            treeMap.put(k, v);
            size++;
            if (size > UPPER_TOL * M && capacity_index < capacity.length - 1) {
                capacity_index++;
                resize(capacity_index);
            }
        }
    }
    public V remove(K k) {
        TreeMap<K, V> treeMap = hashTable[hash(k)];
        V ret = null;
        if (treeMap.containsKey(k)) {
            ret = treeMap.remove(k);
            size--;
            if (size < LOWER_TOL * M && capacity_index - 1 >= 0) {
                capacity_index--;
                resize(capacity_index);
            }
        }
        return ret;
    }
    public V set(K k, V v) {
        TreeMap<K, V> treeMap = hashTable[hash(k)];
        if (!treeMap.containsKey(k)) {
            throw new IllegalArgumentException(k + ""doesn't exist~"");
        }
        return treeMap.put(k, v);
    }
    public V get(K k) {
        return hashTable[hash(k)].get(k);
    }
    private void resize(int newCapacity) {
        TreeMap[] newHashTable = new TreeMap[newCapacity];
        for (int i = 0; i < newCapacity; i++) {
            newHashTable[i] = new TreeMap();
        }
        int oldM = M;
        M = newCapacity;
        for (int i = 0; i < oldM; i++) {
            TreeMap<K, V> treeMap = hashTable[i];
            for (K k : treeMap.keySet()) {
                newHashTable[hash(k)].put(k, treeMap.get(k));
            }
        }
        hashTable = newHashTable;
    }
}",0,0,0,0,0,0,0,0,1
1410,"def hash_function(key_str, size):
    return sum([ord(c) for c in key_str]) % size
class HashTable:
    def __init__(self, capacity=1000):
        self.capacity = capacity
        self.size = 0
        self._keys = []
        self.data = [[] for _ in range(capacity)]
    def _find_by_key(self, key, find_result_func):
        index = hash_function(key, self.capacity)
        hash_table_cell = self.data[index]
        found_item = None
        for item in hash_table_cell:
            if item[0] == key:
                found_item = item
                break
        return find_result_func(found_item, hash_table_cell)
    def set(self, key, obj):
        def find_result_func(found_item, hash_table_cell):
            if found_item:
                found_item[1] = obj
            else:
                hash_table_cell.append([key, obj])
                self.size += 1
                self._keys.append(key)
        self._find_by_key(key, find_result_func)
        return self
    def get(self, key):
        def find_result_func(found_item, _):
            if found_item:
                return found_item[1]
            else:
                raise KeyError(key)
        return self._find_by_key(key, find_result_func)
    def remove(self, key):
        def find_result_func(found_item, hash_table_cell):
            if found_item:
                hash_table_cell.remove(found_item)
                self._keys.remove(key)
                self.size -= 1
                return found_item[1]
            else:
                raise KeyError(key)
        return self._find_by_key(key, find_result_func)
    def keys(self):
        return self._keys
    def __setitem__(self, key, value):
        self.set(key, value)
    def __getitem__(self, key):
        return self.get(key)
    def __delitem__(self, key):
        return self.remove(key)
    def __repr__(self):
        return '{ ' + ', '.join([key + ':' + str(self.get(key)) for key in self._keys]) + ' }'
if __name__ == ""__main__"":
    import unittest
    testsuite = unittest.TestLoader().discover('test', pattern=""*hashtable*"")
    unittest.TextTestRunner(verbosity=1).run(testsuite)",0,0,0,0,0,1,0,0,1
1411,"package Hashtables.HashTable;
public class Hashtable<Key, Value> {
    public class Node {
        private Key key;
        private Value value;
        private Node next;
        private int hash;
        public Node(Key key, Value value, Node next, int hash){
            this.key = key;
            this.value = value;
            this.next = next;
            this.hash = hash;
        }
    }
    private Node[] nodes;
    @SuppressWarnings(""unchecked"")
	public Hashtable(int size){
        nodes = new Hashtable.Node[size];
    }
    private int getIndex(Key key){
        int hash = key.hashCode() % nodes.length;
        if(hash < 0){
            hash += nodes.length;
        }
        return hash;
    }
    public Value insert(Key key, Value value){
        int hash = getIndex(key);
        for(Node node = nodes[hash]; node != null; node = node.next){
            if((hash == node.hash) && key.equals(node.key)){
                Value oldData = node.value;
                node.value = value;
                return oldData;
            }
        }
        Node node = new Node(key, value, nodes[hash], hash);
        nodes[hash] = node;
        return value;
    }
    public boolean remove(Key key){
        int hash = getIndex(key);
        Node previous = null;
        for(Node node = nodes[hash]; node != null; node = node.next){
            if((hash == node.hash) && key.equals(node.key)){
                if(previous != null)
                    previous.next = node.next;
                else
                    nodes[hash] = node.next;
                return true;
            }
            previous = node;
        }
        return false;
    }
    public Value get(Key key){
        int hash = getIndex(key);
        Node node = nodes[hash];
        while (node != null) {
            if(key.equals(node.key))
                return node.value;
            node = node.next;
        }
        return null;
    }
    public void resize(int size){
    	Hashtable<Key, Value> tbl = new Hashtable<Key, Value>(size);
        for(Node node : nodes){
            while (node != null) {
                tbl.insert(node.key, node.value);
                remove(node.key);
                node = node.next;
            }
        }
        nodes = tbl.nodes;
    }
}",0,0,0,0,0,1,0,0,1
1412,"class HashTable:
    def __init__(self, size=9973):
        self.size = size
        self.array = [[] for i in range(self.size)]
        self.itemlst = []
    def __hashed(self, key):
        hash = ''
        for i in str(key):
            hash += str(ord(i) - 22)
        return int(hash) % self.size
    def __setitem__(self, key, value):
        flag = True
        for i in self.array[self.__hashed(key)]:
            if i[0] == key:
                x = i[1]
                i[1] = value
                flag = False
                self.itemlst.remove((key, x))
                self.itemlst.append((key, value))
        if flag == True:
            self.array[self.__hashed(key)].append([key, value])
            self.itemlst.append((key, value))
    def __getitem__(self, key):
        return self.get(key)
    def __delitem__(self, key):
        return self.pop(key)
    def get(self, key):
        for i in self.array[self.__hashed(key)]:
            if i[0] == key:
                return i[1]
        raise KeyError(key)
    def pop(self, key):
        for i in self.array[self.__hashed(key)]:
            if i[0] == key:
                self.itemlst.remove((key, self.get(key)))
                self.array[self.__hashed(key)].remove(i)
                return
        raise KeyError(key)
    def clear(self):
        self.array = [[] for i in range(self.size)]
        self.itemlst = []
    def items(self):
        return f""hashtable_items({self.itemlst})""
    def keys(self):
        keylst = []
        for i in self.itemlst:
            keylst.append(i[0])
        return f""hashtable_keys({keylst})""
    def values(self):
        valuelst = []
        for i in self.itemlst:
            valuelst.append(i[1])
        return f""hashtable_values({valuelst})""",0,0,0,0,0,0,0,0,1
1413,"class HashTable:
    def __init__(self, buckets = 11):
        self.buckets = buckets
        self.table = [[] for i in range(self.buckets)]
    def buckets_str(self):
        buckets_index = """"
        counter = 0
        for bucket in self.table:
            buckets_index += ""%04d->"" % counter
            pairs = []
            for key_value in bucket:
                pairs.append("":"".join([str(key_value[0]), str(key_value[1])]))
            buckets_index += "", "".join(pairs) + '\n'
            counter += 1
        return buckets_index
    def __str__(self):
        b = []
        if len(self.table) == 0:
            return ""{}""
        for buck in self.table:
            for key_value in buck:
                pairs = str(key_value[0]) + "":"" + str(key_value[1])
                b.append(pairs)
        result = ', '.join(b)
        result = ""{"" + result + ""}""
        if result == """":
            return ""{"" + result + ""}""
        return result
    def get(self, key):
        index, exists, buck_num = self.bucket_indexof(key)
        if exists is False:
            return set()
        else:
            return self.table[buck_num][index][1]
    def put(self, key, value):
        index, exists, buck_num = self.bucket_indexof(key)
        if exists is True:
            index, exists, buck_num = self.bucket_indexof(key)
            self.table[buck_num][index] = (key, set([value]))
            return None
        elif exists is False:
            self.table[buck_num].append((key, value))
            return None
    def bucket_indexof(self, key):
        tuple_index = 0
        if type(key) == int:
            hashcode = key
        elif type(key) == str:
            hashcode = 0
            for i in key:
                hashcode = hashcode * 31 + ord(i)
        else:
            hashcode = None
        buck_number = hashcode % len(self.table)
        buck = self.table[buck_number]
        exists = False
        for elem in buck:
            if key == elem[0]:
                tuple_index = buck.index(elem)
                exists = True
        return tuple_index, exists, buck_number
    def __setitem__(self, key, item):
        self.put(key, item)
    def __getitem__(self, key):
        return self.get(key)",0,0,0,0,0,1,0,0,1
1414,"import shmht
import marshal
class HashTable(object):
    def __init__(self, name, capacity=0, force_init=False, serializer=marshal):
        force_init = 1 if force_init else 0
        self.fd = shmht.open(name, capacity, force_init)
        self.loads = serializer.loads
        self.dumps = serializer.dumps
    def close(self):
        shmht.close(self.fd)
    def get(self, key, default=None):
        val = shmht.getval(self.fd, key)
        if val == None:
            return default
        return val
    def set(self, key, value):
        return shmht.setval(self.fd, key, value)
    def remove(self, key):
        return shmht.remove(self.fd, key)
    def foreach(self, callback, unserialize=False):
        if not unserialize:
            cb = callback
        else:
            loads = self.loads
            def mcb(key, value):
                return callback(key, loads(value))
            cb = mcb
        return shmht.foreach(self.fd, cb)
    def getobj(self, key, default=None):
        val = self.get(key, default)
        if val == default:
            return default
        return self.loads(val)
    def setobj(self, key, val):
        val = self.dumps(val)
        return self.set(key, val)
    def __getitem__(self, key):
        val = shmht.getval(self.fd, key)
        if val == None:
            raise KeyError(key)
        return val
    def __setitem__(self, key, value):
        return shmht.setval(self.fd, key, value)
    def __delitem__(self, key):
        if False == shmht.remove(self.fd, key):
            raise KeyError(key)
    def __contains__(self, key):
        return shmht.getval(self.fd, key) != None
    def to_dict(self, unserialize=False):
        d = {}
        def insert(k,v):
            d[k] = v
        self.foreach(insert, unserialize)
        return d
    def update(self, d, serialize=False):
        dumps = self.dumps
        if serialize:
            for k in d:
                self[k] = dumps(d[k])
        else:
            for k in d:
                self[k] = d[k]
if __name__ == ""__main__"":
    loads = marshal.loads
    dumps = marshal.dumps
    ht = HashTable('/dev/shm/test.HashTable', 1024, 1)
    ht['a'] = '1'
    ht.set('b', '2')
    c = {'hello': 'world'}
    ht.setobj('c', c)
    print ht['b'] == '2'
    print ht['c'] == marshal.dumps(c)
    print ht.getobj('c') == c
    print ht.get('d') == None
    try:
        ht['d']
        print False
    except:
        print True
    print ('c' in ht) == True
    print ('d' in ht) == False
    del ht['c']
    print ht.get('c') == None
    try:
        del ht['d']
        print 'del:', False
    except:
        print True
    ht.setobj('c', c)
    print ht.to_dict() == {'a': '1', 'b': '2', 'c': dumps(c)}
    s = ''
    def cb(key, value):
        global s
        s += key + str(value)
    ht.foreach(cb)
    print s == 'a1b2c' + dumps(c)
    ht.update({'a': 1, 'b': 2}, serialize=True)
    s = ''
    ht.foreach(cb, unserialize=True)
    print s == 'a1b2c' + str(c)
    print ht.to_dict() == {'a':dumps(1), 'b':dumps(2), 'c':dumps(c)}
    print ht.to_dict(unserialize=True) == {'a': 1, 'b': 2, 'c': c}
    ht.close()
    try:
        ht['a']
        print False
    except:
        print True
    import time
    capacity = 300000
    ht = HashTable('/dev/shm/test.HashTable', capacity, True)
    begin_time = time.time()
    for i in range(capacity):
        s = '%064d' % i
        ht[s] = s
    end_time = time.time()
    print capacity / (end_time - begin_time), 'iops @ set'
    begin_timend_time = time.time()
    for i in range(capacity):
        s = '%064d' % i
        if s != ht[s]:
            raise Exception(s)
    end_time = time.time()
    print capacity / (end_time - begin_time), 'iops @ get'
    ht.close()",0,0,0,0,0,0,0,0,1
1415,"import math
from LinkedList import *
class Entry:
    def __str__(self):
        return str(self.value)
    def __init__(self, key = 0, value = 0):
        self.key = key
        self.value = value
class Link:
    def __str__(self):
        if self.next == None:
            return str(self.value) + "" ""
        else:
            return str(self.value) + "" "" + str(self.next)
    def __init__(self, key = 0, value = 0, next = None):
        self.key = key
        self.value = value
        self.next = next
def DivisionHash(key, size):
    return key % size
def AuxiliaryHash(key, size):
    A = 0.618
    return int(math.floor(size * ((key * A) % 1)))
def LinearHash(key, i, size):
    return (AuxiliaryHash(key, size) + i) % size
def AuxiliaryHash2(key, size):
    return 1 + (key % (size - 1))
def QuadraticHash(key, i, size):
    c_1 = 0.5
    c_2 = 0.5
    return int((AuxiliaryHash(key, size) + c_1 * i + c_2 * i * i) % size)
def DoubleHash(key, i, size):
    return int((DivisionHash(key, size) + i * AuxiliaryHash2(key, size)) % size)
class ChainedHashtable:
    Size = 23
    def put(self, key, value):
        llist = self.links[self.hash(key)]
        if llist == None:
            node = Link(key = key, value = value)
            llist = LinkedList(head=node)
            self.links[self.hash(key)] = llist
            return
        cur_node = llist.head
        while cur_node != None:
            if cur_node.key == key:
                cur_node.value = value
                return
            else:
                cur_node = cur_node.next
        llist.push(Link(key = key, value = value))
    def get(self, key):
        llist = self.links[self.hash(key)]
        if llist == None:
            return None
        cur_node = llist.head
        while cur_node != None:
            if cur_node.key == key:
                return cur_node.value
            else:
                cur_node = cur_node.next
        return None
    def search(self, key):
        llist = self.links[self.hash(key)]
        if llist == None:
            return str(self.hash(key))
        search_result = """"
        cur_node = llist.head
        search_result += str(self.hash(key)) + "" "" 
        while cur_node != None:
            search_result += str(cur_node.value) + "" ""
            if cur_node.key == key:
                return search_result
            else:
                cur_node = cur_node.next
        return search_result
    def insert(self, value):
        self.put(value, value)
    def hash(self, key):
        return DivisionHash(key, ChainedHashtable.Size)
    def __str__(self):
        lines = []
        for i in range(len(self.links)):
            if self.links[i] == None:
                lines.append("""" + str(i) + ""\t"")
            else:
                lines.append("""" + str(i) + ""\t"" + str(self.links[i]))
        return ""\n"".join(lines)
    def __init__(self):
        self.links = [None] * ChainedHashtable.Size
class LinearHashtable:
    Size = 32
    def get(self, key):
        i = 0
        entry = self.entries[self.hash(key, i)]
        while (entry == None or entry.key != key):
            i+=1
            if i == LinearHashtable.Size:
                return None
            entry = self.entries[self.hash(key, i)]
        return entry.value
    def search(self, key):
        i = 0
        search_result = """"
        entry = self.entries[self.hash(key, i)]
        search_result = str(self.hash(key, i)) + "" ""
        while (entry == None or entry.key != key):
            i+=1
            if i == LinearHashtable.Size:
                return search_result + ""-1""
            entry = self.entries[self.hash(key, i)]
            search_result += str(self.hash(key, i)) + "" ""
        return search_result
    def put(self, key, value):
        i = 0
        entry = self.entries[self.hash(key, i)]
        while (entry != None and entry.key != key):
            i+=1
            if i == LinearHashtable.Size:
                return
            entry = self.entries[self.hash(key, i)]
        if entry == None:
            entry = Entry(key = key, value = value)
            self.entries[self.hash(key, i)] = entry
        else:
            entry.value = value
    def insert(self, value):
        self.put(value, value)
    def hash(self, key, i):
        return LinearHash(key, i, LinearHashtable.Size)
    def __str__(self):
        lines = []
        for i in range(len(self.entries)):
            if self.entries[i] == None:
                lines.append("""" + str(i) + ""\t"" + ""-1"")
            else:
                lines.append("""" + str(i) + ""\t"" + str(self.entries[i].value))
        return ""\n"".join(lines)
    def __init__(self):
        self.entries = [None] * LinearHashtable.Size
class QuadraticHashtable:
    Size = 32
    def get(self, key):
        i = 0
        entry = self.entries[self.hash(key, i)]
        while (entry == None or entry.key != key):
            i+=1
            if i == QuadraticHashtable.Size:
                return None
            entry = self.entries[self.hash(key, i)]
        return entry.value
    def put(self, key, value):
        i = 0
        entry = self.entries[self.hash(key, i)]
        while (entry != None and entry.key != key):
            i+=1
            if i == LinearHashtable.Size:
                return
            entry = self.entries[self.hash(key, i)]
        if entry == None:
            entry = Entry(key = key, value = value)
            self.entries[self.hash(key, i)] = entry
        else:
            entry.value = value
    def search(self, key):
        i = 0
        search_result = """"
        entry = self.entries[self.hash(key, i)]
        search_result = str(self.hash(key, i)) + "" ""
        while (entry == None or entry.key != key):
            i+=1
            if i == LinearHashtable.Size:
                return search_result + ""-1""
            entry = self.entries[self.hash(key, i)]
            search_result += str(self.hash(key, i)) + "" ""
        return search_result
    def hash(self, key, i):
        return QuadraticHash(key, i, QuadraticHashtable.Size)
    def insert(self, value):
        self.put(value, value)
    def __str__(self):
        lines = []
        for i in range(len(self.entries)):
            if self.entries[i] == None:
                lines.append("""" + str(i) + ""\t"" + ""-1"")
            else:
                lines.append("""" + str(i) + ""\t"" + str(self.entries[i].value))
        return ""\n"".join(lines)
    def __init__(self):
        self.entries = [None] * QuadraticHashtable.Size
class DoubleHashtable:
    Size = 31
    def get(self, key):
        i = 0
        entry = self.entries[self.hash(key, i)]
        while (entry == None or entry.key != key):
            i+=1
            if i == DoubleHashtable.Size:
                return None
            entry = self.entries[self.hash(key, i)]
        return entry.value
    def put(self, key, value):
        i = 0
        entry = self.entries[self.hash(key, i)]
        while (entry != None and entry.key != key):
            i+=1
            if i+1 == LinearHashtable.Size:
                return
            entry = self.entries[self.hash(key, i)]
        if entry == None:
            entry = Entry(key = key, value = value)
            self.entries[self.hash(key, i)] = entry
        else:
            entry.value = value
    def search(self, key):
        i = 0
        search_result = """"
        entry = self.entries[self.hash(key, i)]
        search_result = str(self.hash(key, i)) + "" ""
        while (entry == None or entry.key != key):
            i+=1
            if i+1 == LinearHashtable.Size:
                return search_result + ""-1""
            entry = self.entries[self.hash(key, i)]
            search_result += str(self.hash(key, i)) + "" ""
        return search_result
    def insert(self, value):
        self.put(value, value)
    def hash(self, key, i):
        return DoubleHash(key, i, DoubleHashtable.Size)
    def __str__(self):
        lines = []
        for i in range(len(self.entries)):
            if self.entries[i] == None:
                lines.append("""" + str(i) + ""\t"" + ""-1"")
            else:
                lines.append("""" + str(i) + ""\t"" + str(self.entries[i].value))
        return ""\n"".join(lines)
    def __init__(self):
        self.entries = [None] * DoubleHashtable.Size",0,0,0,0,0,1,0,0,1
1416,"class HashTableEntry:
    def __init__(self, key, value, next=None):
        self.key = key
        self.value = value
        self.next = next
MIN_CAPACITY = 8
class HashTable:
    def __init__(self, capacity=MIN_CAPACITY):
        self.capacity = capacity
        self.storage = [0] * capacity
        self.itemCount = 0
    def get_num_slots(self):
        return len(self.storage)
    def get_load_factor(self):
        load = self.itemCount / self.capacity
        return load
    def fnv1(self, key):
    def djb2(self, key):
        hash = 5381
        for x in key:
            hash = ((hash << 5) + hash) + ord(x)
        return hash & 0xFFFFFFFF
    def hash_index(self, key):
        return self.djb2(key) % self.capacity
    def put(self, key, value):
        if self.get_load_factor() > 0.7:
            self.resize(self.capacity * 2)
        ind = self.hash_index(key)
        if self.storage[ind] == 0:
            self.storage[ind] = HashTableEntry(key, value)
        else:
            curr = self.storage[ind]
            while curr.next != None:
                if curr.key == key:
                    curr.value = value
                    self.itemCount += 1
                    break
                else:
                    curr = curr.next
            curr.next = HashTableEntry(key, value)
            self.itemCount += 1
    def delete(self, key):
        ind = self.hash_index(key)
        curr = self.storage[ind]
        prev = curr
        if curr != 0:
            count = 0
            while curr.key != None:
                if curr.key == key:
                    if curr.next == None and count == 0:
                        self.storage[ind] = 0
                        break
                    elif curr.next != None and count == 0:
                        self.storage[ind] = curr.next
                        break
                    elif curr.next == None and count > 0:
                        prev.next = None
                        break
                    else:
                        prev.next = curr.next
                        break
                else:
                    count += 1
                    prev = prev.next
                    curr = curr.next
        else:
            print('Warning key not found')
    def get(self, key):
        ind = self.hash_index(key)
        result = None
        if self.storage[ind] != 0:
            curr = self.storage[ind]
            while curr:
                if curr.key == key:
                    result = curr.value
                curr = curr.next
        return result
    def resize(self, new_capacity):
        self.capacity= new_capacity
        oldArr= self.storage
        newArr= [0] * new_capacity
        self.storage= newArr
        for i in range(len(oldArr) -1):
            if oldArr[i] != 0:
                curr = oldArr[i]
                while curr:
                    ind= self.hash_index(curr.key)
                    newArr[ind]= curr
                    curr= curr.next
if __name__ == ""__main__"":
    ht = HashTable(8)
    ht.put(""line_1"", ""'Twas brillig, and the slithy toves"")
    ht.put(""line_2"", ""Did gyre and gimble in the wabe:"")
    ht.put(""line_3"", ""All mimsy were the borogoves,"")
    ht.put(""line_4"", ""And the mome raths outgrabe."")
    ht.put(""line_5"", '""Beware the Jabberwock, my son!')
    ht.put(""line_6"", ""The jaws that bite, the claws that catch!"")
    ht.put(""line_7"", ""Beware the Jubjub bird, and shun"")
    ht.put(""line_8"", 'The frumious Bandersnatch!""')
    ht.put(""line_9"", ""He took his vorpal sword in hand;"")
    ht.put(""line_10"", ""Long time the manxome foe he sought--"")
    ht.put(""line_11"", ""So rested he by the Tumtum tree"")
    ht.put(""line_12"", ""And stood awhile in thought."")
    ht.put(""line_13"", ""And stood awhile in thought."")
    ht.put(""line_14"", ""And stood awhile in thought."")
    ht.put(""line_15"", ""And stood awhile in thought."")
    ht.put(""line_16"", ""And stood awhile in thought."")
    ht.put(""line_17"", ""And stood awhile in thought."")
    print("""")
    for i in range(1, 13):
        print(ht.get(f""line_{i}""))
    print('')
    old_capacity = ht.get_num_slots()
    ht.resize(ht.capacity * 2)
    new_capacity = ht.get_num_slots()
    print(f""\nResized from {old_capacity} to {new_capacity}.\n"")
    for i in range(1, 13):
        print(ht.get(f""line_{i}""))
    print("""")",0,0,0,0,0,1,0,0,1
1417,"from linked_list import LinkedList, Node
class HashTable:
    def __init__(self):
        self.buckets = [LinkedList() for i in range(1024)]
    def hash(self, key):
        ascii_sum_for_key = sum([ord(char) for char in key])
        prime_num = 599
        hashing_index = (ascii_sum_for_key * prime_num) % len(self.buckets)
        return hashing_index
    def add(self, key, value):
        index = self.hash(key)
        bucket = self.buckets[index]
        bucket.insert({'key':key, 'value':value})
    def get(self, key):
        index = self.hash(key)
        bucket = self.buckets[index]
        current = bucket.head
        while current:
            key_val_pair = current.value
            if key_val_pair['key'] == key:
                return key_val_pair['value']
            current = current.next
        else:
            raise(ValueError)
    def contains(self, key):
        index = self.hash(key)
        bucket = self.buckets[index]
        current = bucket.head
        while current:
            key_val_pair = current.value
            if key_val_pair['key'] == key:
                return True
            current = current.next ",0,0,0,0,0,1,0,0,1
1418,"class HashTable:
    def __init__(self, size):
        self.size = size
        self.array = [None for i in range(size)]
    def insert(self, data):
        target = hash(data) % self.size
        end = target
        while self.array[target] is not None:
            target = (target + 1) % self.size
            if target == end:
                return ""Hash table is full""
        self.array[target] = data
    def getIndex(self, data):
        target = hash(data) % self.size
        end = target
        while self.array[target] != data:
            target = (target + 1) % self.size
            if target == end:
                return -1
        return target
    def delete(self, data):
        target = self.getIndex(data)
        if target != -1:
            self.array[target] = None
        else:
            return False
    def exists(self, data):
        return not self.getIndex(data) == -1
    def __str__(self):
        res = """"
        for i in range(len(self.array)):
            res += str(i) + "": "" + str(self.array[i])
        return res",0,0,0,0,0,1,0,0,1
1419,"class HashTable:
    def __init__(self, bucket_cnt=0):
        self.bucket_count = bucket_cnt
        self.htable = []
        for i in range(0, bucket_cnt):
            self.htable.append([])
    def hash_function(self, key):
        count = 0
        for letter in key:
            count+=ord(letter)
        return count % self.bucket_count
    def add_entry(self, key, value):
        hash_val = self.hash_function(key)
        bucket = self.htable[hash_val]
        bucket.append([key, value])
    def retrieve_entry(self, key):
        hash_val = self.hash_function(key)
        bucket = self.htable[hash_val]
        for entry in bucket:
            if entry[0] == key:
                return entry[1]
        return None",0,0,0,0,0,1,0,0,1
1420,"package hashTable;
import java.util.LinkedList;
public class HashTable<T> {
    private static int INIT_TABLE_SIZE = 20;
    private LinkedList<Node<T>>[] bucket;
    private int size;
    @SuppressWarnings(""unchecked"")
    public HashTable(){
        this.bucket = new LinkedList[INIT_TABLE_SIZE];
        this.size = 0;
    }
    public int hash(String key){
        int hash = key.hashCode();
        return  Math.abs(hash) % this.bucket.length;
    }
    public Node<T> add(String key, T value){
        int index = hash(key);
        Node<T> newNode = new Node<>(key,value);
        if(this.bucket[index] == null){
            this.bucket[index] = new LinkedList<>();
        }
        this.bucket[index].add(newNode);
        this.size++;
        return newNode;
    }
    @SuppressWarnings(""unchecked"")
    public T get(String key){
        int index = hash(key);
        if(this.bucket[index] != null) {
            for (Node node : this.bucket[index]) {
                if (node.key.equals(key)) {
                    return (T) node.value;
                }
            }
        }
        return null;
    }
    public boolean contains(String key){
        int index = hash(key);
        if(this.bucket[index] != null){
            for( Node n : this.bucket[index]){
                if(n.key.equals(key)){
                    return true;
                }
            }
        }
        return false;
    }
    public int size(){
        return this.size;
    }
    private static class Node<T> {
        public String key;
        public T value;
        public Node next;
        public Node(String key, T value){
            this.key = key;
            this.value = value;
        }
        public String toString() {
            return this.key + "": "" + this.value;
        }
    }
    public static void main(String[] args) {
        HashTable hashTable = new HashTable();
        hashTable.add(""Yoko"", ""Rabbit"");
        hashTable.add(""Miko"", ""dog"");
        hashTable.add(""Hamster"", ""Buttons"");
        hashTable.add(""Hamster"", ""Rhino"");
        hashTable.add(""Hamster"", ""Sam"");
        hashTable.add(""Hamster"", ""Snowball"");
        hashTable.add(""German Shepard"", ""Germy"");
        hashTable.add(""Zebra"", ""Stripes"");
        System.out.println(""Get: "" + hashTable.get(""Hello""));
        for(LinkedList n :  hashTable.bucket){
            System.out.print(n + "", "");
            if(n != null){
                System.out.println(n.size());
            }
        }
    }
}",0,0,0,0,0,1,0,0,1
1421,"class HashTable:
    def __init__(self):
        self.size = 256
        self.hashmap = [[] for _ in range(0, self.size)]
    def hash_func(self, key):
        hashed_key = hash(key) % self.size
        return hashed_key
    def set(self, key, value):
        hash_key = self.hash_func(key)
        key_exists = False
        slot = self.hashmap[hash_key]
        for i, kv in enumerate(slot):
            k, v = kv
            if key == k:
                key_exists = True
                break
        if key_exists:
            slot[i] = ((key, value))
        else:
            slot.append((key, value))
    def get(self, key):
        hash_key = self.hash_func(key)
        slot = self.hashmap[hash_key]
        for kv in slot:
            k, v = kv
            if key == k:
                return v
            else:
                raise KeyError('Key does not exist.')
    def __setitem__(self, key, value):
        return self.set(key, value)
    def __getitem__(self, key):
        return self.get(key)
H = HashTable()
H.set('key1','value1')
H.set('key2','value2')
H.set('key3','value3')
H.set(10,'value10')
H.set(20, 'value20')
H['NEWWWWWWWWW'] = 'newwwwwwwww'
print(H['key1'])
print(H[10])
print(H[20])
print(H.hashmap)",0,0,0,0,0,1,0,0,1
1422,"public class HashTableBST<K extends Comparable<K>, V extends Comparable<V>> implements KWHashMap<K,V> {
    private BinaryTree<Entry<K,V>>[] table;
    private int numKeys;
    private static final int CAPACITY = 101;
    private static final double LOAD_THRESHOLD = 3.0;
    public HashTableBST(){
        table = new BinaryTree[CAPACITY];
    }
    @Override
    public V get(Object key) {
        int index = key.hashCode() % table.length;
        if(index<0){
            index += table.length;
        }
        if(table[index] == null){
            return null;
        }
        K k = (K) key;
        Entry<K,V> val = table[index].getSearch(new Entry<>(k,null));
        return val.getValue();
    }
    @Override
    public boolean isEmpty() {
        return table.length ==0;
    }
    @Override
    public V put(K key, V value) {
        int index = key.hashCode() % table.length;
        if(index<0){
            index += table.length;
        }
        if(table[index] == null){
            table[index] = new BinaryTree<>();
        }
        boolean flag = table[index].searchKey(new Entry<>(key,value));
        if(!flag){
            table[index].insert(new Entry<>(key,value));
            numKeys++;
            if(numKeys >(LOAD_THRESHOLD*table.length))
                rehash();
        }
        return null;
    }
    private void rehash(){
        BinaryTree<Entry<K,V>> [] oldTable = table;
        table = new BinaryTree[2*oldTable.length+1];
        numKeys = 0;
        for(int i=0; i<oldTable.length ; i++){
            if((oldTable[i] != null) ){
                table[i] = oldTable[i];
            }
        }
    }
    @Override
    public V remove(Object key) {
        int index = key.hashCode() % table.length;
        if(index<0){
            index += index +table.length;
        }
        if(table[index] == null){
            return null;
        }
        K k = (K) key;
        Entry<K,V> val = table[index].deleteSearch(new Entry<>(k,null));
        return val.getValue();
    }
    @Override
    public int size() {
        return table.length;
    }
    static class Entry<K extends Comparable<K>,V extends Comparable<V>> implements Comparable<Entry<K,V>>  {
        private final K key;
        private V value;
        public boolean inTable;
        public boolean isInTable() {
            return inTable;
        }
        public K getKey() {
            return key;
        }
        public V getValue() {
            return value;
        }
        public void setValue(V value) {
            this.value = value;
        }
        public Entry(K key , V value){
            this.key = key;
            this.value = value;
            inTable = true;
        }
        @Override
        public int compareTo(Entry<K, V> o) {
            return this.key.compareTo(o.getKey());
        }
    }
}",0,0,0,0,0,0,0,0,1
1423,"import java.nio.IntBuffer;
import java.util.LinkedList;
public class HashtableChain<K extends Comparable<K>, V extends Comparable<V>> implements KWHashMap<K, V> {
    private LinkedList<Entry<K, V>>[] table;
    private int numKeys;
    private static final int CAPACITY = 400000;
    private static final double LOAD_THRESHOLD = 3.0;
    public HashtableChain() {
        table = new LinkedList[CAPACITY];
    }
    @Override
    public V get(Object key) {
        int index = key.hashCode() % table.length;
        if (index < 0)
            index += table.length;
        if (table[index] == null)
            return null;  
        for (Entry<K, V> nextItem : table[index]) {
            if (nextItem.getKey().equals(key))
                return nextItem.getValue();
        }
        return null;
    }
    @Override
    public boolean isEmpty() {
        return size()==0;
    }
    @Override
    public V put(K key, V value) {
        int index = key.hashCode() % table.length;
        if (index < 0)
            index += table.length;
        if (table[index] == null) {
            table[index] = new LinkedList<>();
        }
        for (Entry<K, V> nextItem : table[index]) {
            if (nextItem.getKey().equals(key)) {
                V oldVal = nextItem.getValue();
                nextItem.setValue(value);
                return oldVal;
            }
        }
        table[index].addFirst(new Entry<>(key, value));
        numKeys++;
        if (numKeys > (LOAD_THRESHOLD * table.length))
            rehash();
        return null;
    }
    private void rehash() {
        LinkedList<Entry<K, V>>[] oldTable = table;
        table = new LinkedList[(CAPACITY *2) +1];
        numKeys = 0;
        for (int i = 0; i < oldTable.length; i++) {
            if ((oldTable[i] != null)) {
                table[i].addAll(oldTable[i]);
            }
        }
    }
    @Override
    public V remove(Object key) {
        int index = key.hashCode() % table.length;
        if(index<0){
            index += table.length;
        }
        if (table[index] == null){
            return null;
        }
        for (Entry<K, V> nextItem : table[index]) {
            if (nextItem.getKey().equals(key)) {
                V oldVal = nextItem.getValue();
                nextItem.setValue(null);
                return oldVal;
            }
        }
        return null;
    }
    @Override
    public int size() {
        return table.length;
    }
    private static class Entry<K extends Comparable<K>,V extends Comparable<V>> implements Comparable<Entry<K,V>>  {
        private final K key;
        private V value;
        public boolean inTable;
        public boolean isInTable() {
            return inTable;
        }
        public K getKey() {
            return key;
        }
        public V getValue() {
            return value;
        }
        public void setValue(V value) {
            this.value = value;
        }
        public Entry(K key , V value){
            this.key = key;
            this.value = value;
            inTable = true;
        }
        @Override
        public int compareTo(Entry<K, V> o) {
            return this.key.compareTo(o.getKey());
        }
    }
}",0,0,0,0,0,1,0,0,1
1424,"class HashTableChaining implements HashTable {
  private final ChainedList[] arr;
  private final HashFunction func;
  public HashTableChaining(HashFunction f) {
    arr = new ChainedList[f.size()];
    func = f;
  }
  @Override
  public boolean put(Object key, Object val) {
    if (key == null || val == null) return false;
    int i = func.compute(key);
    if (arr[i] == null) {
      arr[i] = new ChainedList(key, val);
      return true;
    }
    ChainedList.ListElement searchRes = arr[i].search(key);
    if (searchRes == null) {
      arr[i].add(key, val);
      return true;
    }
    searchRes.setVal(val);
    return true;
  }
  @Override
  public Object get(Object key) {
    if (key == null) return null;
    int i = func.compute(key);
    if (arr[i] == null) return null;
    if (arr[i].search(key) == null) return null;
    return arr[i].search(key).getVal();
  }
  @Override
  public boolean remove(Object key) {
    if (key == null) return false;
    int i = func.compute(key);
    if (arr[i] == null) return false;
    return arr[i].remove(key);
  }
  @Override
  public void dump() {
    StringBuilder out = new StringBuilder();
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] != null) {
        out.append(arr[i].dump(i));
      }
    }
    System.out.print(out);
  }
  private static class ChainedList {
    private ListElement first;
    private ChainedList(Object firstKey, Object firstVal) {
      this.first = new ListElement(null, firstKey, firstVal);
    }
    private void add(Object key, Object val) {
      first = new ListElement(first, key, val);
    }
    private boolean remove(Object key) {
      if (first == null) return false;
      if (first.key.equals(key)) {
        first = first.next;
        return true;
      }
      ListElement prevKeyElem = first;
      while (prevKeyElem.next != null && !prevKeyElem.next.key.equals(key)) {
        prevKeyElem = prevKeyElem.next;
      }
      if (prevKeyElem.next == null) return false;
      prevKeyElem.next = prevKeyElem.next.next;
      return true;
    }
    private ListElement search(Object key) {
      if (first == null) return null;
      return first.search(key);
    }
    private String dump(int index) {
      if (first == null) return """";
      return first.dump(index);
    }
    private static class ListElement {
      private ListElement next;
      private final Object key;
      private Object val;
      private ListElement(ListElement next, Object key, Object val) {
        this.next = next;
        this.key = key;
        this.val = val;
      }
      private void setVal(Object val) {
        this.val = val;
      }
      private Object getVal() {
        return val;
      }
      private ListElement search(Object key) {
        if (this.key.equals(key)) {
          return this;
        }
        if (next == null) return null;
        return next.search(key);
      }
      private String dump(int index) {
        String out = String.format(""%d %s %s\n"", index, key, val);
        if (next == null) return out;
        return out += next.dump(index);
      }
    }
  }
}",0,0,0,0,0,1,0,0,1
1425,"public class HashTableLin {
    public Integer[] table;
    private int maxLoad, size, load;
    private double loadFactor;
    public int probeCount = 0;
    public HashTableLin(int maxLoad, double load){
        this.maxLoad = maxLoad;
        this.loadFactor = load;
        int minSize = (int) (maxLoad/load);
        while(this.isPrime(minSize) == false){
            minSize++;
        }
        table = new Integer[minSize];
        this.size = minSize;
        this.load = 0;
    }
    public void insert(int n){
        int hashIndex = n % this.size;
        if((this.load +1) > this.maxLoad){
            this.rehash();
            this.insert(n);
        }
        else{
            load++;
            while(this.table[hashIndex] != null){
                probeCount++;
                if(this.table[hashIndex] == n){
                    return;
                }
                if(hashIndex < (this.size-1)){
                    hashIndex++;
                }
                else{
                    hashIndex = 0;
                }
            }
            this.table[hashIndex] = n;
        }
    }
    public void rehash(){
        HashTableLin temp;  
        temp = new HashTableLin((this.size * 2), this.loadFactor);
        for(int i=0; i<this.size; i++){
            if(this.table[i] != null){
                temp.insert(this.table[i]);
            }
        }
        this.table = temp.table;
        this.maxLoad = temp.maxLoad;
        this.size = temp.size;
        this.load = temp.load;
    }
    public boolean isIn(int n){
        int hashIndex = n % this.size;
        while(this.table[hashIndex] != null){
            if(this.table[hashIndex] == n){
                return true;
            }
            if(hashIndex < (this.size-1)){
                hashIndex++;
            }
            else{
                hashIndex = 0;
            }
        }
        return false;
    }
    public void printKeys(){
        for(int i=0; i<this.size; i++){
            if(this.table[i] != null){
                System.out.println(this.table[i]);
            }
        }
    }
    public void printKeysAndIndexes(){
        System.out.println(""Key ==> Index"");
        for(int i=0; i<this.size; i++){
            if(this.table[i] != null){
                System.out.println(this.table[i] + "" ==> "" + i);
            }
        }
    }
    public int getMaxLoad(){
        return this.maxLoad;
    }
    public int getNumOfKeys(){
        return this.load;
    }
    public int getTableSize(){
        return this.size;
    }
    public double getLoadFactor(){
        return this.loadFactor;
    }
    private boolean isPrime(int num){
        int tracker = 0;
        for(int i=2; i<(Math.sqrt(num)); i++){
            if(num%i == 0){
                tracker++;
            }
        }
        if(tracker == 0) return true;
        else return false;
    }
}",0,0,0,0,0,1,0,0,1
1426,"public class HashtableOpen<K extends Comparable<K>,V extends Comparable<V>> implements KWHashMap<K,V> {
    private Entry<K, V>[] table;
    private static final int START_CAPACITY = 101;
    private double LOAD_THRESHOLD = 0.75;
    private int numKeys;
    private int numDeletes;
    private final Entry<K, V> DELETED = new Entry<>(null, null);
    public HashtableOpen() {
        table = new Entry[START_CAPACITY];
    }
    private int find(Object key) {
        int index = key.hashCode() % table.length;
        if (index < 0)
            index += table.length;  
        while ((table[index] != null)
                && (!key.equals(table[index].getKey()))) {
            index++;
            if (index >= table.length)
                index = 0;  
        }
        return index;
    }
    @Override
    public V get(Object key) {
        int index = find(key);
        if (table[index] != null)
            return table[index].getValue();
        else
            return null;  
    }
    @Override
    public boolean isEmpty() {
        return numKeys == 0;
    }
    @Override
    public V put(K key, V value) {
        int index = find(key);
        if (table[index] == null) {
            table[index] = new Entry<>(key, value);
            numKeys++;
            double loadFactor =
                    (double) (numKeys + numDeletes) / table.length;
            if (loadFactor > LOAD_THRESHOLD)
                rehash();
            return null;
        }
        V oldVal = table[index].getValue();
        table[index].setValue(value);
        return oldVal;
    }
    private void rehash() {
        Entry<K, V>[] oldTable = table;
        table = new Entry[2 * oldTable.length + 1];
        numKeys = 0;
        numDeletes = 0;
        for (int i = 0; i < oldTable.length; i++) {
            if ((oldTable[i] != null) && (oldTable[i] != DELETED)) {
                put(oldTable[i].getKey(), oldTable[i].getValue());
            }
        }
    }
    @Override
    public V remove(Object key) {
        int index = find(key);
        if(table[index] == null){
            return null;
        }
        V temp = table[index].getValue();
        table[index] = DELETED;
        numDeletes++;
        numKeys--;
        return temp;
    }
    @Override
    public int size() {
        return numKeys;
    }
    static class Entry<K extends Comparable<K>,V extends Comparable<V>> implements Comparable<Entry<K,V>>  {
        private final K key;
        private V value;
        public boolean inTable;
        public boolean isInTable() {
            return inTable;
        }
        public K getKey() {
            return key;
        }
        public V getValue() {
            return value;
        }
        public void setValue(V value) {
            this.value = value;
        }
        public Entry(K key , V value){
            this.key = key;
            this.value = value;
            inTable = true;
        }
        @Override
        public int compareTo(Entry<K, V> o) {
            return this.key.compareTo(o.getKey());
        }
    }
}",0,0,0,0,0,0,0,0,1
1427,"public class HashTableOpenAddressing implements HashTable {
  private final HashSequence seq;
  private final Entry[] arr;
  public HashTableOpenAddressing(HashSequence seq) {
    this.seq = seq;
    this.arr = new Entry[seq.size()];
  }
  private HelperObj helperFunc(Object key){
    int ind = seq.first(key);
    int remembered = -1;
    for(int j = 0; j < seq.size(); j++){
      if(arr[ind] == null) return new HelperObj(remembered == -1?ind:remembered, HelperObj.nichtVorhanden);
      if(arr[ind].isDelMarker() && remembered == -1) remembered = ind;
      if(!arr[ind].isDelMarker() && arr[ind].getKey().equals(key)) return new HelperObj(ind, HelperObj.vorhanden);
      ind = seq.next();
    }
    if(remembered != -1) return new HelperObj(remembered, HelperObj.nichtVorhanden);
    return new HelperObj(-1, HelperObj.tabelleVoll);
  }
  @Override
  public boolean put(Object key, Object val) {
    if(key == null || val == null) return false;
    HelperObj h = helperFunc(key);
    if(h.status == HelperObj.tabelleVoll) return false;
    arr[h.index] = new Entry(false, key, val);
    return true;
  }
  @Override
  public Object get(Object key) {
    if(key == null) return null;
    HelperObj h = helperFunc(key);
    if(h.status == HelperObj.vorhanden){
      Entry entry = arr[h.index];
      return entry.getVal();
    }
    return null;
  }
  @Override
  public boolean remove(Object key) {
    if(key == null) return false;
    HelperObj h = helperFunc(key);
    if(h.status == HelperObj.nichtVorhanden || h.status == HelperObj.tabelleVoll) return false;
    arr[h.index] = new Entry(true, null, null);
    return true;
  }
  @Override
  public void dump() {
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] != null && !arr[i].isDelMarker()) {
        Entry entry = arr[i];
        System.out.println(String.format(""%d %s %s"", i, entry.getKey(), entry.getVal()));
      }
    }
  }
  private static class HelperObj {
    static final int nichtVorhanden = -1;
    static final int vorhanden = 1;
    static final int tabelleVoll = 0;
    final int index;
    final int status;
    private HelperObj(int index, int status) {
      this.index = index;
      this.status = status;
    }
  }
  private static class Entry {
    private final boolean isDelMarker;
    private final Object key;
    private final Object val;
    private Entry(boolean isDelMarker, Object key, Object val) {
      this.isDelMarker = isDelMarker;
      this.key = key;
      this.val = val;
    }
    private boolean isDelMarker() {
      return isDelMarker;
    }
    private Object getVal() {
      return val;
    }
    private Object getKey() {
      return key;
    }
  }
}",0,0,0,0,0,0,0,0,1
1428,"public class HashTableQuad {
    public Integer[] table;
    private int maxLoad, size, load;
    private double loadFactor;
    public int probeCount = 0;
    public HashTableQuad(int maxLoad, double load){
        this.maxLoad = maxLoad;
        this.loadFactor = load;
        int minSize = (int) (maxLoad/load);
        while(this.isPrime(minSize) == false){
            minSize++;
        }
        table = new Integer[minSize];
        this.size = minSize;
        this.load = 0;
    }
    public void insert(int n){
        int orgIndex = n % this.size;
        int hashIndex = n % this.size;
        int jump = 0;
        if((this.load +1) > this.maxLoad){
            this.rehash();
            this.insert(n);
        }
        else{
            load++;
            while(this.table[hashIndex] != null){
                probeCount++;
                if(this.table[hashIndex] == n){
                    return;
                }
                jump++;
                if((orgIndex + Math.pow(jump, 2)) < (this.size-1)){
                    hashIndex = (int)(orgIndex + Math.pow(jump, 2));
                }
                else{
                    hashIndex = (int)(orgIndex + Math.pow(jump, 2)) % this.size;
                }
            }
            this.table[hashIndex] = n;
        }
    }
    public void rehash(){
        HashTableQuad temp;  
        temp = new HashTableQuad((this.size * 2), this.loadFactor);
        for(int i=0; i<this.size; i++){
            if(this.table[i] != null){
                temp.insert(this.table[i]);
            }
        }
        this.table = temp.table;
        this.maxLoad = temp.maxLoad;
        this.size = temp.size;
        this.load = temp.load;
    }
    public boolean isIn(int n){
        int orgIndex = n % this.size;
        int hashIndex = n % this.size;
        int jump = 0;
        while(this.table[hashIndex] != null){
            if(this.table[hashIndex] == n){
                return true;
            }
            jump++;
            if((orgIndex + Math.pow(jump, 2)) < (this.size-1)){
                hashIndex = (int)(orgIndex + Math.pow(jump, 2));
            }
            else{
                hashIndex = (int)(orgIndex + Math.pow(jump, 2)) % this.size;
            }
        }
        return false;
    }
    public void printKeys(){
        for(int i=0; i<this.size; i++){
            if(this.table[i] != null){
                System.out.println(this.table[i]);
            }
        }
    }
    public void printKeysAndIndexes(){
        System.out.println(""Key ==> Index"");
        for(int i=0; i<this.size; i++){
            if(this.table[i] != null){
                System.out.println(this.table[i] + "" ==> "" + i);
            }
        }
    }
    public int getMaxLoad(){
        return this.maxLoad;
    }
    public int getNumOfKeys(){
        return this.load;
    }
    public int getTableSize(){
        return this.size;
    }
    public double getLoadFactor(){
        return this.loadFactor;
    }
    private boolean isPrime(int num){
        int tracker = 0;
        for(int i=2; i<(Math.sqrt(num)); i++){
            if(num%i == 0){
                tracker++;
            }
        }
        if(tracker == 0) return true;
        else return false;
    }
}",0,0,0,0,0,1,0,0,1
1429,"class HashTable(object):
    def __init__(self):
        self.table = [None]*10000
    def store(self, string):
        hash_value = self.calculate_hash_value(string)
        if self.table[hash_value] != None:
            self.table[hash_value].append(string)
        else:
            self.table[hash_value] = [string]
    def lookup(self, string):
        hash_value = self.calculate_hash_value(string)
        if self.table[hash_value] != None:
            if string in self.table[hash_value]:
                return hash_value
        return -1
    def calculate_hash_value(self, string):
        hash_value = ord(string[0])*100+ord(string[1])
        return hash_value
hash_table = HashTable()
print hash_table.calculate_hash_value('UDACITY')
print hash_table.lookup('UDACITY')
hash_table.store('UDACITY')
print hash_table.lookup('UDACITY')
hash_table.store('UDACIOUS')
print hash_table.lookup('UDACIOUS')",0,0,0,0,0,0,0,0,1
1430,"import {HashMap} from '../hashmap/';
import {Container} from '../hashmap/container';
import {some, none} from ""../option"";
export class LinkedHashMap extends HashMap {
    constructor(copy) {
        super(copy);
        if (this.size === 0) {
            this.start = undefined;
            this.end = undefined;
        }
    }
    clear() {
        this.start = undefined;
        this.end = undefined;
        return super.clear();
    }
    setLeft(key, value, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.addToStart = true;
        this.buckets.set(key, value, op);
        return this;
    }
    emplaceLeft(key, handler, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.addToStart = true;
        return this.buckets.emplace(key, handler, op);
    }
    push(key, value, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        this.buckets.set(key, value, op);
        return this;
    }
    pushEmplace(key, handler, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        return this.buckets.emplace(key, handler, op);
    }
    unshift(key, value, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        op.addToStart = true;
        this.buckets.set(key, value, op);
        return this;
    }
    unshiftEmplace(key, handler, overrides) {
        const op = this.equalsAndHash(key, overrides);
        op.moveOnUpdate = true;
        op.addToStart = true;
        return this.buckets.emplace(key, handler, op);
    }
    shift() {
        const entry = this.start;
        if (entry) {
            entry.parent.deleteEntry(entry);
            return entry.slice();
        }
        return undefined;
    }
    pop() {
        const entry = this.end;
        if (entry) {
            entry.parent.deleteEntry(entry);
            return entry.slice();
        }
        return undefined;
    }
    head() {
        const entry = this.start;
        if (entry) {
            return entry[1];
        }
        return undefined;
    }
    tail() {
        const entry = this.end;
        if (entry) {
            return entry[1];
        }
        return undefined;
    }
    optionalHead() {
        const entry = this.start;
        if (entry) {
            return some(entry[1]);
        }
        return none;
    }
    optionalTail() {
        const entry = this.end;
        if (entry) {
            return some(entry[1]);
        }
        return none;
    }
    headKey() {
        const entry = this.start;
        if (entry) {
            return entry[0];
        }
        return undefined;
    }
    tailKey() {
        const entry = this.end;
        if (entry) {
            return entry[0];
        }
        return undefined;
    }
    optionalHeadKey() {
        const entry = this.start;
        if (entry) {
            return some(entry[0]);
        }
        return none;
    }
    optionalTailKey() {
        const entry = this.end;
        if (entry) {
            return some(entry[0]);
        }
        return none;
    }
    reverse(){
        if(this.size > 1){
            let entry = this.start;
            do {
                const previous = entry.previous;
                const next = entry.next;
                entry.previous = next;
                entry.next = previous;
                entry = next;
            } while(entry);
            const start = this.start;
            this.start = this.end;
            this.end = start;
        }
        return this;
    }
    clone() {
        return new LinkedHashMap(this);
    }
    * [Symbol.iterator]() {
        yield* this.entries();
    }
    * entries() {
        let entry = this.start;
        while (entry) {
            yield entry.slice();
            entry = entry.next;
        }
    }
    * entriesRight() {
        let entry = this.end;
        while (entry) {
            yield entry.slice();
            entry = entry.previous;
        }
    }
    * keys() {
        let entry = this.start;
        while (entry) {
            yield entry[0];
            entry = entry.next;
        }
    }
    * values() {
        let entry = this.start;
        while (entry) {
            yield entry[1];
            entry = entry.next;
        }
    }
    * keysRight() {
        let entry = this.end;
        while (entry) {
            yield entry[0];
            entry = entry.previous;
        }
    }
    * valuesRight() {
        let entry = this.end;
        while (entry) {
            yield entry[1];
            entry = entry.previous;
        }
    }
}
Object.defineProperty(LinkedHashMap.prototype, 'createContainer', {
    value: function createContainer(parent, hash) {
        return new LinkedContainer(this, parent, hash);
    },
    configurable: true
});
export class LinkedContainer extends Container {
    constructor(map, parent, hash) {
        super(map, parent, hash);
    }
    createEntry(key, value, overrides) {
        const entry = super.createEntry(key, value, overrides);
        const map = this.map;
        if (map.start === undefined) {
            map.end = map.start = entry;
        } else if (overrides.addToStart) {
            map.start.previous = entry;
            entry.next = map.start;
            map.start = entry;
        } else {
            map.end.next = entry;
            entry.previous = map.end;
            map.end = entry;
        }
        return entry;
    }
    updateEntry(entry, newValue, overrides) {
        super.updateEntry(entry, newValue, overrides);
        if (overrides.moveOnUpdate) {
            if (overrides.addToStart) {
                if (entry.previous) {
                    if (entry.next) {
                        entry.next.previous = entry.previous;
                    }
                    entry.previous.next = entry.next;
                    if (entry === this.map.end) {
                        this.map.end = entry.previous;
                    }
                    entry.previous = undefined;
                    this.map.start.previous = entry;
                    entry.next = this.map.start;
                    this.map.start = entry;
                }
            } else if (entry.next) {
                if (entry.previous) {
                    entry.previous.next = entry.next;
                }
                entry.next.previous = entry.previous;
                if (entry === this.map.start) {
                    this.map.start = entry.next;
                }
                entry.next = undefined;
                this.map.end.next = entry;
                entry.previous = this.map.end;
                this.map.end = entry;
            }
        }
    }
    deleteIndex(idx) {
        const oldEntry = super.deleteIndex(idx);
        const map = this.map;
        if (oldEntry.previous) {
            oldEntry.previous.next = oldEntry.next;
        } else {
            map.start = oldEntry.next;
        }
        if (oldEntry.next) {
            oldEntry.next.previous = oldEntry.previous;
        } else {
            map.end = oldEntry.previous;
        }
    }
}",0,0,0,0,0,0,0,0,0
1431,"(function (factory, window) {
    ""use strict"";
    var hashmapUrl = {
        amd: ""./hashmap"",
        node: ""hashmap"",
        browser: ""HashMap""
    }
    if(typeof define === ""function"" && define.amd) {
        define([hashmapUrl.amd], factory);
    }
    else if (typeof exports === ""object"") {
        exports.SpatialHashMap = factory( require(hashmapUrl.node).HashMap );
    }
    else {
        window.SpatialHashMap = factory( window[hashmapUrl.browser] );
    }
}(function(HashMap) {
    ""use strict"";
    HashMap.prototype.Get = function(key) {
        var data = this.get(key);
        if(!data) {
            var data = [];
            this.set(key, data);
        }
        return data;
    }
    var Key = function(cell) {
        return cell.x + "":"" + cell.y;
    }
    var Keys = function(cells) {
        var result = [];
        for(var i = 0, len = cells.length; i < len; i++) {
            result.push(this.key(cells[i]));
        }
        return result;
    }
    var cellInArray = function(arr, item) {
        for(var i = 0, len = arr.length; i < len; i++) {
            if(arr[i].x === item.x && arr[i].y === item.y) {
                return true;
            }
        }
        return false;
    }
    var removeFromCell = function(grid, cell, obj) {
        var key = Key(cell);
        var objectsInCell = grid[key] || [];
        var index = objectsInCell.indexOf(obj);
        if(index > -1) {
            grid[key] = objectsInCell.splice(index, 1);
        }
    }
    var addToCell = function(grid, cell, obj) {
        var key = Key(cell);
        var objectsInCell = grid[key];
        if(!objectsInCell) {objectsInCell = grid[key] = [];}
        objectsInCell.push(obj);
    }
    var removeFromCells = function(grid, cells, obj) {
        for(var i = 0, len = cells.length; i < len; i++) {
            removeFromCell(grid, cells[i], obj);
        }
    }
    var addToCells = function(grid, cells, obj) {
        for(var i = 0, len = cells.length; i < len; i++) {
            addToCell(grid, cells[i], obj);
        }
    }
    var concat = function(orig, other) {
        Array.prototype.push.call(orig, other);
    }
    var sanitize = function(arr, exclude) {
        if(!(exclude instanceof Array)) {exclude = [exclude];}
        var result = [];
        for(var i = 0, len = arr.length; i < len; i++) {
            var item = arr[i];
            if(result.indexOf(item) === -1 && exclude.indexOf(item) === -1) {
                result.push(item);
            }
        }
        return result;
    }
    var removeDuplicates = function(arr) {
        var result = [];
        for(var i = 0, len = arr.length; i < len; i++) {
            var item = arr[i];
            if(result.indexOf(item) === -1) {
                result.push(item);
            }
        }
    }
    var removeDuplicateCells = function(arr) {
        var result = [];
        for(var i = 0, len = arr.length; i < len; i++) {
            var item = arr[i];
            if(!cellInArray(result, arr[i])) {
                result.push(item);
            }
        }
    }
    function SpatialHashMap(cellSize) {
        this.cellSize = cellSize;
        this.grid = {};
        this.objects = new HashMap();
        return this;
    }
    SpatialHashMap.prototype.add = function(aabb, obj) {
        var cells = this.cellsForAABB(aabb);
        addToCells(this.grid, cells, obj);
        this.objects.set(obj, {AABB: aabb, cells: cells});
        return this;
    }
    SpatialHashMap.prototype.remove = function(obj) {
        var cells = this.cellsForObject(obj);
        removeFromCells(this.grid, cells, obj);
        return this;
    }
    SpatialHashMap.prototype.moveAndResizeBy = SpatialHashMap.prototype.moveAndResize = function(diff, obj) {
        var object = this.objects.get(obj);
        var aabb = object.AABB;
        var oldCells = this.cellsForAABB(aabb);
        aabb.x += diff.x;
        aabb.y += diff.y;
        aabb.w += diff.w;
        aabb.h += diff.w;
        var newCells = this.cellsForAABB(aabb);
        var cellsToRemove = oldCells.map(function(cell) {
            return newCells.indexOf(cell) === -1;
        });
        var cellsToAdd = newCells.map(function(cell) {
            return oldCells.indexOf(cell) === -1;
        });
        removeFromCells(this.grid, cellsToRemove, obj);
        addToCells(this.grid, cellsToAdd, obj);
        object.cells = newCells;
        return this;
    }
    SpatialHashMap.prototype.moveAndResizeTo = function(newAABB, obj) {
        var oldAABB = this.getAABB(obj);
        var diff = {x: newAABB.x - oldAABB.x,  y: newAABB.y - oldAABB.y,  w: newAABB.w - oldAABB.w,  h: newAABB.h - oldAABB.h};
        this.moveAndResizeBy(diff, obj);
        return this;
    }
    SpatialHashMap.prototype.resizeBy = function(diff, obj) {
        diff .x = 0;
        diff.y = 0;
        this.moveAndResizeBy(diff, obj);
        return this;
    }
    SpatialHashMap.prototype.resizeTo = function(newSize, obj) {
        var aabb = this.getAABB(obj);
        var diff = {x: 0, y: 0,  w: newSize.w - aabb.w,  h: newSize.h - aabb.h};
        this.moveAndResizeBy(diff, obj);
        return this;
    }
    SpatialHashMap.prototype.moveBy = SpatialHashMap.prototype.move = function(diff, obj) {
        diff.w = 0;
        diff.h = 0;
        this.moveAndResizeBy(diff, obj);
        return this;
    }
    SpatialHashMap.prototype.moveTo = function(newPos, obj) {
        var aabb = this.getAABB(obj);
        var diff = {x: newPos.x - aabb.x,   y: newPos.y - aabb.y,  w: 0,  h: 0};
        this.moveAndResizeBy(diff, obj);
        return this;
    }
    SpatialHashMap.prototype.getAABB = function(obj) {
        return this.objects.get(obj).AABB;
    }
    SpatialHashMap.prototype.getAABBs = function(objs) {
        var aabbs = [];
        for(var i = 0, len = objs.length; i < len; i++) {
            aabbs.push(this.getAABB(objs[i]));
        }
        return aabbs;
    }
    SpatialHashMap.prototype.cellForVector = function(vec) {
        var cellSize = this.cellSize;
        var x = Math.floor(vec.x / cellSize);
        var y = Math.floor(vec.y / cellSize);
        return {x:x, y:y};
    }
    SpatialHashMap.prototype.cellsForAABB = function(aabb) {
        var cellSize = this.cellSize;
        var Xmin = Math.floor(aabb.x / cellSize);
        var Xmax = Math.ceil((aabb.x + aabb.w) / cellSize);
        var Ymin = Math.floor(aabb.y / cellSize);
        var Ymax = Math.ceil((aabb.y + aabb.h) / cellSize);
        var cells = [];
        for(var x = Xmin; x < Xmax; x++) {
            for(var y = Ymin; y < Ymax; y++) {
                cells.push({x:x, y:y});
            }
        }
        return cells;
    }
    SpatialHashMap.prototype.cellsForAABBs = function(aabbs, raw) {
        var cells = [];
        for(var i = 0, len = aabbs.length; i < len; i++) {
            concat(cells, this.cellsForAABB(aabbs[i]));
        }
        return raw ? cells : removeDuplicateCells(cells);
    }
    SpatialHashMap.prototype.cellsForObject = function(obj) {
        return this.objects.get(obj).cells;
    }
    SpatialHashMap.prototype.cellsForObjects = function(objs, raw) {
        var cells = [];
        for(var i = 0, len = objs.length; i < len; i++) {
            concat(cells, this.cellsForObject(objs[i]));
        }
        return raw ? cells : removeDuplicateCells(cells);
    }
    SpatialHashMap.prototype.objectsForCell = function(cell) {
        return this.grid.Get(cell);
    }
    SpatialHashMap.prototype.objectsForCells = function(cells, raw) {
        var objects = [];
        for(var i = 0, len = cells.length; i < len; i++) {
            concat(objects, this.grid.Get(cells[i]));
        }
        return raw ? objects : removeDuplicates(objects);
    }
    SpatialHashMap.prototype.objectsForObject = function(obj, raw) {
        var cells = this.cellsForObject(obj);
        var objects = this.objectsForCells(cells, true);
        return raw ? objects : sanitize(objects, obj);
    }
    SpatialHashMap.prototype.objectsForObjects = function(objs, raw) {
        var cells = this.cellsForObjects(objs);
        var objects = this.objectsForCells(cells, true);
        return raw ? objects : sanitize(objects, objs);
    }
    SpatialHashMap.prototype.objectsForAABB = function(aabb, raw) {
        var cells = this.cellsForAABB(aabb);
        return this.objectsForCells(cells, raw);
    }
    SpatialHashMap.prototype.objectsForAABBs = function(aabbs, raw) {
        var cells = this.cellsForAABBs(aabbs, raw);
        return this.objectsForCells(cells, raw);
    }
    SpatialHashMap.prototype.AABBsForCell = function(cell) {
        var objects = this.objectsForCell(cell);
        return this.getAABBs(objects);
    }
    SpatialHashMap.prototype.AABBsForCells = function(cells, raw) {
        var objects = this.objectsForCells(cells, raw);
        return this.getAABBs(objects);
    }
    SpatialHashMap.prototype.AABBsForObject = function(obj, raw) {
        var cells = this.cellsForObject(obj, raw);
        return this.AABBsForCells(cells, raw);
    }
    SpatialHashMap.prototype.AABBsForObjects = function(objs, raw) {
        var cells = this.cellsForObjects(objs, raw);
        return this.AABBsForCells(cells, raw);
    }
    SpatialHashMap.prototype.AABBsForAABB = function(aabb, raw) {
        var cells = this.cellsForAABB(aabb, raw);
        return this.AABBsForCells(cells, raw);
    }
    SpatialHashMap.prototype.AABBsForAABBs = function(aabbs, raw) {
        var cells = this.cellsForAABBs(aabbs, raw);
        return this.AABBsForCells(cells, raw);
    }
    return SpatialHashMap;
}, window));",0,0,0,0,0,0,0,0,0
1432,"from collections import MutableMapping
class MapBase(MutableMapping):
    class _Item:
        __slots__ = '_key', '_value'
        def __init__(self, k, v):
            self._key = k
            self._value = v
        def __eq__(self, other):
            return self._key == other._key
        def __ne__(self, other):
            return not(self == other)
        def __lt__(self, other):
            return self._key < other._key",0,0,0,0,0,0,0,0,0
1433,"class MultiMap:
    _MapType = dict         
    def __init__(self):
        self._map = self._MapType()
        self._n = 0
    def __len__(self):
        return self._n
    def __iter__(self):
        for k,secondary in self._map.items():
            for v in secondary:
                yield (k,v)
    def add(self, k, v):
        container = self._map.setdefault(k, [])
        container.append(v)
        self._n += 1
    def pop(self, k):
        secondary = self._map[k]
        v = secondary.pop()
        if len(secondary) == 0:
            del self._map[k]
        self._n -= 1
        return (k,v)
    def find(self, k):
        secondary = self._map[k]
        return (k, secondary[0])
    def find_all(self, k):
        secondary = self._map.get(k, [])
        for v in secondary:
            yield (k,v)",0,0,0,0,0,0,0,0,0
1434,"package answers.map;
import lombok.AllArgsConstructor;
import lombok.ToString;
@ToString(of = ""buckets"")
@AllArgsConstructor
class MyHashMap<K, V> implements MyMap<K, V> {
    private Buckets<K, V> buckets;
    private static final double LOAD_FACTOR = 0.75;
    MyHashMap() {
        this.buckets = Buckets.of();
    }
    public void put(K key, V value) {
        if (loadFactorExceeded()) {
            resize();
        }
        buckets.insert(key, value);
    }
    public V get(K key) {
        return buckets.get(key);
    }
    public long size() {
        return buckets.countElementsInBuckets();
    }
    private void resize() {
        buckets = buckets.withDoubledBucketsCount();
    }
    private boolean loadFactorExceeded() {
        return buckets.loadFactorExceeded(LOAD_FACTOR);
    }
}",0,0,0,0,0,0,0,0,0
1435,"package edu.luc.cs271.myhashmap;
import java.util.*;
public class MyHashMap<K, V> implements Map<K, V> {
  private static final int DEFAULT_TABLE_SIZE = 11;  
  private List<List<Entry<K, V>>> table;
  public MyHashMap() {
    this(DEFAULT_TABLE_SIZE);
  }
  public MyHashMap(final int tableSize) {
    table = new ArrayList<>(tableSize);
    for (var i = 0; i < tableSize; i += 1) {
      table.add(new LinkedList<>());
    }
  }
  @Override
  public int size() {
    int result = 0;
    return result;
  }
  @Override
  public boolean isEmpty() {
    return size() == 0;
  }
  @Override
  public boolean containsKey(final Object key) {
    final int index = calculateIndex(key);
    return false;
  }
  @Override
  public boolean containsValue(final Object value) {
    return false;
  }
  @Override
  public V get(final Object key) {
    final int index = calculateIndex(key);
    return null;
  }
  @Override
  public V put(final K key, final V value) {
    final int index = calculateIndex(key);
    return null;
  }
  @Override
  public V remove(final Object key) {
    final int index = calculateIndex(key);
    final var iter = table.get(index).iterator();
    while (iter.hasNext()) {
      final var entry = iter.next();
      if (entry.getKey().equals(key)) {
        final var oldValue = entry.getValue();
        iter.remove();
        return oldValue;
      }
    }
    return null;
  }
  @Override
  public void putAll(final Map<? extends K, ? extends V> m) {
  }
  @Override
  public void clear() {
  }
  @Override
  public Set<K> keySet() {
    final Set<K> result = new HashSet<>();
    return Collections.unmodifiableSet(result);
  }
  @Override
  public Collection<V> values() {
    final List<V> result = new LinkedList<>();
    return Collections.unmodifiableCollection(result);
  }
  @Override
  public Set<Entry<K, V>> entrySet() {
    final Set<Entry<K, V>> result = new HashSet<>();
    return Collections.unmodifiableSet(result);
  }
  @Override
  public String toString() {
    return """";
  }
  public boolean equals(final Object that) {
    if (this == that) {
      return true;
    } else if (!(that instanceof Map)) {
      return false;
    } else {
      return false;
    }
  }
  private int calculateIndex(final Object key) {
    return Math.floorMod(key.hashCode(), table.size());
  }
}",0,0,0,0,0,0,0,0,0
1436,"package com.manish.hashmap;
import java.util.Arrays;
public class MyHashMap {
    public static void main(String args[]){
        HashMap hashMap = new HashMap(2);
        hashMap.put(""Jan"", ""January"");
        hashMap.put(""Feb"", ""Febuary1"");
        hashMap.put(""Feb"", ""February2""); 
        hashMap.put(""Mar"", ""March"");
        hashMap.put(""Apr"", ""April"");
        hashMap.delete(""Jan"");
        hashMap.delete(""Feb"");
        System.out.println(hashMap);
        System.out.println(""value of jan ""+hashMap.get(""Jan""));
        System.out.println(""value of feb ""+hashMap.get(""Feb""));
    }
}
class HashMap{
   static class Entry{
        String key;
        String value;
        Entry next=null;
        Entry(String key,String value){
            this.key=key;
            this.value=value;
        }
        @Override
        public String toString() {
            return ""Entry{"" +
                    ""key='"" + key + '\'' +
                    "", value='"" + value + '\'' +
                    "", next="" + next +
                    '}';
        }
    }
    private Entry entry;
    int BUCKET_SIZE=4;
    Entry []bucket;
    HashMap(int size){
         this.BUCKET_SIZE=size;
         bucket = new Entry[size];
    }
    public String get(String key){
        int hash= key.length()%BUCKET_SIZE;
        Entry entry = bucket[hash];
        if(entry==null){
            return ""0"";
        }else{
            while(entry!=null){
                if(entry.key.equalsIgnoreCase(key)){
                    return entry.value;
                }
                entry = entry.next;
            }
        }
    return ""0"";
    }
    public void put(String key,String value){
        boolean found= false;
        if(key!=null){
            int hash= key.length()%BUCKET_SIZE;
            Entry entry = bucket[hash];
            if(entry==null){
                entry = new Entry(key,value);
                bucket[hash]=entry; 
            }else{
                Entry cur = entry;
                while (cur!=null){
                        if(cur.key.equalsIgnoreCase(key)){
                            cur.value= value;
                            return;
                        }
                        cur = cur.next;
                }
                    cur= new Entry(key,value);
            }
        }
    }
    public void delete(String key){
        if(key!=null){
            int hash = key.length()%BUCKET_SIZE;
            Entry entry= bucket[hash];
            if(bucket==null){
                System.out.println(""No such key"");
                return;
            }
            Entry prev = entry;
            Entry cur = entry;
            while(cur!=null){
                if(cur.next==null){
                }
                if(cur.key.equalsIgnoreCase(key)){
                    prev.next= cur.next;
                    cur = null;
                    return;
                }else{
                    prev = cur;
                    cur = cur.next;
                }
            }
        }
    }
    @Override
    public String toString() {
        return ""MyHashMap{"" +
                ""bucket="" + Arrays.toString(bucket) +
                '}';
    }
}",0,0,0,0,0,1,0,0,1
1437,"from Entry import Entry
from LinkedList import SingleEntryLinkedList
DEFAULT_MAXIMUM_LOAD_FACTOR = 0.75
DEFAULT_MAXIMUM_UNLOAD_FACTOR = 0.1
MAXIMUM_CAPACITY = 1 << 30
class MyHashMap(object):
    DEFAULT_INITIAL_CAPACITY = 4
    def __init__(self, capacity=DEFAULT_INITIAL_CAPACITY, load_factor=DEFAULT_MAXIMUM_LOAD_FACTOR):
        if capacity > MAXIMUM_CAPACITY:
            self.capacity = MAXIMUM_CAPACITY
        else:
            self.capacity = self.trim_power_of2(capacity)
        self.thresholdLoadFactor = load_factor
        self.thresholdUnloadFactor = DEFAULT_MAXIMUM_UNLOAD_FACTOR
        self.size = 0
        self.table = [SingleEntryLinkedList() for i in range(capacity)]
    def trim_power_of2(self, initial_capacity):  
        capacity = 1
        while capacity < initial_capacity:
            capacity <<= 1
        return capacity
    def hash_code(self, key):
        hash = 0
        for char in str(key):
            hash += ord(char)
        return hash % self.capacity
    def clear(self):
        self.size = 0
        self.remove_entries()
    def remove_entries(self):
        for entry_list in self.table:
            if entry_list.list_length != 0:
                entry_list.head = None
    def contains_key(self, key):
        index = self.hash_code(key)
        if self.table[index].list_length != 0:
            return self.table[index].unordered_search_key(key)
    def contains_value(self, value):
        for entry_list in self.table:
            if entry_list.list_length != 0:
                if entry_list.unordered_search_value(value):
                    return True
        return False
    def get(self, key):  
        if key is not None:
            index = int(self.hash_code(key))
            if self.table is not None:
                if self.table[index].list_length != 0:
                    return self.table[index].unordered_search_get_entry_by_key(key)
        return None
    def put(self, key, value):  
        index = int(self.hash_code(key))
        if (self.get(key) is not None) & (self.table[index].list_length != 0):  
            if self.table[index].unordered_search_key(key):
                return self.table[index].override_list_item(Entry(key, value))
        self.table[index].add_list_item(Entry(key, value))
        self.size = + 1
        if self.size + 1 >= self.capacity * self.thresholdLoadFactor:  
            if self.capacity == MAXIMUM_CAPACITY:
                RuntimeError(""Exceeding maximum capacity"")
            self.resize()
        return None
    def entry_set(self):  
        e_set = set()
        for entry_list in self.table:
            current_node = entry_list.head
            while current_node is not None:
                e_set.add(current_node.data)
                current_node = current_node.next
        return e_set
    def resize(self):
        do_resize = False
        if self.size / self.capacity > self.thresholdLoadFactor:
            self.capacity = self.capacity * 2
            self.thresholdLoadFactor = self.capacity * 0.75
            do_resize = True
        if self.size / self.capacity < self.thresholdUnloadFactor:
            self.capacity = self.capacity / 2
            self.thresholdLoadFactor = self.capacity * 0.75
            do_resize = True
        if do_resize:
            entry_set_old_table = self.entry_set()
            self.table = [SingleEntryLinkedList() for i in range(int(self.capacity))]
            for entry in entry_set_old_table:
                self.put(entry.key, entry.val)
    def is_empty(self):  
        return self.size == 0
    def key_set(self):  
        k_set = set()
        for entry in self.entry_set():
            k_set.add(entry.key)
        return k_set
    def map_copy(self, map_to_copy):  
        m_set = map_to_copy.entry_set()
        for entry in m_set:
            self.put(entry.key, entry.val)
    def remove(self, key):  
        index = self.hash_code(key)
        last_entry = self.table[index].head
        while last_entry.data.key != key:
            last_entry = last_entry.next
        old_value = last_entry.data.val
        last_entry.data = None
        self.size -= 1
        if self.size + 1 <= self.capacity * self.thresholdUnloadFactor:
            self.resize()
        return old_value
    def value_set(self):  
        v_list = set()
        for entry in self.entry_set():
            v_list.add(entry.val)
        return v_list
    def print_map(self):
        for entry_list in self.table:
            entry_list.output_list()
    def generator(self):
        for index in range(-1, len(self.table) - 1, 1):
            yield self.table[index]",0,0,0,0,0,0,0,0,1
1438,"import java.util.ArrayList;
import java.util.List;
public class MyHashMapImpl<K,V> implements MyHashMap<K, V> {
	private int numBuckets;
	private List<MyHashMap.Bucket<K, V>> list;
	private int size=0;
	MyHashMapImpl(int numBuckets)
	{
		list=new ArrayList<MyHashMap.Bucket<K, V>>();
		MyHashMap.Bucket<K,V> bucket;
		for(int i=0;i<numBuckets;i++)
			{
				bucket=new BucketImpl();
				list.add(bucket);
			}
		this.numBuckets=numBuckets;
	}
	@Override
	public V get(K key) {
		int i=translate(key.hashCode(),numBuckets);
		MyHashMap.Bucket<K,V> bucket=list.get(i);
		for(MyHashMap.Entry<K, V> entry:bucket.getEntries())
		{
			if(entry.getKey().equals(key))
				return entry.getValue();
		}
		return null;
	}
	@Override
	public V put(K key, V value) {
		int i=translate(key.hashCode(),numBuckets);
		MyHashMap.Bucket<K,V> bucket=list.get(i);
		for(MyHashMap.Entry<K, V> entry:bucket.getEntries())
		{
			if(entry.getKey().equals(key))
				{
					V val=((EntryImpl)entry).v;
					((BucketImpl)bucket).list2.remove(entry);
					((EntryImpl)entry).v=value;
					((BucketImpl)bucket).list2.add(entry);
					return val;
				}
		}
		MyHashMap.Entry<K, V> entryy=new EntryImpl();
		((EntryImpl)entryy).k=key;
		((EntryImpl)entryy).v=value;
		((BucketImpl)bucket).list2.add(entryy);
		size++;
		return null;
	}
	@Override
	public V remove(K key) {
		int i=translate(key.hashCode(),numBuckets);
		MyHashMap.Bucket<K,V> bucket=list.get(i);
		for(MyHashMap.Entry<K, V> entry:bucket.getEntries())
		{
			if(entry.getKey()==key)
			{
				V val=((EntryImpl)entry).v;
				((BucketImpl)bucket).list2.remove(entry);
				size--;
				return val;
			}
		}
		return null;
	}
	@Override
	public int size() {
		return size;
	}
	@Override
	public List<? extends MyHashMap.Bucket<K, V>> getBuckets() {
		return list;
	}
	public int translate(int hashCode, int size) {
		return Math.abs(hashCode) % size;
	}
	public class EntryImpl implements MyHashMap.Entry<K, V>
	{
		K k;
		V v;
		@Override
		public K getKey() {
			return k;
		}
		@Override
		public V getValue() {
			return v;
		}
	}
	public class BucketImpl implements MyHashMap.Bucket<K, V>
	{
		private List<MyHashMap.Entry<K, V>> list2=new ArrayList<MyHashMap.Entry<K, V>>();
		@Override
		public List<? extends MyHashMap.Entry<K, V>> getEntries() {
			return list2;
		}
	}
}",0,0,0,0,0,1,0,0,1
1439,"class HashTable:
    def __init__(self):
        self.size = 8
        self.map = [None]*self.size
    def _get_hash(self,key):
        hashed = 0
        for char in str(key):
            hashed = hashed + ord(char)
        return hashed % self.size
    def add(self,key,value):
        hash_address = self._get_hash(key)
        key_value = [key,value]
        if self.map[hash_address] is None:
            self.map[hash_address] = list([key_value])
            return True
        else:
            for pairs in self.map[hash_address]:
                if pairs[0] == key:
                    pairs[1] = value
                    return True
            self.map[hash_address].append(key_value)
            return True
    def get(self,key):
        hash_address = self._get_hash(key)
        if self.map[hash_address] is not None:
            for pairs in self.map[hash_address]:
                if pairs[0] == key:
                    return pairs[1]
        return None
    def getOne(self,key):
        hash_address = self._get_hash(key)
        for i in range(0,len(self.map[hash_address])):
            if self.map[hash_address][i][0] == key:
                return self.map[hash_address][i][1]
        return None
    def delete(self,key):
        hash_address = self._get_hash(key)
        if self.map[hash_address] is not None:
            for i in range(0,len(self.map[hash_address])):
                if self.map[hash_address][i][0] == key:
                    self.map[hash_address].pop(i)
                    return True
    def keys(self):
        ArrayKeys =[]
        for i in range(0,len(self.map)):
            if(self.map[i]):
                ArrayKeys.append(self.map[i][0][0])
        print(ArrayKeys)
    def print(self):
        for eachItem in self.map:
            if eachItem is not None:
                print(str(eachItem))
myFirstHash = HashTable()
myFirstHash.add(""shahid"",""1234"")
myFirstHash.add(""hsahid"",""abcdefgh"")
myFirstHash.add(""abc"",""32143"")
myFirstHash.print()
myFirstHash.keys()
print(myFirstHash.map)
print(""With get"",myFirstHash.get(""shahid""))",0,0,0,0,0,1,0,0,1
1440,"class HashTable:
    def __init__(self):
        self.size = 8
        self.map = [None]*self.size
    def _get_hash(self,key):
        hashed = 0
        for char in str(key):
            hashed = hashed + ord(char)
        return hashed % self.size
    def add(self,key,value):
        hash_address = self._get_hash(key)
        key_value = [key,value]
        if self.map[hash_address] is None:
            self.map[hash_address] = list([key_value])
            return True
        else:
            for pairs in self.map[hash_address]:
                if pairs[0] == key:
                    pairs[1] = value
                    return True
            self.map[hash_address].append(key_value)
            return True
    def get(self,key):
        hash_address = self._get_hash(key)
        if self.map[hash_address] is not None:
            for pairs in self.map[hash_address]:
                if pairs[0] == key:
                    return pairs[1]
        return None
    def getOne(self,key):
        hash_address = self._get_hash(key)
        for i in range(0,len(self.map[hash_address])):
            if self.map[hash_address][i][0] == key:
                return self.map[hash_address][i][1]
        return None
    def delete(self,key):
        hash_address = self._get_hash(key)
        if self.map[hash_address] is not None:
            for i in range(0,len(self.map[hash_address])):
                if self.map[hash_address][i][0] == key:
                    self.map[hash_address].pop(i)
                    return True
    def keys(self):
        ArrayKeys =[]
        for i in range(0,len(self.map)):
            if(self.map[i]):
                ArrayKeys.append(self.map[i][0][0])
        print(ArrayKeys)
    def print(self):
        for eachItem in self.map:
            if eachItem is not None:
                print(str(eachItem))
myFirstHash = HashTable()
myFirstHash.add(""shahid"",""1234"")
myFirstHash.add(""hsahid"",""abcdefgh"")
myFirstHash.add(""abc"",""32143"")
myFirstHash.print()
myFirstHash.keys()
print(myFirstHash.map)
print(""With get"",myFirstHash.get(""shahid""))",0,0,0,0,0,1,0,0,1
1441,"from Ds.Maps_Dictionaries.HashMapBase import HashMapBase
class ProbeHashMap(HashMapBase):
    _AVAIL = object()
    def _is_available(self, j):
        return self._table[j] is None or self._table[j] is ProbeHashMap._AVAIL
    def _find_slot(self, j, k):
        firstAvail = None
        while True:
            if self._is_available(j):
                if firstAvail is None:
                    firstAvail = j                  
                if self._table[j] is None:
                    return (False, firstAvail)      
            elif k == self._table[j]._key:
                return (True, j)                    
            j = (j+1) % len(self._table)            
    def _bucket_getitem(self, j, k):
        found, s = self._find_slot(j, k)
        if not found:
            raise KeyError('Key Error: ' + repr(k)) 
        return self._table[s]._value
    def _bucket_setitem(self, j, k, v):
        found , s = self._find_slot(j, k)
        if not found:
            self._table[s] = self._Item(k,v)        
            self._n += 1                            
        else:
            self._table[s]._value = v               
    def _bucket_delitem(self, j, k):
        found, s = self._find_slot(j, k)
        if not found:
             raise KeyError('Key Error: ' + repr(k))
        self._table[s] == ProbeHashMap._AVAIL       
    def __iter__(self):
        for j in range(len(self._table)):
            if not self._is_available(j):
                yield self._table[j]._key",0,0,0,0,0,0,0,0,0
1442,"from hash_stats import HashStats
class RoboHash:
    """"""Initializes RoboHash
    array_size -- the size of the table to start with, will double when reaching storage_threshold
    storage_threshold -- the ratio of hashed items to buckets. Array will double when threshold is exceeded
    """"""
    def __init__(self, array_size=1117, storage_threshold=0.7):
        self.storage_threshold = storage_threshold
        self.array_size = array_size
        self.storage = [None for _ in range(array_size)]
        self.stats = HashStats()
    def get_stats(self):
        return self.stats
    """""" inserts a value into the hashtable
    key -- the key to be used to retrieve the value
    value -- the value associated with the key
    """"""
    def insert(self, key, value):
        self.stats.increment_count()
        self.__resize_if_needed()
        idx = self.__hash(key)
        while True:
            item = self.storage[idx]
            if item is None:
                self.storage[idx] = (key, value)
                break
            elif item[0] == key:
                self.storage[idx] = (key, value)
                break
            else:
                self.stats.increment_collisions()
                if idx == self.array_size - 1:
                    idx = 0
                else:
                    idx += 1
    """""" retrieves an item from the hashtable with the specified key """"""
    def get(self, key):
        idx = self.__hash(key)
        self.stats.increment_requests()
        while True:
            item = self.storage[idx]
            self.stats.increment_seeks()
            if item is None:
                return None
            elif item[0] == key:
                return item[1]
            else:
                if idx == self.array_size - 1:
                    idx = 0
                else:
                    idx += 1
    def __hash(self, key):
        return hash(key) % self.array_size
    def get_hash(self, key):
        return self.__hash(key)
    def __resize_if_needed(self):
        if (self.stats.count / self.array_size) > self.storage_threshold:
            self.__resize()
    def __resize(self):
        new_size = (self.array_size * 2) + 1
        new_hash = RoboHash(new_size)
        self.stats.increment_resizes()
        for item in self.storage:
            if item is not None:
                new_hash.insert(item[0], item[1])
        self.storage = new_hash.storage
        self.array_size = new_size
    def pretty_print(self):
        for i in range(0, self.array_size):
            item = self.storage[i]
            if item is not None:
                print(""["" + str(i) + ""] Key: "" + str(item[0]) + "" Value: "" + str(item[1]))",0,0,0,0,0,1,0,0,1
1443,"from DS.Maps_Dictionaries.MapBase import MapBase
class SortedTableMap(MapBase):
    def _find_index(self, k, low, high):
        if high < low:
            return high + 1     
        else:
            mid = (low + high) // 2
            if k == self._table[mid]._key:
                return mid
            elif k < self._table[mid]._key:
                return self._find_index(k, low, mid-1)
            else:
                return self._find_index(k, mid+1, high)
    def __init__(self):
        self._table = []
    def __len__(self):
        return len(self._table)
    def __getitem__(self, k):
        j = self._find_index(k, 0, len(self._table)-1)
        if j == len(self._table) or self._table[j]._key != k:
            raise KeyError('Key Error: ' + repr(k))
        return self._table[j]._value
    def __setitem__(self, k, v):
        j = self._find_index(k, 0, len(self._table)-1)
        if j < len(self._table) and self._table[j]._key == k:
            self._table[j]._value = v
        else:
            self._table.insert(j, self._Item(k,v))
    def __delitem__(self, k):
        j = self._find_index(k, 0, len(self._table)-1)
        if j == len(self._table) or self._table[j]._key != k:
            raise KeyError('Key Error: '+ repr(k))
        self._table.pop(j)
    def __iter__(self):
        for item in reversed(self._table):
            yield item._key
    def find_min(self):
        if len(self._table) > 0:
            return (self._table[0]._key, self._table[0]._value)
        else:
            return None
    def find_max(self):
        if len(self._table) > 0:
            return (self._table[-1]._key, self._table[-1]._value)
        else:
            return None
    def find_ge(self, k):
        j = self._find_index(k, 0, len(self._table)-1)
        if j < len(self._table):
            return (self._table[j]._key, self._table[j]._value)
        else:
            return None
    def find_lt(self):
        j = self._find_index(k, 0, len(self._table)-1)
        if j > 0:
            return (self._table[j-1]._key, self._table[j-1]._value)
        else:
            return None
    def find_gt(self, k):
        j = self._find_index(k , 0, len(self._table)-1)
        if j < len(self._table) and self._table[j]._key == k:
            j+=1
        if j < len(self._table):
            return (self._table[j]._key, self._table[j]._value)
        else:
            return None
    def find_range(self, start, stop):
        if start is None:
            j = 0
        else:
            j = self._find_index(start, 0, len(self._table)-1)
        while j < len(self._table) and (stop is None or self._table[j].key < stop):
            yield (self._table[j]._key, self._table[j]._value)
            j+=1
if __name__ == ""__main__"":
    s = SortedTableMap()
    for i in range(10):
        s[i]=-i
    print(list(s.find_range(5,None)))",0,0,0,0,0,0,0,0,0
1444,"from DS.Maps_Dictionaries.MapBase import MapBase
class UnsortedTableMap(MapBase):
    def __init__(self):
        self._table = []
    def __getitem__(self, k):
        for item in self._table:
            if k == item._key:
                return item._value
        raise KeyError('Key Error: ' + repr(k))
    def __setitem__(self, k, v):
        for item in self._table:
            if k == item._key:
                item._value = v
                return
        self._table.append(self._Item(k,v))
    def __delitem__(self, k):
        for j in range(len(self._table)):
            if k == self._table[j]._key:
                self._table.pop(j)
                return
        raise KeyError('Key Error: ' + repr(k))
    def __len__(self):
        return len(self._table)
    def __iter__(self):
        for item in self._table:
            yield item._key",0,0,0,0,0,1,0,0,1
1445,"package com.epublica.java;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;
public class WeakValueHashMap<K,V> extends AbstractMap<K,V> {
	private HashMap<K, WeakValue<V>> references;
	private ReferenceQueue<V> gcQueue;
	public WeakValueHashMap(int capacity) {
		references = new HashMap<K, WeakValue<V>>(capacity);
		gcQueue = new ReferenceQueue<V>();
	}
	public WeakValueHashMap() {
		this(1);
	}
	public WeakValueHashMap(Map<? extends K, ? extends V> map) {
		this(map.size());
		for (Map.Entry<? extends K, ? extends V> entry : map.entrySet() ) {
			put(entry.getKey(), entry.getValue());
		}
	}
	@Override
	public V put(K key, V value) {
		processQueue();
		WeakValue<V> valueRef = new WeakValue<V>(key, value, gcQueue);
		return getReferenceValue(references.put(key, valueRef));
	};
	@Override
	public V get(Object key) {
		processQueue();
		return getReferenceValue(references.get(key));
	}
	@Override
	public V remove(Object key) {
		return getReferenceValue(references.get(key));
	}
	@Override
	public void clear() {
		references.clear();
	}
	@Override
	public boolean containsKey(Object key) {
		processQueue();
		return references.containsKey(key);
	}
	@Override
	public boolean containsValue(Object value) {
		processQueue();
		for (Map.Entry<K, WeakValue<V>> entry : references.entrySet()) {
			if (value == getReferenceValue(entry.getValue())) {
				return true;
			}
		}
		return false;
	}
	@Override
	public Set<K> keySet() {
		processQueue();
		return references.keySet();
	}
	@Override
	public int size() {
		processQueue();
		return references.size();
	}
	@Override
	public Set<Map.Entry<K,V>> entrySet() {
		processQueue();
		Set<Map.Entry<K,V>> entries = new LinkedHashSet<Map.Entry<K,V>>();
		for (Map.Entry<K,WeakValue<V>> entry : references.entrySet()) {
			entries.add(new AbstractMap.SimpleEntry<K,V>(entry.getKey(), getReferenceValue(entry.getValue())));
		}
		return entries;
	}
	public Collection<V> values() {
		processQueue();
		Collection<V> values = new ArrayList<V>();
		for (WeakValue<V> valueRef : references.values()) {
			values.add(getReferenceValue(valueRef));
		}
		return values;
	}
	private V getReferenceValue(WeakValue<V> valueRef) {
		return valueRef == null ? null : valueRef.get();
	}
	@SuppressWarnings(""unchecked"")
	private void processQueue() {
		WeakValue<V> valueRef;
		while ( (valueRef = (WeakValue<V>) gcQueue.poll()) != null ) {
			references.remove(valueRef.getKey());
		}
	}
	private class WeakValue<T> extends WeakReference<T> {
		private final K key;
		private WeakValue(K key, T value, ReferenceQueue<T> queue) {
			super(value, queue);
			this.key = key;
		}
		private K getKey() {
			return key;
		}
	}
}",0,0,0,0,0,0,0,0,0
1446,"from __future__ import annotations
from abc import abstractmethod
from math import inf, floor, ceil
from typing import Optional, Tuple, Generic, TypeVar, Protocol, Union
class Comparable(Protocol):
    @abstractmethod
    def __lt__(self: T, other: T) -> bool:
        pass
T = TypeVar(""T"", bound=Comparable)
class LinkedList(Generic[T]):
    def __init__(self, data: T, next_: Optional[LinkedList[T]] = None) -> None:
        self.data = data
        self.next = next_
    def __repr__(self) -> str:
        try:
            return str(self.data) + (
                (""-"" + repr(self.next)) if self.next is not None else """"
            )
        except RecursionError:
            return str(self.data) + ((""-"" + ""..."") if self.next is not None else """")
    def contains(self, data: T) -> bool:
        if self.data == data:
            return True
        if self.next is None:
            return False
        return self.next.contains(data)
    def get_last(self) -> LinkedList[T]:
        cur = self
        while cur.next is not None:
            cur = cur.next
        return cur
    def __len__(self) -> int:
        if self.next is None:
            return 1
        return 1 + len(self.next)
    def split_equal(self) -> Tuple[LinkedList[T], Optional[LinkedList[T]]]:
        slow = self
        fast = self
        while True:
            if slow.next is None:
                return (slow, None)
            if fast.next is None or fast.next.next is None:
                front = self
                back = slow.next
                slow.next = None  
                return (front, back)
            slow = slow.next
            fast = fast.next.next
    def is_circular(self) -> bool:
        slow = self
        fast = self
        while True:
            if slow.next is None or fast.next is None or fast.next.next is None:
                return False
            slow = slow.next
            fast = fast.next.next
            if fast is None:
                return False
            if slow == fast:
                return True
    def append(self, data: T) -> None:
        last = self.get_last()
        last.next = LinkedList(data, None)
    def reverse(self: LinkedList[T]) -> LinkedList[T]:
        r: Optional[LinkedList[T]] = None
        p = self
        while p is not None:
            q = p.next
            p.next = r
            r = p
            if q is None:
                break
            p = q
        return r
    def pop(self) -> Tuple[T, Optional[LinkedList[T]]]:
        head = self.data
        tail = self.next
        return (head, tail)
    def insert(self, index: int, data: T) -> None:
        if index <= 0:
            raise ValueError(""index must be larger than zero"")
        cur = self
        i = 0
        while i < index - 1 and cur.next is not None:
            cur = cur.next
            i += 1
        tail = cur.next
        cur.next = LinkedList(data, tail)
    @staticmethod
    def sort(ll: LinkedList[T], method: str = ""bubblesort"") -> LinkedList[T]:
        if method == ""bubblesort"":
            return _bubblesort(ll)
        raise NotImplementedError(f""Method '{method}' for sorting is not implemented."")
    def dedupe(self) -> LinkedList[T]:
        p = self
        while p.next is not None:
            q = p.next
            if p.data == q.data:
                if q.next is None:
                    p.next = None
                    break
                else:
                    p.next = q.next
                    q = q.next
            else:
                p = q
        return self
    @staticmethod
    def merge(list1: LinkedList[T], list2: LinkedList[T]) -> LinkedList[T]:
        last = list1.get_last()
        last.next = list2
        return list1
    def is_palindrome(self) -> bool:
        part1, part2 = self.split_equal()
        if part2 is None:
            return True
        part2 = LinkedList.reverse(part2)
        p = part1
        q = part2
        result = None
        while True:
            if p.data != q.data:
                result = False
                break
            if p.next is None or q.next is None:
                result = True
                break
            p = p.next
            q = q.next
        if p.next is not None:
            p = p.next
        p.next = LinkedList.reverse(part2)
        return result
def _bubblesort(ll: LinkedList[T]) -> LinkedList[T]:
    start_node = ll  
    end = None
    while end != start_node:
        r = p = start_node
        while p.next is not None and p.next != end:
            q = p.next
            if p.data > q.data:
                p.next = q.next
                q.next = p
                if p != start_node:
                    r.next = q
                else:
                    start_node = q
                p, q = q, p
            r = p
            assert p.next is not None  
            p = p.next
        end = p  
    return start_node",0,0,0,0,1,1,0,1,0
1447,"class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next
class LinkedList:
    def __init__(self):
        self.head = None
    def print(self):
        if self.head is None:
            print(""Linked list is empty"")
            return
        itr = self.head
        llstr = ''
        while itr:
            llstr += str(itr.data)+' --> ' if itr.next else str(itr.data)
            itr = itr.next
        print(llstr)
    def get_length(self):
        count = 0
        itr = self.head
        while itr:
            count+=1
            itr = itr.next
        return count
    def insert_at_begining(self, data):
        node = Node(data, self.head)
        self.head = node
    def insert_at_end(self, data):
        if self.head is None:
            self.head = Node(data, None)
            return
        itr = self.head
        while itr.next:
            itr = itr.next
        itr.next = Node(data, None)
    def insert_at(self, index, data):
        if index<0 or index>self.get_length():
            raise Exception(""Invalid Index"")
        if index==0:
            self.insert_at_begining(data)
            return
        count = 0
        itr = self.head
        while itr:
            if count == index - 1:
                node = Node(data, itr.next)
                itr.next = node
                break
            itr = itr.next
            count += 1
    def remove_at(self, index):
        if index<0 or index>=self.get_length():
            raise Exception(""Invalid Index"")
        if index==0:
            self.head = self.head.next
            return
        count = 0
        itr = self.head
        while itr:
            if count == index - 1:
                itr.next = itr.next.next
                break
            itr = itr.next
            count+=1
    def insert_values(self, data_list):
        self.head = None
        for data in data_list:
            self.insert_at_end(data)
if __name__ == '__main__':
    ll = LinkedList()
    ll.insert_values([""banana"",""mango"",""grapes"",""orange""])
    ll.insert_at(1,""blueberry"")
    ll.remove_at(2)
    ll.print()
    ll.insert_values([45,7,12,567,99])
    ll.insert_at_end(67)
    ll.print()",0,0,0,0,0,0,0,1,0
1448,"class Node(object):
	def __init__(self, data):
		self.data = data
  self.prev = None
  self.next = None
 def __str__(self):
		return str(self.data)
class CDLLwS(object):
	def __init__(self, nodeClass):
		self.nodeClass = nodeClass
  self.sentinel = self.nodeClass(None)
  self.sentinel.next = self.sentinel.prev = self.sentinel
  self.len = 0
 def __len__(self):
		return self.len
 def __iter__(self):
		x = self.sentinel.next
  while x != self.sentinel:
			yield x
   x = x.next
 def __getitem__(self, i):
		if not -1 <= i < len(self):
			raise IndexError()
  elif i == 0:
			return self.sentinel.next
  elif i == -1:
			if len(self) > 0:
				return self.sentinel.prev
   else:
				raise IndexError()
  else:
			for j, x in enumerate(self):
				if j == i: return x
 def _insert_node(self, node, nextNode):
		node.prev = nextNode.prev
  node.next = nextNode
  node.prev.next = node
  node.next.prev = node
  self.len += 1
 def insert(self, i, node):
		self._insert_data(
   node,
   self.__getitem__(i, getNode=True) if len(self) > 0 else self.sentinel
  )
 def append(self, node):
		self._insert_node(
   node,
   self.sentinel
  )
 def pop(self, i=-1):
		x = self[i]
  x.prev.next = x.next
  x.next.prev = x.prev
  self.len -= 1
  return x
 def find(self, s, propName=""data""):
		for x in self:
			if getattr(x, propName) == s:
				return x
  return None
 def __str__(self):
		return str(map(lambda x:x.data, self))",0,0,0,0,0,1,0,1,0
1449,,0,0,0,0,0,0,0,0,0
1450,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
class circularDoublyLinkedList:
    def __init__(self):
        self.last = None
    def insertFirst(self):
        data = int(input(""Enter the value of the node to be inserted : ""))
        newNode = Node(data)
        if (self.last == None):
            self.last = newNode
            newNode.next = self.last
            newNode.prev = self.last
        else:
            head = self.last.next
            self.last.next = newNode
            newNode.prev = self.last
            newNode.next = head
            head.prev = newNode
        print(""The Node has been inserted in the beginning of the list\n"")
    def deleteFirst(self):
        if (self.last == None):
            print(""The list is empty\n"")
        elif (self.last.next == self.last):
            print(""Removed first : "", self.last.data, ""\n"")
            self.last = None
        else:
            head = self.last.next
            print(""Removed first : "", head.data, ""\n"")
            head = head.next
            head.prev = self.last
            self.last.next = head
    def insertLast(self):
        data = int(input(""Enter the value of the node to be inserted : ""))
        newNode = Node(data)
        if (self.last == None):
            self.last = newNode
            newNode.next = self.last
        else:
            head = self.last.next
            self.last.next = newNode
            newNode.prev = self.last
            newNode.next = head
            head.prev = newNode
            self.last = newNode
        print(""The Node has been inserted in the end of the list\n"")
    def deleteLast(self):
        if (self.last == None):
            print(""The list is empty\n"")
        elif (self.last.next == self.last):
            print(""Removed last : "", self.last.data, ""\n"")
            self.last = None
        else:
            print(""Removed last : "", self.last.data, ""\n"")
            head = self.last.next
            curr = head
            while curr.next.next != head:
                curr = curr.next
            self.last = curr
            self.last.next = head
            head.prev = self.last
    def search(self, item):
        if (self.last == None):
            print(""List is empty\n"")
        else:
            head = self.last.next
            curr = head
            flag = 0
            while curr.next != head:
                if (curr.data == item):
                    flag = 1
                curr = curr.next
            if curr.data == item:
                flag = 1
            if (flag):
                print(""item was found\n"")
            else:
                print(""not found\n"")
    def displayForeward(self):
        if (self.last == None):
            print(""List is empty\n"")
        else:
            head = self.last.next
            curr = head
            print(""the elements of the list in foreward direction are : "")
            while curr.next != head:
                print(curr.data, end="" "")
                curr = curr.next
            print(curr.data, ""\n"")
    def dislplayBackWard(self):
        if (self.last == None):
            print(""List is Empty\n"")
        else:
            head = self.last.next
            curr = head
            print(""the elements of the list in backward direction are : "")
            while curr.next != head:
                curr = curr.next
            while curr != head:
                print(curr.data, end="" "")
                curr = curr.prev
            print(curr.data, ""\n"")
CDLL = circularDoublyLinkedList()
while True:
    print(""Enter a option you want to perform "")
    op = int(input(
        ""1.Insert First \n2.Delete First \n3.Insert Last \n4.Delete Last \n5.search \n6.displayForeward \n7.dislplayBackWard \n8.exit \n""))
    if (op == 1):
        CDLL.insertFirst()
    elif (op == 2):
        CDLL.deleteFirst()
    elif (op == 3):
        CDLL.insertLast()
    elif (op == 4):
        CDLL.deleteLast()
    elif (op == 5):
        item = int(input(""enter the item to be searched : ""))
        CDLL.search(item)
    elif (op == 6):
        CDLL.displayForeward()
    elif (op == 7):
        CDLL.dislplayBackWard()
    elif (op == 8):
        exit()
    else:
        print(""enter correct option"")",0,0,0,0,0,1,0,1,0
1451,"class Node:    
  def __init__(self,data):    
    self.data = data;    
    self.next = None;    
class CreateList:    
  def __init__(self):    
    self.head = Node(None);    
    self.tail = Node(None);    
    self.head.next = self.tail;    
    self.tail.next = self.head;    
  def add(self,data):    
    newNode = Node(data);    
    if self.head.data is None:    
      self.head = newNode;    
      self.tail = newNode;    
      newNode.next = self.head;    
    else:    
      self.tail.next = newNode;    
      self.tail = newNode;    
      self.tail.next = self.head;    
  def display(self):    
    current = self.head;    
    if self.head is None:    
      print(""List is empty"");    
      return;    
    else:    
        print(""Nodes of the circular linked list: "");    
        print(current.data),    
        while(current.next != self.head):    
            current = current.next;    
            print(current.data),    
class CircularLinkedList:    
  cl = CreateList();    
  cl.add(1);    
  cl.add(2);    
  cl.add(3);    
  cl.add(4);    
  cl.display();    ",0,0,0,0,0,0,0,0,0
1452,"class Node:    
  def __init__(self,data):    
    self.data = data;    
    self.next = None;    
class CreateList:    
  def __init__(self):    
    self.head = Node(None);    
    self.tail = Node(None);    
    self.head.next = self.tail;    
    self.tail.next = self.head;    
  def add(self,data):    
    newNode = Node(data);    
    if self.head.data is None:    
      self.head = newNode;    
      self.tail = newNode;    
      newNode.next = self.head;    
    else:    
      self.tail.next = newNode;    
      self.tail = newNode;    
      self.tail.next = self.head;    
  def display(self):    
    current = self.head;    
    if self.head is None:    
      print(""List is empty"");    
      return;    
    else:    
        print(""Nodes of the circular linked list: "");    
        print(current.data),    
        while(current.next != self.head):    
            current = current.next;    
            print(current.data),    
class CircularLinkedList:    
  cl = CreateList();    
  cl.add(1);    
  cl.add(2);    
  cl.add(3);    
  cl.add(4);    
  cl.display();    ",0,0,0,0,0,0,0,0,0
1453,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class CircularLinkedList:
    def __init__(self):
        self.head = None
    def prepend(self, data):
        if self.head is None:
            new_node = Node(data)
            self.head = new_node
            new_node.next = self.head
        else:
            new_node = Node(data)
            new_node.next = self.head
            cur = self.head
            while cur.next is not self.head:
                cur = cur.next
            cur.next = new_node
            self.head = new_node
    def append(self, data):  
        if self.head is None:
            new_node = Node(data)
            self.head = new_node
            self.head.next = self.head
        else:
            new_node = Node(data)
            cur = self.head
            while cur.next is not self.head:
                cur = cur.next
            cur.next = new_node
            new_node.next = self.head
    def __str__(self):  
        if self.head is None:
            return ""List is Empty""
        else:
            st = """"
            cur = self.head
            while cur:
                st += str(cur.data) + "" ""
                cur = cur.next
                if cur is self.head:
                    break
            return st
if __name__ == ""__main__"":
    cLL = CircularLinkedList()
    cLL.prepend(100)
    cLL.prepend(200)
    cLL.append(10)
    print(cLL)  
    cLL.append(20)
    cLL.append(30)
    cLL.append(40)
    print(cLL)  
    cLL.prepend(200)
    print(cLL)  ",0,0,0,0,0,0,0,1,0
1454,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class CircularLinkedList:
    def __init__(self):
        self.head = None
    def __len__(self):
        current_node = self.head
        count = 0
        while current_node:
            count+=1
            current_node = current_node.next
            if current_node == self.head:
                break
        return count
    def append(self, data):
        if not self.head:
            self.head = Node(data)
            self.head.next = self.head
        else:
            current_node = self.head
            new_node = Node(data)
            while current_node.next != self.head:
                current_node = current_node.next
            current_node.next = new_node
            new_node.next = self.head
    def prepend(self, data):
        new_node = Node(data)
        current_node = self.head
        new_node.next = self.head
        if not self.head:
            new_node.next = new_node
        else:
            while current_node.next != self.head:
                current_node = current_node.next
            current_node.next = new_node
        self.head = new_node
    def delete_node(self, data):
        if self.head:
            if self.head.data == data:
                current_node = self.head
                while current_node.next != self.head:
                    current_node = current_node.next
                if self.head == self.head.next:
                    self.head = None
                else:
                    current_node.next = self.head.next
                    self.head = self.head.next
            else:
                current_node = self.head
                previous_node = None
                while current_node.next != self.head:
                    previous_node = current_node
                    current_node = current_node.next
                    if current_node.data == data:
                        previous_node.next = current_node.next
                        current_node = current_node.next
    def split_list(self):
        size = len(self)
        if size == 0:
            return None
        if size == 1:
            return self.head
        mid = size//2
        count = 0
        current_node = self.head
        previous_node = None
        while current_node and count < mid:
            previous_node = current_node
            current_node = current_node.next
            count+=1
        previous_node.next = self.head
        new_cllist = CircularLinkedList()
        while current_node.next != self.head:
            new_cllist.append(current_node.data)
            current_node = current_node.next
        new_cllist.append(current_node.data)
        self.print_list()
        print(""\n"")
        new_cllist.print_list()
    def print_list(self):
        curr = self.head
        while curr:
            print(curr.data)
            curr = curr.next
            if curr == self.head:
                break
cllist = CircularLinkedList()
cllist.append(""C"")
cllist.append(""D"")
cllist.prepend(""B"")
cllist.prepend(""A"")
cllist.append(""E"")
cllist.append(""F"")
cllist.split_list()",0,0,0,0,0,0,0,1,0
1455,"class Node:    
  def __init__(self,data):    
    self.data = data;    
    self.next = None;    
class CreateList:    
  def __init__(self):    
    self.head = Node(None);    
    self.tail = Node(None);    
    self.head.next = self.tail;    
    self.tail.next = self.head;    
  def add(self,data):    
    newNode = Node(data);    
    if self.head.data is None:    
      self.head = newNode;    
      self.tail = newNode;    
      newNode.next = self.head;    
    else:    
      self.tail.next = newNode;    
      self.tail = newNode;    
      self.tail.next = self.head;    
  def display(self):    
    current = self.head;    
    if self.head is None:    
      print(""List is empty"");    
      return;    
    else:    
        print(""Nodes of the circular linked list: "");    
        print(current.data),    
        while(current.next != self.head):    
            current = current.next;    
            print(current.data),    
class CircularLinkedList:    
  cl = CreateList();    
  cl.add(1);    
  cl.add(2);    
  cl.add(3);    
  cl.add(4);    
  cl.display();    ",0,0,0,0,0,0,0,0,0
1456,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class circularSinglyLinkedList:
    def __init__(self):
        self.last = None
    def insertFirst(self):
        data = int(input(""Enter the value of the node to be inserted : ""))
        newNode = Node(data)
        if (self.last == None):
            self.last = newNode
            newNode.next = self.last
        else:
            head = self.last.next
            self.last.next = newNode
            newNode.next = head
        print(""The Node has been inserted in the beginning of the list\n"")
    def deleteFirst(self):
        if (self.last == None):
            print(""The list is empty\n"")
        elif (self.last.next == self.last):
            print(""Removed first : "", self.last.data, ""\n"")
            self.last = None
        else:
            head = self.last.next
            print(""Removed first : "", head.data, ""\n"")
            head = head.next
            self.last.next = head
    def insertLast(self):
        data = int(input(""Enter the value of the node to be inserted : ""))
        newNode = Node(data)
        if (self.last == None):
            self.last = newNode
            newNode.next = self.last
        else:
            head = self.last.next
            self.last.next = newNode
            newNode.next = head
            self.last = newNode
        print(""The Node has been inserted in the end of the list\n"")
    def deleteLast(self):
        if (self.last == None):
            print(""The list is empty\n"")
        elif (self.last.next == self.last):
            print(""Removed last : "", self.last.data, ""\n"")
            self.last = None
        else:
            print(""Removed last : "", self.last.data, ""\n"")
            head = self.last.next
            curr = head
            while curr.next.next != head:
                curr = curr.next
            self.last = curr
            self.last.next = head
    def search(self, item):
        if (self.last == None):
            print(""List is empty\n"")
        else:
            head = self.last.next
            curr = head
            flag = 0
            while curr.next != head:
                if (curr.data == item):
                    flag = 1
                curr = curr.next
            if curr.data == item:
                flag = 1
            if (flag):
                print(""item was found\n"")
            else:
                print(""not found\n"")
    def display(self):
        if (self.last == None):
            print(""List is empty\n"")
        else:
            head = self.last.next
            curr = head
            print(""the elements of the list are:"")
            while curr.next != head:
                print(curr.data, end="" "")
                curr = curr.next
            print(curr.data, ""\n"")
CSLL = circularSinglyLinkedList()
while True:
    print(""Enter a option you want to perform "")
    op = int(
        input(""1.Insert First \n2.Delete First \n3.Insert Last \n4.Delete Last \n5.search \n6.display \n7.exit \n""))
    if (op == 1):
        CSLL.insertFirst()
    elif (op == 2):
        CSLL.deleteFirst()
    elif (op == 3):
        CSLL.insertLast()
    elif (op == 4):
        CSLL.deleteLast()
    elif (op == 5):
        item = int(input(""enter the item to be searched : ""))
        CSLL.search(item)
    elif (op == 6):
        CSLL.display()
    elif (op == 7):
        exit()
    else:
        print(""enter correct option"")",0,0,0,0,0,1,0,1,0
1457,,0,0,0,0,0,0,0,0,0
1458,"package Java.DataStructures;
class DListNode {
    public int item;
    public DListNode prev;
    public DListNode next;
    DListNode() {
        item = 0;
        prev = null;
        next = null;
    }
    DListNode(int i) {
        item = i;
        prev = null;
        next = null;
    }
}
public class CircularDList {
    protected DListNode head;
    protected long size;
    public CircularDList() {
        head = new DListNode();
        head.item = Integer.MIN_VALUE;
        head.next = head;
        head.prev = head;
        size = 0;
    }
    public CircularDList(int a) {
        head = new DListNode();
        head.item = Integer.MIN_VALUE;
        head.next = new DListNode();
        head.next.item = a;
        head.prev = head.next;
        head.next.prev = head;
        head.prev.next = head;
        size = 1;
    }
    public CircularDList(int a, int b) {
        head = new DListNode();
        head.item = Integer.MIN_VALUE;
        head.next = new DListNode();
        head.next.item = a;
        head.prev = new DListNode();
        head.prev.item = b;
        head.next.prev = head;
        head.next.next = head.prev;
        head.prev.next = head;
        head.prev.prev = head.next;
        size = 2;
    }
    public boolean isEmpty(){
        return size == 0;
    }
    public long length(){
        return size;
    }
    public Object head(){
        if(size == 0){
            return null;
        }
        return head.next.item;
    }
    public Object tail(){
        if(size == 0){
            return null;
        }
        return head.prev.item;
    }
    public void insertFront(int i) {
        DListNode node = new DListNode(i);
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        size++;
    }
    public void insertEnd(int i){
        DListNode node = new DListNode(i);
        node.next = head;
        node.prev = head.prev;
        head.prev.next = node;
        head.prev = node;
        size++;
    }
    public void removeFront() {
        if(size == 0){
            return;
        }
        DListNode node = head.next;
        node.next.prev = head;
        head.next = node.next;
        size--;
    }
    public void removeEnd(){
        if(size == 0){
            return;
        }
        DListNode node = head.prev;
        node.prev.next = head;
        head.prev = node.prev;
        size--;
    }
    public String toString() {
        String result = ""[  "";
        DListNode current = head.next;
        while (current != head) {
            result = result + current.item + ""  "";
            current = current.next;
        }
        return result + ""]"";
    }
    public static void main(String[] args) {
        CircularDList lst1 = new CircularDList();
        System.out.println(""Here is a list after construction: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be true. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 0. It is: "" +
                lst1.length());
        lst1.insertFront(3);
        System.out.println(""Here is a list after insertFront(3) to an empty list: ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new CircularDList();
        lst1.insertFront(3);
        lst1.insertFront(2);
        lst1.insertFront(1);
        System.out.println();
        System.out.println(""Here is a list after insertFront 3, 2, 1: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 3. It is: "" +
                lst1.length());
        lst1.insertEnd(4);
        System.out.println(""Here is the same list after insertEnd(4): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new CircularDList();
        lst1.insertEnd(6);
        lst1.insertEnd(7);
        System.out.println();
        System.out.println(""Here is a list after insertEnd 6, 7: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 2. It is: "" +
                lst1.length());
        lst1.insertFront(5);
        System.out.println(""Here is the same list after insertFront(5): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new CircularDList();
        lst1.insertEnd(1);
        lst1.insertEnd(2);
        lst1.insertEnd(3);
        lst1.insertEnd(4);
        lst1.insertEnd(5);
        lst1.insertEnd(6);
        System.out.println();
        System.out.println(""Here is a list after insertEnd 1,2,3,4,5,6: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 6. It is: "" +
                lst1.length());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.insertFront(5);
        System.out.println(""Here is the same list after insertFront(5): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.removeFront();
        lst1.removeFront();
        System.out.println(""Here is the same list after two removeFront(): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.removeEnd();
        lst1.removeEnd();
        System.out.println(""Here is the same list after two removeEnd(): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
    }
}",0,0,0,0,0,0,0,1,0
1459,"class Node():
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
    def __str__(self):
        return str(self.data)
class CDLL():
    def __init__(self):
        self.first = None
    def insertFront(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
            self.first.next = newNode
            self.first.prev = newNode
        else:
            newNode.next = self.first
            newNode.prev = self.first.prev
            newNode.prev.next = newNode
            self.first.prev = newNode
            self.first = newNode
    def insertBack(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
            self.first.next = newNode
            self.first.prev = newNode
        else:
            current = self.first
            while current.next is not self.first:
                current = current.next
            current.next = newNode
            newNode.prev = current
            newNode.next = self.first
            self.first.prev = newNode
    def exists(self, data):
        if self.first is None:
            return False
        else:
            current = self.first
            while current.data is not data:
                current = current.next
                if current is self.first:
                    return False
            return True
    def delete(self, data):
        if self.exists(data):
            current = self.first
            if self.first.data is data:
                self.first = current.next
                self.first.prev = current.prev
                current.prev.next = self.first
                return True
            while current.data is not data:
                current = current.next
            current.prev.next = current.next
            current.next.prev = current.prev
            return True
        else:
            return False
    def __str__(self):
        if self.first is None:
            return None
        else:
            result = ''
            current = self.first
            while True:
                result += str(current) + '\n'
                current = current.next
                if current == self.first:
                    break
            return result",0,0,0,0,0,1,0,1,0
1460,"import os
class _Node:
    __slots__ = '_element', '_link'
    def __init__(self, element, link):
        self._element = element
        self._link = link
class CicularLL:
    def __init__(self):
        self._head = None
        self._tail = None
        self._size = 0
    def __len__(self):
        return self._size
    def isempty(self):
        return self._size == 0
    def addLast(self, e):
        newest = _Node(e, None)
        if self.isempty():
            self._head = newest
            newest._link = self._head
        else:
            newest._link = self._tail._link
            self._tail._link = newest
        self._tail = newest
        self._size += 1
    def addFirst(self, e):
        newest = _Node(e, None)
        newest._link = self._head
        if self.isempty():
            self._head = newest
            self._tail = newest
        else:
            self._tail._link = newest
            self._head = newest
        self._size += 1
    def addAnywhere(self, e, index):
        newest = _Node(e, None)
        if index >= self._size:
            print(
                f""Index out of range. It should be between 0 - {self._size - 1}"")
        elif self.isempty():
            print(""List was empty, item will be added in the End."")
            self.addLast(e)
        elif index == 0:
            self.addFirst(e)
        else:
            p = self._head
            for _ in range(index - 1):
                p = p._link
            newest._link = p._link
            p._link = newest
            print(f""Added Item at index {index}!\n\n"")
            self._size += 1
    def removeFirst(self):
        if self.isempty():
            print(""List is Empty"")
            return
        e = self._head._element
        self._head = self._head._link
        self._tail._link = self._head
        self._size -= 1
        return e
    def removeLast(self):
        if self.isempty():
            print(""List is Empty"")
            return
        p = self._head  
        if p._link == self._head:
            return self.removeFirst()
        else:
            while p._link._link != self._head:
                p = p._link
            e = p._link._element
            p._link = self._head
            self._tail = p
        self._size -= 1
        return e
    def removeAnywhere(self, index):
        if index >= self._size:
            print(
                f""Index out of range. It should be between 0 - {self._size - 1}"")
        elif self.isempty():
            print(""List is Empty"")
            return
        elif index == 0:
            return self.removeFirst()
        elif index == self._size - 1:
            return self.removeLast()
        else:
            p = self._head
            for _ in range(index - 1):
                p = p._link
            e = p._link._element
            p._link = p._link._link
            self._size -= 1
        return e
    def display(self):
        if self.isempty() == 0:
            p = self._head
            while True:
                print(p._element, end='-->')
                p = p._link
                if p == self._head:
                    break
            print(f'({p._element} head)')
        else:
            print(""Empty"")
def options():
    options_list = ['Add Last', 'Add First', 'Add Anywhere',
                    'Remove First', 'Remove Last', 'Remove Anywhere',
                    'Display List', 'Exit']
    print(""MENU"")
    for i, option in enumerate(options_list):
        print(f'{i + 1}. {option}')
    choice = int(input(""Enter choice: ""))
    return choice
def switch_case(choice):
    os.system('cls')
    if choice == 1:
        elem = int(input(""Enter Item: ""))
        CL.addLast(elem)
        print(""Added Item at Last!\n\n"")
    elif choice == 2:
        elem = int(input(""Enter Item: ""))
        CL.addFirst(elem)
        print(""Added Item at First!\n\n"")
    elif choice == 3:
        elem = int(input(""Enter Item: ""))
        index = int(input(""Enter Index: ""))
        CL.addAnywhere(elem, index)
    elif choice == 4:
        print(""Removed Element from First:"", CL.removeFirst())
    elif choice == 5:
        print(""Removed Element from last:"", CL.removeLast())
    elif choice == 6:
        index = int(input(""Enter Index: ""))
        print(f""Removed Item: {CL.removeAnywhere(index)} !\n\n"")
    elif choice == 7:
        print(""List: "", end='')
        CL.display()
        print(""\n"")
    elif choice == 8:
        import sys
        sys.exit()
if __name__ == '__main__':
    CL = CicularLL()
    while True:
        choice = options()
        switch_case(choice)",0,0,0,0,0,0,0,1,0
1461,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
class CircularList:
    def __init__(self, data=None):
        self.head = None
        self.tail = None
        self.size = 0
    def clear(self):
        self.tail = None
        self.head = None
    def append(self, data):
        node = Node(data)
        if self.head:
            self.head.next = node
            self.head = node
        else:
            self.head = node
            self.tail = node
        self.head.next = self.tail
        self.size += 1
    def delete(self, data):
        current = self.tail
        prev = self.tail
        while prev == current or prev != self.head:
            if current.data == data:
                if current == self.tail:
                    self.tail = current.next
                    self.head.next = self.tail
                else:
                    prev.next = current.next
                self.size -= 1
                return
            prev = current
            current = current.next
    def iter(self):
        current = self.tail
        while current:
            val = current.data
            current = current.next
            yield val
words = CircularList()
words.append('eggs')
words.append('ham')
words.append('spam')
counter = 0
for word in words.iter():
    print(word)
    counter += 1
    if counter > 1000:
        break
import sys
sys.exit()
l.append('foo')
l.append('bar')
l.append('bim')
l.append('baz')
l.append('quux')
l.append('duux')
counter = 0
for item in l.iter():
    print(item)
    counter += 1
    if counter > 1000:
        break
print(""Done iterating. Now we try to delete something that isn't there."")
l.delete('socks')
print('back to iterating')
counter = 0
for item in l.iter():
    print(item)
    counter += 1
    if counter > 1000:
        break
print('Let us delete something that is there.')
l.delete('foo')
print('back to iterating')
counter = 0
for item in l.iter():
    print(item)
    counter += 1
    if counter > 1000:
        break",0,0,0,0,0,0,0,1,0
1462,"class Node():
    def __init__(self, data):
        self.data = data
        self.next = None
    def __str__(self):
        return str(self.data)
class CSLL():
    def __init__(self):
        self.first = None
    def insertFront(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
            self.first.next = newNode
        else:
            cur = self.first
            while cur.next is not self.first:
                cur = cur.next
            cur.next = newNode
            newNode.next = self.first
            self.first = newNode
    def insertBack(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
            self.first.next = newNode
        else:
            cur = self.first
            while cur.next is not self.first:
                cur = cur.next
            cur.next = newNode
            newNode.next = self.first
    def exists(self, data):
        if self.first is None:
            return False
        else:
            cur = self.first
            while (cur.next is not self.first) and (cur.data is not data):
                cur = cur.next
            if cur.data is not data:
                return False
            return True
    def delete(self, data):
        if self.exists(data):
            cur = self.first
            if cur.data is data:
                while cur.next is not self.first:
                    cur = cur.next
                cur.next = self.first.next
                self.first = self.first.next
            else:
                while cur.next.data is not data:
                    cur = cur.next
                cur.next = cur.next.next
            return True
        else:
            return False
    def __str__(self):
        if self.first is None:
            return None
        else:
            res = ''
            cur = self.first
            while True:
                res += str(cur) + '\n'
                cur = cur.next
                if cur == self.first:
                    break
            return res
LL = CSLL()
LL.insertFront(10)
LL.insertFront(20)
LL.insertBack(5)
print(LL)",0,0,0,0,0,1,0,1,0
1463,"package Java.DataStructures;
class SListNode {
    int item;
    SListNode next;
    SListNode(int obj, SListNode next) {
        item = obj;
        this.next = next;
    }
    SListNode(int obj) {
        this(obj, null);
    }
}
public class CircularSList{
    private SListNode head;
    private long size;
    public CircularSList(){
        size = 0;
        head = new SListNode(Integer.MIN_VALUE);
        head.next = head;
        size = 0;
    }
    public boolean isEmpty(){
        return size == 0;
    }
    public long length(){
        return size;
    }
    public Object head(){
        if(size == 0){
            return null;
        }
        return head.next.item;
    }
    public Object tail(){
        if(size == 0){
            return null;
        }
        SListNode node = head.next;
        while(node.next != head){
            node = node.next;
        }
        return node.item;
    }
    public void insertFront(int obj){
        SListNode node = new SListNode(obj, head.next);
        head.next = node;
        size++;
    }
    public void insertEnd(int obj){
        SListNode node = new SListNode(obj);
        SListNode node2 = head.next;
        while(node2.next != head){
            node2 = node2.next;
        }
        node2.next = node;
        node.next = head;
        size++;
    }
    public void removeFront(){
        if(size == 0){
            return;
        }
        head.next = head.next.next;
        size--;
    }
    public void removeEnd(){
        if(size == 0){
            return;
        }
        SListNode current, prev;
        current = head.next;
        prev = current;
        while(current.next != head){
            prev = current;
            current = current.next;
        }
        prev.next = head;
        size--;
    }
    public String toString(){
        String result = ""[ "";
        SListNode current = head.next;
        while(current != head){
            result = result + current.item + "" "";
            current = current.next;
        }
        return result + ""]"";
    }
    public static void main(String[] args) {
        CircularSList lst1 = new CircularSList();
        System.out.println(""Here is a list after construction: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be true. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 0. It is: "" +
                lst1.length());
        lst1.insertFront(3);
        System.out.println(""Here is a list after insertFront(3) to an empty list: ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new CircularSList();
        lst1.insertFront(3);
        lst1.insertFront(2);
        lst1.insertFront(1);
        System.out.println();
        System.out.println(""Here is a list after insertFront 3, 2, 1: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 3. It is: "" +
                lst1.length());
        lst1.insertEnd(4);
        System.out.println(""Here is the same list after insertEnd(4): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new CircularSList();
        lst1.insertEnd(6);
        lst1.insertEnd(7);
        System.out.println();
        System.out.println(""Here is a list after insertEnd 6, 7: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 2. It is: "" +
                lst1.length());
        lst1.insertFront(5);
        System.out.println(""Here is the same list after insertFront(5): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new CircularSList(); lst1.insertEnd(1);
        lst1.insertEnd(2);
        lst1.insertEnd(3);
        lst1.insertEnd(4);
        lst1.insertEnd(5);
        lst1.insertEnd(6);
        System.out.println();
        System.out.println(""Here is a list after insertEnd 1,2,3,4,5,6: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 6. It is: "" +
                lst1.length());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.insertFront(5);
        System.out.println(""Here is the same list after insertFront(5): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.removeFront();
        lst1.removeFront();
        System.out.println(""Here is the same list after two removeFront(): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.removeEnd();
        lst1.removeEnd();
        System.out.println(""Here is the same list after two removeEnd(): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
    }
}",0,0,0,0,0,0,0,1,0
1464,"package Java.DataStructures;
class DListNode{
    public int item;
    public DListNode prev;
    public DListNode next;
    DListNode() {
        item = 0;
        prev = null;
        next = null;
    }
    DListNode(int i) {
        item = i;
        prev = null;
        next = null;
    }
}
public class DList {
    protected DListNode head;
    protected DListNode tail;
    protected long size;
    public DList() {
        head = null;
        tail = null;
        size = 0;
    }
    public DList(int a) {
        head = new DListNode();
        tail = head;
        head.item = a;
        size = 1;
    }
    public DList(int a, int b) {
        head = new DListNode();
        head.item = a;
        tail = new DListNode();
        tail.item = b;
        head.next = tail;
        tail.prev = head;
        size = 2;
    }
    public boolean isEmpty(){
        return size == 0;
    }
    public long length(){
        return size;
    }
    public void insertFront(int i) {
        DListNode node = new DListNode(i);
        if(size == 0){
            head = tail = node;
        }else {
            node.next = head;
            head.prev = node;
            head = node;
        }
        size++;
    }
    public void insertEnd(int i){
        DListNode node = new DListNode(i);
        if(size == 0){
            head = tail = node;
        }else{
            node.prev = tail;
            tail.next = node;
            tail = node;
        }
        size++;
    }
    public void removeFront() {
        if(size > 1){
            head = head.next;
            head.prev = null;
            size--;
        }
        else{
            head = tail = null;
            size = 0;
        }
    }
    public void removeEnd(){
        if(size > 1){
            tail = tail.prev;
            tail.next = null;
            size--;
        }else{
            head = tail = null;
            size = 0;
        }
    }
    public Object head(){
        if(head==null){
            return null;
        }
        return head.item;
    }
    public Object tail(){
        if(tail == null){
            return null;
        }
        return tail.item;
    }
    public String toString() {
        String result = ""[  "";
        DListNode current = head;
        while (current != null) {
            result = result + current.item + ""  "";
            current = current.next;
        }
        return result + ""]"";
    }
    public static void main(String[] args) {
        DList lst1 = new DList();
        System.out.println(""Here is a list after construction: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be true. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 0. It is: "" +
                lst1.length());
        lst1.insertFront(3);
        System.out.println(""Here is a list after insertFront(3) to an empty list: ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new DList();
        lst1.insertFront(3);
        lst1.insertFront(2);
        lst1.insertFront(1);
        System.out.println();
        System.out.println(""Here is a list after insertFront 3, 2, 1: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 3. It is: "" +
                lst1.length());
        lst1.insertEnd(4);
        System.out.println(""Here is the same list after insertEnd(4): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new DList();
        lst1.insertEnd(6);
        lst1.insertEnd(7);
        System.out.println();
        System.out.println(""Here is a list after insertEnd 6, 7: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 2. It is: "" +
                lst1.length());
        lst1.insertFront(5);
        System.out.println(""Here is the same list after insertFront(5): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1 = new DList();
        lst1.insertEnd(1);
        lst1.insertEnd(2);
        lst1.insertEnd(3);
        lst1.insertEnd(4);
        lst1.insertEnd(5);
        lst1.insertEnd(6);
        System.out.println();
        System.out.println(""Here is a list after insertEnd 1,2,3,4,5,6: ""
                + lst1.toString());
        System.out.println(""isEmpty() should be false. It is: "" +
                lst1.isEmpty());
        System.out.println(""length() should be 6. It is: "" +
                lst1.length());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.insertFront(5);
        System.out.println(""Here is the same list after insertFront(5): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.removeFront();
        lst1.removeFront();
        System.out.println(""Here is the same list after two removeFront(): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
        lst1.removeEnd();
        lst1.removeEnd();
        System.out.println(""Here is the same list after two removeEnd(): ""
                + lst1.toString());
        System.out.println(""Head is: "" + lst1.head() + ""\nTail is: "" + lst1.tail());
    }
}",0,0,0,0,0,0,0,1,0
1465,"class Node(object):
    def __init__(self, val, next_node=None, prev_node=None):
        self.val = val
        self.next_node = next_node
        self.prev_node = prev_node
class DLL(object):
    def __init__(self, iter=None):
        self.tail = None
        self.head = None
        if iter:
            for val in iter:
                self.insert(val)
    def insert(self, val):
        new_node = Node(val=val, next_node=self.head)
        if self.head:
            self.head.prev_node = new_node
        else:
            self.tail = new_node
        self.head = new_node
    def append(self, val):
        new_node = Node(val=val, prev_node=self.tail)
        if self.tail:
            self.tail.next_node = new_node
        else:
            self.head = new_node
        self.tail = new_node
    def pop(self):
        try:
            rtn_value = self.head.val
            new_head = self.head.next_node
            self.head = new_head
            if self.head is None:
                self.tail = None
                return rtn_value
            self.head.prev_node = None
            return rtn_value
        except AttributeError:
            return None
    def shift(self):
        try:
            rtn_value = self.tail.val
            new_tail = self.tail.prev_node
            self.tail = new_tail
            if self.tail is None:
                self.head = None
                return rtn_value
            self.tail.next_node = None
            return rtn_value
        except AttributeError:
            return None
    def remove(self, val):
        val_search = self.search(val)
        if val_search is None:
            raise ValueError
        try:  
            val_search.prev_node.next_node = val_search.next_node
            val_search.next_node.prev_node = val_search.prev_node
        except AttributeError:
            try:  
                if self.head == val_search:
                    self.head = val_search.next_node
                    self.head.prev_node = None
                if self.tail == val_search:
                    self.tail = val_search.prev_node
                    self.tail.next_node = None
            except AttributeError:
                self.head = None
                self.tail = None
        return val_search.val
    def search(self, val):
        step_head = self.head
        while step_head:
            if step_head.val == val:
                return step_head
            step_head = step_head.next_node
        else:
            return None
    def to_string(self):
        rtn_string = u""(""
        step_head = self.head
        while step_head:
            if step_head.next_node is None:
                rtn_string += str(step_head.val)
                break
            rtn_string += str(step_head.val) + u"", ""
            step_head = step_head.next_node
        rtn_string += u"")""
        return rtn_string
    def size(self):
        count = 0
        step_head = self.head
        while step_head:
            count += 1
            step_head = step_head.next_node
        return count",0,0,0,0,0,1,0,1,0
1466,"import linked_list
class Node(linked_list.Node):
    def __init__(self, val, nxt=None, prev=None):
        super(Node, self).__init__(val, nxt)
        self.prev = prev
class DLL(linked_list.LinkedList):
    def __init__(self, iterable=None):
        self.tail = None
        super(DLL, self).__init__(iterable)
    def push(self, val):
        old_head = self.head
        self.head = Node(val, nxt=self.head)
        self.length += 1
        if old_head:
            old_head.prev = self.head
        else:
            self.tail = self.head
    def append(self, val):
        old_tail = self.tail
        self.tail = Node(val, prev=self.tail)
        self.length += 1
        if old_tail:
            old_tail.nxt = self.tail
        else:
            self.head = self.tail
    def pop(self):
        val = super(DLL, self).pop()
        if self.head:
            self.head.prev = None
        else:
            self.tail = None
        return val
    def shift(self):
        if not self.tail:
            raise IndexError('Cannot shift from empty list.')
        val = self.tail.val
        self.tail = self.tail.prev
        if self.tail:
            self.tail.nxt = None
        else:
            self.head = None
        self.length -= 1
        return val
    def remove(self, val):
        if not self.head:
            raise ValueError('Cannot remove from empty list.')
        if self.head.val == val:
            self.pop()
            return
        curr = self.head
        while curr.nxt:
            if curr.val == val:
                curr.prev.nxt, curr.nxt.prev = curr.nxt, curr.prev
                self.length -= 1
                return
            curr = curr.nxt
        if self.tail.val == val:
            self.shift()
            return
        raise ValueError('Value is not in list.')",0,0,0,0,0,0,0,1,0
1467,"class Node(object):
    def __init__(self, data=None, next_node=None, prev=None):
        self.data = data
        self.next = next_node
        self.prev = prev
    def __repr__(self):
        return ""Value: {}"".format(self.data)
class DoubleLinkedList(object):
    def __init__(self, data=None):
        self.head = None
        self.tail = None
        self._length = 0
        try:
            for val in data:
                self.push(val)
        except TypeError:
            if data:
                self.push(data)
    def push(self, val):
        old_head = self.head
        self.head = Node(val, next_node=old_head)
        if old_head:
            old_head.prev = self.head
        if not self.tail:
            self.tail = self.head
        self._length += 1
    def pop(self):
        to_return = self.head
        if self._length < 1:
            raise IndexError('Cannot pop from an empty list.')
        new_head = self.head.next
        if new_head:
            new_head.prev = None
        self.head = new_head
        self._length -= 1
        if self._length < 1:
            self.tail = None
        return to_return.data
    def append(self, val):
        old_tail = self.tail
        self.tail = Node(val, prev=old_tail)
        if old_tail:
            old_tail.next = self.tail
        if self._length < 1:
            self.head = self.tail
        self._length += 1
    def shift(self):
        to_return = self.tail
        if self._length < 1:
            raise IndexError('Cannot shift from an empty list.')
        new_tail = self.tail.prev
        if new_tail:
            new_tail.next = None
        self.tail = new_tail
        self._length -= 1
        if self._length < 1:
            self.tail = None
        return to_return.data
    def remove(self, val):
        curr = self.head
        while curr:
            if curr.data is val:
                if self._length is 1:
                    self.head, self.tail = None, None
                elif curr is not self.head and curr is not self.tail:
                    curr.next.prev, curr.prev.next = curr.prev, curr.next
                elif curr is self.head:
                    self.head, curr.next.prev = curr.next, None
                elif curr is self.tail:
                    self.tail, curr.prev.next = curr.prev, None
                self._length -= 1
                return
            curr = curr.next
        raise ValueError('{} is not in the list'.format(val))
    def _repr(self):
        l = []
        while True:
            try:
                popped_data = self.pop()
                l.append(popped_data)
            except IndexError:
                break
        return l",0,0,0,0,0,1,0,1,0
1468,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
class DoubleLinkedList:
    def __init__(self):
        self.head = None
    def append(self, data):
        if self.head is None:
            new_node = Node(data)
            new_node.prev = None
            self.head = new_node
        else:
            new_node = Node(data)
            current_node = self.head
            while current_node.next:
                current_node = current_node.next
            current_node.next = new_node
            new_node.prev = current_node
            new_node.next = None
    def preappend(self, data):
        if self.head is None:
            new_node = Node(data)
            new_node.prev = None
            self.head = new_node
        else:
            new_node = Node(data)
            self.head.prev = new_node
            new_node.next = self.head
            self.head = new_node
    def append_after(self, key, data):
        current_node = self.head
        while current_node:
            if current_node.next is None and current_node.data == key:
                self.append(data)
            elif current_node.data == key:
                new_node = Node(data)
                next = current_node.next
                current_node.next = new_node
                new_node.next = next
                next.prev = new_node
            current_node = current_node.next
    def show(self):
        current_node = self.head
        while current_node:
            print(current_node.data)
            current_node = current_node.next
    def length(self):
        current_node = self.head
        total = 1
        while current_node:
            current_node = current_node.next
            total += 1
        return total
list = DoubleLinkedList()
list.append(1)
list.append(2)
list.append(3)
list.append(5)
list.preappend(0)
list.append_after(3,4)
list.show()
n = list.length()
print(f""Length of the List is: {n}"")",0,0,0,0,0,0,0,1,0
1469,"class DoubleLinkedList:
    def __init__(self):
        self.head = DoubleLLNode(None, None, None)
        self.tail = self.head
    def add_element(self, data):
        if self.head.value is None:
            self.head.value = data
        else:
            self.tail.next = DoubleLLNode(data, None, None)
            self.tail.next.prev = self.tail
            self.tail = self.tail.next
    def set_element(self, index, data):
        pass
    def index(self, index):
        current = self.head
        for i in range(index):
            current = current.next
        return current
    def size(self):
        current = self.head
        counter = 0
        while current is not None:
            current = current.next
            counter += 1
        return counter
    def remove(self, index):
        if index == 0:
            self.head = self.head.next
        else:
            curr = self.index(index)
            curr.prev.next = curr.next
    def pprint(self):
        current = self.head
        while current is not None:
            print(current.value)
            current = current.next
    def to_list(self):
        lst = []
        current = self.head
        while current is not None:
            lst.append(current.value)
            current = current.next
        return lst
    def add_at_index(self, index, data):
        if index == 0:
            self.add_first(data)
        else:
            curr = self.index(index)
            curr.prev.next = DoubleLLNode(data, curr, curr.prev)
    def add_first(self, data):
        self.head.prev = Node(data, self.head, None)
        self.head = self.head.prev
    def add_list(self, lst):
        for item in lst:
            self.tail.next = DoubleLLNode(item, None, self.tail)
            self.tail = self.tail.next
    def add_linked_list(self, otherll):
        self.tail.next = otherll.head
        otherll.head.prev = self.tail
        self.tail = otherll.tail
    def ll_from_to(self, start_index, end_index):
        ll = LinkedList()
        current = self.index(start_index)
        for i in range(end_index - start_index):
            ll.add_element(current.value)
            current = current.next
        return ll
    def pop(self):
        self.tail.prev.next = None
        self.tail = self.tail.prev
    def reduce_to_unique(self):
        unique_values = set()
        unique_ll = LinkedList()
        current = self.head
        for i in range(self.size()):
            if current.value not in unique_values:
                unique_ll.add_element(current.value)
                unique_values.add(current.value)
            current = current.next
        return unique_ll
class DoubleLLNode:
    def __init__(self, value, next_node, prev_node):
        self.value = value
        self.prev = prev_node
        self.next = next_node
def main():
    pass
if __name__ == ""__main__"":
    main()",0,0,0,0,0,0,0,1,0
1470,"from typing import Optional, List
class _DoubleNode:
    def __init__(self, value: 'object') -> None:
        self.data, self.next, self.prev = value, None, None
class DoubleLinkedList:
    def __init__(self, items: List[Optional['object']]) -> None:
        if not items:
            self._first = None
        else:
            self._first = _DoubleNode(items[0])
            prev, curr = None, self._first
            for item in items[1:]:
                curr.next = _DoubleNode(item)
                prev, curr = curr, curr.next
                prev.next, curr.prev = curr, prev
    def __len__(self) -> int:
        count, current = 0, self._first
        while current:
            count += 1
            current = current.next
        return count
    def __str__(self) -> str:
        holder = """"
        curr = self._first
        if curr:
            holder += str(curr.data)
        while curr:
            curr = curr.next
            if curr:
                holder += "" <-> "" + str(curr.data)
        return holder
    def insert(self, index: int, value: 'object') -> None:
        if not self._first:
            self._first = _DoubleNode(value)
        else:
            new_node = _DoubleNode(value)
            curr = self._first
            if index == 0:
                new_node.next = curr
                curr.prev = new_node
                self._first = new_node
            elif len(self) <= index:
                while curr.next:
                    curr = curr.next
                new_node.prev, curr.next = curr, new_node
            else:
                count = 0
                while count < index:
                    count += 1
                    curr = curr.next
                curr.prev.next = new_node
                new_node.prev = curr.prev
                new_node.next = curr
                curr.prev = new_node
    def __contains__(self, item):
        cur = self._first
        while cur:
            if cur.data == item:
                return True
            cur = cur.next
        return False
    def remove(self, item:'object') -> None:
        if not (item in self):
            raise ValueError
        elif self._first.data == item:
            self._first = self._first.next
            if len(self) > 0:
                self._first.prev = None
        else:
            prev, curr = None, self._first
            while curr.data != item:
                nxt = curr.next
                prev, curr = curr, nxt
            prev.next = curr.next
            if curr:
                curr.next.prev = prev
    def pop(self) -> 'object':
        if not self._first:
            raise IndexError
        elif len(self) == 1:
            placeholder = self._first.data
            self._first = None
            return placeholder
        else:
            prev, curr, placeholder = None, self._first, self._first.next
            while placeholder:
                prev, curr, placeholder = curr, placeholder, placeholder.next
            prev.next = placeholder
            return curr.data
    def append(self, item: 'object') -> None:
        new_node = _DoubleNode(item)
        if len(self) == 0:
            self._first = new_node
        else:
            prev, curr = None, self._first
            while curr:
                nxt = curr.next
                prev, curr = curr, nxt
            prev.next = new_node
            new_node.prev = prev
if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",0,0,0,0,0,1,0,1,0
1471,,0,0,0,0,0,0,0,0,0
1472,"class Node(object):
    def __init__(self, data=None):
        self.data = data
        self.pre = None
        self.next = None
class DoubleListLink(object):
    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.pre = self.head
        self.length = 0
    def append(self, data):
        node = Node(data)
        if self.head.data is None:
            self.head = node
        pre = self.tail.pre
        pre.next = node
        node.next = self.tail
        self.tail.pre = node
        node.pre = pre
        self.length += 1
    def show(self):
        if self.length == 0:
            print('doubleListLink is None')
        else:
            tmp = self.head
            while tmp:
                print(tmp.data, end="" "")
                tmp = tmp.next
            print('\n')
if __name__ == ""__main__"":
    dl = DoubleListLink()
    dl.append(2)
    dl.append(3)
    dl.show()",0,0,0,0,0,0,0,0,0
1473,"class Node:
    def __init__(self,value,previous=None,next=None):
        self.value = value
        self.next = next
        self.previous = previous
class DoublyLinkedList:
    def __init__(self,value,next=None,previous=None):
        self.head = Node(value=value)
        self.tail = self.head
        self.length = 1
    def append(self,value):
        self.CurrentNode = Node(value=value)
        self.tail.next = self.CurrentNode
        self.CurrentNode.previous = self.tail
        self.tail = self.CurrentNode
        self.length = self.length + 1
    def prepend(self,value):
        self.CurrentNode = Node(value=value)
        self.CurrentNode.next = self.head
        self.head.previous = self.CurrentNode
        self.head = self.CurrentNode
        self.length = self.length + 1
    def insert(self,index,value):
        self.CurrentNode = Node(value=value)
        leader = self.traverseToIndex(index - 1)
        headingPointer = leader.next
        leader.next = self.CurrentNode
        self.CurrentNode.previous = leader
        self.CurrentNode.next = headingPointer
        headingPointer.previous = self.CurrentNode
    def traverseToIndex(self,index):
        CurrentNode = self.head
        counter =0
        while(counter != index):
            CurrentNode = CurrentNode.next
            counter = counter + 1
        return CurrentNode
    def printList(self):
        currentNode = self.head
        while(currentNode != None):
            print(""Current node value"",currentNode.value)
            print(""Current node next"",currentNode.next)
            print(""previous"",currentNode.previous)
            currentNode = currentNode.next
myLinkedList = DoublyLinkedList(10)
myLinkedList.append(15)
myLinkedList.append(20)
myLinkedList.prepend(100)
myLinkedList.insert(1,300)
myLinkedList.printList()",0,0,0,0,0,0,0,0,0
1474,"class Node:
    def __init__(self,value,previous=None,next=None):
        self.value = value
        self.next = next
        self.previous = previous
class DoublyLinkedList:
    def __init__(self,value,next=None,previous=None):
        self.head = Node(value=value)
        self.tail = self.head
        self.length = 1
    def append(self,value):
        self.CurrentNode = Node(value=value)
        self.tail.next = self.CurrentNode
        self.CurrentNode.previous = self.tail
        self.tail = self.CurrentNode
        self.length = self.length + 1
    def prepend(self,value):
        self.CurrentNode = Node(value=value)
        self.CurrentNode.next = self.head
        self.head.previous = self.CurrentNode
        self.head = self.CurrentNode
        self.length = self.length + 1
    def insert(self,index,value):
        self.CurrentNode = Node(value=value)
        leader = self.traverseToIndex(index - 1)
        headingPointer = leader.next
        leader.next = self.CurrentNode
        self.CurrentNode.previous = leader
        self.CurrentNode.next = headingPointer
        headingPointer.previous = self.CurrentNode
    def traverseToIndex(self,index):
        CurrentNode = self.head
        counter =0
        while(counter != index):
            CurrentNode = CurrentNode.next
            counter = counter + 1
        return CurrentNode
    def printList(self):
        currentNode = self.head
        while(currentNode != None):
            print(""Current node value"",currentNode.value)
            print(""Current node next"",currentNode.next)
            print(""previous"",currentNode.previous)
            currentNode = currentNode.next
myLinkedList = DoublyLinkedList(10)
myLinkedList.append(15)
myLinkedList.append(20)
myLinkedList.prepend(100)
myLinkedList.insert(1,300)
myLinkedList.printList()",0,0,0,0,0,0,0,0,0
1475,"class ListNode:
    def __init__(self, value, prev=None, next=None):
        self.prev = prev
        self.value = value
        self.next = next
    def insert_after(self, value):
        current_next = self.next
        self.next = ListNode(value, self, current_next)
        if current_next:
            current_next.prev = self.next
    def insert_before(self, value):
        current_prev = self.prev
        self.prev = ListNode(value, current_prev, self)
        if current_prev:
            current_prev.next = self.prev
    def delete(self):
        if self.prev:
            self.prev.next = self.next
        if self.next:
            self.next.prev = self.prev
class DoublyLinkedList:
    def __init__(self, node=None):
        self.head = node
        self.tail = node
        self.length = 1 if node is not None else 0
    def __len__(self):
        return self.length
    def add_to_head(self, value):
        new_node = ListNode(value, None, None)
        self.length += 1
        if not self.head and not self.tail:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
    def remove_from_head(self):
        if not self.head and not self.tail:
            return None
        self.length -= 1
        if self.head == self.tail:
            current_head = self.head
            self.head = None
            self.tail = None
            return current_head.value
        current_head = self.head
        self.head = self.head.next
        self.head.prev = None
        return current_head.value
    def add_to_tail(self, value):
        new_node = ListNode(value, None, None)
        self.length += 1
        if not self.tail and not self.head:
            self.tail = new_node
            self.head = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
    def remove_from_tail(self):
        if not self.head and not self.tail:
            return None
        self.length -= 1
        if self.head == self.tail:
            current_tail = self.tail
            self.head = None
            self.tail = None
            return current_tail.value
        current_tail = self.tail
        self.tail = self.tail.prev
        self.tail.next = None
        return current_tail.value
    def move_to_front(self, node):
        if node is self.head:
            return
        value = node.value
        if node is self.tail:
            self.remove_from_tail()
        else:
            node.delete()
            self.length -= 1
        self.add_to_head(value)
    def move_to_end(self, node):
        if node is self.tail:
            return
        value = node.value
        if node is self.head:
            self.remove_from_head()
            self.add_to_tail(value)
        else:
            node.delete()
            self.length -= 1
            self.add_to_tail(value)
    def delete(self, node):
        self.length -= 1
        if not self.head and not self.tail:
            return
        if self.head == self.tail:
            self.head = None
            self.tail = None
        elif self.head == node:
            self.head = node.next
            node.delete()
        elif self.tail == node:
            self.tail = node.prev
            node.delete()
        else:
            node.delete()
    def get_max(self):
        if not self.head:
            return None
        max_val = self.head.value
        current = self.head
        while current:
            if current.value > max_val:
                max_val = current.value
            current = current.next
        return max_val
    def find_and_delete(self, value):
        current = self.head
        while current:
            if current.value == value:
                self.delete(current)
                return
            current = current.next
        print(""Error, "" + str(value) + "" not found"")",0,0,0,0,0,1,0,1,0
1476,"class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
        self.last = None
class List(object):
    def __init__(self, *data):
        self.head = None
        self.tail = None
        if data:
            for val in data:
                self.insert(val)
    def __iter__(self):
        a = self.head
        while a:
            yield a
            a = a.next
    def insert(self, data):
        last_node = self.head
        self.head = Node(data)
        self.head.next = last_node
        if last_node:
            last_node.last = self.head
        if self.tail is None:
            self.tail = self.head
    def append(self, data):
        next_node = self.tail
        self.tail = Node(data)
        self.tail.last = next_node
        if next_node:
            next_node.next = self.tail
        if self.head is None:
            self.head = self.tail
    def pop(self):
        if self.head is None:
            print ""Sorry, the queue is empty!""
            raise IndexError
        our_returned_value = self.head.data
        self.head = self.head.next
        self.head.last = None
        return our_returned_value
    def shift(self):
        if self.tail is None:
            print ""Sorry, the queue is empty!""
            raise IndexError
        our_returned_value = self.tail.data
        self.tail = self.tail.last
        self.tail.next = None
        return our_returned_value
    def remove(self, val):
        a = self.head
        val_found = False
        while a is not None:
            if a.data == val:
                val_found = True
                if a == self.head:
                    a.next.last = None
                else:
                    a.next.last = a.last
                    a.last.next = a.next
            a = a.next
        if not val_found:
            raise IndexError",0,0,0,0,0,0,0,1,0
1477,"class Node():
    def __init__(self, data):           
        self.val = data
        self.next = None
        self.prev = None
    def setVal(self,val):               
        self.val = val
    def setNext(self,next_node):        
        self.next = next_node
    def setPrev(self, prev_node):       
        self.prev = prev_node
class DoublyLinkedList():
    def __init__(self):                 
        self.head = None
        self.end = None
        self.len = int()
    def addNodeH(self,node):            
        assert isinstance(node, Node)
        if self.len > 0:
            self.head.setPrev(node)
            node.setNext(self.head)
            self.head = node
            self.len += 1
        else:
            self.head = node
            self.end = node
            self.len += 1
    def addNodeE(self,node):            
        assert isinstance(node, Node)
        if self.len > 0:
            self.end.setNext(node)
            node.setPrev(self.end)
            self.end = self.end.next
            self.len += 1
        else:
            self.head = node
            self.end = node
            self.len += 1
    def addNodeNext(self, node, loc_val): 
        current = self.head
        if current == None:
            print (""Empty List"")
        else: 
            while True:
                if current == None:
                    print(""Element not found."")
                    break
                elif current.val == loc_val:
                    temp = current.next
                    current.setNext(node)
                    node.setPrev(current)
                    if temp != None:
                        node.setNext(temp)
                        temp.setPrev(node)
                    else:
                        self.end = node
                    self.len += 1
                    break
                else:
                    current = current.next
    def addNodePrev(self, node, loc_val): 
        current = self.head
        if current == None:
            print (""Empty List"")
        else: 
            while True:
                if current == None:
                    print(""Element not found."")
                    break
                elif current.val == loc_val:
                    temp = current.prev
                    current.setPrev(node)
                    node.setNext(current)
                    if temp != None:
                        node.setPrev(temp)
                        temp.setNext(node)
                    else:
                        self.head = node
                    self.len += 1
                    break
                else:
                    current = current.next
    def delNodeH(self):                 
        if self.head != None:
            if self.len == 1:
                self.head = None
                self.end = None
                self.len = 0
            else:
                self.head = self.head.next
                self.head.prev.setNext(None)
                self.head.setPrev(None)
                self.len -= 1
        else:
            print (""Empty List"")
    def delNodeE(self):                 
        if self.end != None:
            if self.len == 1:
                self.head = None
                self.end = None
                self.len = 0
            else:
                self.end = self.end.prev
                self.end.next.setPrev(None)
                self.end.setNext(None)
                self.len -= 1
        else:
            print (""Empty List"")
    def delNodeS(self, loc_val):       
        current = self.head
        if current == None:
            print (""Empty List"")
        else:
            while True:
                if current == None:
                    print(""Element not found"")
                    break
                elif current.val == loc_val:
                    if self.len == 1:
                        self.head = None
                        self.end = None
                        self.len = 0
                    else:
                        if current.prev == None:
                            self.head = self.head.next
                            self.head.prev.setNext(None)
                            self.head.setPrev(None)
                            self.len -= 1
                        elif current.next == None:
                            self.end = self.end.prev
                            self.end.next.setPrev(None)
                            self.end.setNext(None)
                            self.len -=1
                        else:
                            current.prev.setNext(current.next)
                            current.next.setPrev(current.prev)
                            current.setNext(None)
                            current.setPrev(None)
                            self.len -= 1
                    break
                else:
                    current = current.next
    def print(self):                
        lt = []
        current = self.head
        while True:
            if current == None:
                break
            else:
                lt.append(current.val)
                current = current.next
        print (lt)
    def printLen(self):                 
        print (self.len)",0,0,0,0,0,0,0,1,0
1478,"import node
import iterator
class Empty(Exception):
    pass
class DoublyLinkedList:
    def __init__(self):
        self._header = node.Node()
        self._trailer = node.Node()
        self._header._next = self._trailer
        self._trailer._previous = self._header
        self._size = 0
    def insert_between(self, data, predecessor, successor):
        new_node = node.Node(data, predecessor, successor)
        predecessor._next = new_node
        successor._previous = new_node
        self._size += 1
        return new_node
    def delete_node(self, node):
        if self.is_empty():
            raise Empty
        predecessor = node._previous
        successor = node._next
        predecessor._next = successor
        successor._previous = predecessor
        data = node._data
        node._data = node._previous = node._next = None
        self._size -= 1
        return data
    def insert_first(self, data):
        self.insert_between(data, self._header, self._header._next)
    def insert_last(self, data):
        self.insert_between(data, self._trailer._previous, self._trailer)
    def first(self):
        if self.is_empty():
            raise Empty
        return self._header._next._data
    def last(self):
        if self.is_empty():
            raise Empty
        return self._trailer._previous._data
    def is_empty(self):
        return self._size == 0
    def __iter__(self):
        first = self._header._next
        return iterator.Iterator(first, None)
    def __reversed__(self):
        last = self._trailer._previous
        return iterator.Iterator(None, last)
    def __len__(self):
        return self._size",0,0,0,0,0,0,0,1,0
1479,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
class DoublyLinkedList:
    def __init__(self):
        self.head = None
    def append(self, data):
        if self.head is None:
            new_node = Node(data)
            new_node.prev = None
            self.head = new_node
        else:
            new_node = Node(data)
            cur = self.head
            while cur.next:
                cur = cur.next
            cur.next = new_node
            new_node.prev = cur
            new_node.next = None
    def prepend(self, data):
        if self.head is None:
            new_node = Node(data)
            new_node.prev = None
            self.head = new_node
        else:
            new_node = Node(data)
            self.head.prev = new_node
            new_node.next = self.head
            new_node.prev = None
            self.head = new_node
    def print_list(self):
        st = """"
        cur = self.head
        while cur.next:
            st += str(cur.data) + "" ""
            cur = cur.next
        return st
if __name__ == ""__main__"":
    dll = DoublyLinkedList()
    dll.prepend(10)
    dll.append(1)
    dll.append(2)
    dll.append(3)
    dll.append(5)
    print(dll.print_list())  
    dll.prepend(9)
    dll.prepend(8)
    dll.prepend(7)
    print(dll.print_list())  ",0,0,0,0,0,0,0,1,0
1480,"class Node:
    __slots__ = 'user_name', 'user_mail', '_next', '_previous'
    def __init__(self, user_name, user_mail, _next, _previous):
        self.user_name = user_name
        self.user_mail = user_mail
        self._next = _next
        self._previous = _previous
class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    def __len__(self):
        return self.size
    def is_empty(self):
        return self.size == 0
    def create_user(self, name, mail):
        new_user = Node(name, mail, None, None)
        if self.is_empty():
            self.head = new_user
            self.tail = new_user
        else:
            self.tail._next = new_user
            new_user._previous = self.tail
            self.tail = new_user
        self.size += 1
    def display(self):
        if self.is_empty():
            print('The list is empty\n')
            return False
        else:
            p = self.head
            while p is not None:
                print('User:', p.user_name)
                print('Mail:', p.user_mail, '\n')
                p = p._next
    def display_reverse(self):
        if self.is_empty():
            print('The list is empty\n')
            return False
        else:
            p = self.tail
            while p is not None:
                print('User:', p.user_name)
                print('Mail:', p.user_mail, '\n')
                p = p._previous
    def search(self, mail):
        if self.is_empty():
            print('The list is empty\n')
            return False
        else:
            p = self.head
            while p is not None:
                if p.user_mail == mail:
                    print('User with the mail', '""' + mail + '""', 'is found!')
                    print('User:', p.user_name)
                    print('Mail:', p.user_mail, '\n')
                    return True
                p = p._next
            print('User with mail', mail, 'is not found\n')
            return False
    def add_to_beginning(self, name, mail):
        new_user = Node(name, mail, None, None)
        if self.is_empty():
            self.head = new_user
            self.tail = new_user
        else:
            self.head._previous = new_user
            new_user._next = self.head
            self.head = new_user
        self.size += 1
    def add_user_to_random_place(self, add_name, add_mail, position):
        if position < 1 or position > len(self):
            print('The list contains', self.size, 'elements')
            print(""You can't insert in non existing position!\n"")
            return False
        inserting_user = Node(add_name, add_mail, None, None)
        p = self.head
        i = 0
        while i < position - 1:
            p = p._next
            i += 1
        if p == self.head:
            self.head._previous = inserting_user
            inserting_user._next = self.head
            self.head = inserting_user
            self.size += 1
            return inserting_user
        elif p == self.tail:
            inserting_user._next = self.tail
            inserting_user._previous = self.tail._previous
            self.tail._previous._next = inserting_user
            self.tail._previous = inserting_user
            self.size += 1
            return inserting_user
        inserting_user._next = p._next
        p._next._previous = inserting_user
        p._next = inserting_user
        inserting_user._previous = p
        self.size += 1
    def remove_user(self, mail):
        if self.is_empty():
            print('The list is empty\n')
            return False
        else:
            p = self.head
            while p is not None:
                if p.user_mail == mail:
                    break
                p = p._next
            if p is None:
                print('User with mail', mail, 'is not found\n')
                return False
            elif p == self.head:
                self.head = self.head._next
                p._next = None
                p = self.head
                self.size -= 1
                return p
            elif p == self.tail:
                self.tail = self.tail._previous
                self.tail._next = None
                self.size -= 1
                return p
            p._previous._next = p._next
            p._next._previous = p._previous
            self.size -= 1
user = DoublyLinkedList()",0,0,0,0,0,1,0,1,0
1481,"class Node:
	def __init__(self, data):
		self.data = data
  self.next = None
  self.prev = None
class doublyLinkedList:
	def __init__(self):
		self.head = None
 def insertFirst(self):
		data = int(input(""Enter the value of the node to be inserted : ""))
  newNode = Node(data)
  newNode.next = self.head
  newNode.prev = None
  if self.head != None:
			self.head.prev = newNode
  self.head = newNode
  print(""New node has been inserted into the beginning doubly linked list \n"")
 def deleteFirst(self):
		if self.head == None:
			print(""The list is empty\n"")
  elif self.head.next == None:
			print(""Removed the first node : "", self.head.data, ""\n"")
   self.head = None
  else:
			print(""Removed the first node : "", self.head.data, ""\n"")
   self.head = self.head.next
   self.head.prev = None
 def insertLast(self):
		data = int(input(""Enter the vlaue of the node to be inserted : ""))
  newNode = Node(data)
  if self.head is None:
			self.head = newNode
  else:
			curr = self.head
   while curr.next != None:
				curr = curr.next
   curr.next = newNode
   newNode.prev = curr
  print(""New node has been inserted into the end doubly linked list \n"")
 def deleteLast(self):
		if self.head == None:
			print(""The list is empty\n"")
  elif self.head.next == None:
			print(""Removed the last node : "", self.head.data, ""\n"")
   self.head = None
  else:
			curr = self.head
   while curr.next != None:
				curr = curr.next
   print(""Removed the last node : "", curr.data, ""\n"")
   curr = curr.prev
   curr.next = None
 def insertAfter(self, prev_node):
		data = int(input(""Enter the value of the node to be inserted : ""))
  if prev_node == None:
			print(""Previous node can not be Null"")
  else:
			newNode = Node(data)
   nxt_node = prev_node.next
   newNode.prev = prev_node
   prev_node.next = newNode
   newNode.next = nxt_node
   nxt_node.prev = newNode
  print(""The Node has been sucessfully inserted after "", prev_node.data, ""\n"")
 def delete(self):
		key = int(input(""Enter the key to be deleted : ""))
  flag = 0
  curr = self.head
  while curr != None:
			if(curr.data == key):
				flag = 1
    break
   curr = curr.next
  if flag:
			prev_node = curr.prev
   nxt_node = curr.next
   prev_node.next = nxt_node
   nxt_node.prev = prev_node
   print(key, ""was deleted\n"")
  else:
			print(""The key was not found\n"")
 def displayForeward(self):
		if(self.head == None):
			print(""The list is empty\n"")
  else:
			print(""The elements of the DLL in foreward direction"")
   curr = self.head
   while curr != None:
				print(curr.data, end = "" "")
    curr = curr.next
  print()
 def displayBackward(self):
		if(self.head == None):
			print(""The list is empty\n"")
  else:
			print(""The elements of the DLL in backward direction"")
   curr = self.head
   while curr.next != None:
				curr = curr.next
   while curr != None:
				print(curr.data, end = "" "")
    curr = curr.prev
   print()
DLL = doublyLinkedList()
while True:
	print(""Enter a option you want to perform "")
 op=int(input(""1.Insert First \n2.Delete First \n3.Insert Last \n4.Delete Last \n5.Insert After \n6.Delete \n7.Display Foreward \n8.Display Backward \n9.Exit \n""))
 if(op==1):
		DLL.insertFirst()
 elif(op==2):
		DLL.deleteFirst()
 elif(op==3):
		DLL.insertLast()
 elif(op==4):
		DLL.deleteLast()
 elif(op==5):
		x = int(input(""enter the  value of the node After which you want to insert the new node : ""))
  curr = DLL.head
  flag = 0
  while curr != None:
			if(curr.data == x):
				flag = 1
    break
   curr = curr.next
  if(flag):
			DLL.insertAfter(curr)
  else:
			print(""The Node was not found"")
 elif(op==6):
		DLL.delete()
 elif(op == 7):
		DLL.displayForeward()
 elif(op==8):
		DLL.displayBackward()
 elif(op == 9):
		exit()
 else:
		print(""enter correct option"")",0,0,0,0,0,0,0,1,0
1482,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
class DoublyLinkedList:
    def __init__(self):
        self.head = None
    def append(self, data):
        if self.head is None:
            new_node = Node(data)
            self.head = new_node
        else:
            new_node = Node(data)
            current_node = self.head
            while current_node.next:
                current_node = current_node.next
            current_node.next = new_node
            new_node.prev = current_node
    def prepend(self, data):
        if self.head is None:
            new_node = Node(data)
            self.head = new_node
        else:
            new_node = Node(data)
            self.head.prev = new_node
            new_node.next = self.head
            self.head = new_node
    def add_after_node(self, key, data):
        current_node = self.head
        while current_node:
            if current_node.next is None and current_node.data == key:
                self.append(data)
                return
            elif current_node.data == key:
                new_node = Node(data)
                next_node = current_node.next
                current_node.next = new_node
                new_node.next = next_node
                new_node.prev = current_node
                next_node.prev = new_node
                return
            current_node = current_node.next
    def add_before_node(self, key, data):
        current_node = self.head
        while current_node:
            if current_node.next is None and current_node.data == key:
                self.append(data)
                return
            elif current_node.data == key:
                new_node = Node(data)
                previous_node = current_node.prev
                previous_node.next = new_node
                new_node.prev = previous_node
                new_node.next = current_node
                current_node.prev = new_node
                return
            current_node = current_node.next
    def delete(self, key):
        current_node = self.head
        while current_node:
            if current_node.data == key and current_node == self.head:
                if not current_node.next:
                    current_node = None
                    self.head = None
                    return
                else:
                    next_node = current_node.next
                    current_node.next = None
                    next_node.prev = None
                    current_node = None
                    self.head = next_node
                    return
            elif current_node.data == key:
                if current_node.next:
                    next_node = current_node.next
                    previous_node = current_node.prev
                    previous_node.next = next_node
                    next_node.prev = previous_node
                    current_node.next = None
                    current_node.prev = None
                    current_node = None
                    return
                else:
                    previous_node = current_node.prev
                    previous_node.next = None
                    current_node.prev = None
                    current_node = None
                    return
            current_node = current_node.next
    def remove_duplicates(self):
        current_node = self.head
        seen = dict()
        while current_node:
            if current_node.data not in seen:
                seen[current_node.data] = 1
                current_node = current_node.next
            else:
                next_node = current_node.next
                self.delete(current_node.data)
                current_node = next_node
    def pairs_with_sum(self,key):
        pairs = list()
        p = self.head
        q = None
        while p:
            q = p.next
            while q:
                if (p.data + q.data) == key:
                    pairs.append(f""({p.data},{q.data})"")
                q = q.next
            p = p.next
        return pairs
    def reverse(self):
        temp_node = None
        current_node = self.head
        while current_node:
            temp_node = current_node.prev
            current_node.prev = current_node.next
            current_node.next = temp_node
            current_node = current_node.prev
        if temp_node:
            self.head = temp_node.prev
    def print_list(self):
        cur = self.head
        while cur:
            print(cur.data)
            cur = cur.next
dllist = DoublyLinkedList()
dllist.append(1)
dllist.append(2)
dllist.append(3)
dllist.append(4)
dllist.append(5)
dllist.append(4)
dllist.append(6)
print(dllist.pairs_with_sum(6))",0,0,0,0,0,1,0,1,0
1483,"from linked_list import LinkedList
class Node(object):
    def __init__(self, data, next, prev):
        self.data = data
        self.next = next
        self.prev = prev
class DoublyLinkedList(object):
    def __init__(self, iterable=None):
        self.list = LinkedList()
        self.head = None
        self.tail = None
        self._counter = 0
        if isinstance(iterable, (tuple, list)):
            for item in iterable:
                self.append(item)
    def __len__(self):
        return self._counter
    def push(self, val):
        if len(self) == 0:
            new_node = Node(val, None, None)
            self.head = new_node
            self.tail = new_node
        if len(self) > 0:
            new_node = Node(val, self.head, None)
            self.head.prev = new_node
            self.head = new_node
        self._counter += 1
    def append(self, val):
        if len(self) == 0:
            new_node = Node(val, None, None)
            self.tail = new_node
            self.head = new_node
        if len(self) > 0:
            new_node = Node(val, None, self.tail)
            self.tail.next = new_node
            self.tail = new_node
        self._counter += 1
    def pop(self):
        try:
            output = self.head.data
            self.head = self.head.next
            self._counter -= 1
            return output
        except AttributeError:
            raise IndexError('Cannot pop empty list.')
    def shift(self):
        try:
            output = self.tail.data
            self.tail = self.tail.prev
            self._counter -= 1
            return output
        except AttributeError:
            raise IndexError('Cannot shift empty list.')
    def remove(self, val):
        curr_node = self.head
        while curr_node:
            if curr_node.data == val:
                curr_node.prev.next = curr_node.next
                curr_node.next.prev = curr_node.prev
                self._counter -= 1
                return
            curr_node = curr_node.next
        raise ValueError('Value not in list.')",0,0,0,0,0,1,0,1,0
1484,"class Node:
    def __init__(self, data=None, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev
class DoublyLinkedList:
    def __init__(self):
        self.head = None
    def print_forward(self):
        if self.head is None:
            print(""Linked list is empty"")
            return
        itr = self.head
        llstr = ''
        while itr:
            llstr += str(itr.data) + ' --> '
            itr = itr.next
        print(llstr)
    def print_backward(self):
        if self.head is None:
            print(""Linked list is empty"")
            return
        last_node = self.get_last_node()
        itr = last_node
        llstr = ''
        while itr:
            llstr += itr.data + '-->'
            itr = itr.prev
        print(""Link list in reverse: "", llstr)
    def get_last_node(self):
        itr = self.head
        while itr.next:
            itr = itr.next
        return itr
    def get_length(self):
        count = 0
        itr = self.head
        while itr:
            count+=1
            itr = itr.next
        return count
    def insert_at_begining(self, data):
        if self.head == None:
            node = Node(data, self.head, None)
            self.head = node
        else:
            node = Node(data, self.head, None)
            self.head.prev = node
            self.head = node
    def insert_at_end(self, data):
        if self.head is None:
            self.head = Node(data, None, None)
            return
        itr = self.head
        while itr.next:
            itr = itr.next
        itr.next = Node(data, None, itr)
    def insert_at(self, index, data):
        if index<0 or index>self.get_length():
            raise Exception(""Invalid Index"")
        if index==0:
            self.insert_at_begining(data)
            return
        count = 0
        itr = self.head
        while itr:
            if count == index - 1:
                node = Node(data, itr.next, itr)
                if node.next:
                    node.next.prev = node
                itr.next = node
                break
            itr = itr.next
            count += 1
    def remove_at(self, index):
        if index<0 or index>=self.get_length():
            raise Exception(""Invalid Index"")
        if index==0:
            self.head = self.head.next
            self.head.prev = None
            return
        count = 0
        itr = self.head
        while itr:
            if count == index:
                itr.prev.next = itr.next
                if itr.next:
                    itr.next.prev = itr.prev
                break
            itr = itr.next
            count+=1
    def insert_values(self, data_list):
        self.head = None
        for data in data_list:
            self.insert_at_end(data)
if __name__ == '__main__':
    ll = DoublyLinkedList()
    ll.insert_values([""banana"",""mango"",""grapes"",""orange""])
    ll.print_forward()
    ll.print_backward()
    ll.insert_at_end(""figs"")
    ll.print_forward()
    ll.insert_at(0,""jackfruit"")
    ll.print_forward()
    ll.insert_at(6,""dates"")
    ll.print_forward()
    ll.insert_at(2,""kiwi"")
    ll.print_forward()",0,0,0,0,0,0,0,1,0
1485,"class Node(object):
    def __init__(self, data=None, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev
class DoublyLinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None
        self.count = 0
    def append(self, data):
        new_node = Node(data, None, None)
        if self.head is None:
            self.head = new_node
            self.tail = self.head
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        self.count += 1
    def iter(self):
        current = self.head 
        while current:
            val = current.data
            current = current.next
            yield val
    def reverse_iter(self):
        current = self.tail
        while current:
            val = current.data
            current = current.prev
            yield val
    def delete(self, data):
        current = self.head
        node_deleted = False
        if current is None:
            node_deleted = False
        elif current.data == data:
            self.head = current.next
            self.head.prev = None
            node_deleted = True
        elif self.tail.data == data:
            self.tail = self.tail.prev
            self.tail.next = None
            node_deleted = True
        else:
            while current:
                if current.data == data:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                    node_deleted = True
                current = current.next
        if node_deleted:
            self.count -= 1
    def search(self, data):
        for node in self.iter():
            if data == node:
                return True
        return False
    def print_forward(self):
        for node in self.iter():
            print(node)
    def print_backward(self):
        current = self.tail
        while current:
            print(current.data)
            current = current.prev
    def insert_head(self, data):
        if self.head is not None:
            new_node = Node(data, None, None)
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
            self.count += 1
    def reverse(self):
        current = self.head
        while current:
            temp = current.next
            current.next = current.prev
            current.prev = temp
            current = current.prev
        temp = self.head
        self.head = self.tail
        self.tail = temp
    def __getitem__(self, index):
        if index > self.count - 1:
            raise Exception(""Index out of range."")
        current = self.head 
        for _ in range(index):
            current = current.next
        return current.data
    def __setitem__(self, index, value):
        if index > self.count - 1:
            raise Exception(""Index out of range."")
        current = self.head 
        for _ in range(index):
            current = current.next
        current.data = value",0,0,0,0,0,1,0,1,0
1486,"class Node:
    def __init__(self):
        self.prev = None
        self.next = None
        self.data = None
class DoublyLinkedList:
    def __init__(self):
        self.first_node = None
        self.last_node = None
    def init_node(self, val):
        new_node = Node()
        new_node.data = val
        return new_node
    def _init_first_node(self, new_node):
        self.first_node = new_node
        self.last_node = new_node
    def insert(self, val):
        new_node = self.init_node(val)
        if self.first_node is None and self.last_node is None:
            self._init_first_node(new_node)
        else:
            new_node.next = self.first_node
            self.first_node.prev = new_node
            if self.first_node.next is None:
                self.last_node = self.first_node
            self.first_node = new_node
    def append(self, val):
        new_node = self.init_node(val)
        if self.first_node is None and self.last_node is None:
            self._init_first_node(new_node)
        else:
            new_node.prev = self.last_node
            self.last_node.next = new_node
            if self.last_node.prev is None:
                self.first_node = self.last_node
            self.last_node = new_node
    def pop(self):
        if self.first_node is None:
            raise IndexError(u""List is emtpy, cannot pop value"")
        else:
            x = self.first_node
            self.first_node = self.first_node.next
            return x
    def shift(self):
        if self.first_node is None:
            raise IndexError(u""List is emtpy, cannot shift value"")
        else:
            x = self.last_node
            self.last_node = self.last_node.prev
            return x
    def remove(self, val):
        if self.first_node is None:
            raise IndexError(u""List is emtpy, cannot remove value"")
        current = self.first_node
        while current.data != val:
            current = current.next
            if current is None:
                raise ValueError(u""Value not in list"")
        if current.prev is None:
            self.first_node = self.first_node.next
        elif current.next is None:
            self.last_node = self.last_node.prev
        else:
            current.prev.next = current.next
            current.next.prev = current.prev",0,0,0,0,0,0,0,1,0
1487,,0,0,0,0,0,0,0,0,0
1488,,0,0,0,0,0,0,0,0,0
1489,"class ListNode {
  constructor(val) {
    this.val = val;
    this.prev = null;
    this.next = null;
  }
}
class DoublyLinkedList {
  constructor() {
    this.head = null;
  }
  getNode(index) {
    if (index < 0) return null;
    let curr = this.head;
    for (let i = 0; i < index && curr; ++i) {
      curr = curr.next;
    }
    return curr;
  }
  getHead() {
    return this.head;
  }
  getTail() {
    let curr = this.head;
    while (curr && curr.next) {
      curr = curr.next;
    }
    return curr;
  }
  get(index) {
    let curr = this.getNode(index);
    return curr == null ? -1 : curr.val;
  }
  addAtHead(val) {
    const curr = new ListNode(val);
    curr.next = this.head;
    if (this.head != null) this.head.prev = curr;
    this.head = curr;
  }
  addAtTail(val) {
    if (this.head == null) {
      this.addAtHead(val);
      return;
    }
    let prev = this.getTail();
    const curr = new ListNode(val);
    prev.next = curr;
    curr.prev = prev;
  }
  addAtIndex(index, val) {
    if (index <= 0) {
      this.addAtHead(val);
      return;
    }
    let prev = this.getNode(index - 1);
    if (prev == null) return;
    let next = prev.next || null;
    const curr = new ListNode(val);
    curr.prev = prev;
    curr.next = next;
    prev.next = curr;
    if (next != null) next.prev = curr;
  }
  deleteAtIndex(index) {
    let curr = this.getNode(index);
    if (curr == null) return;
    let prev = curr.prev;
    let next = curr.next;
    if (prev != null) prev.next = next;
    else this.head = next;
    if (next != null) next.prev = prev;
  }
}",0,0,0,0,0,0,0,1,0
1490,"class Empty(Exception):
	pass
class _DoublyLinkedBase:
  class _Node:
    __slots__ = '_element', '_prev', '_next'            
    def __init__(self, element, prev, next):            
      self._element = element                           
      self._prev = prev                                 
      self._next = next                                 
  def __init__(self):
    self._header = self._Node(None, None, None)
    self._trailer = self._Node(None, None, None)
    self._header._next = self._trailer                  
    self._trailer._prev = self._header                  
    self._size = 0                                      
  def __len__(self):
    return self._size
  def is_empty(self):
    return self._size == 0
  def _insert_between(self, e, predecessor, successor):
    newest = self._Node(e, predecessor, successor)      
    predecessor._next = newest
    successor._prev = newest
    self._size += 1
    return newest
  def _delete_node(self, node):
    predecessor = node._prev
    successor = node._next
    predecessor._next = successor
    successor._prev = predecessor
    self._size -= 1
    element = node._element                             
    node._prev = node._next = node._element = None      
    return element                                      ",0,0,0,0,0,0,0,0,0
1491,"class _DoublyLinkedBase:
    class _Node:
        __slots__ = '_element','_prev','_next'
        def __init__(self,element, prev, next):
            self._element = element
            self._prev = prev
            self._next = next
    def __init__(self):
        self._header = self._Node(None,None,None)
        self._trailer = self._Node(None,None,None)
        self._header._next = self._trailer
        self._trailer._prev = self._header
        self._size = 0
    def __len__(self):
        return self._size
    def is_empty(self):
        return self._size == 0
    def _insert_between(self, e, predecessor, successor):
        newest = self._Node(e,predecessor,successor)
        predecessor._next = newest
        successor._prev = newest
        self._size += 1
        return newest
    def _delete_node(self, node):
        predecessor = node._prev
        successor = node._next
        successor._prev = predecessor
        predecessor._next = successor
        self._size -= 1
        element = node._element
        node._prev = node._next = node._element = None 
        return element",0,0,0,0,0,0,0,0,0
1492,"class Node(object):
    def __init__(self, data, next = None, previous = None):
        self.data = data;
        self.next = next;
        self.previous = previous
class DoublyLinkedList(object):
    def __init__(self):
        self.head = None
    def insertAtStart(self, data):
        if self.head == None:
            newNode = Node(data)
            self.head = newNode
        else:
            newNode = Node(data)
            self.head.previous = newNode
            newNode.next = self.head
            self.head = newNode
    def insertAtEnd(self, data):
        newNode = Node(data)
        temp = self.head
        while(temp.next != None):
            temp = temp.next
        temp.next = newNode
        newNode.previous = temp
    def delete(self, data):
        temp = self.head
        if(temp.next != None):
            if(temp.data == data):
                temp.next.previous = None
                self.head = temp.next
                temp.next = None
                return
            else:
                while(temp.next != None):
                    if(temp.data == data):
                        break
                    temp = temp.next
                if(temp.next):
                    temp.previous.next = temp.next
                    temp.next.previous = temp.previous
                    temp.next = None
                    temp.previous = None
                else:
                    temp.previous.next = None
                    temp.previous = None
                return
        if (temp == None):
            return
    def printdll(self):
        temp = self.head
        while(temp != None):
            print(temp.data, end=' ')
            temp = temp.next
if __name__ == '__main__':
    dll = DoublyLinkedList()
    dll.insertAtStart(1)
    dll.insertAtStart(2)
    dll.insertAtEnd(3)
    dll.insertAtStart(4)
    dll.printdll()
    dll.delete(2)
    print()
    dll.printdll()",0,0,0,0,0,0,0,1,0
1493,"__author__ = 'Elias Haroun'
from List_ADT.list.Node import *
class DoublyLinkedList(object):
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    def isEmpty(self):
        return self.size == 0
    def getSize(self):
        return self.size
    def getHead(self):
        return self.head
    def getTail(self):
        return self.tail
    def setHead(self, aNode):
        self.head = aNode
    def setTail(self, aNode):
        self.tail = aNode
    def insertLast(self, data):
        newNode = Node(data, None, None)
        if self.isEmpty():
            self.setHead(newNode)
            self.setTail(newNode)
        else:
            newNode.setPrevious(self.tail)
            self.getTail().setNext(newNode)
            self.setTail(newNode)
        self.size += 1
    def insertFirst(self, data):
        newNode = Node(data, None, None)
        if self.isEmpty():
            self.setHead(newNode)
            self.setTail(newNode)
        else:
            newNode.setNext(self.head)
            self.getHead().setPrevious(newNode)
            self.setHead(newNode)
        self.size += 1
    def deleteLast(self):
        if self.isEmpty() is not True:
            self.getTail().getPrevious().setNext(None)
            self.getTail().setPrevious(None)
            self.setTail(self.getTail().getPrevious())
            self.size -= 1
    def deleteFirst(self):
        if self.isEmpty() is not True:
            self.setHead(self.getHead().getNext())
            self.getHead().setPrevious(None)
            self.size -= 1
    def getContent(self):
        result = []
        temp = self.getHead()
        while temp:
            result.append(temp.getValue())
            temp = temp.getNext()
        print(result)
    def find(self, data):
        index = 0
        temp = self.getHead()
        while temp:
            if temp.getValue() == data:
                return index
            index += 1
            temp = temp.getNext()
        return -1",0,0,0,0,0,1,0,1,0
1494,"class Node(object):
    def __init__(self, data, next = None, previous = None):
        self.data = data;
        self.next = next;
        self.previous = previous
class DoublyLinkedList(object):
    def __init__(self):
        self.head = None
    def insertAtStart(self, data):
        if self.head == None:
            newNode = Node(data)
            self.head = newNode
        else:
            newNode = Node(data)
            self.head.previous = newNode
            newNode.next = self.head
            self.head = newNode
    def insertAtEnd(self, data):
        newNode = Node(data)
        temp = self.head
        while(temp.next != None):
            temp = temp.next
        temp.next = newNode
        newNode.previous = temp
    def delete(self, data):
        temp = self.head
        if(temp.next != None):
            if(temp.data == data):
                temp.next.previous = None
                self.head = temp.next
                temp.next = None
                return
            else:
                while(temp.next != None):
                    if(temp.data == data):
                        break
                    temp = temp.next
                if(temp.next):
                    temp.previous.next = temp.next
                    temp.next.previous = temp.previous
                    temp.next = None
                    temp.previous = None
                else:
                    temp.previous.next = None
                    temp.previous = None
                return
        if (temp == None):
            return
    def printdll(self):
        temp = self.head
        while(temp != None):
            print(temp.data, end=' ')
            temp = temp.next
if __name__ == '__main__':
    dll = DoublyLinkedList()
    dll.insertAtStart(1)
    dll.insertAtStart(2)
    dll.insertAtEnd(3)
    dll.insertAtStart(4)
    dll.printdll()
    dll.delete(2)
    print()
    dll.printdll()",0,0,0,0,0,0,0,1,0
1495,"class LLNode(object):
    def __init__(self, data='none'):
        self.data = data
        self.next = None
        self.prev = None
class DoublyLinkedList(object):
    def __init__(self):
        self.head = None
    def insert_front(self, data):
        if data is None:
            print(""Data is null"")
            return
        if self.head is None:
            new_node = LLNode(data)
            self.head = new_node
        else:
            new_node = LLNode(data)
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
    def insert_back(self, data):
        if data is None:
            print(""Data is null"")
            return
        if self.head is None:
            new_node = LLNode(data)
            self.head = new_node
        else:
            cur_node = self.head
            while cur_node.next is not None:
                cur_node = cur_node.next
            new_node = LLNode(data)
            cur_node.next = new_node
            new_node.prev = cur_node
    def insert_after_node(self, node, data):
        if node is None:
            return
        if self.head is None:
            return
        cur_node = self.head
        while cur_node:
            if cur_node == node:
                new_node = LLNode(data)
                new_node.next = cur_node.next
                new_node.prev = cur_node
                cur_node.next = new_node
                return
            cur_node = cur_node.next
    def insert_after_data(self, target_data, data):
        if target_data is None:
            return
        if self.head is None:
            return
        cur_node = self.head
        while cur_node:
            if cur_node.data == target_data:
                new_node = LLNode(data)
                new_node.next = cur_node.next
                new_node.prev = cur_node
                cur_node.next = new_node
                if new_node.next is not None:
                    new_node.next.prev = new_node
                return
            cur_node = cur_node.next
    def delete_front(self):
        if self.head is None:
            return
        if self.head.next is None:
            self.head = None
            return
        temp_node = self.head
        self.head = self.head.next
        self.head.prev = None
        return temp_node
    def delete_back(self):
        if self.head is None:
            return
        if self.head.next is None:
            self.head = None
            return
        cur_node = self.head
        while cur_node.next:
            cur_node = cur_node.next
        temp_node = cur_node
        cur_node.prev.next = None
        temp_node.prev = None  
        return temp_node
    def print_all(self):
        if self.head is None:
            return
        print("""")
        print(""[head]"")
        print(""   v"")
        print(""   "", end="""")
        cur_node = self.head
        while cur_node:
            if cur_node.next is None:
                print(cur_node.data + ""("" + cur_node.prev.data + "")"")
            else:
                if cur_node == self.head:
                    print(cur_node.data + "" -> "", end='')
                else:
                    print(cur_node.data +
                          ""("" + cur_node.prev.data + "")"" + "" -> "", end='')
            cur_node = cur_node.next
dll = DoublyLinkedList()
dll.insert_front(""A"")
dll.insert_front(""B"")
dll.insert_front(""C"")
dll.insert_back(""D"")
dll.print_all()",0,0,0,0,0,0,0,1,0
1496,"class Node(object):
    def __init__(self, data, next = None, previous = None):
        self.data = data;
        self.next = next;
        self.previous = previous
class DoublyLinkedList(object):
    def __init__(self):
        self.head = None
    def insertAtStart(self, data):
        if self.head == None:
            newNode = Node(data)
            self.head = newNode
        else:
            newNode = Node(data)
            self.head.previous = newNode
            newNode.next = self.head
            self.head = newNode
    def insertAtEnd(self, data):
        newNode = Node(data)
        temp = self.head
        while(temp.next != None):
            temp = temp.next
        temp.next = newNode
        newNode.previous = temp
    def delete(self, data):
        temp = self.head
        if(temp.next != None):
            if(temp.data == data):
                temp.next.previous = None
                self.head = temp.next
                temp.next = None
                return
            else:
                while(temp.next != None):
                    if(temp.data == data):
                        break
                    temp = temp.next
                if(temp.next):
                    temp.previous.next = temp.next
                    temp.next.previous = temp.previous
                    temp.next = None
                    temp.previous = None
                else:
                    temp.previous.next = None
                    temp.previous = None
                return
        if (temp == None):
            return
    def printdll(self):
        temp = self.head
        while(temp != None):
            print(temp.data, end=' ')
            temp = temp.next
if __name__ == '__main__':
    dll = DoublyLinkedList()
    dll.insertAtStart(1)
    dll.insertAtStart(2)
    dll.insertAtEnd(3)
    dll.insertAtStart(4)
    dll.printdll()
    dll.delete(2)
    print()
    dll.printdll()",0,0,0,0,0,0,0,1,0
1497,"class DLLNode:
    def __init__(self, val, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev
class DoublyLinkedList:
    def __init__(self):
        self.head = None
    def append(self,val):
        new_node = DLLNode(val)
        if self.head is None:
            self.head = new_node
        else:
            curr = self.head
            while curr.next:
                curr = curr.next
            curr.next = new_node
            new_node.prev = curr
    def prepend(self, val):
        new_node = DLLNode(val)
        if self.head is None:
            self.head = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
    def add_node_before(self, node, val):
        new_node = DLLNode(val)
        new_node.next = node
        prev = node.prev
        node.prev = new_node
        if prev:
            prev.next = new_node
            new_node.prev = prev
        else:
            self.head = new_node
    def add_node_after(self, node, val):
        new_node = DLLNode(val)
        new_node.prev = node
        nxt = node.next
        node.next = new_node
        if nxt:
            nxt.prev = new_node
            new_node.next = nxt
    def print_list(self):
        curr = self.head
        prev = None
        while curr:
            prev = curr
            print(curr.val, end=""-> "")
            curr = curr.next
        print(""None"")
        while prev:
            print(prev.val, end= ""-> "")
            prev = prev.prev
        print(""None"")
    def delete_node(self, val):
        if self.head is None:
            print(""Empty list"")
        if self.head.val == val:
            curr = self.head
            self.head = self.head.next
            if self.head:
                self.head.prev = None
            curr = None
            return
        curr = self.head.next
        while curr:
            nxt = curr.next
            if curr.val == val:
                curr.prev.next = curr.next
                if curr.next:
                    curr.next.prev = curr.prev
            curr = None
            curr = nxt
    def reverse(self):
        curr = self.head
        temp = None
        while curr:
            temp = curr.prev
            curr.prev = curr.next
            curr.next = temp
            curr = curr.prev
        if temp:
            self.head = temp.prev
if __name__ == ""__main__"":
    llist = DoublyLinkedList()
    llist.append(1)
    llist.add_node_after(llist.head, 0)
    llist.append(2)
    llist.prepend(3)
    llist.prepend(5)
    llist.append(4)
    llist.add_node_before(llist.head, 9)
    llist.add_node_before(llist.head.next , 10)
    llist.add_node_after(llist.head , 11)
    llist.delete_node(9)
    llist.delete_node(4)
    llist.delete_node(3)
    llist.print_list()
    llist.reverse()
    llist.print_list()",0,0,0,0,0,0,0,1,0
1498,"class Node():
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
    def __str__(self):
        return str(self.data)
class DLL():
    def __init__(self):
        self.first = None
    def insertFront(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
        else:
            newNode.next = self.first
            self.first.prev = newNode
            self.first = newNode
    def insertBack(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
        else:
            current = self.first
            while current.next is not None:
                current = current.next
            current.next = newNode
            newNode.prev = current
    def exists(self, data):
        if self.first is None:
            return False
        else:
            current = self.first
            while (current is not None) and (current.data is not data):
                current = current.next
            if current is None:
                return False
            else:
                return True
    def delete(self, data):
        if self.exists(data):
            current = self.first
            while current.data is not data:
                current = current.next
            if current.prev is None:  
                self.first = current.next
                self.first.prev = None
            else:
                if current.next is not None:
                    current.next.prev = current.prev
                current.prev.next = current.next
            return True
        else:
            return False
    def __str__(self):
        if self.first is None:
            return None
        else:
            result = ''
            current = self.first
            while current is not None:
                result += str(current) + '\n'
                current = current.next
            return result",0,0,0,0,0,1,0,1,0
1499,"package com.roche.andy.datastructures;
class DoublyLinkedList<T extends Comparable<T>> {
    class Node<K> {
        K data;
        Node<K> prev, next;
        Node(K d) {
            data = d;
        }
    }
    Node<T> head;  
    void push(T newData) {
        Node<T> newNode = new Node<>(newData);
        newNode.next = head;
        newNode.prev = null;
        if (head != null)
            head.prev = newNode;
        head = newNode;
    }
    void insertAfter(Node previousNode, T newData) {
        if (previousNode == null) {
            System.out.println(""The given previous node cannot be NULL "");
            return;
        }
        Node newNode = new Node<>(newData);
        newNode.next = previousNode.next;
        previousNode.next = newNode;
        newNode.prev = previousNode;
        if (newNode.next != null) {
            newNode.next.prev = newNode;
        }
    }
    void insertBefore(Node previousNode, T newData) {
        if (previousNode == head) {
            push(newData);
        } else {
            insertAfter(previousNode.prev, newData);
        }
    }
    void append(T newData) {
        Node<T> newNode = new Node<>(newData);
        Node<T> last = head;
        newNode.next = null;
        if (head == null) {
            newNode.prev = null;
            head = newNode;
            return;
        }
        while (last.next != null) {
            last = last.next;
        }
        last.next = newNode;
        newNode.prev = last;
    }
    void printList() {
        Node<T> temp = head;
        while (temp != null) {
            System.out.print(temp.data + "" "");
            temp = temp.next;
        }
        System.out.println();
    }
}
class DLLTest {
    public static void main(String[] args) {
        DoublyLinkedList<Integer> dll = new DoublyLinkedList<>();
        dll.append(6);
        dll.push(7);
        dll.push(1);
        dll.append(4);
        dll.printList();
        dll.insertAfter(dll.head.next, 8);
        dll.printList();
        dll.insertBefore(dll.head, 9);
        dll.printList();
    }
}",0,0,0,0,0,0,0,1,0
1500,"function Node(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
}
function List() {
    this.length = 0;
    this.head = null;
    this.tail = null;
}
List.prototype.add = function(data) {
    var node = new Node(data);
    if (this.head === null) {  
        this.head = this.tail = node;
        this.length++;
        return node;
    }
    else{  
        this.tail.next = node;
        node.prev = this.tail;
        this.tail = node;
        this.length++;
        return node;
    }
};
List.prototype.searchNodeAt = function(index) {
    var tmpNode = this.head;
    var count = 0;
    while(tmpNode != null){
        if(count == index)
            return tmpNode;
        tmpNpde = tmpNode.next;
        count++;
    }
    return null;   
};
List.prototype.searchNodewith = function(data) {
    var tmpNode = this.head;
    var iondex = 0;
    while(tmpNode != null){
        if(tmpNode.data == data)
            return index;
        tmpNpde = tmpNode.next;
        index++;
    }
    return 0;   
};
List.prototype.removeByIndex = function(index) {
    if(index == null)
        return null;
    if(!(index >= this.length)){
        var tmp = this.head;
        var count = 0;
        if(index == 0){
            tmp = this.head.next;
            delete this.head;
            this.head = tmp;
            this.length--;
            return true;
        }
        else{
            var tmp2 = tmp.next;
            while(tmp2 != null){
                if(count == index - 1){
                    tmp.next = tmp2.next;
                    delete tmp2;
                    this.length--;
                    return true;
                }
                tmp = tmp.next;
                tmp2 = tmp2.next;
                count++;
            }
        }
    }
    return false;
};
List.prototype.removeByData = function(data) {
    return this.removeByIndex(this.searchNodewith(data));
};
List.prototype.printForwards = function(){
    var tmp = this.head;
    while(tmp != null){
        console.log(tmp.data);
        tmp = tmp.next;
    }
};
List.prototype.printBackwords = function(){
    var tmp = this.tail;
    while(tmp != null){
        console.log(tmp.data);
        tmp = tmp.prev;
    }
};",0,0,0,0,0,1,0,1,0
1501,"class Node:
	def __init__(self, data=None):
		self.data = data
  self.next = None
  self.prev = None
 def getData(self):
		return self.data
 def getNext(self):
		return self.next
 def getPrev(self):
		return self.prev
 def setData(self, data):
		self.data = data
 def setNext(self, next):
		self.next = next
 def setPrev(self, prev):
		self.prev = prev
class DoublyLinkedList:
	def __init__(self):
		self.head = None
 def print(self):
		if self.head is None:
			print(""linked list is empty, nothing to print"")
   return
  current = self.head
  while current:
			print(current.data)
   current = current.next
 def reverse_print(self):
		if self.head is None:
			print(""linked list is empty, nothing to print"")
   return
  current = self.head
  while current.next != None:
			current = current.next
  while current !=None:
			print(current.data)
   current = current.prev
 def add_at_the_begining(self, data):
		node = Node(data)
  if self.head is None: 
			self.head = node
   return
  else:
			node.next = self.head
   self.head.prev = node
   self.head = node
 def add_at_the_end(self, data):
		node = Node(data)
  if self.head is None: 
			self.head = node
   return
  else:
			current = self.head
   while current.next != None:
				current = current.next
   current.next = node
   node.prev = current
 def add_at_nth_position(self, data, pos):
		node = Node(data)
  if pos <= 0:
			print(""Invalid position, it can not be less than or equal to 0"")
   return
  elif pos == 1: 
				self.add_at_the_begining(data)
  else:
			current = self.head
   i=1
   while i < pos-1 and current != None: 
				current = current.next
    i = i+1
   if current is None: 
				print(""Invalid position!!!"")
    return
   elif current.next is None:
				self.add_at_the_end(data)
   else:
				node.next = current.next
    node.prev = current
    current.next.prev = node
    current.next = node
 def remove_at_the_begining(self):
		if self.head is None:
			print(""List is empty, nothing to remove."")
  elif self.head.next is None: 
			temp = self.head
   self.head = None
   print(""Last node of the list has been removed. List is empty now!!!"")
  else:
			temp = self.head
   self.head = self.head.next 
   self.head.prev = None 
   temp.next = None 
   print(""Node has been removed"")
 def remove_at_the_end(self):
		if self.head is None:
			print(""List is empty, nothing to remove."")
  elif self.head.next == None: 
			temp = self.head
   self.head = None
   print(""Last node of the list has been removed. List is empty now!!!"")
  else:
			temp = self.head
   while temp.next != None: 
				temp = temp.next
   temp.prev.next = None 
   temp.prev = None 
   print(""Node has been removed"")
 def remove_at_nth_position(self, pos):
		if pos == 0:
			print(""Invalid postion"")
   return
  elif pos == 1: 
			self.remove_at_the_begining()
  else:
			current = self.head
   i=1
   while i < pos and current != None:
				current = current.next
    i = i+1
   if current is None:
				print(""Invalid position!!!"")
   elif current.next is None: 
				self.remove_at_the_end()
   else:
				current.prev.next = current.next
    current.next.prev = current.prev
    current.prev = None 
    current.next = None 
    print(""Node has been removed"")
 def print_recursion(self, p):
		if p == None:
			return
  print(p.data)
  self.print_recursion(p.next)
 def reverse_print_recursion(self, p):
		if p == None:
			return
  self.reverse_print_recursion(p.next)
  print(p.data)
 def reverse_using_recursion(self,p): 
		if p.next == None: 
			self.head = p
   return
  self.reverse_using_recursion(p.next) 
  q = p.next
  q.prev = q.next 
  q.next = p
  p.next = None
mylist = DoublyLinkedList()
mylist.add_at_the_end(2)
mylist.add_at_the_end(4)
mylist.add_at_the_end(6)
mylist.add_at_the_end(8)
mylist.add_at_the_end(10)
mylist.print()
print(""Reverse print:"")
mylist.reverse_print()",0,0,0,0,0,0,0,1,0
1502,"class DoublyLinkedListNode(object):
    def __init__(self,value):
        self.value = value
        self.prev_node = None
        self.next_node = None
a = DoublyLinkedListNode(1)
b = DoublyLinkedListNode(2)
c = DoublyLinkedListNode(3)        
b.prev_node = a
a.next_node = b
b.next_node = c
c.prev_node = b
print (a.value)
print (b.value)
print (c.value)
print (a.next_node.value)
print (b.next_node.value)
print (b.prev_node.value)
print (c.prev_node.value)",0,0,0,0,0,0,0,0,0
1503,"import os
class _Node:
    __slots__ = '_element', '_link', '_prev'
    def __init__(self, element, link, prev):
        self._element = element
        self._link = link
        self._prev = prev
class DoublyLL:
    def __init__(self):
        self._head = None
        self._tail = None
        self._size = 0
    def __len__(self):
        return self._size
    def isempty(self):
        return self._size == 0
    def addLast(self, e):
        newest = _Node(e, None, None)
        if self.isempty():
            self._head = newest
        else:
            self._tail._link = newest
            newest._prev = self._tail
        self._tail = newest
        self._size += 1
    def addFirst(self, e):
        newest = _Node(e, None, None)
        if self.isempty():
            self._head = newest
            self._tail = newest
        else:
            newest._link = self._head
            self._head._prev = newest
        self._head = newest
        self._size += 1
    def addAnywhere(self, e, index):
        if index >= self._size:
            print(
                f'Index value out of range, it should be between 0 - {self._size - 1}')
        elif self.isempty():
            print(""List was empty, item will be added at the end"")
            self.addLast(e)
        elif index == 0:
            self.addFirst(e)
        elif index == self._size - 1:
            self.addLast(e)
        else:
            newest = _Node(e, None, None)
            p = self._head
            for _ in range(index - 1):
                p = p._link
            newest._link = p._link
            p._link._prev = newest
            newest._prev = p
            p._link = newest
            self._size += 1
    def removeFirst(self):
        if self.isempty():
            print('List is already empty')
            return
        e = self._head._element
        self._head = self._head._link
        self._size -= 1
        if self.isempty():
            self._tail = None
        else:
            self._head._prev = None
        return e
    def removeLast(self):
        if self.isempty():
            print(""List is already empty"")
            return
        e = self._tail._element
        self._tail = self._tail._prev
        self._size -= 1
        if self.isempty():
            self._head = None
        else:
            self._tail._link = None
        return e
    def removeAnywhere(self, index):
        if index >= self._size:
            print(
                f'Index value out of range, it should be between 0 - {self._size - 1}')
        elif self.isempty():
            print(""List is empty"")
        elif index == 0:
            return self.removeFirst()
        elif index == self._size - 1:
            return self.removeLast()
        else:
            p = self._head
            for _ in range(index - 1):
                p = p._link
            e = p._link._element
            p._link = p._link._link
            p._link._prev = p
            self._size -= 1
        return e
    def display(self):
        if self.isempty():
            print(""List is Empty"")
            return
        print(""Forward direction"")
        p = self._head
        print(""NULL<-->"", end='')
        while p:
            print(p._element, end=""<-->"")
            p = p._link
        print(""NULL"")
        print(""\nReverse direction"")
        p = self._tail
        print(""NULL<-->"", end='')
        while p:
            print(p._element, end=""<-->"")
            p = p._prev
        print(""NULL"")
        print(
            f""\nHead : {self._head._element}, Tail : {self._tail._element}"")
def options():
    options_list = ['Add Last', 'Add First', 'Add Anywhere',
                    'Remove First', 'Remove Last', 'Remove Anywhere',
                    'Display List', 'Exit']
    print(""MENU"")
    for i, option in enumerate(options_list):
        print(f'{i + 1}. {option}')
    choice = int(input(""Enter choice: ""))
    return choice
def switch_case(choice):
    os.system('cls')
    if choice == 1:
        elem = int(input(""Enter Item: ""))
        DL.addLast(elem)
        print(""Added Item at Last!\n\n"")
    elif choice == 2:
        elem = int(input(""Enter Item: ""))
        DL.addFirst(elem)
        print(""Added Item at First!\n\n"")
    elif choice == 3:
        elem = int(input(""Enter Item: ""))
        index = int(input(""Enter Index: ""))
        DL.addAnywhere(elem, index)
    elif choice == 4:
        print(""Removed Element from First:"", DL.removeFirst())
    elif choice == 5:
        print(""Removed Element from last:"", DL.removeLast())
    elif choice == 6:
        index = int(input(""Enter Index: ""))
        print(f""Removed Item: {DL.removeAnywhere(index)} !\n\n"")
    elif choice == 7:
        print(""List:"")
        DL.display()
        print(""\n"")
    elif choice == 8:
        import sys
        sys.exit()
if __name__ == '__main__':
    DL = DoublyLL()
    while True:
        choice = options()
        switch_case(choice)",0,0,0,0,0,0,0,1,0
1504,"from DS.LinkedList.PositionalList import PositionalList
class FavouritesList:
    class _Item:
        __slots__ = '_value', '_count'  
        def __init__(self, e):
            self._value = e         
            self._count = 0         
    def _find_position(self, e):
        walk = self._data.first()
        while walk is not None and walk._element()._value != e:
            walk = self._data.after(walk)
        return walk
    def _move_up(self, p):
        if p != self._data.first():
            cnt = p.element()._count
            walk = self._data.before(p)
            if cnt > walk.element()._count:
                while (walk != self._data.first() and
                       cnt > self._data.before(walk).element()._count):
                    walk = self._data.before(walk)
                self._data.add_before(walk, self._data.delete(p))
    def __init__(self):
        self._data = PositionalList()
    def __len__(self):
        return len(self._data)
    def is_empty(self):
        return len(self._data) == 0
    def access(self, e):
        p = self._find_position(e)      
        if p is None:
            p = self._data.add_last(self._Item(e)) 
        p.element()._count += 1     
        self._move_up(p)        
    def remove(self, e):
        p = self._find_position(e)      
        if p is not None:
            self._data.delete(p)        
    def top(self, k):
        if not 1 <= k <= len(self):
            raise ValueError('Illegal Value for k')
        walk = self._data.first()
        for j in range(k):
            item = walk.element()       
            yield item._value
            walk = self._data.after(walk)",0,0,0,0,0,1,0,0,0
1505,"import json
class LinkNode():
    value = ''
    next = None
    prev = None
    def __init__(self, value, next=None, prev=None):
        self.value = value
        self.next = next
        self.prev = prev
class LinkList():
    head = None
    comparison_func = None
    def __init__(self, comparison_func=None):
        self.head = None
        self.comparison_func = comparison_func
    def toJSON(self):
        buf = json.dumps(self, default=lambda o: o.__dict__, indent=0, separators=(',', ': '))
        buf = buf.replace('\n', ' ').replace('\r', '')
        return buf
    def toStr(self):
        c, cnt = 0, self.count()
        buf = ''
        ptr = self.head
        while ptr is not None:
            buf = buf + ptr.value + ','
            ptr = ptr.next
            c += 1
            if (c > cnt):
                raise AssertionError(f'WAIT!!! Forever Loop!\nRecursive LinkList/Node\nbuf:[{buf}]')
        if buf.endswith(','):
            buf = buf[:-1]
        return buf
    def insert(self, value):
        node = LinkNode(value, self.head)
        node.next = self.head
        self.head = node
    def get(self, value):  
        cur = self.head
        while cur is not None:
            if self.comparison_func is not None:
                if self.comparison_func(cur.value, value):
                    return cur.value
            else:
                if cur.value == value:
                    return cur.value
            cur = cur.next
        raise Exception('Not found.')
    def includes(self, value):
        ret = False
        cur = self.head
        while cur is not None:
            if self.comparison_func is not None:
                if self.comparison_func(cur.value, value):
                    ret = True
                    break
            else:
                if cur.value == value:
                    ret = True
                    break
            cur = cur.next
        return ret
    def count(self):
        cnt = 0
        cur = self.head
        while cur is not None:
            cnt += 1
            cur = cur.next
        return cnt
    def append(self, value) -> bool:
        prev, cur = None, self.head
        while cur is not None:
            prev = cur
            cur = cur.next
        node = LinkNode(value, None)
        if (prev == None):
            self.head = node
        else:
            prev.next = node
        return True
    def peekHead(self) -> [bool, str]:
        retStr = ''
        retBool = False
        if self.head is not None:
            retStr = self.head.value
            retBool = True
        return [retBool, retStr]
    def remove(self, value) -> bool:
        ret = False
        if self.includes(value):
            prev, cur = None, self.head
            while cur is not None:
                found = False
                if self.comparison_func is not None:
                    if self.comparison_func(cur.value, value):
                        found = True
                elif cur.value == value:
                    found = True
                if found:
                    if prev is None:
                        self.head = cur.next
                    else:
                        prev.next = cur.next
                    ret = True
                    break
                prev = cur
                cur = cur.next
        return ret
    def insertBefore(self, targetVal: int, newVal: str, afterInstead=False):
        found = False
        prev, cur = None, self.head
        while cur is not None:
            if cur.value == targetVal:
                found = True
                break
            prev = cur
            cur = cur.next
        if found:
            node = LinkNode(newVal)
            if afterInstead:
                node.next = cur.next
                cur.next = node
            else:
                node.next = cur
                if prev is None:  
                    self.head = node
                else:
                    prev.next = node
        return found
    def insertAfter(self, targetVal: int, newVal: str):
        return self.insertBefore(targetVal, newVal, True)
    def traverse(self, action_func):
        cur = self.head
        while cur:
            action_func(cur.value)
            cur = cur.next
    def kthFromEnd(self, k):
        if k < 0:
            raise AssertionError(f'WAIT!!! You must pass a positive integer, k:[{k}]')
        ptrA = self.head
        ptrB = self.head
        tooSmall = False
        c = 0
        while c < k-1:
            if ptrA.next is None:
                tooSmall = True
                break
            ptrA = ptrA.next
            c += 1
        if tooSmall:
            raise AssertionError(f'WAIT!!! There are not enough elements in the link list for k:[{k}].')
        while ptrA.next is not None:
            ptrA = ptrA.next
            if c >= k:
                ptrB = ptrB.next
            c += 1
        return ptrB.value
    def mergeList(self, listA, listB):
        ptrA = listA.head
        ptrB = listB.head
        while ptrA is not None or ptrB is not None:
            if ptrA is not None:
                prev = ptrA
                ptrA = ptrA.next
                prev.next = ptrB
            if ptrB is not None:
                prev = ptrB
                ptrB = ptrB.next
                prev.next = ptrA
        return listA
if __name__ == ""__main__"":
    listA = LinkList()
    listA.append('apple')
    listA.append('bannana')
    listA.append('orange')
    listB = LinkList()
    listB.append('cheerios')
    listB.append('frosted flakes')
    listB.append('wheaties')
    expected = 'apple,cheerios,bannan,frosted flakes,orange,wheaties'
    listA.mergeList(listA, listB)
    actual = listA.toStr()
    print(f'actual:[{actual}]')",0,0,0,0,0,1,0,1,0
1506,"class LinkedList:
    def __init__(self, value):
        self.head = {
            value:value,
            next: None
        }
        self.tail = self.head
        self.length = 1
        self.NewNode = {}
    def append(self,value):
        self.NewNode = {
            value:value,
            next:None
        }
        self.tail[next] = self.NewNode
        self.tail = self.NewNode
        self.length = self.length + 1
    def prepend(self,value):
        self.PrependNode = {
            value:value,
            next :None
        }
        self.PrependNode[next]= self.head
        self.head = self.PrependNode
        self.length = self.length +1
    def __str__(self):
        return str(self.head)
    def insert(self,index,value):
        self.NewNode ={
            value:value,
            next:None
        }
myLinkedList = LinkedList(10)
myLinkedList.append(12)
myLinkedList.append(4)
myLinkedList.append((3))
myLinkedList.prepend(14)
myLinkedList.prepend(190)",0,0,0,0,0,0,0,1,0
1507,"class LinkedList:
    def __init__(self, value):
        self.head = {
            value:value,
            next: None
        }
        self.tail = self.head
        self.length = 1
        self.NewNode = {}
    def append(self,value):
        self.NewNode = {
            value:value,
            next:None
        }
        self.tail[next] = self.NewNode
        self.tail = self.NewNode
        self.length = self.length + 1
    def prepend(self,value):
        self.PrependNode = {
            value:value,
            next :None
        }
        self.PrependNode[next]= self.head
        self.head = self.PrependNode
        self.length = self.length +1
    def __str__(self):
        return str(self.head)
    def insert(self,index,value):
        self.NewNode ={
            value:value,
            next:None
        }
myLinkedList = LinkedList(10)
myLinkedList.append(12)
myLinkedList.append(4)
myLinkedList.append((3))
myLinkedList.prepend(14)
myLinkedList.prepend(190)",0,0,0,0,0,0,0,1,0
1508,"class Node(object):
    def __init__(self, data=None, nxt=None):
        self.data = data
        self.next = nxt
class LinkedList(object):
    def __init__(self, head=None):
        self.head = head
        self.tail = tail
    def insert(self, data, position):
        new_node = Node(data)
        if position == 0:
            new_node.next = self.head
            self.head = new_node
        if position == self.size():
            self.tail.next = new_node
            self.tail = new_node
        prev = None
        curr = self.head
        index = 0
        while curr.next:
            if position == index:
                prev.next = new_node
                new_node.next = curr
                return
            index +=1
            prev = prev.next
            curr = curr.next
    def size(self):
        size = 0
        if head is None and tail is None:
            return size
        curr = self.head
        while curr:
            size += 1
            curr = curr.next
        return size
    def search(self, data):
        curr = self.head
        while curr:
            if curr.data == data:
                return curr
            curr = curr.next
        raise ValueError('Data not in linked list.')
    def delete(self, data):
        prev = None
        curr = self.head
        while curr:
            if curr.data == data:
                if curr == self.head:
                    self.head = curr.next
                else:
                    prev.next = curr.next
            prev = curr
            curr = curr.next
        if curr is None:
            raise ValueError('Data not in linked list.')",0,0,0,0,0,1,0,1,0
1509,"class Linked_List_Element:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None
    def find(self, key):
        target = self
        while target and target.key != key:
            target = target.next
        return target
    def insert(self, element):
        self.prev = element
        element.next = self
        return element
    def update(self, value):
        self.value = value
        return self
    def delete(self):
        if self.prev:
            self.prev.next = self.next
        if self.next:
            self.next.prev = self.prev
        return self
    def __repr__(self):
        return ""(k: "" + str(self.key) + "", v: "" + str(self.value) + "")""
class Linked_List:
    def __init__(self):
        self.head = None
    def find(self, key):
        return self.head and self.head.find(key)
    def insert(self, key, value):
        element = Linked_List_Element(key, value)
        if self.head:
            self.head.insert(element)
        self.head = element
        return element
    def delete(self, key):
        target = self.find(key)
        if target:
            if target is self.head:
                self.head = target.next
            target.delete()
        return target
    def update(self, key, value):
        target = self.find(key)
        return target.update(value) if target else self.insert(key,value)
    def __repr__(self):
        rep = []
        element = self.head
        while element:
            rep.append((element.key, element.value))
            element = element.next
        return str(rep)",0,0,0,0,0,1,0,1,0
1510,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class LinkedList:
    def __init__(self):
        self.head = None
    def show(self):
        current_node = self.head
        while current_node:
            print(current_node.data)
            current_node = current_node.next
    def length(self):
        current_node = self.head
        total = 0
        while current_node:
            current_node = current_node.next
            total = total + 1
        return total
    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node
    def preappend(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    def insert_after_node(self, prev_node, data):
        if not prev_node:
            print(""Previous Node Not Exist in the list"")
            return
        new_node = Node(data)
        new_node.next = prev_node.next
        prev_node.next = new_node
    def remove(self, key):
        current_node = self.head
        if current_node and current_node.data == key:
            self.head = current_node.next
            current_node = None
            return
        prev_node = None
        while current_node and current_node.data != key:
            prev_node = current_node
            current_node = current_node.next
        if current_node is None:
            print(""Node Does Not Exist"")
            return
        prev_node.next = current_node.next
        current_node = None
list = LinkedList()
list.append(""A"")
list.append(""B"")
list.append(""D"")
list.append(""E"")
list.insert_after_node(list.head.next, ""C"")
list.show()
list.remove(""D"")
print(""After Deleting"")
list.show()
print(f""Length of the List: {list.length()}"")",0,0,0,0,0,1,0,1,0
1511,"class Node(object):
    def __init__(self, data, next):
        self.data = data
        self.next = next
class LinkedList(object):
    def __init__(self, *args):
        self.size = 0
        self.first_node = None
        args = args[::-1]
        for arg in args:
            self.insert(arg)
    def pop(self):
        x = self.first_node
        self.first_node = self.first_node.next
        return x
    def insert(self, data):
        new_node = Node(data, self.first_node)
        self.first_node = new_node
        self.size += 1
    def size(self):
        return self.size
    def search(self, data):
        n = self.first_node
        while True:
            if n.data == data:
                return n
            n = n.next
        return None
    def remove(self, data):
        node = self.first_node
        if node.data == data:
            self.first_node = self.first_node.next
            return self
        while node.next:
            if node.next.data == data:
                node.next = node.next.next
                return self
            node = node.next
    def print_tuple(self):
        n = self.first_node
        linked_list_tuple = ()
        while n:
            linked_list_tuple = linked_list_tuple + (n.data, )
            n = n.next
        print linked_list_tuple",0,0,0,0,0,1,0,1,0
1512,"import weakref
class _LinkedListItem(object):
    def __init__(self, key, value, prev, next, parent):
        self.prev = prev
        self.next = next
        self.key = key
        self.value = value
        self.parent = weakref.ref(parent)
class LinkedList(object):
    def __init__(self):
        self.front = None
        self.back = None
        self.length = 0
    def add_to_back(self, key, value=None):
        item = _LinkedListItem(key, value, self.back, None, self)
        if self.back:
            self.back.next = item
        self.back = item
        if not self.front:
            self.front = item
        self.length += 1
        return item
    def remove(self, item):
        if not isinstance(item, _LinkedListItem):
            raise Exception('item must be of class _LinkedListItem')
        if item.parent() != self:
            raise Exception('item does not belong to this list and cannot be removed')
        if item.prev:
            item.prev.next = item.next
        else:
            self.front = item.next
        if item.next:
            item.next.prev = item.prev
        else:
            self.back = item.prev
        item.parent = None
        if not (item.prev or item.next):
            self.front = self.back = None
            self.length = 0
        else:
            self.length -= 1
    def add_to_front(self, key, value=None):
        item = _LinkedListItem(key, value, None, self.front, self)
        if self.front:
            self.front.prev = item
        self.front = item 
        if not self.back:
            self.back = item
        self.length += 1 
        return item
    def find_first(self, key):
        current = self.front
        while current:
            if current.key == key:
                return current
            current = current.next
        return None
    def find_last(self, key):
        current = self.back
        while current:
            if current.key == key:
                return current
            current = current.prev
        return None
    def insert_after(self, item, key, value):
        if not isinstance(item, _LinkedListItem):
            raise Exception('|item| must be of class _LinkedListItem')
        if item.parent() != self:
            raise Exception('|item| does not belong to this list')
        new_item = _LinkedListItem(key, value, item, item.next, self)
        if item.next:
            item.next.prev = new_item
        item.next = new_item
        if self.back == item:
            self.back = new_item
        self.length += 1 
        return new_item
    def insert_before(self, item, key, value):
        if not isinstance(item, _LinkedListItem):
            raise Exception('|item| must be of class _LinkedListItem')
        if item.parent() != self:
            raise Exception('|item| does not belong to this list')
        new_item = _LinkedListItem(key, value, item.prev, item, self)
        if item.prev:
            item.prev.next = new_item
        item.prev = new_item
        if self.front == item:
            self.front = new_item
        self.length += 1 
        return new_item
    def swap(self, item1, item2):
        if not isinstance(item1, _LinkedListItem):
            raise Exception('|item1| must be of class _LinkedListItem')
        if not isinstance(item2, _LinkedListItem):
            raise Exception('|item2| must be of class _LinkedListItem')
        if item1.parent() != self:
            raise Exception('|item1| does not belong to this list')
        if item2.parent() != self:
            raise Exception('|item2| does not belong to this list')
        if self.front == item1:
            self.front = item2
        elif self.front == item2:
            self.front = item1
        if self.back == item1:
            self.back = item2
        elif self.back == item2:
            self.back = item1
        tmp_next = item2.next
        tmp_prev = item2.prev
        item2.next = item1.next
        if item2.next:
            item2.next.prev = item2
        item2.prev = item1.prev
        if item2.prev:
            item2.prev.next = item2
        item1.next = tmp_next
        if item1.next:
            item1.next.prev = item1
        item1.prev = tmp_prev
        if item1.prev:
            item1.prev.next = item1
    def filter(self, func):
        ll = LinkedList()
        current = self.front
        while current:
            if not func or func(current.key, current.value):
                ll.add_to_back(current.key, current.value)
            current = current.next
        return ll
    def in_filter(self, func):
        if not func:
            return
        current = self.front
        while current:
            if not func(current.key, current.value):
                self.remove(current)
            current = current.next
    def in_map(self, func):
        if not func:
            return
        current = self.front
        while current:
            tup = func(current.key, current.value)
            current.key = tup[0]
            current.value = tup[1]
            current = current.next
    def map(self, func):
        ll = LinkedList()
        current = self.front
        while current:
            tup = func(current.key, current.value) if func else (current.key, current.value)
            ll.add_to_back(tup[0], tup[1])
            current = current.next
        return ll",0,0,0,0,0,1,0,1,0
1513,"class Node(object):
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node
class LinkedList(object):
    def __init__(self, data=None):
        self._length = 0
        self.head = None
        try:
            for val in data:
                self.push(val)
        except TypeError:
            if data:
                self.push(data)
    def push(self, val):
        old_head = self.head
        self.head = Node(val, old_head)
        self._length += 1
    def pop(self):
        if not self.head:
            raise IndexError('Cannot pop from an empty list')
        to_return = self.head
        self.head = self.head.next
        self._length -= 1
        return to_return.data
    def size(self):
        return self._length
    def search(self, val):
        curr = self.head
        while curr:
            if curr.data == val:
                return curr
            curr = curr.next
    def remove(self, val):
        curr = self.head
        if curr and val is self.head.data:
            self.head = self.head.next
            self._length -= 1
        while curr:
            if (curr.next and curr.next.data == val):
                curr.next = curr.next.next
                self._length -= 1
            curr = curr.next
    def display(self):
        curr = self.head
        display = '('
        while curr:
            display += str(curr.data) + ', '
            curr = curr.next
        return display[:-2] + ')'",0,0,0,0,0,1,0,1,0
1514,"class Node(object):
    def __init__(self, data, node = None):
        self.data = data
        self.next = node
class LinkedList(object):
    def __init__(self, *data):
        self.size = 0
        self.head = None
        if data:
            for val in data:
                self.insert(val)
    def __iter__(self):
        current_node = self.head
        while current_node:
            yield current_node
            current_node = current_node.next
    def insert(self, val):
        new_node = Node(val, self.head)
        self.head = new_node
        self.size += 1
    def pop(self):
        old_node = self.head
        if old_node is None:
            raise IndexError
        self.head = old_node.next
        self.size -= 1
        old_node.next = None
        return old_node.data
    def search(self, val):
        node = self.head
        while node is not None:
            if node.data == val:
                return node
            node = node.next
        return None
    def remove(self, val):
        first = self.head
        if first.data == val:
            self.pop()
            return first
        while first.next is not None:
            if first.next.data == val:
                remove_node = first.next
                second = remove_node.next
                remove_node.next = None
                first.next = second
                self.size -= 1
                return remove_node
            first = first.next
        if first.next is None:
            raise IndexError
    def toString(self):
        node = self.head
        result = ""(""
        while node.next is not None:
            val = node.data
            if type(val) == type(u'hello'):
                result = result + ""'"" + str(val) + ""', ""
            else:
                result = result + """" + str(val) + "", ""
            node = node.next
        if type(node.data) == type(u'hello'):
            return result + ""'"" + str(node.data) + ""')""
        else:
            return result + """" + str(node.data) + "")""",0,0,0,0,0,1,0,1,0
1515,"class LinkedList:
    def __init__(self):
        self.head = Node(None, None)
        self.tail = self.head
    def add_element(self, data):
        if self.head.value is None:
            self.head.value = data
        else:
            self.tail.next = Node(data, None)
            self.tail = self.tail.next
    def set_element(self, index, data):
        current = self.index(index)
        current.value = data
    def index(self, index):
        current = self.head
        for i in range(index):
            current = current.next
        return current
    def size(self):
        cnt = 0
        current = self.head
        while current is not None:
            cnt += 1
            current = current.next
        return cnt
    def remove(self, index):
        if index != 0:
            prev = self.index(index - 1)
            prev.next = prev.next.next
        else:
            self.head = self.head.next
    def pprint(self):
        current = self.head
        while current is not None:
            print(current.value)
            current = current.next
    def to_list(self):
        lst = []
        current = self.head
        while current is not None:
            lst.append(current.value)
            current = current.next
        return lst
    def add_at_index(self, index, data):
        if index != 0:
            prev = self.index(index - 1)
            prev.next = Node(data, prev.next)
        else:
            self.add_first(data)
    def add_first(self, data):
        self.head = Node(data, self.head)
    def add_list(self, lst):
        for item in lst:
            self.tail.next = Node(item, None)
            self.tail = self.tail.next
    def add_linked_list(self, llist):
        self.tail.next = llist.head
        self.tail = llist.tail
    def ll_from_to(self, start_index, end_index):
        ll = LinkedList()
        current = self.index(start_index)
        for i in range(end_index - start_index):
            ll.add_element(current.value)
            current = current.next
        return ll
    def pop(self):
        before_last = self.index(self.size() - 2)
        last = before_last.next.value
        before_last.next = None
        self.tail = before_last
        return last
    def reduce_to_unique(self):
        unique_values = set()
        unique_ll = LinkedList()
        current = self.head
        for i in range(self.size()):
            if current.value not in unique_values:
                unique_ll.add_element(current.value)
                unique_values.add(current.value)
            current = current.next
        return unique_ll
class Node:
    def __init__(self, value, nxt_node):
        self.value = value
        self.next = nxt_node
def main():
if __name__ == ""__main__"":
    main()",0,0,0,0,0,0,0,1,0
1516,"from dataclasses import dataclass
import typing as tp
@dataclass
class Node:
    next: tp.Optional[tp.Any]
    value: tp.Any
class LinkedList:
    _head: tp.Optional[Node]
    _current: tp.Any
    _size: int
    def __init__(self) -> None:
        self._size = 0
        self._head = None
        self._current = self._head
    def append(self, element: tp.Any) -> None:
        if self._size == 0:
            self._head = Node(None, element)
            self._current = self._head
            self._size += 1
        else:
            current_node = self._head
            while True:
                if current_node.next is not None:
                    current_node = current_node.next
                else:
                    current_node.next = Node(None, element)
                    self._size += 1
                    break
    def __repr__(self):
        str_t = '['
        current = self._head
        while True:
            str_t += str(current.value)
            if current.next is not None:
                str_t += ', '
                current = current.next
            else:
                break
        str_t += ']'
        return str_t
    def __contains__(self, val: tp.Any):
        pass
    def __len__(self):
        return self._size
    def __iter__(self):
        return self
    def iteration(self, func):
        current = self._head
        if current is None:
            return
        while True:
            if current.next is not None:
                func(current)
                current = current.next
            else:
                break",0,0,0,0,0,0,0,1,0
1517,"class Node():
    def __init__(self, data):           
        self.val = data
        self.next = None
    def setVal(self,val):               
        self.val = val
    def setNext(self,next_node):        
        self.next = next_node
class LinkedList():
    def __init__(self):                 
        self.head = None
        self.end = None
        self.len = int()
    def addNodeH(self,node):            
        if self.len > 0:
            node.setNext(self.head)
            self.head = node
            self.len += 1
        else:
            self.head = node
            self.end = node
            self.len += 1
    def addNodeE(self,node):            
        if self.len < 1:
            self.head = node
            self.end = node
            self.len += 1
        else:
            self.end.setNext(node)
            self.end = self.end.next
            self.len += 1
    def addNodeS(self, node, location): 
        assert isinstance(location, int)
        current = self.head
        while True:
            if current == None:
                print(""Element not found."")
                break
            elif current.val == location:
                temp = current.next
                current.next = node
                node.next = temp
                self.len += 1
                break
            else:
                current = current.next
    def delNodeH(self):                 
        if self.head != None:
            temp = self.head
            self.head = self.head.next
            temp.setNext(None)
            self.len -= 1
        else:
            print (""Empty List"")
    def delNodeE(self):                 
        self.delNodeS(self.end.val)
    def delNodeS(self, location):       
        assert isinstance(location, int)
        current = self.head
        if current == None:
            print (""Empty List"")
        else: 
            prev = None
            while True:
                if current == None:
                    print(""Element not found"")
                    break
                elif current.val == location:
                    if current == self.head:
                        temp = self.head
                        self.head = self.head.next
                        temp.setNext(None)
                        self.len -= 1
                        break
                    elif current == self.end:
                        prev.next = None
                        self.end = prev
                        self.len -= 1
                        break
                    else:
                        prev.next = current.next
                        current.setNext(None)
                        self.len -= 1
                        break
                else:
                    prev = current
                    current = current.next
    def print(self):                
        lt = []
        current = self.head
        while True:
            if current == None:
                break
            else:
                lt.append(current.val)
                current = current.next
        print (lt)
    def printLen(self):                 
        print (self.len)",0,0,0,0,0,0,0,1,0
1518,"from link import Link
class LinkedList(object):
    def __init__(self):
        self.head = Link()
        self.tail = Link()
        self.head.next = self.tail
        self.tail.prev = self.head
    def __getitem__(self, desired_index):
        current_index = 0
        link = self.first()
        while link != self.tail:
            if current_index == desired_index:
               return link
            link = link.next
            current_index += 1
        return None
    def first(self):
        return self.head.next
    def last(self):
        return self.tail.prev
    def empty(self):
        return self.first() == self.tail
    def get(self, key):
        link = self.first()
        while link != self.tail:
            if link.key == key:
                return link.val
            link = link.next
        return None
    def include(self, key):
        return not not self.find(key)
    def append(self, key, val):
        old_prev = self.tail.prev
        new_link = Link(key, val)
        new_link.next = self.tail
        self.tail.prev = new_link
        new_link.prev = old_prev
        old_prev.next = new_link
    def find(self, key):
        link = self.first()
        while link != self.tail:
            if link.key == key:
                return link
            link = link.next
        return None
    def update(self, key, val):
        link = self.find(key)
        if link:
            link.val = val
        return link
    def remove(self, key):
        link = self.find(key)
        if link:
            link.remove()
        return link
    def __str__(self):
        links = []
        link = self.first()
        while link != self.tail:
            links.append(str(link))
            link = link.next
        return "", "".join(links)
    def keys(self):
        links = []
        link = self.first()
        while link != self.tail:
            links.append(link.key)
            link = link.next
        return links",0,0,0,0,0,1,0,1,0
1519,"class Node:
    def __init__(self, data):
        self.data = data  
        self.next = None  
class LinkedList:
    def __init__(self):
        self.head = None
    def add_node_at_start(self, data):
        new_node = Node(data)  
        new_node.next = self.head  
        self.head = new_node  
    def add_node_at_end(self, data):
      new_node = Node(data)
      if self.head is None:
        self.head = new_node
        return None
      node = self.head
      while node.next:
        node = node.next
      node.next = new_node
    def list_print(self):
        node = self.head
        while node:
            print(node.data)
            node = node.next
linked_list = LinkedList()
linked_list.add_node_at_start(1)
linked_list.add_node_at_start(2)
linked_list.add_node_at_start(3)
linked_list.add_node_at_end(4)
linked_list.list_print()",0,0,0,0,0,0,0,0,0
1520,"class LinkedList:
    def __init__(self, head=None):
        self.head = None
    def insert(self, value):
        self.head = Node(value, self.head)
class Node:
    def __init__(self, value, next=None):
        self.value = value
        self.next = next",0,0,0,0,0,0,0,0,0
1521,"class LinkedList:
    def __init__(self):
        self.head = None
    def insert(self, node_value):
        self.head = Node(node_value, self.head)
    def append_val(self, node_value):
        new_node = Node(node_value)
        if self.head is None:
            self.head = new_node
            return
        end_point = self.head
        while (end_point.next):
            end_point = end_point.next
        end_point.next = new_node
    def insert_before(self, targeted_value, node_value):
        new_node = Node(node_value)
        if self.head is None:
            self.head = new_node
            return
        current = self.head
        if current.next.node_value == targeted_value:
            current = Node(node_value, current.next)
    def insert_after(self, targeted_value, node_value):
        new_node = Node(node_value)
        if self.head is None:
            self.head = new_node
            return
        current = self.head
        if current.node_value == targeted_value:
            current = new_node
            current.next = Node(node_value, current.next)
    def kth_from_end(self, k):
        basic_counter = 0
        length = 0
        current = self.head
        while current.next:
            length += 1
            current = current.next
        if k > length:
            return 'This value is beyond the scope of the list'
        elif length >= 1:
            k_endpoint = ((length + 1) - k)
        elif length <= 1:
            k_endpoint = (length - k)
        while basic_counter != k_endpoint:
            current = self.head
            basic_counter += 1
            current = current.next
        if length > 1 and k < 1:
            return current.next.next.node_value
        elif k == length:
            return self.head.node_value
        elif k >= 1:
            return current.next.node_value 
        elif k < 1 and length <= 1:
            return self.head.node_value
    def merge_lists(self, ll_1):
        current_1 = self.head
        current_2 = ll_1.head
        while current_1 != None and current_2 != None:
            current_1_next = current_1.next
            current_2_next = current_2.next
            current_2.next = current_1_next,
            current_1_next = current_2_next
            current_1 = current_1_next
            current_2 = current_2_next
        ll_1.head = current_1
        return ll_1.head.node_value
    def includes_val(self, search_value):
        current = self.head
        while current != None:
            if current.node_value == search_value:
                return True
            current = current.next
        return False
    def __str__(self):
        node_str = ''
        current = self.head
        while current != None:
            node_str += str(current.node_value)
            current = current.next
        return node_str
class Node:
    def __init__(self, node_value, next=None):
        self.node_value = node_value
        self.next = next
try:
    LinkedList()
except ValueError:
    print('There has been an error with the value')",0,0,0,0,0,0,0,1,0
1522,"class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.number_of_created_nodes = 0
        self.number_of_deleted_nodes = 0
    def insert(self, val):
        new_node = Node()
        new_node.data = val
        new_node.next_node = self.head
        if self.head is None:
            self.tail = new_node
        self.head = new_node
        self.number_of_created_nodes += 1
    def pop(self):
        value_to_return = self.head.data
        self.head = self.head.next_node
        if self.head is None:
            self.tail = None
        self.number_of_deleted_nodes += 1
        return value_to_return
    def size(self):
        return (self.number_of_created_nodes - self.number_of_deleted_nodes)
    def search(self, val):
        if self.head is None:
            return None
        else:
            return self.head.search_self_or_next_node_for_a_value(val)
    def remove(self, node):
        if self.head is None:
            return None
        else:
            node_before_the_node_to_remove, node_to_remove =                self.head.search_self_or_next_node_for_identity_match(None, node)
            if (node_to_remove != self.tail) and (node_to_remove != self.head):
                node_after_the_node_to_remove = node_to_remove.next_node
                node_before_the_node_to_remove.next_node =                    node_after_the_node_to_remove
            if node_to_remove == self.tail:
                if node_before_the_node_to_remove is not None:
                    node_before_the_node_to_remove.next_node = None
                self.tail = node_before_the_node_to_remove
            if node_to_remove == self.head:
                self.head = node_to_remove.next_node
        self.number_of_deleted_nodes += 1
    def __str__(self):
        if self.head is None:
            string_to_return = ""()""
        else:
            node_to_check = self.head
            incrementor_for_node_printing = 0
            string_to_return = ""(""
            while True:
                if incrementor_for_node_printing != 0:
                    string_to_return += "", ""
                if isinstance(node_to_check.data, str):
                    string_to_return += ""'"" + str(node_to_check.data) + ""'""
                else:
                    string_to_return += str(node_to_check.data)
                incrementor_for_node_printing += 1
                if node_to_check != self.tail:
                    node_to_check = node_to_check.next_node
                else:
                    break
            string_to_return += "")""
        return string_to_return
class Node:
    def __init__(self):
        self.data = None
        self.next_node = None
    def search_self_or_next_node_for_a_value(self, value):
        if self.data == value:
            return self
        elif self.next_node is None:
            return None
        else:
            return self.next_node.search_self_or_next_node_for_a_value(value)
    def search_self_or_next_node_for_identity_match(self, previous_node,
                                               supplied_node):
        if self == supplied_node:
            return previous_node, self
        elif self.next_node is None:
            return previous_node, None
        else:
            return self.next_node                       .search_self_or_next_node_for_identity_match(
                           self, supplied_node)",0,0,0,0,0,1,0,1,0
1523,"import node
class Iterator:
    def __init__(self, start):
        self._current = start
    def __iter__(self):
        return self
    def __next__(self):
        if not self._current:
            raise StopIteration
        else:
            current = self._current
            self._current = self._current.next
            return current
class Empty(Exception):
    pass
class LinkedList:
    def __init__(self):
        self._first = None
        self._last  = self._first
        self._size  = 0
    def push_back(self, data):
        if self.is_empty():
            self._first = node.Node(data)
            self._last = self._first
            self._size += 1
        else:
            old_last = self._last
            self._last = node.Node(data)
            old_last.next = self._last
            self._size += 1
    def push_front(self, data):
        if self.is_empty():
            self._first = node.Node(data)
            self._last  = self._first
            self._size += 1
        else:
            old_first = self._first
            self._first = node.Node(data)
            self._first.next = old_first
            self._size += 1
    def pop_front(self):
        if self.is_empty():
            raise Empty
        else:
            data = self._first.data
            self._first = self._first.next
            self._size -= 1
            return data
    def first(self):
        if self.is_empty():
            raise Empty
        else:
            return self._first.data
    def last(self):
        if self.is_empty():
            raise Empty
        else:
            return self._last.data
    def is_empty(self):
        return self._size == 0
    def __eq__(self, other):
        if not type(other) is type(self):
            return False
        if len(self) != len(other):
            return False
        for node_self, node_other in zip(self, other):
            if node_self != node_other:
                return False
        return True
    def __ne__(self, other):
        return not self.__eq__(other)
    def __iter__(self):
        return Iterator(self._first)
    def __len__(self):
        return self._size",0,0,0,0,0,0,0,1,0
1524,"class LinkedList(object):
    def __init__(self, iter=None):
        self.head = None
        if iter:
            for val in iter:
                self.insert(val)
    def insert(self, val):
        new_node = Node(val, self.head)
        self.head = new_node
    def pop(self):
        try:
            rtn_value = self.head.val
            new_head = self.head.next_node
            self.head = new_head
            return rtn_value
        except AttributeError:
            return None
    def size(self):
        count = 0
        step_head = self.head
        while step_head:
            count += 1
            step_head = step_head.next_node
        return count
    def search(self, val):
        step_head = self.head
        while step_head:
            if step_head.val == val:
                return step_head
            step_head = step_head.next_node
        else:
            return None
    def remove(self, node):
        step_head = self.head
        prev_node = None
        if self.search(node.val) is None:
            raise ValueError('Node is not in list.')
        while step_head:
            if step_head.val == node.val:
                if prev_node is None:
                    self.head = step_head.next_node
                    step_head = self.head
                else:
                    prev_node.next_node = step_head.next_node
                    step_head = prev_node
            prev_node = step_head
            step_head = step_head.next_node
    def to_string(self):
        rtn_string = u""(""
        step_head = self.head
        while step_head:
            if step_head.next_node is None:
                rtn_string += str(step_head.val)
                break
            rtn_string += str(step_head.val) + u"", ""
            step_head = step_head.next_node
        rtn_string += u"")""
        return rtn_string
    def display(self):
        print(self.to_string())
class Node(object):
    def __init__(self, val, next_node=None):
        self.val = val
        self.next_node = next_node",0,0,0,0,0,1,0,1,0
1525,"class SinglyLinkedList:
    def __init__(self):
        self.root = None
    def get_size(self):
        if self.root is None:
            return 0
        else:
            return self.root.get_size()
    def get_item(self, index):
        if index == 0:
            self.get_first_item()
        else:
            return self.root.get_item(index)
    def get_first_item(self):
        if self.root is None:
            raise ListEmptyError()
        else:
            data = self.root.data
            self.root = self.root.next_node
            return data
    def get_last_item(self):
        if self.root is None:
            raise ListEmptyError()
        if self.root.next_node is None:
            data = self.root.data
            self.root = None
            return data
        else:
            return self.root.get_last_item()
    def peek_item(self, index):
        if index == 0:
            if self.root is None:
                raise IndexError(""List is empty."")
            else:
                return self.root.data
        else:
            return self.root.peek_item(index)
    def peek_first_item(self):
        if self.root is None:
            raise ListEmptyError()
        else:
            return self.root.data
    def peek_last_item(self):
        if self.root is None:
            raise ListEmptyError()
        else:
            return self.root.peek_last_item()
    def add_item(self, data, index):
        if index == 0:
            self.add_item_front(data)
        else:
            self.root.add_item(data, index)
    def add_item_front(self, data):
        self.root = _Node(self.root, data)
    def add_item_end(self, data):
        if self.root is None:
            self.add_item_front(data)
        else:
            self.root.add_item_end(data)
    def is_empty(self):
        if self.root is None:
            return True
        else:
            return False
    def clear(self):
        self.root = None
class _Node:
    def __init__(self, next_node=None, data=None):
        self.next_node = next_node
        self.data = data
    def get_size(self, count=1):
        if self.next_node is None:
            return count
        else:
            return self.next_node.get_size(count+1)
    def get_item(self, index, count=1):
        if index == count:
            data = self.next_node.data
            self.next_node = self.next_node.next_node
            return data
        else:
            if self.next_node.next_node is None:
                raise IndexError()
            else:
                return self.next_node.get_item(index, count+1)
    def get_last_item(self):
        if self.next_node.next_node is None:
            data = self.next_node.data
            self.next_node = None
            return data
        else:
            return self.next_node.get_last_item()
    def peek_item(self, index, count=1):
        if index == count:
            return self.data
        else:
            return self.next_node.peek_item(index, count+1)
    def peek_last_item(self):
        if self.next_node is None:
            return self.data
        else:
            self.next_node.peek_item()
    def add_item(self, data, index, count=1):
        if index == count:
            self.next_node = _Node(self.next_node, data)
        else:
            self.next_node.add_item(data, index, count+1)
    def add_item_end(self, data):
        if self.next_node is None:
            self.next_node = _Node(None, data)
        else:
            self.next_node.add_item_end(data)
class ListEmptyError(Exception):
    pass
if __name__ == '__main__':
    x = LinkedList()
    x.add_item_end(1)
    x.add_item_end(2)
    x.add_item_end(1)
    print x.get_first_item()
    print x.get_first_item()
    print x.get_first_item()",0,0,0,0,0,0,0,1,0
1526,"class Node(object):
    def __init__(self,data):
        self.data = data
        self.nextNode = None
class LinkedList(object):
    def __init__(self):
        self.head = None
        self.size_ = 0
    def insert_start(self,data):
        self.size_ += 1
        newNode = Node(data)
        if not self.head :
            self.head = newNode
        else :
            newNode.nextNode = self.head
            self.head = newNode
    def size(self):
        return self.size_
    def insert_end(self,data):
        self.size_ += 1
        newNode = Node(data)
        last_node = self.head
        while last_node.nextNode is not None :
            last_node = last_node.nextNode
        last_node.nextNode = newNode
    def traverse(self):
        last_node = self.head
        list_items = []
        while last_node is not None :
            list_items.append(last_node.data)
            last_node = last_node.nextNode
        print(list_items)
    def remove(self,data):
        if self.head is None :
            return
        self.size_ -= 1
        previousNode = None
        current_node = self.head
        while current_node.data != data:
            previous_node = current_node
            current_node = current_node.nextNode
        if previous_node is None :
            self.head = current_node.nextNode
        else :
            previous_node.nextNode = current_node.nextNode
    def search(self,data):
        current_node = self.head
        print(current_node.data,data)
        while current_node.data != data :
            current_node = current_node.nextNode
        if current_node.data != data :
            return ""Given item doesn't exist""
        else :
            if current_node.data == data and current_node.nextNode is None :
                return current_node.data , current_node.nextNode
            elif current_node.data == data and current_node.nextNode is not  None:
                return current_node.data , current_node.nextNode.data
if __name__ == '__main__':
    linkedlist = LinkedList() 
    linkedlist.insert_start(1)
    linkedlist.insert_start(2)
    linkedlist.insert_start(3)
    linkedlist.insert_start(4)
    linkedlist.insert_end(100)
    linkedlist.traverse()
    size = linkedlist.size()
    print('size:',size)
    linkedlist.remove(3)
    linkedlist.traverse()
    size = linkedlist.size()
    print('size after removing:',size)
    node = linkedlist.search(90)
    print(node)",0,0,0,0,0,1,0,1,0
1527,"class Node:
	def __init__(self, data=None, next=None):
		self.data = data
  self.next = next
class LinkedList:
	def __init__(self):
		self.head = None
 def insert_at_beginning(self, data):
		node = Node(data, self.head)
  self.head = node
 def insert_at_end(self, data):
		if self.head is None:
			self.head = Node(data, None)
   return
  itr = self.head
  while itr.next:
			itr = itr.next
  itr.next = Node(data, None)
 def insert_values(self, data_list):
		self.head = None
  for data in data_list:
			self.insert_at_end(data)
 def get_length(self):
		count = 0
  itr = self.head
  while itr:
			count += 1
   itr = itr.next
  return count
 def remove_at(self, index):
		if index < 0 or index >= self.get_length():
			raise Exception(""Invalid index"")
  if index == 0:
			self.head = self.head.next
   return
  count = 0
  itr = self.head
  while itr:
			if count == index-1:
				itr.next = itr.next.next
    break
   itr = itr.next
   count += 1
 def insert_at(self, index, data):
		if index < 0 or index >= self.get_length():
			raise Exception(""Invalid Index"")
  if index == 0:
			self.insert_at_beginning(data)
   return
  count = 0
  itr = self.head
  while itr:
			if count == index-1:
				node = Node(data, itr.next)
    itr.next = node
    break
   itr = itr.next
   count += 1
 def print(self):
		if self.head is None:
			print(""Linked list is empty"")
   return
  itr = self.head
  listr = ''
  while itr:
			listr += str(itr.data) + "" ""
   itr = itr.next
  print(listr)
if __name__ == '__main__':
	ll = LinkedList()
 ll.insert_values(['A', 'B', 'C', 'D', 'E'])
 ll.insert_at_end('F')
 ll.insert_at_beginning('a')
 ll.print()  
 ll.remove_at(2)
 ll.print()  
 ll.insert_at(3, 'Z')
 ll.print()  
 ll.insert_at(3, 'X')
 ll.print() 
 print(""Length of linked list: "", ll.get_length())",0,0,0,0,0,0,0,1,0
1528,"class Node(object):
    def __init__(self, val, nxt=None):
        self.val = val
        self.nxt = nxt
class LinkedList(object):
    def __init__(self, iterable=None):
        self.head = None
        self.length = 0
        if isinstance(iterable, (str, list, tuple)):
            for item in iterable:
                self.push(item)
    def __len__(self):
        return self.length
    def __str__(self):
        return self.display()
    def size(self):
        return len(self)
    def push(self, val):
        self.head = Node(val, self.head)
        self.length += 1
    def pop(self):
        if not self.head:
            raise IndexError('Cannot pop from empty list.')
        val = self.head.val
        self.head = self.head.nxt
        self.length -= 1
        return val
    def search(self, val):
        curr = self.head
        while curr:
            if curr.val == val:
                return curr
            curr = curr.nxt
    def remove(self, node):
        if self.head is node:
            self.head = self.head.nxt
            self.length -= 1
            return
        curr = self.head
        while curr:
            if curr.nxt is node:
                curr.nxt = node.nxt
                self.length -= 1
                return
            curr = curr.nxt
        raise ValueError('Node is not in list.')
    def display(self):
        curr = self.head
        output = []
        while curr:
            output.append(curr.val)
            curr = curr.nxt
        return tuple(output).__str__()",0,0,0,0,0,1,0,1,0
1529,"class Node(object):
    def __init__(self, data, next):
        self.data = data
        self.next = next
class LinkedList(object):
    def __init__(self, iterable=None):
        self.head = None
        self._counter = 0
        if isinstance(iterable, (tuple, list)):
            for item in iterable:
                self.push(item)
    def push(self, data):
        if isinstance(data, (tuple, list)):
            for item in data:
                new_node = Node(item, self.head)
                self.head = new_node
                self._counter += 1
        else:
            new_node = Node(data, self.head)
            self.head = new_node
            self._counter += 1
    def pop(self):
        if not self.head:
            raise IndexError(""List is empty."")
        output = self.head.data
        self.head = self.head.next
        self._counter -= 1
        return output
    def size(self):
        return self._counter
    def search(self, val):
        curr = self.head
        while curr:
            if curr.data == val:
                return curr
            curr = curr.next
    def display(self):
        output_string = ""(""
        node = self.head
        if node is None:
            return '()'
        while node:
            try:
                float(node.data)
                output_string += (str(node.data) + "", "")
            except ValueError:
                output_string += (""\'"" + node.data + ""\'"") + "", ""
            node = node.next
        output_string = output_string[:-2] + ')'
        return(output_string)
    def __len__(self):
        return self._counter
    def remove(self, node):
        current_node = self.head
        previous_node = None
        while current_node:
            if current_node.data == node:
                if previous_node is None:
                    self.head = current_node.next
                    self._counter -= 1
                    return
                else:
                    previous_node.next = current_node.next
                    self._counter -= 1
                    return
            else:
                previous_node = current_node
                current_node = current_node.next
        raise IndexError('Node not in linked list.')
    def __str__(self):
        return self.display()",0,0,0,0,0,1,0,1,0
1530,"class Element(object):
    def __init__(self, value):
        self.value = value
        self.next = None
class LinkedList(object):
    def __init__(self, head=None):
        self.head = head
    def append(self, new_element):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element
    def get_position(self, position):
        current=self.head
        i=1
        while(i<position):
            current=current.next
            i = i+1
            if (current == None):
                return current
        return current
    def insert(self, new_element, position):
        temp = self.head
        current=self.head
        i=1
        while(i < position):
            temp=current
            current=current.next
            i=i+1
        temp.next=new_element
        new_element.next=current
    def delete(self, value):
        temp = 0
        current = self.head
        while(current.value != value):
            temp=current
            current=current.next
        if(current == self.head):
            self.head = current.next
        else:
            temp.next = current.next
e1 = Element(1)
e2 = Element(2)
e3 = Element(3)
e4 = Element(4)
ll = LinkedList(e1)
ll.append(e2)
ll.append(e3)
print ll.head.next.next.value
print ll.get_position(3).value
ll.insert(e4,3)
print ll.get_position(3).value
ll.delete(1)
print ll.get_position(1).value
print ll.get_position(2).value
print ll.get_position(3).value",0,0,0,0,0,1,0,1,0
1531,"function Node(data) {
    this.data = data;
    this.next = null;
}
function LinkedList() {
    this._length = 0;
    this.head = null;
}
LinkedList.prototype.add = function(value) {
    var node = new Node(value), currentNode = this.head;
    if (!currentNode) {
        this.head = node;
        this._length++;
        return node;
    }
    while (currentNode.next) {
        currentNode = currentNode.next;
    }
    currentNode.next = node;
    this._length++;
    return node;
};
LinkedList.prototype.delete = function(value) {
   var currentNode = this.head;
    if (!currentNode) {
        return;
    }
	if (currentNode.data === value) {
		if (currentNode.next) {
			this.head = currentNode.next
			return;
		} else {
			this.head = null;
			return;
		}
	} 
    while (currentNode && currentNode.next) {
    	if(currentNode.next.data === value) {
    		if (!currentNode.next.next) {  
    			currentNode.next = null;
    		} else {
    			currentNode.next = currentNode.next.next;
    		}
    	}
        currentNode = currentNode.next;
    }
    this._length--;
    return;
};
var list = new LinkedList();
list.add(""These"");
list.add(""words"");
list.add(""are"");
list.add(""elements"");
list.add(""in"");
list.add(""a"");
list.add(""linked list"");
list.add(""."");
list.delete(""."");
list.delete(""These"");
list.delete(""linked list"");
var pointer = list.head;
  while(pointer !== null){
    console.log(pointer.data);
    pointer = pointer.next;
}",0,0,0,0,0,0,0,1,0
1532,"from node import Node
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    def put(self, key, value) -> None:
        new_node = Node(key, value)
        if self.is_empty():
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node
        self.size += 1
        return new_node
    def get_key(self, key):
        node = self.head
        while node:
            if node.key == key:
                return node
            node = node.next
        return
    def get_value(self, value):
        node = self.head
        while node:
            if node.value == value:
                return node
            node = node.next
        return
    def update(self, key, value) -> None:
        node = self.get_key(key=key)
        if node:
            node.value = value
            return node
    def remove(self, key) -> None:
        curr = self.head
        if self.head.key == key:
            if self.head.next is not None:
                self.head.next.prev = None
            self.head = self.head.next
        if self.tail and self.tail.key == key:
            if self.tail.prev is not None:
                self.tail.prev.next = None
            self.tail = self.tail.prev
        while curr:
            if curr.key == key:
                curr.remove()
                self.size -= 1
                break
            curr = curr.next
        return
    def is_empty(self) -> bool:
        return self.size == 0 and self.head is None and self.tail is None
    def items(self) -> dict:
        items = []
        curr = self.head
        while curr:
            items.append((curr.key, curr.value))
            curr = curr.next
        return items",0,0,0,0,0,1,0,1,0
1533,"class ListNode {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
  }
  getNode(index) {
    if (index < 0) return null;
    let curr = this.head;
    for (let i = 0; i < index && curr; ++i) {
      curr = curr.next;
    }
    return curr;
  }
  getTail() {
    let curr = this.head;
    while (curr && curr.next) {
      curr = curr.next;
    }
    return curr;
  }
  get(index) {
    let curr = this.getNode(index);
    return curr == null ? -1 : curr.val;
  }
  addAtHead(val) {
    const newNode = new ListNode(val);
    newNode.next = this.head;
    this.head = newNode;
  }
  addAtTail(val) {
    if (this.head == null) {
      this.addAtHead(val);
      return;
    }
    let prev = this.getTail();
    const newNode = new ListNode(val);
    prev.next = newNode;
  }
  addAtIndex(index, val) {
    if (index <= 0) {
      this.addAtHead(val);
      return;
    }
    let prev = this.getNode(index - 1);
    if (prev == null) return;
    const curr = new ListNode(val);
    const next = prev.next;
    curr.next = next;
    prev.next = curr;
  }
  deleteAtIndex(index) {
    let curr = this.getNode(index);
    if (curr == null) return;
    let prev = this.getNode(index - 1);
    let next = curr.next;
    if (prev) prev.next = next;
    else this.head = next;
  }
  getlength() {}
  search() {}
}",0,0,0,0,0,0,0,1,0
1534,"class ListNode {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }
  get(index) {
    if (index > this.size) return -1;
    if (this.head == null) return -1;
    let count = 0;
    let loc = this.head;
    while (loc) {
      if (index == count) return loc.val;
      count++;
      loc = loc.next;
    }
    return -1;
  }
  addAtHead(val) {
    const newNode = new ListNode(val);
    newNode.next = this.head;
    this.head = newNode;
    this.size++;
  }
  addAtTail(val) {
    const newNode = new ListNode(val);
    let loc = this.head;
    let prev;
    while (loc) {
      prev = loc;
      loc = loc.next;
    }
    prev.next = newNode;
    this.size++;
  }
  addAtIndex(index, val) {
    if (index > this.size) return;
    let count = 0;
    let loc = this.head;
    let prev = null;
    const newNode = new ListNode(val);
    if (index == count || index < 0) {
      newNode.next = loc;
      this.head = newNode;
      return;
    }
    while (loc) {
      if (index == count) {
        prev.next = newNode;
        newNode.next = loc;
        this.size++;
        return;
      }
      count++;
      prev = loc;
      loc = loc.next;
    }
    prev.next = newNode;
    this.size++;
  }
  deleteAtIndex(index) {
    if (index > this.size) return;
    let loc = this.head;
    let prev = null;
    let count = 0;
    if (index == count) {
      this.head = this.head.next;
      return;
    }
    while (loc) {
      if (index == count) {
        prev.next = loc.next;
        this.size--;
        return;
      }
      count++;
      prev = loc;
      loc = loc.next;
    }
    if (index == this.size) {
      loc = null;
    }
  }
}",0,0,0,0,0,0,0,1,0
1535,"class LinkedListNode {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}
const a = new LinkedListNode(5);
const b = new LinkedListNode(1);
const c = new LinkedListNode(9);
a.next = b;
b.next = c;
deleteNode(b);
function appendToList(head, value) {
  let tail = head;
  while (tail.next) {
    tail = tail.next;
  }
  tail.next = new LinkedListNode(value);
  return tail.next;
}
let head = new LinkedListNode(1);
let nodeToDelete = head;
appendToList(head, 2);
appendToList(head, 3);
appendToList(head, 4);
function valuesToLinkedListNodes(values) {
  const nodes = [];
  for (let i = 0; i < values.length; i++) {
    const node = new LinkedListNode(values[i]);
    if (i > 0) {
      nodes[i - 1].next = node;
    }
    nodes.push(node);
  }
  return nodes;
}
let nodes = valuesToLinkedListNodes([1, 2, 3, 4]);
reversedList = reverse(nodes[0]);
nodes = valuesToLinkedListNodes([1, 2, 3, 4, 5, 6]);",0,0,0,0,0,0,0,0,0
1536,"class Node:
  def __init__(self,data):
    self.data = data 
    self.nextNode = None 
def PrintLinkedList (node):
    while node is not None:
        print(node.data,end="" "")
        node = node.nextNode
    print("""")
def Insert2End(currentNode,newNode):
    while(currentNode.nextNode is not None):
        currentNode = currentNode.nextNode
    currentNode.nextNode = newNode
def DeleteNode(headNode,data):
    n = headNode
    if (n.data == data):
        return(n.nextNode)
    while(n.nextNode is not None):
        if (n.nextNode.data == data):
            n.nextNode = n.nextNode.nextNode
            return(headNode)    
        else:
            n = n.nextNode
    print(data,"" Not found!"")
    return headNode
inputs = [1,2,3,4,5]
head = Node(inputs[0])
for x in range(1,len(inputs)):
    currentNode = head
    Insert2End(currentNode,Node(inputs[x]))
print(""Linked List (insert to end):"")
PrintLinkedList(head)
remove = 3
head = DeleteNode(head, remove)
print(""Linked List (after deleting %d):"" %(remove))
PrintLinkedList(head)",0,0,0,0,0,0,0,1,0
1537,"class Element(object):
    def __init__(self, value):
        self.value = value
        self.next = None
class LinkedList(object):
    def __init__(self, head=None):
        self.head = head
    def append(self, new_element):
        current = self.head
        if current:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element
    def get_position(self, position):
        current = self.head
        i = 1
        if self.head:
            while i != position:
                current = current.next
                i += 1
            return current
        else:
            return None
    def insert(self, new_element, position):
        current = self.head
        i = 1
        while i != position-1:
            current = current.next
            i += 1
        temp = current.next
        current.next = new_element
        current.next.next = temp
    def delete(self, value):
        current = self.head
        if current:
            i = 1
            while current.value != value:
                current = current.next
                i += 1
            current = self.head
            j = 1
            while j != i:
                current = current.next
                j += 1
            if j == 1:
                self.head = self.head.next
            else:
                current.next = current.next.next
e1 = Element(1)
e2 = Element(2)
e3 = Element(3)
e4 = Element(4)
ll = LinkedList(e1)
ll.append(e2)
ll.append(e3)
print(ll.head.next.next.value)
print(ll.get_position(3).value)
ll.insert(e4,3)
print(ll.get_position(3).value)
ll.delete(1)
print(ll.get_position(1).value)
print(ll.get_position(2).value)
print(ll.get_position(3).value)",0,0,0,0,0,1,0,1,0
1538,"package algos;
import java.util.Iterator;
public class LinkedList<T> implements Iterable<T>
{
    private static class Node<T>
    {
        private T       data;
        private Node<T> next;
        Node()
        {
            data = null;
            next = null;
        }
        Node(T _data, Node<T> _next)
        {
            this();
            setData(_data);
            setNext(_next);
        }
        public void setData(T _data)
        {
            data = _data;
        }
        public void setNext(Node<T> _next)
        {
            next = _next;
        }
        public T getData()
        {
            return data;
        }
        public Node<T> getNext()
        {
            return next;
        }
    }
    private Node<T> head = null;
    int             len  = 0;
    public void insert(T _data)
    {
        head = new Node<T>(_data, head);
        len++;
    }
    public T pop()
    {
        if (head == null) {
            return null;
        }
        T retval = head.getData();
        head = head.getNext();
        len--;
        return retval;
    }
    public int size()
    {
        return len;
    }
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder(""["");
        boolean isFirst = true;
        for (T data : this) {
            if (isFirst) {
                isFirst = false;
            }
            else {
                sb.append("", "");
            }
            sb.append(data);
        }
        sb.append(""]"");
        return sb.toString();
    }
    public LinkedList<T> reverse()
    {
        Node<T> ret = null;
        while (head != null) {
            Node<T> tmp = head.next;
            head.setNext(ret);
            ret = head;
            head = tmp;
        }
        head = ret;
        return this;
    }
    public LinkedList<T> reversed()
    {
        LinkedList<T> ret = new LinkedList<T>();
        for (T data : this) {
            ret.insert(data);
        }
        return ret;
    }
    @Override
    public Iterator<T> iterator()
    {
        return new Iterator<T>()
        {
            private Node<T> current  = head;
            private Node<T> prev     = null;
            private Node<T> prevprev = null;
            @Override
            public boolean hasNext()
            {
                return current != null;
            }
            @Override
            public T next()
            {
                prevprev = prev;
                prev = current;
                current = current.getNext();
                return prev.getData();
            }
            @Override
            public void remove()
            {
                if (prev == null) {
                    return;
                }
                if (prevprev == null) {
                    LinkedList.this.pop();
                    prev = null;
                    return;
                }
                prevprev.setNext(current);
                prev = null;
                len -= 1;
            }
        };
    }
}",0,0,0,0,0,0,0,1,0
1539,"class Node:
  def __init__(self, value):
    self.value = value
    self.next_node = None
  def get_value(self):
    return self.value
  def get_next_node(self):
    return self.next_node
  def set_next_node(self, next_node):
    self.next_node = next_node
class LinkedList:
  def __init__(self, head_node=None):
    self.head_node = head_node
  def insert(self, new_node):
    current_node = self.head_node
    if not current_node:
      self.head_node = new_node
    while(current_node):
      next_node = current_node.get_next_node()
      if not next_node:
        current_node.set_next_node(new_node)
      current_node = next_node
  def __iter__(self):
    current_node = self.head_node
    while(current_node):
      yield current_node.get_value()
      current_node = current_node.get_next_node()",0,0,0,0,0,0,0,0,0
1540,"package LinkedList;
public class LinkedList<E> {
    private class Node {
        public E e;
        public Node next;
        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }
        public Node(E e) {
           this(e, null);
        }
        public Node() {
           this(null, null);
        }
        @Override
        public String toString() {
            return e.toString();
        }
    }
    private Node dummyHead;
    private int size;
    public LinkedList() {
        this.dummyHead = new Node();
        this.size = 0;
    }
    public int getSize() {
        return size;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public void add(int index, E e) {
        if ((index < 0 || index > size)) {
            throw new IllegalArgumentException(""add failed!"");
        }
        Node pre = dummyHead;
        for (int i = 0; i < index; i++) {
            pre = pre.next;
        }
        pre.next = new Node(e, pre.next);
        size++;
    }
    public void addFirst(E e) {
        add(0, e);
    }
    public void addLast(E e) {
        add(size, e);
    }
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException(""no node!"");
        }
        Node cur = dummyHead.next;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        return cur.e;
    }
    public E getFirst() {
        return get(0);
    }
    public E getLast() {
        return get(size - 1);
    }
    public void set(int index, E e) {
        if (index < 0 || index >= size) {
            throw new IllegalArgumentException(""no index!"");
        }
        Node cur = dummyHead.next;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        cur.e = e;
    }
    public E remove(int index) {
        if ((index < 0 || index >= size)) {
            throw new IllegalArgumentException(""index is illegal!"");
        }
        Node pre = dummyHead;
        for (int i = 0; i < index; i++) {
            pre = pre.next;
        }
        Node cur = pre.next;
        pre.next = cur.next;
        cur.next = null;
        size--;
        return cur.e;
    }
    public E removeFirst() {
        return remove(0);
    }
    public E removeLast() {
        return remove(size - 1);
    }
    public void removeElement(E e){
        Node prev = dummyHead;
        while(prev.next != null){
            if(prev.next.e.equals(e))
                break;
            prev = prev.next;
        }
        if(prev.next != null){
            Node delNode = prev.next;
            prev.next = delNode.next;
            delNode.next = null;
            size --;
        }
    }
    public boolean isContains(E e) {
        Node cur = dummyHead.next;
        while (cur != null) {
            if (cur.e.equals(e)) {
                return true;
            }
            cur = cur.next;
        }
        return false;
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""LinkedList: "");
        for (Node cur = dummyHead.next; cur != null; cur = cur.next) {
            sb.append(cur).append("" -> "");
        }
        sb.append(""NULL"");
        return sb.toString();
    }
}",0,0,0,0,0,1,0,1,0
1541,"class node:
    def __init__(self, data = None):
        self.data = data
        self.next = None
class linked_list:
    def __init__(self):
        self.head = node()
    def append(self, data):
        new_node = node(data)
        cur = self.head
        while cur.next != None:
            cur = cur.next
        cur.next = new_node
    def length(self):
        cur = self.head
        total = 0
        while cur.next != None:
            total += 1
            cur = cur.next
        return total
    def display(self):
        elements = list()
        cur = self.head
        while cur.next != None:
            cur = cur.next
            elements.append(cur.data)
        print(elements)
    def get(self, index):
        if index >= self.length():
            print(""Error: 'Get' index out of range"")
            return None
        cur_index = 0
        cur = self.head
        while True:
            cur = cur.next
            if cur_index == index:
                return cur.data
            cur_index += 1
    def erase(self,index):
        if index >= self.length():
            print (""ERROR"")
            return
        cur_idx = 0
        cur = self.head
        while True:
            last_node = cur
            cur = cur.next
            if cur_idx == index:
                last_node.next = cur.next
                return
            cur_idx += 1
mylist = linked_list()
mylist.append(1)
mylist.append(2)
mylist.append(3)
mylist.append(4)
mylist.display()",0,0,0,0,0,1,0,1,0
1542,"package org.epalrov.collections;
import java.util.List;
import java.util.Collection;
import java.util.Iterator;
import java.util.ListIterator;
public class LinkedList<E> implements List<E>
{
	private ListNode<E> head;
	private int size;
	public LinkedList() {
		head = new ListNode<E>(null, null, null);
		head.next = head;
		head.prev = head;
		size = 0;
	}
	public int size() {
		return size;
	}
	public boolean isEmpty() {
		return size == 0 ? true : false;
	}
	public boolean add(E e) {
		ListNode<E> n = head;
		ListNode<E> node = new ListNode<E>(e, n, n.prev);
		n.prev.next = node;
		n.prev = node;
		size++;
		return true;
	}
	public void add(int index, E e) {
		ListNode<E> n = head;
		if (index == size) {
			n = head;
		} else if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				""Index: "" + index + "", Size: "" + size);
		}
		ListNode<E> node = new ListNode<E>(e, n, n.prev);
		n.prev.next = node;
		n.prev = node;
		size++;
	}
	public E get(int index) {
		ListNode<E> n = head;
		if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				""Index: "" + index + "", Size: "" + size);
		}
		return n.elem;
	}
	public E set(int index, E e) {
		ListNode<E> n = head;
		if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				""Index: "" + index + "", Size: "" + size);
		}
		E oldElem = n.elem;
		n.elem = e;
		return oldElem;
	}
	public E remove(int index) {
		ListNode<E> n = head;
		if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				""Index: "" + index + "", Size: "" + size);
		}
		n.next.prev = n.prev;
		n.prev.next = n.next;
		size--;
		return n.elem;
	}
	public boolean remove(Object o) {
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			if ((o != null && o.equals(n.elem)) ||
					(o == null && n.elem == null)) {
				n.next.prev = n.prev;
				n.prev.next = n.next;
				size--;
				return true;
			}
		}
		return false;
	}
	public void clear() {
		ListNode<E> n = head;
		while (size > 0) {
			n.next.prev = n.prev;
			n.prev.next = n.next;
			size--;
		}
	}
	public int indexOf(Object o) {
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			if ((o != null && o.equals(n.elem)) ||
					(o == null && n.elem == null))
				return i;
		}
		return -1;
	}
	public int lastIndexOf(Object o) {
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.prev;
			if ((o != null && o.equals(n.elem)) ||
					(o == null && n.elem == null))
				return size - 1 - i;
		}
		return -1;
	}
	public boolean contains(Object o) {
		return indexOf(o) != -1 ? true : false;
	}
	public Iterator<E> iterator() {
		return new LinkedListIterator(0);
	}
	public ListIterator<E> listIterator() {
		return new LinkedListIterator(0);
	}
	public ListIterator<E> listIterator(int index) {
		return new LinkedListIterator(index);
	}
	private class LinkedListIterator implements ListIterator<E> {
		private ListNode<E> currNode;
		private ListNode<E> nextNode;
		private int nextIndex;
		LinkedListIterator(int index) {
			currNode = head;
			nextNode = head;
			if (index >= 0 && index < size/2) {
				for (int i = 0; i <= index; i++)
					nextNode = nextNode.next;
			} else if (index <= size && index >= size/2) {
				for (int i = size; i >= index; i--)
					nextNode = nextNode.prev;
			} else {
				throw new IndexOutOfBoundsException(
					""Index: "" + index + "", Size: "" + size);
			}
			nextIndex = index;
		}
		public boolean hasNext() {
			return nextIndex == size ? false : true;
		}
		public E next() {
			currNode = nextNode;
			nextNode = nextNode.next;
			nextIndex++;
			return currNode.elem;
		}
		public int nextIndex() {
			return nextIndex;
		}
		public boolean hasPrevious() {
			return nextIndex == 0 ? false : true;
		}
		public E previous() {
			currNode = nextNode;
			nextNode = nextNode.prev;
			nextIndex--;
			return currNode.elem;
		}
		public int previousIndex() {
			return nextIndex;
		}
		public void set(E e) {
			currNode.elem = e;
		}
		public void add(E e) {
			ListNode<E> n = nextNode;
			ListNode<E> node = new ListNode<E>(e, n, n.prev);
			n.prev.next = node;
			n.prev = node;
			nextIndex++;
			size++;
		}
		public void remove() {
			ListNode<E> n = nextNode;
			n.prev.prev.next = n;
			n.prev = n.prev.prev;
			nextIndex--;
			size--;
		}
	}
	public Object[] toArray() {
		Object[] o = new Object[size];
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			o[i] = n.elem;
		}
		return o;
	} 
	public <T> T[] toArray(T[] a) {
		if (a.length < size)
			a = (T[])java.lang.reflect.Array.newInstance(
				a.getClass().getComponentType(), size);
		ListNode<E> n = head;
		for (int i = 0; i < size; i++) {
			n = n.next;
			a[i] = (T)n.elem;
		}
		return a;
	}
	public boolean containsAll(Collection<? extends Object> c) {
		Iterator<? extends Object> i = c.iterator();
		while (i.hasNext())
			if (!contains(i.next()))
				return false;
		return true;
	}
	public boolean addAll(Collection<? extends E> c) {
		ListNode<E> n = head;
		Iterator<? extends E> i = c.iterator();
		while (i.hasNext()) {
			ListNode<E> node =
				new ListNode<E>((E)i.next(), n, n.prev);
			n.prev.next = node;
			n.prev = node;
			size++;
		}
		return true;
	}
	public boolean addAll(int index, Collection<? extends E> c) {
		ListNode<E> n = head;
		if (index == size) {
			n = head;
		} else if (index >= 0 && index < size/2) {
			for (int i = 0; i <= index; i++)
				n = n.next;
		} else if (index < size && index >= size/2) {
			for (int i = size; i > index; i--)
				n = n.prev;
		} else {
			throw new IndexOutOfBoundsException(
				""Index: "" + index + "", Size: "" + size);
		}
		Iterator<? extends E> i = c.iterator();
		while (i.hasNext()) {
			ListNode<E> node =
				new ListNode<E>((E)i.next(), n, n.prev);
			n.prev.next = node;
			n.prev = node;
			size++;
		}
		return true;
	}	
	public boolean removeAll(Collection<?> c) {
		ListNode<E> n = head;
		for (int i = 0, count = size; i < count; i++) {
			n = n.next;
			if (c.contains(n.elem)) {
				n.next.prev = n.prev;
				n.prev.next = n.next;
				size--;
			}
		}
		return true;
	}
	public boolean retainAll(Collection<?> c) {
		ListNode<E> n = head;
		for (int i = 0, count = size; i < count; i++) {
			n = n.next;
			if (!c.contains(n.elem)) {
				n.next.prev = n.prev;
				n.prev.next = n.next;
				size--;
			}
		}
		return true;
	}
	public List<E> subList(int fromIndex, int toIndex) {
		throw new UnsupportedOperationException();
	}
	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof List))
			return false;
		Iterator<E> i = iterator();
		Iterator<?> j = ((List<?>) o).iterator();
		while (i.hasNext() && j.hasNext()) {
			E elem = i.next();
			Object obj = j.next();
			if (!(obj != null && obj.equals(elem)) ||
					(obj == null && elem == null))
				return false;
		}
		return !(i.hasNext() || j.hasNext());
	}
	public int hashCode() {
		int hash = 1;
		Iterator<E> i = iterator();
		while (i.hasNext()) {
			E elem = i.next();
			hash = 31*hash + (elem == null ? 0 : elem.hashCode());
		}
		return hash;
	}
	private static class ListNode<E> {
		E elem;
		ListNode<E> next;
		ListNode<E> prev;
		ListNode(E e, ListNode<E> n, ListNode<E> p) {
			elem = e;
			next = n;
			prev = p;
		}
	}
}",0,0,0,0,0,1,0,1,0
1543,"class LinkedList:
    def push(self, new, prev = None):
        if prev == None:
            new.next = self.head
            self.head = new
        else:
            new.next = prev.next
            prev.next = new
    def pop(self, index = 0):
        cur = index
        prev_node = None
        cur_node = self.head
        while cur > 0:
            prev_node = cur_node
            cur_node = cur_node.next
            cur -= 1
        if prev_node == None:
            popped = self.head
            self.head = self.head.next
            return popped
        else:
            prev_node = cur_node.next
            return cur_node
    def insert(self, node, index = 0):
        if node == None:
            raise Exception(""node is None Type"")
            return
        cur = index
        prev_node = None
        cur_node = self.head
        while cur > 0:
            prev_node = cur_node
            cur_node = cur_node.next
            cur -= 1
        if prev_node == None:
            self.head = node
        else:
            prev_node.next = node
        node.next = cur_node
    def __str__(self):
        if self.head == None:
            return """"
        else:
            return str(self.head)
    def __init__(self, head = None):
        self.head = head",0,0,0,0,0,0,0,1,0
1544,"class node(object):
    def __init__(self):
        self.x=None
        self.next=None
root=None
def init():
    global root
    root=node()
    pass
def insert_end(v):
    global root
    if root.x is None:
        root.x=v
    else:
        c=root
        while not (c.next is None):
            c=c.next
        c.next=node()
        c=c.next
        c.x=v
    pass
def insert_beg(v):
    global root
    if root.x is None:
        root.x=v
    else:
        c=root
        root=node()
        root.x=v
        root.next=c
    pass
def insert_n(n,v):
    global root
    if n==0:
        insert_beg(v)
        return
    c=root
    while not (c.next is None or n ==1):
        c=c.next
        n-=1
    t=c.next
    c.next=node()
    c=c.next
    c.x=v
    c.next=t
    pass
def remove_end():
    global root
    if root.x is None:
        print ""Empty list""
    elif root.next is None:
        root.x=None
    else:
        c=root
        while not (c.next.next is None):
            c=c.next
        c.next=None    
    pass
def remove_beg():
    global root
    if root.x is None:
        print ""Empty list""
    elif root.next is None:
        root.x=None
    else:
        root=root.next
    pass
def remove_n(n):
    global root
    if n==0:
        remove_beg()
        return
    c=root
    while not (c.next is None or n ==1):
        c=c.next
        n-=1
    if n<1:
        print ""Invalid n value""
    else:
        c.next=c.next.next
    pass
def rev():
    global root
    if root.x is None:return
    r=root
    c=r.next
    r.next=None
    while not (c is None):
        t=c.next
        c.next=r
        r=c
        if t is None:
            root=c
        c=t
def trav():
    global root
    if root.x is None:
        print ""Empty list""
    else:
        print ""The List: "",
        c=root
        while not (c is None):
            print ""->"",c.x,
            c=c.next
        print
    pass
if __name__=='__main__':
    init()
    while True:
        print ""Enter choice:""
        print ""0. Re-initialise the list""
        print ""1. Traverse list""
        print ""2. Insert at end""
        print ""3. Insert at root""
        print ""4. Remove from root""
        print ""5. Remove from end""
        print ""6. Insert at middle for a given n""
        print ""7. Remove from middle for a given n""
        print ""8. Reverse list""
        print ""9. Exit""
        print ""$Linked-list\_"",
        n=input()
        if n==9:print ""Exiting..."";break
        elif n==0:init();print ""Initialised...""
        elif n==1:trav()
        elif n==2:insert_end(input(""Enter value : ""));print ""Inserted ""
        elif n==3:insert_beg(input(""Enter value : ""));print ""Inserted ""
        elif n==4:remove_beg();print ""Removed ""
        elif n==5:remove_end();print ""Removed ""
        elif n==6:insert_n(input(""Enter n : ""),input(""Enter value : ""));print ""Inserted ""
        elif n==7:remove_n(input(""Enter n : ""));print ""Removed ""
        elif n==8:rev();print ""Reversed ""
        else:continue
        l=raw_input(""(Press Enter)"")",0,0,0,0,0,0,0,1,0
1545,"class Node:
	def __init__(self, data=None):
		self.data = data
  self.next = None
 def getData(self):
		return self.data
 def getNext(self):
		return self.next
 def setData(self, data):
		self.data = data
 def setNext(self, next):
		self.next = next
class LinkedList:
	def __init__(self):
		self.head = None
 def print(self):
		if self.head is None:
			print(""linked list is empty, nothing to print"")
   return
  current = self.head
  while current:
			print(current.data)
   current = current.next
 def add_at_the_begining(self, data):
		node = Node(data)
  if self.head is None: 
			self.head = node
  else:
			node.next = self.head
   self.head = node
  return self.head
 def add_at_the_end(self, data):
		node = Node(data)
  if self.head is None: 
			self.head = node
  else:
			current = self.head
   while current.next != None:
				current = current.next
   current.next = node
  return self.head
 def add_at_nth_position(self, data, pos):
		node = Node(data)
  if pos <= 0:
			return ""Invalid position, it can not be less than or equal to 0""
  elif pos == 1: 
				return self.add_at_the_begining(data)
  else:
			current = self.head
   i=1
   while i < pos-1 and current != None: 
				current = current.next
    i = i+1
   if current is None:
				return ""Invalid position, it exceeds the size of the linked list""
   node.next = current.next
   current.next = node
   return self.head
 def remove_at_the_begining(self):
		if self.head is None:
			return ""List is empty, nothing to remove""
  else:
			temp = self.head
   self.head = self.head.next
   return self.head
 def remove_at_the_end(self):
		if self.head is None:
			return ""List is empty, nothing to remove""
  elif self.head.next == None: 
			self.head = None
  else:
			temp = self.head
   temp2 = temp.next
   while temp2.next != None:
				temp = temp2
    temp2 = temp2.next
   temp.next = None
  return self.head
 def remove_at_nth_position(self, pos):
		if pos <= 0:
			return ""Invalid position, it can not be less than or equal to 0""
  elif pos == 1: 
			return self.remove_at_the_begining()
  else:
			temp = self.head
   temp2 = temp.next
   i=1
   while i < pos-1 and temp2 != None:
				temp = temp2
    temp2 = temp2.next
    i = i+1
   if temp2 is None:
				return ""Invalid position, it exceeds the size of the linked list""
   temp.next = temp2.next
  return self.head
 def reverse(self):
		if self.head is None: 
			return ""List is empty, nothing to reverse""
  else:
			currentNode = self.head
   prevNode = None
   while currentNode != None:
				nextNode = currentNode.next
    currentNode.next = prevNode
    prevNode = currentNode
    currentNode = nextNode
   self.head = prevNode
   return self.head
 def print_recursion(self, p):
		if p == None:
			return
  print(p.data)
  self.print_recursion(p.next)
 def reverse_print_recursion(self, p):
		if p == None:
			return
  self.reverse_print_recursion(p.next)
  print(p.data)
 def reverse_using_recursion(self,p):
		if self.head is None: 
			return ""List is empty, nothing to reverse""
  if p.next == None:
			self.head = p
   return self.head
  self.reverse_using_recursion(p.next)
  q = p.next
  q.next = p
  p.next = None
  return self.head",0,0,0,0,0,0,0,1,0
1546,"import sys
class Node:
	def __init__(self , value):
		self.next = None
  self.data = value
class LinkedList:
	def __init__(self):
		self.start = None
 def insertLast(self , value):
		newNode = Node(value)
  if self.start == None:
			self.start = newNode
   print(""{} inserted in the beginning"".format(value))
  else:
			temp = self.start
   while temp.next is not None:
				temp = temp.next
   temp.next = newNode
   print(""{} inserted successfully at the last"".format(value))
 def insertFirst(self , value):
		newNode = Node(value)
  if self.start == None:
			self.start = newNode
   print(""{} inserted in the beginning"".format(value))
  else:
			newNode.next = self.start
   self.start = newNode
   print(""{} inserted successfully in the beginning"".format(value))
 def insertAfter(self , after , value):
		newNode = Node(value)
  if self.start == None:
			print(""Linked list is empty , inserting {}"".format(value))
   self.start = newNode
  else:
			temp = self.start
   while temp is not None:
				if temp.data == after:
					newNode.next = temp.next
     temp.next = newNode
     break
    else:
					temp = temp.next
   print(""{} inserted successfully after {}"".format(value , after))
 def insertBefore(self , before , value):
		newNode = Node(value)
  if self.start == None:
			print(""Linked list is empty , inserting {}"".format(value))
   self.start = newNode
  else:
			previous_node = self.start
   next_node = previous_node.next
   if self.start.data == before:
				insertFirst(value)
   else:
				while next_node is not None:
					if next_node.data == before:
						newNode.next = next_node
      previous_node.next = newNode
      print(""{} inserted successfully before {}"".format(value , before))
      break
     else:
						previous_node = next_node
      next_node = next_node.next
 def removeFirst(self):
		if self.start == None:
			print(""Linked list is empty"")
  else:
			temp = self.start
   self.start = self.start.next
   print(""Start Node successfully deleted"")
 def removeLast(self):
		if self.start == None:
			print(""Linked list is empty"")
  else:
			second_last = self.start
   last = second_last.next
   while last.next is not None:
				second_last = last
    last = last.next
   second_last.next = None
   print(""Last Node successfully deleted"")
 def removeValue(self , value):
		if self.start == None:
			print(""Linked list is empty"")
  else:
			target_node = self.start
   nextNode = target_node.next
   if target_node.data == value:
				self.removeFirst()
   else:
				while nextNode.data != value:
					target_node = nextNode
     nextNode = nextNode.next
    target_node.next = nextNode.next
    print(""{} successfully deleted"".format(value))
 def displayList(self):
		if self.start == None:
			print(""Linked list is empty"")
  else:
			temp = self.start
   print(""\nLinked List:"")
   while temp is not None:
				print(temp.data , end = ""  "")
    temp = temp.next
obj = LinkedList()
while True:
	print(""\n--------------------------------"")
 print(""Main Menu"")
 print(""1. Insert node (start)"")
 print(""2. Insert node (end)"")
 print(""3. Insert after number"")
 print(""4. Insert before number"")
 print(""5. Remove node (start)"")
 print(""6. Remove node (end)"")
 print(""7. Remove node (by value"")
 print(""Enter <space> to display linked list"")
 print()
 print(""Enter any other key to exit"")
 print(""---------------------------------"")
 ch = input(""> "")
 if ch == "" "":
		obj.displayList()
 elif ch == ""1"":
		values = list(map(int , input(""Enter space separated values > "").strip().split("" "")))
  for value in values:
			obj.insertFirst(value)
 elif ch == ""2"":
		values = list(map(int , input(""Enter space separated values > "").strip().split("" "")))
  for value in values:
			obj.insertLast(value)
 elif ch == ""3"":
		l = input(""Enter the data after which the value is to be inserted and the value separated by space > "").strip().split("" "")
  obj.insertAfter(int(l[0]) , int(l[1]))
 elif ch == ""4"":
		l = input(""Enter the data before which the value is to be inserted and the value separated by space > "").strip().split("" "")
  obj.insertBefore(int(l[0]) , int(l[1]))
 elif ch == ""5"":
		obj.removeFirst()
 elif ch == ""6"":
		obj.removeLast()
 elif ch == ""7"":
		l = int(input(""Enter the value to be removed > ""))
  obj.removeValue(l)
 else:
		sys.exit()",0,0,0,0,0,0,0,1,0
1547,"import element
class LinkedList(object):
    def __init__(self, head=None):
        self.head = head
    def append(self, new_element):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element
    """"""Get an element from a particular position.
        Assume the first position is ""1"".
        Return ""None"" if position is not in the list.""""""
    def get_position(self, position):
        if not self.head:
            return None
        elif position == 1:
            return self.head
        else:
            current = self.head
            while (position > 1):
                current = current.next
                if current == None:
                    return None
                position = position - 1
            return current
    """"""Insert a new node at the given position.
            Assume the first position is ""1"".
            Inserting at position 3 means between
            the 2nd and 3rd elements.""""""
    def insert(self, new_element, position):
        if not self.head:
            self.head = new_element
            return
        try:
            prev_element = self.get_position(position - 1)
            next_element = prev_element.next
            prev_element.next = new_element
            new_element.next = next_element
        except:
            raise Exception('Unable to insert element at this position.')
    """"""Delete the first node with a given value.""""""
    def delete(self, value):
        if value == self.head.value:
            new_head = self.head.next
            self.head = new_head
            return
        previous = self.head
        current = self.head.next
        while (previous.next != None):
            if (current.value == value):
                previous.next = current.next
                return
            current = current.next
            previous = previous.next",0,0,0,0,0,1,0,1,0
1548,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class LinkedList:
    def __init__(self):
        self.head = None
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node
if __name__ == '__main__':
    linkedlist = LinkedList()
    newData = 0
    while newData != ""fin"":
        newData = input(""Enter the number you want to add to the list, enter \""fin\"" when you've finished:"")
        if newData != ""fin"":
            linkedlist.push(newData)
            print(newData + "" is added"")
    currentNode = linkedlist.head
    print(""All nodes off the Linked List:"")
    while currentNode is not None:
        data = currentNode.data
        print(data)
        currentNode = currentNode.next",0,0,0,0,0,0,0,0,0
1549,"class LinkedList:
    def __init__(self):
        self.head = None
    def addToStart(self, data):
        tempNode = Node(data)
        tempNode.setLink(self.head)
        self.head = tempNode
        del tempNode
    def addToEnd(self, data):
        start = self.head
        tempNode = Node(data)
        while start.getNextNode():
            start = start.getNextNode()
        start.setLink(tempNode)
        del tempNode
        return True
    def display(self):
        start = self.head
        if start is None:
            print(""Empty List!!!"")
            return False
        while start:
            print(str(start.getData()), end="" "")
            start = start.link
            if start:
                print(""-->"", end="" "")
        print()
    def length(self):
        start = self.head
        size = 0
        while start:
            size += 1
            start = start.getNextNode()
        return size
    def index(self, data):
        start = self.head
        position = 1
        while start:
            if start.getData() == data:
                return position
            else:
                position += 1
                start = start.getNextNode()
    def remove(self, item):
        start = self.head
        previous = None
        found = False
        while not found:
            if start.getData() == item:
                found = True
            else:
                previous = start
                start = start.getNextNode()
        if previous is None:
            self.head = start.getNextNode()
        else:
            previous.setLink(start.getNextNode())
        return found
    def Max(self):
        start = self.head
        largest = start.getData()
        while start:
            if largest < start.getData():
                largest = start.getData()
            start = start.getNextNode()
        return largest
    def Min(self):
        start = self.head
        smallest = start.getData()
        while start:
            if smallest > start.getData():
                smallest = start.getData()
            start = start.getNextNode()
        return smallest
    def push(self, data):
        self.addToEnd(data)
        return True
    def pop(self):
        start = self.head
        previous = None
        while start.getNextNode():
            previous = start
            start = start.getNextNode()
        if previous is None:
            self.head = None
        else:
            previous.setLink(None)
            data = start.getData()
            del start
            return data
    def atIndex(self, position):
        start = self.head
        position = int(position)
        pos = 1
        while pos != position:
            start = start.getNextNode()
            pos += 1
        data = start.getData()
        return data
    def copy(self):
        temp = LinkedList()
        start = self.head
        temp.addToStart(start.getData())
        start = start.getNextNode()
        while start:
            temp.addToEnd(start.getData())
            start = start.getNextNode()
        return temp
    def clear(self):
        self.head = None
        return True
    def removePosition(self, position):
        data = self.atIndex(position)
        self.remove(data)
        return data
    def toString(self, seperator=""""):
        start = self.head
        finalString = """"
        while start:
            tempString = start.getData()
            finalString += str(tempString)
            start = start.getNextNode()
            if start:
                finalString += seperator
        return finalString
    def count(self, element):
        start = self.head
        count1 = 0
        while start:
            if start.getData() == element:
                count1 += 1
            start = start.getNextNode()
        return count1
    def toList(self):
        start = self.head
        tempList = []
        while start:
            tempElement = start.getData()
            tempList.append(tempElement)
            start = start.getNextNode()
        return tempList
    def toSet(self):
        start = self.head
        tempSet = set()
        while start:
            tempElement = start.getData()
            if tempElement not in tempSet:
                tempSet.add(tempElement)
            start = start.getNextNode()
        return tempSet
    def reverse(self):
        start = self.head
        tempNode = None
        previousNode = None
        while start:
            tempNode = start.getNextNode()
            start.setLink(previousNode)
            previousNode = start
            start = tempNode
        self.head = previousNode
        return True
    def sort(self):
        start = self.head
        beginNode = start
        while beginNode:
            tempNode = beginNode
            tempNode2 = beginNode
            smallest = beginNode.getData()
            while tempNode:
                if smallest > tempNode.getData():
                    smallest = tempNode.getData()
                    tempNode2 = tempNode
                tempNode = tempNode.getNextNode()
            temp = beginNode.getData()
            beginNode.updateData(tempNode2.getData())
            tempNode2.updateData(temp)
            beginNode = beginNode.getNextNode()
    def sorted(self):
        start = self.head
        tempList = self.copy()
        tempList.sort()
        return tempList
class Node:
    def __init__(self, data=None, link=None):
        self.data = data
        self.link = link
    def updateData(self, data):
        self.data = data
    def setLink(self, node):
        self.link = node
    def getData(self):
        return self.data
    def getNextNode(self):
        return self.link
myList = LinkedList()
myList.addToStart(5)
myList.addToStart(4)
myList.addToStart(3)
myList.addToStart(2)
myList.addToStart(1)
myList.display()
myList.addToEnd(12)
myList.addToEnd(13)
myList.addToEnd(3)
myList.display()
print(myList.length())
print(myList.index(3))
print(myList.atIndex(5))
print(myList.remove(12))
myList.removePosition(2)
myList.display()
print(myList.Max())
print(myList.Min())
print(myList.push(31))
myList.display()
print(myList.pop())
myList.display()
myList2 = myList.copy()
myList2.display()
myList2.clear()
myList2.display()
print(myList.toString("",""))
print(myList.count(3))
newList = myList.toList()
print(newList)
newSet = myList.toSet()
print(newSet)
myList.reverse()
myList.display()
myList3 = myList.sorted()
myList3.display()
myList.sort()
myList.display()",0,0,1,0,0,1,0,1,0
1550,"class Node:
    def __init__(self,data=None):
        self.data = data
        self.next = None
class LinkedList:
    def __init__(self):
        self.head = Node()
    def add(self,data):
        new_node = Node(data)
        cur = self.head
        while cur.next != None:
            cur = cur.next
        cur.next = new_node
    def length(self):
        cur = self.head
        count = 0
        while cur.next != None:
            count+=1
            cur = cur.next            
        return count
    def display(self):
        cur = self.head
        elems = []
        while cur.next != None:
            cur=cur.next
            elems.append(cur.data)
        print(elems)
    def get(self,index):
        if(index>=self.length()):
            print('LinkedList has less elements than {}'.format(index))
            return 
        cur = self.head
        idx_count = 0
        while idx_count <= index:
            cur = cur.next
            idx_count+=1
        return cur.data
    def insert(self,index,data):
        if(index<0):
            print('ERROR: Not a valid index!')
            return
        ll_length = self.length()
        if(index>ll_length+1):
            print('LinkedList size was {}. You inserted in index {}.\nUnset indecies were set to \'None\'\n'.format(ll_length, index))
            diff = index - ll_length
            for i in range(diff-1):
                self.add(None)
            self.add(data)
        else:
            cur = self.head
            idx_count = 0
            while True:
                last_node = cur
                cur = cur.next
                if(idx_count == index):
                    new_node = Node(data)
                    last_node.next = new_node
                    new_node.next = cur
                    return
                idx_count+=1        
    def remove(self,index):
        if(index<0):
            print('ERROR! Invalid index ({}) to be removed!\n'.format(index))
            return
        if(index>=self.length()):
            print('LinkedList has less elements than {}'.format(index))
            return 
        cur = self.head
        idx_count = 0
        while True:
            last_node = cur
            cur = cur.next
            if(idx_count == index):
                last_node.next = cur.next
                return
            idx_count+=1
    def update(self,index,data):
        if(index>=self.length()):
            print('LinkedList is samller is samller than {} elements'.format(index))
            return
        cur = self.head
        idx_count = 0
        while True:
            cur = cur.next
            if(idx_count == index):
                cur.data = data
                return
            idx_count+=1
if __name__ == ""__main__"":
    print('\n')
    print('Tesing our LinkedList in Python...')
    print('\n')
    sll = LinkedList()
    print('An empty Singly LinkedList created')
    print('\n')
    print('Current LinkedList:')
    sll.display()
    print('Current size of LinkedList: {}'.format(sll.length()))
    print('\n')
    print('Some numbers were added to the LinkedList...')
    sll.add(10)
    sll.add(0)
    sll.add(37)
    sll.add(-4)
    sll.add(-5)
    sll.add(64)
    print('Current LinkedList:')
    sll.display()
    print('Current size of the LinkedList: {}'.format(sll.length()))
    print('\n')
    print('Value 3 was added to index 3:')
    print('Current LinkedList:')
    sll.insert(3,3)
    sll.display()
    print('Current size of the LinkedList: {}'.format(sll.length()))
    print('\n')
    print('Value 8 was added to index 10. READ THE MESSAGE BELOW from function!!')
    sll.insert(10,8)
    print('Current LinkedList:')
    sll.display()
    print('\n')
    print('Index 8 was updated with value 7:')
    sll.update(8,7)
    print('Current LinkedList:')
    sll.display()
    print('\n')
    print('Index 8 was updated with value -100 again:')
    sll.update(8,-100)
    print('Current LinkedList:')
    sll.display()
    print('\n')
    print('A value was tried to be added to index -7:')
    sll.insert(-7,21)
    print('Current LinkedList:')
    sll.display()
    print('\n')
    print('The first element was removed from LinkedList')
    sll.remove(0)
    print('Current LinkedList:')
    sll.display()
    print('\n')",0,0,0,0,0,1,0,1,0
1551,"class Element(object):
    def __init__(self, value):
        self.value = value
        self.next = None
class LinkedList(object):
    def __init__(self, head=None):
        self.head = head
    def append(self, new_element):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element
    def get_position(self, position):
        counter = 1
        current = self.head
        while current:
            if counter == position:
                return current
            else:
                current = current.next
                counter += 1
        return None
    def insert(self, new_element, position):
        counter = 1
        current = self.head
        if position == 1:
            new_element.next = self.head.next
            self.head = new_element
        else:
            while current:
                if counter == position-1:
                    new_element.next = current.next
                    current.next = new_element
                    break
                else:
                    current = current.next
                    counter += 1
    def delete(self, value):
        current = self.head
        if current.value == value:
            self.head = current.next
        else:
            while current.next:
                if current.next.value == value:
                    current.next = current.next.next
                    break
                else:
                    current = current.next
e1 = Element(1)
e2 = Element(2)
e3 = Element(3)
e4 = Element(4)
ll = LinkedList(e1)
ll.append(e2)
ll.append(e3)
print(ll.head.next.next.value)
print(ll.get_position(3).value)
ll.insert(e4,3)
print(ll.get_position(3).value)
ll.delete(1)
print(ll.get_position(1).value)
print(ll.get_position(2).value)
print(ll.get_position(3).value)",0,0,0,0,0,1,0,1,0
1552,"__author__ = 'Elias Haroun'
from List_ADT.list.Node import *
class LinkedList(object):
    def __init__(self):
        self.head = None
        self.size = 0
    def isEmpty(self):
        return self.size == 0
    def getSize(self):
        return self.size
    def getHead(self):
        return self.head
    def setHead(self, aNode):
        self.head = aNode
    def insertLast(self, data):
        newNode = Node(data, None, None)
        if self.isEmpty():
            self.setHead(newNode)
        else:
            temp = self.head
            while temp.getNext() is not None:
                temp = temp.getNext()
            temp.setNext(newNode)
        self.size += 1
    def insertFirst(self, data):
        newNode = Node(data, None, None)
        newNode.setNext(self.getHead())
        self.setHead(newNode)
        self.size += 1
    def deleteLast(self):
        if self.isEmpty() is not True:
            temp = self.getHead()
            while temp.getNext().getNext() is not None:
                temp = temp.getNext()
            temp.setNext(None)
            self.size -= 1
    def deleteFirst(self):
        if self.isEmpty() is not True:
            self.setHead(self.head.getNext())
            self.size -= 1
    def getContent(self):
        result = []
        temp = self.getHead()
        while temp:
            result.append(temp.getData())
            temp = temp.getNext()
        print(result)
    def find(self, data):
        index = 0
        temp = self.getHead()
        while temp:
            if temp.getData() == data:
                return index
            index += 1
            temp = temp.getNext()
        return -1",0,0,0,0,0,1,0,1,0
1553,"import os
from typing import NewType
class _Node:
    __slots__ = '_element', '_link'
    def __init__(self, element, link):
        self._element = element
        self._link = link
class LinkedList:
    def __init__(self):
        self._head = None
        self._tail = None
        self._size = 0
    def __len__(self):
        return self._size
    def isempty(self):
        return self._size == 0
    def addLast(self, e):
        newest = _Node(e, None)
        if self.isempty():
            self._head = newest
        else:
            self._tail._link = newest
        self._tail = newest
        self._size += 1
    def addFirst(self, e):
        newest = _Node(e, None)
        if self.isempty():
            self._head = newest
            self._tail = newest
        else:
            newest._link = self._head
            self._head = newest
        self._size += 1
    def addAnywhere(self, e, index):
        newest = _Node(e, None)
        i = index - 1
        p = self._head
        if self.isempty():
            self.addFirst(e)
        else:
            for i in range(i):
                p = p._link
            newest._link = p._link
            p._link = newest
            print(f""Added Item at index {index}!\n\n"")
        self._size += 1
    def addSorted(self, e):
        newest = _Node(e, None)
        if self.isempty():
            self.addFirst(e)
        else:
            curr = prev = self._head
            while curr and curr._element < e:
                prev = curr
                curr = curr._link
            if curr == self._head:
                self.addFirst(e)
            else:
                newest._link = prev._link
                prev._link = newest
                self._size += 1
    def removeFirst(self):
        if self.isempty():
            print(""List is Empty. Cannot perform deletion operation."")
            return
        e = self._head._element
        self._head = self._head._link
        self._size = self._size - 1
        if self.isempty():
            self._tail = None
        return e
    def removeLast(self):
        if self.isempty():
            print(""List is Empty. Cannot perform deletion operation."")
            return
        p = self._head
        if p._link == None:
            e = p._element
            self._head = None
        else:
            while p._link._link != None:
                p = p._link
            e = p._link._element
            p._link = None
            self._tail = p
        self._size = self._size - 1
        return e
    def removeAnywhere(self, index):
        p = self._head
        i = index - 1
        if index == 0:
            return self.removeFirst()
        elif index == self._size - 1:
            return self.removeLast()
        else:
            for x in range(i):
                p = p._link
            e = p._link._element
            p._link = p._link._link
        self._size -= 1
        return e
    def display(self):
        if self.isempty() == 0:
            p = self._head
            while p:
                print(p._element, end='-->')
                p = p._link
            print(""NULL"")
        else:
            print(""Empty"")
    def search(self, key):
        p = self._head
        index = 0
        while p:
            if p._element == key:
                return index
            p = p._link
            index += 1
        return -1
def options():
    options_list = ['Add Last', 'Add First', 'Add Anywhere', 'Insert Sorted',
                    'Remove First', 'Remove Last', 'Remove Anywhere',
                    'Display List', 'Print Size', 'Search', 'Exit']
    print(""MENU"")
    for i, option in enumerate(options_list):
        print(f'{i + 1}. {option}')
    choice = int(input(""Enter choice: ""))
    return choice
def switch_case(choice):
    if choice == 1:
        elem = int(input(""Enter Item: ""))
        L.addLast(elem)
        print(""Added Item at Last!\n\n"")
    elif choice == 2:
        elem = int(input(""Enter Item: ""))
        L.addFirst(elem)
        print(""Added Item at First!\n\n"")
    elif choice == 3:
        elem = int(input(""Enter Item: ""))
        index = int(input(""Enter Index: ""))
        L.addAnywhere(elem, index)
    elif choice == 4:
        elem = int(input(""Enter Item: ""))
        L.addSorted(elem)
    elif choice == 5:
        print(""Removed Element from First:"", L.removeFirst())
    elif choice == 6:
        print(""Removed Element from last:"", L.removeLast())
    elif choice == 7:
        index = int(input(""Enter Index: ""))
        print(f""Removed Item: {L.removeAnywhere(index)} !\n\n"")
    elif choice == 8:
        print(""List: "", end='')
        L.display()
        print(""\n"")
    elif choice == 9:
        print(""Size:"", len(L))
        print(""\n"")
    elif choice == 10:
        key = int(input(""Enter item to search: ""))
        if L.search(key) >= 0:
            print(f""Item {key} found at index position {L.search(key)}\n\n"")
        else:
            print(""Item not in the list\n\n"")
    elif choice == 11:
        import sys
        sys.exit()
if __name__ == '__main__':
    L = LinkedList()
    while True:
        choice = options()
        switch_case(choice)",0,0,0,0,0,1,0,1,0
1554,"import collections
class Node():
    def __init__(self, value):
        self.value = value
        self.next = None
    def __repr__(self):
        return '%s(%r)' % ('Node', self.value)
class LinkedList(collections.MutableSequence):
    def __init__(self, iterable=None):
        self._len = 0
        self._head = None
        self._tail = None
        if iterable is not None: 
            self += iterable
    def __repr__(self):
        node = self._head
        _list = []
        while node:
            _list.append( str(node) )
            node = node.next
        return '->'.join(_list)
    def _getnode(self, index):
        if self._head is None: 
            return None
        if index >= self._len: 
            return None
        node = self._head
        i = 0
        while i < index:
            node = node.next
            i += 1
        return node
    """"""
      Protocol for MutableSequence
      Provide index based operations
    """"""
    def __len__(self):
        return self._len
    def __getitem__(self, index):
        return self._getnode(index)
    def __setitem__(self, index, value):
        node = self._getnode(index)
        node.value = value
    def __delitem__(self, index):
        if index  == 0: 
            self._head = self[0].next
        else:
            pre = self._getnode(index-1)
            node = self._getnode(index)
            pre.next = node.next
            if node == self._tail:
                self._tail = pre
        self._len -= 1
    def append(self, value):
        newnode = Node(value)
        if self._head is None:
            self._head = newnode
        else:
            self._tail.next = newnode
        self._tail = newnode
        self._len += 1
    def insert(self, index, value):
        newnode = Node(value)
        if index == 0: 
            newnode.next = self._head
            self._head = newnode
            return
        elif index == len(self): 
            self._tail.next = newnode
            self._tail = newnode
        else:
            node = self._getnode(index-1)
            if node is None:
                return
            temp = node.next
            node.next = newnode
            newnode.next = temp
        self._len += 1
    def reverse_(self):
        def recurse(self, prev, node):
            if node is None:
                return
            recurse(self, node, node.next)
            if node == self._tail:
                self._head = node
            node.next = prev
            if prev is None:
                self._tail = node
        recurse(self, None, self._head)
    def reverse(self):
        prev, cur = None, self._head
        self._tail = cur
        while cur:
            temp = cur.next
            cur.next = prev
            prev = cur
            cur = temp
        self._head = prev
if __name__ == '__main__':
    import timeit
    sp = 'from linkedlist import *; ll = LinkedList(range(1000000))'
    print timeit.repeat(""ll.insert(0, 9)"", setup=sp, number=5)
    print timeit.repeat(""l.insert(0, 9)"", setup='l = range(1000000)', number=5)",0,0,0,0,0,0,0,1,0
1555,"class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None
class LinkedList:
    head = None
    def __init__(self, val):
        if self.head is None:
            self.head = ListNode(val)
    def insert(self, val):
        newListNode = ListNode(val)
        temp = self.head
        while temp.next is not None:
            temp = temp.next
        temp.next = newListNode
        return True
    def print(self):
        temp = self.head
        while temp:
            print(str(temp.val) + "" "")
            temp = temp.next
    def remove(self, element):
        removed = False
        if self.head.val == element :
            self.head = self.head.next
            removed = True
            return True
        else :
            temp = self.head
            while temp :
                if temp.next.val == element:
                    temp.next = temp.next.next
                    return True
                temp = temp.next
myLinkedList = LinkedList(1)
myLinkedList.insert(5)
myLinkedList.insert(6)
myLinkedList.insert(7)
myLinkedList.insert(6)
myLinkedList.insert(6)
myLinkedList.insert(8)
myLinkedList.print()
print(""-------"")
myLinkedList.remove(6)
myLinkedList.print()",0,0,0,0,0,0,0,1,0
1556,"from typing import List, Optional
class _Node:
    def __init__(self, item: 'object') -> None:
        self.item = item
        self.next = None
class LinkedList:
    def __init__(self, items: List[Optional['object']]) -> None:
        if not items:
            self._first = None
        else:
            self._first = _Node(items[0])
            current_node = self._first
            for item in items[1:]:
                current_node.next = _Node(item)
                current_node = current_node.next
    def __str__(self):
        required = """"
        if not self._first:
            return required
        else:
            required += str(self._first.item)
            cur_node = self._first
            while cur_node:
                cur_node = cur_node.next
                if cur_node:
                    required += "" -> "" + str(cur_node.item)
        return required
    def __len__(self):
        counter, cur_node = 0, self._first
        while cur_node:
            counter += 1
            cur_node = cur_node.next
        return counter
    def __getitem__(self, index):
        if (index < 0 and abs(index) > len(self)) or (index >= len(self)):
            raise IndexError
        else:
            if index < 0:
                index = len(self) + index
            counter, cur_node = 0, self._first
            while counter < index:
                cur_node = cur_node.next
                counter += 1
            return cur_node.item
    def reverse(self) -> None:
        cur_node, prev_node = self._first,None
        while cur_node:
            next_node = cur_node.next
            cur_node.next = prev_node
            prev_node = cur_node
            cur_node = next_node
        self._first = prev_node
    def __setitem__(self, key, value):
        if ( key < 0 and abs(key) > len(self)) or (key >= len(self)):
            raise IndexError
        else:
            if key < 0:
                key = len(self) + key
            counter, cur_node = 0, self._first
            while counter < key:
                cur_node = cur_node.next
                counter += 1
            cur_node.item = value
    def __contains__(self, item) -> bool:
        cur_node = self._first
        while cur_node:
            if cur_node.item == item:
                return True
            cur_node = cur_node.next
        return False
    def append(self, item) -> None:
        new_node = _Node(item)
        prev, current = self._first, self._first
        while current:
            prev = current
            current = current.next
        prev.next = new_node
    def count(self, item) -> int:
        count, cur_node = 0, self._first
        while cur_node:
            if cur_node.item == item:
                count += 1
            cur_node = cur_node.next
        return count
    def pop(self) -> 'object':
        if not self._first:
            raise IndexError
        else:
            hold = self._first.item
            if len(self) == 1:
                self._first = None
            else:
                prev_node, current_node, next_node = self._first, self._first, self._first.next
                while next_node:
                    prev_node = current_node
                    current_node, next_node = next_node, next_node.next
                hold = current_node.item
                prev_node.next = None
            return hold
    def extend(self, link: 'LinkedList') -> None:
        if not self._first:
            self._first = link._first
        else:
            prev, current = self._first, self._first
            while current:
                prev, current = current, current.next
            prev.next = link._first
    def remove(self, item: 'objec') -> None:
        if not (item in self):
            raise ValueError
        elif self._first.item == item:
            self._first = self._first.next
        else:
            prev, current = None, self._first
            while current.item != item:
                prev, current = current, current.next
            prev.next = current.next
    def insert(self, index: int, value: 'object') -> None:
        if not self._first:
            self._first = _Node(value)
        else:
            new_node = _Node(value)
            curr_node = self._first
            if index == 0:
                new_node.next = curr_node
                self._first = new_node
            elif len(self) <= index:
                while curr_node.next:
                    curr_node = curr_node.next
                curr_node.next = new_node
            else:
                count, prev = 0, None
                while count < index:
                    prev, curr_node = curr_node, curr_node.next
                    count += 1
                prev.next,new_node.next = new_node, curr_node
if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",0,0,0,0,0,1,0,1,0
1557,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class LinkedList:
    def __init__(self):
        self.head = None
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    def insert_after(self, prev_node, data):
        new_node = Node(data)
        new_node.next = prev_node.next
        prev_node.next = new_node
    def insert_at_end(self, data):
        new_node = Node(data)
        last = self.head
        while(last.next):
            last = last.next
        last.next = new_node
    def insert_at_position(self, position, data):
        new_node = Node(data)
        temp = self.head
        if self.head is None:
            self.head = new_node
        if position == 0:
            new_node.next = self.head
            self.head = new_node
        for i in range(position-1):
            temp = temp.next
            if temp is None:
                break
        if temp is None:
            return
        if temp.next is None:
            return
        cur_node = temp.next
        temp.next = new_node
        new_node.next = cur_node
    def delete_node_at_pos(self, position):
        if self.head == None:
            return None
        temp = self.head
        if position == 0:
            self.head = temp.next
            temp = None
            return None
        for i in range(position-1):
            temp = temp.next
            if temp is None:
                break
        if temp is None:
            return
        if temp.next is None:
            return
        next_node = temp.next.next
        temp.next = None
        temp.next = next_node
    def reverse(self):
        prev = None
        current = self.head
        while(current is not None):
            next = current.next
            current.next = prev
            prev = current
            current = next
        self.head = prev
    def print_rev():
        pass
    def print_list(self):
        temp = self.head
        while(temp):
            print(temp.data)
            temp = temp.next
ll = LinkedList()
ll.head = Node(1)
second = Node(2)
third = Node(4)
ll.head.next = second
second.next = third
ll.insert_at_beginning(0)
ll.insert_after(second, 3)
ll.insert_at_end(5)
ll.insert_at_end(6)
print('Original List:')
ll.print_list()
print('Modified List:')
ll.insert_at_position(3, 10)
ll.print_list()",0,0,0,0,0,0,0,1,0
1558,"from SimpleNode import SimpleNode as no
class LinkedList:
    def __init__(self):
        self.head = None
    def get_head(self):
        if self.head != None:
            return self.head
    def append_node(self, value):
        if self.head == None:
            self.head = no(value)
        else:
            node = self.get_head()
            while node.has_next():
                node = node.get_next()
            node.set_next(no(value))
    def delete_node(self, value):
        if self.head == None:
            raise Exception(""None head"")
            return
        elif self.head.get_value() == value:
            aux = self.head.get_next()
            self.head.set_next(None)
            self.head = aux
        else:
            node = self.get_head()
            aux_next = self.get_head().get_next()
            aux_2_next = self.get_head().get_next().get_next()
            while aux_next.has_next():
                if aux_next.get_value() == value:
                    node.set_next(aux_2_next)
                    aux_next.set_next(None)
                    break
                else:
                    node = node.get_next()
                    aux_next = aux_next.get_next()
                    aux_2_next = aux_2_next.get_next()
    def clear_all(self):
        if self.head == None:
            print(""Empty Linked list"")
        else:
            self.head = None
    def percorror_linked(self):
        head = self.get_head()
        if head != None:
            node = head
            print(node.get_value())
            while node.has_next():
                node = node.get_next()
                print(node.get_value())
        else:
            print(""Empty Linked"")
    def linked_list_len(self):
        head = self.get_head()
        if head == None:
            return 0
        else:
            final_len = 1
            node = head
            while node.has_next():
                final_len += 1
                node = node.get_next()
            return final_len
    def findMin(self):
        head = self.get_head()
        if head == None:
            return 0
        else:
            node = head
            min = node.get_value()
            while node.has_next():
                if node.get_next().get_value() < min:
                    min = node.get_next().get_value()
                node = node.get_next()
            return min
    def findMax(self):
        head = self.get_head()
        if head == None:
            return 0
        else:
            node = head
            min = node.get_value()
            while node.has_next():
                if node.get_next().get_value() > min:
                    min = node.get_next().get_value()
                node = node.get_next()
            return min
    def isEmpty(self):
        head = self.get_head()
        if head == None:
            return True
        return False
    def copy(self):
        head = self.get_head()
        if head == None:
            return None
        else:
            linked_copy = self
            return linked_copy
    def tostring(self):
        head = self.get_head()
        if head == None:
            print(""Empty Linked"")
        else:
            node = head
            count = 1
            out = (
                ""position: ""
                + str(count)
                + "" ""
                + ""value: ""
                + str(node.get_value())
                + ""\n""
            )
            while node.has_next():
                count += 1
                out += (
                    ""position: ""
                    + str(count)
                    + "" ""
                    + ""value: ""
                    + str(node.get_next().get_value())
                    + ""\n""
                )
                node = node.get_next()
        return out",0,0,0,0,0,1,0,1,0
1559,"class LinkedList:
	class Node:
		def __init__(self,element,point):
			self._ele = element
   self._next = point
 def __init__(self):
		self._head = None
  self._size = 0
 def getData(self):
		temp = self._head
  if temp != None:
			while temp._next != None :
				print(temp._ele)
    temp = temp._next
   print(temp._ele)
 def insertAtBegin(self,ele):
		if self._head == None:
			self._head = self.Node(ele, None)
  else:
			temp = self.Node(ele,self._head)
   self._head = temp
  self._size += 1
 def insertAtLast(self,ele):
		if self._head == None:
			self._head = self.Node(ele, None)
  else:
			temp = self._head
   while temp._next != None:
				temp = temp._next
   temp._next = self.Node(ele,None)
  self._size += 1  
 def deleteAtLast(self):
		ele = 0
  if self._head == None:
			print(""Empty list"")
  elif self._head._next == None:
			ele = self._head._ele 
   self._head = None
   self._size -= 1
  else:
			temp = self._head
   while temp._next._next != None:
				temp = temp._next
   ele = temp._next._ele
   temp._next = None
   self._size -= 1
  return ele
 def deleteAtBegin(self):
		ele = 0
  if self._head == None:
			print(""Empty list"")
  elif self._head._next == None:
			ele = self._head._ele
   self._head == None
   self._size -= 1
  else:
			temp = self._head
   ele = temp._ele
   self._head = self._head._next
   temp = None
   self._size -= 1
  return ele
 def countNode(self):
		return self._size
 def insertAfterPosition(self,ele,pos=0):
		if pos <= 0:
			print(""Invalid position item added at first."")
   self.insertAtBegin(ele)
  elif pos >= self._size:
			print(""Invalid position item added at last."")
   self.insertAtLast(ele)
  else:
			temp = self._head
   for i in range(0,pos - 1,1):
				temp = temp._next
   node = self.Node(ele,temp._next)
   temp._next = node
  self._size += 1
 def insertBeforePosition(self,ele,pos=0):
		if pos <= 0:
			print(""Invalid position item added at first."")
   self.insertAtBegin(ele)
  elif pos >= self._size:
			print(""Invalid position item added at last."")
   self.insertAtLast(ele)
  else:
			temp = self._head
   for i in range(0,pos - 2,1):
				temp = temp._next
   node = self.Node(ele,temp._next)
   temp._next = node
  self._size += 1
ll = LinkedList()
ll.insertAtBegin(23)
ll.insertAtBegin(54)
ll.insertAtLast(764)
ll.insertAtBegin(9284)
ll.insertAfterPosition(12,3)
ll.insertBeforePosition(98,3)
ll.getData()
print(ll.countNode())",0,0,0,0,0,0,0,1,0
1560,"from node import Node
class LinkedList(object):
  def __init__(self):
    self.head = None
    self.current = None
  def get_length(self):
    length = 0
    if self.head is None:
      return length
    else:
      length = 1
      self.current = self.head
      while self.current.next != None:
        self.current = self.current.next
        length = length + 1
      return length
  def push(self, node):
    self.current = self.head
    if self.head is None:
      self.head = node
      return self.head
    else:
      while self.current.next != None:
        self.current = self.current.next
      self.current.next = node
    return self.current
  def __len__(self):
    return self.get_length()
  def __str__(self):
    return '<LinkedList: %d nodes>' % self.get_length()
  def __repr__(self):
    nodes = []
    node = self.head
    while not node is None:
      nodes.append(repr(node))
      node = node.next
    return 'LinkedList: Nodes: %r' % nodes
  def remove(self, value):
    previous = None
    self.current = self.head
    if self.current is None:
      return 'Linked List is empty, value of: %d is not here' % value
    else:
      while self.current != None:
        if self.current.data == value:
          if len(self) is 1:
            previous = None
            self.current = None
            self.head = None
          else:
            previous.next = self.current.next
            self.current = None
          return 'Node with the value: %d was removed from the LinkedList' % value
        else:
          previous = self.current
          self.current = self.current.next
      return 'Node is not in LinkedList'",0,0,0,0,0,1,0,1,0
1561,"class Element(object):
    def __init__(self, value):
        self.value = value
        self.next = None
class LinkedList(object):
    def __init__(self, head=None):
        self.head = head
    def append(self, new_element):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = new_element
        else:
            self.head = new_element
    def get_position(self, position):
        current  =  self.head
        pos = 1
        if self.head:
            while pos != position:
                if current.next == None:
                    return None
                pos += 1
                current = current.next
            return current
        else:
            return ""Empty List""
    def insert(self, new_element, position):
        counter = 1
        current = self.head
        if position > 1:
            while counter < position-1:
                current = current.next
                counter += 1
                if current == None:
                    return ""Position is not in the list""
            new_element.next = current.next
            current.next = new_element
        elif position == 1:
            new_element.next = self.head
            self.head = new_element
    def delete(self, value):
        current = self.head
        previous = None
        if self.head:
            if current.value == value:
                self.head = current.next
                return
            while current.value != value:
                if current == None:
                    return ""cant find the element with this value""
                previous = current
                current = current.next
            previous.next = current.next 
        else:
             return ""Empty List""
e1 = Element(1)
e2 = Element(2)
e3 = Element(3)
e4 = Element(4)
ll = LinkedList(e1)
ll.append(e2)
ll.append(e3)
print ll.head.next.next.value
print ll.get_position(3).value
ll.insert(e4,3)
print ll.get_position(3).value
ll.delete(1)
print ll.get_position(1).value
print ll.get_position(2).value
print ll.get_position(3).value",0,0,0,0,0,1,0,1,0
1562,"class LinkedList:
	class Iter:
		def __init__(self, p, parent):
			self.p = p
   self.parent = parent
  def next(self):
			if self.p is not self.parent:
				v = self.p
    self.p = self.p.next
    return v
   raise StopIteration
 class ReversedIter:
		def __init__(self, p, parent):
			self.p = p
   self.parent = parent
  def __iter__(self):
			return self
  def next(self):
			if self.p is not self.parent:
				v = self.p
    self.p = self.p.prev
    return v
   raise StopIteration
 class Node:
		def __init__(self, elem, parent=None, prev=None, next=None):
			self.elem = elem
   self.prev = prev
   self.next = next
   self.parent = parent
  def detach(self):
			if self.parent:
				self.parent.count -= 1
   if self.prev is not None:
				self.prev.next = self.next
   if self.next is not None:
				self.next.prev = self.prev
  def __iter__(self):
			return LinkedList.Iter(self.next, self.parent)
  def __reversed__(self):
			return LinkedList.ReversedIter(self.prev, self.parent)
 def __init__(self, l=[]):
		self.count = 0
  self.prev = self
  self.next = self
  for elem in l:
			self.append(elem)
 def append(self, elem):
		node = self.Node(elem, parent=self, prev=self.prev, next=self)
  self.prev.next = node
  self.prev = node
  self.count += 1
 def __getitem__(self, idx):
		p = self.next
  if idx >= self.count:
			raise IndexError
  elif idx < 0:
			idx = idx + self.count
   if idx >= self.count or idx < 0:
				raise IndexError
  count = 0
  while count < idx:
			p = p.next
   count += 1
  return p
 def __len__(self):
		return self.count
 def __iter__(self):
		return self.Iter(self.next, self)
 def __reversed__(self):
		return self.ReversedIter(self.prev, self)",0,0,0,0,0,0,0,1,0
1563,"class Node:
    def __init__(self, data):
        self.data = data  
        self.next = None  
class LinkedList:
    def __init__(self):
        self.head = None",0,0,0,0,0,0,0,0,0
1564,"from Node import Node
class LinkedList:
    def __init__(self, head=None):
        self.head = Node()
        self.end = Node()
        self.head.next = self.end
        self.end.previous = self.head
        self.size = 0
    def insert(self, value):
        new_node = Node(value, None, None)
        cur = self.head
        while cur.next != self.end:
            cur = cur.next
        cur.next = new_node
        new_node.previous = cur
        new_node.next = self.end
        self.end.previous = new_node
        self.size+=1
    def find_node(self, value):
        cur = self.head.next
        while cur != self.end:
            if cur.value == value:
                print(""Value found in list"")
                return cur
            else:
                cur = cur.next
        print(""Error, not found in list"")
        return None
    def delete_node(self, value):
        found_node = self.find_node(value)
        if found_node != None:
            found_node.previous.next = found_node.next
            found_node.next.previous = found_node.previous
            self.size -= 1
        else:
            print(""Error, cannot delete value. not in list."")
    def get_size(self):
        return self.size
    def __str__(self):
        cur = self.head.next
        string = """"
        while cur != self.end:
            string += str(cur.value) + "" ""
            cur = cur.next
        return string",0,0,0,0,0,1,0,1,0
1565,"class LinkedList(object):
    def __init__(self):
        self.head = None
        self.size = 0
    def debug_print(self):
        print('{} >>> {}'.format(
            self.size, ', '.join([str(item) for item in self])))
    def __iter__(self):
        for node in self._iter_nodes():
            yield node.value
    def _iter_nodes(self):
        current = self.head
        while current != None:
            yield current
            current = current.next
    def _get_node(self, index):
        node = self.head
        if index > self.size - 1:
            raise ValueError(
                ""{} is not within the bounds of the linked list"".format(index))
        for i in range(index):
            node = node.next
        return node
    def add(self, item):
        node = Node(item)
        node.next = None
        if self.head == None:
            self.head = node
            self.size += 1
            return
        for current in self._iter_nodes():
            if current.next == None:
                current.next = node
                self.size += 1
                return
    def insert(self, index, item):
        new_node = Node(item)
        prev_node = self._get_node(index - 1)
        next_node = self._get_node(index)
        if index == 0:
            new_node.next = self.head
            self.head = new_node
        else:
            new_node.next = next_node
            prev_node.next = new_node
        self.size += 1
    def set(self, index, item):
        target_node = self._get_node(index)
        if target_node is not None:
            target_node.value = item
    def get(self, index):
        target_node = self._get_node(index)
        if target_node is not None:
            return target_node.value
    def delete(self, index):
        target_node = self._get_node(index)
        if index == 0:
            self.head = target_node.next
            target_node.value = None
        else:
            prev_node = self._get_node(index - 1)
            prev_node.next = target_node.next
        self.size -= 1
    def swap(self, index1, index2):
        node1 = self._get_node(index1)
        node2 = self._get_node(index2)
        node1.value, node2.value = node2.value, node1.value
class Node(object):
    def __init__(self, value):
        self.value = value
        self.next = None
    def __str__(self):
        return '<Node: {}>'.format(self.value)",0,0,0,0,0,0,0,1,0
1566,"package linkedlist;
import java.util.ArrayList;
import java.util.List;
public class LinkedList {
    public Node head;
    public Node current;
    public LinkedList(){
    }
    public void insert(int value){
        Node newNode = new Node(value);
        newNode.next = head;
        head = newNode;
    }
    public boolean includes(int value){
        current = head;
        while(current != null){
            if(current.data == value){
                return true;
            }
            current = current.next;
        }
        return false;
    }
    public List<Node> print(){
        List<Node> newList = new ArrayList<>();
        current = head;
        while(current != null){
            newList.add(current);
            current = current.next;
        }
        return newList;
    }
}",0,0,0,0,0,1,0,0,0
1567,"function Node(data) {
    this.data = data;
    this.next = null;
}
function List() {
    this.length = 0;
    this.head = null;
    this.tail = null;
}
List.prototype.add = function(data) {
    var node = new Node(data);
    if (this.head === null) {  
        this.head = this.tail = node;
        this.length++;
        return node;
    }
    else{  
        this.tail.next = node;
        this.tail = node;
        this.length++;
        return node;
    }
};
List.prototype.searchNodeAt = function(index) {
    var tmpNode = this.head;
    var count = 0;
    while(tmpNode != null){
        if(count == index)
            return tmpNode;
        tmpNpde = tmpNode.next;
        count++;
    }
    return null;   
};
List.prototype.searchNodewith = function(data) {
    var tmpNode = this.head;
    var iondex = 0;
    while(tmpNode != null){
        if(tmpNode.data == data)
            return index;
        tmpNpde = tmpNode.next;
        index++;
    }
    return 0;   
};
List.prototype.removeByIndex = function(index) {
    if(index == null)
        return null;
    if(!(index >= this.length)){
        var tmp = this.head;
        var count = 0;
        if(index == 0){
            tmp = this.head.next;
            delete this.head;
            this.head = tmp;
            this.length--;
            return true;
        }
        else{
            var tmp2 = tmp.next;
            while(tmp2 != null){
                if(count == index - 1){
                    tmp.next = tmp2.next;
                    delete tmp2;
                    this.length--;
                    return true;
                }
                tmp = tmp.next;
                tmp2 = tmp2.next;
                count++;
            }
        }
    }
    return false;
};
List.prototype.removeByData = function(data) {
    return this.removeByIndex(this.searchNodewith(data));
};
List.prototype.print = function(){
    var tmp = this.head;
    while(tmp != null)
        console.log(tmp.data);
};",0,0,0,0,0,1,0,1,0
1568,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    def is_empty(self):
        if self.head is None and self.tail is None:
            return True
        return False
    def print_list(self):
        next_node=self.head
        while next_node:
            print(next_node.data)
            next_node=next_node.next
    def append(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = new_node
            self.tail = new_node
            return
        self.tail.next = new_node
        self.tail=new_node
    def prepend(self, data):
        new_node = Node(data)
        if self.head is None:
            self.append(data)
            return
        new_node.next = self.head
    def insert_after_node(self, prev_node, data):
        if not prev_node:
            print(""Previous node is not in list"")
            return
        if prev_node.next is None:
            self.append(data)
            return
        new_node = Node(data)
        new_node.next = prev_node.next
        prev_node.next = new_node
    def search_list(self,data):
        last_node=self.head
        while last_node.next:
            if last_node.data == data:
                return last_node
            last_node = last_node.next
        return last_node
    def delete(self):
        if self.is_empty():
            print(""Nothing to delete, list empty"")
            return False
        current_node=self.head
        prev_node=self.head
        while current_node.next:
            prev_node=current_node
            current_node=current_node.next
        prev_node.next=None
        self.tail=prev_node
        return True
    def delete_node(self, data):
        if self.is_empty():
            print(""Nothing to delete, list empty"")
            return False
        if self.head == self.tail:
            if self.head.data == data:
                self.head=None
            else:
                print(""Search data element does not exist in list"")
                return
        if self.head.data == data:
            self.head = self.head.next
            return True
        cur_node = self.head.next
        prev_node = self.head
        while prev_node.next:
            if cur_node.data == data:
                prev_node.next=cur_node.next
                return True
            prev_node=cur_node
            cur_node=cur_node.next
        print(""Nothing to delete, data not found in list"")
        return
    def len_linkedlist(self):
        cur_node=self.head
        count=0
        while cur_node:
            count += 1
            cur_node=cur_node.next
        return count",0,0,0,0,0,1,0,1,0
1569,"class Node{
	int a ;
	Node next;
	Node(int x,Node z){
		a=x;
		next = z;
	}
}
class LinkedList{
	Node head;
	Node append(int data){
		Node n = new Node(data,null);
		if(head==null){
			head = n;
		}
		else{
			Node temp = head;
			while(temp.next!=null){
				temp = temp.next;
			}
			temp.next = n;
		}
		return head;
	}
	Node appendStart(int data,Node head){
		Node head2 = new Node(data,head);
		return head2;
	}
	void print(Node head){
		Node temp = head;
		while(temp!=null){
			System.out.println(temp.a+"" "");
			temp = temp.next;
		}
	}
}
class LinkedListImplementation{
	public static void main(String s[]){
		LinkedList ll = new LinkedList();
		Node head = ll.append(10);
		head = ll.append(20);
		head = ll.append(30);
		head = ll.append(40);
		head = ll.append(50);
		ll.print(head);
		Node head2 = ll.appendStart(0,head);
		ll.print(head2);
	}
}",0,0,0,0,0,0,0,0,0
1570,"package LinkedList;
import queue.LoopQueue;
import queue.Queue;
public class LinkedListQueue<E> implements Queue<E> {
    private class Node {
        public E e;
        public Node next;
        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }
        public Node(E e) {
            this(e, null);
        }
        public Node() {
            this(null, null);
        }
        @Override
        public String toString() {
            return e.toString();
        }
    }
    private Node head;
    private Node tail;
    private int size;
    public LinkedListQueue() {
        head = null;
        tail = null;
        size = 0;
    }
    @Override
    public void enqueue(E e) {
        if (head == null) {
            head = new Node(e);
            tail = head;
        } else {
            tail.next = new Node(e);
            tail = tail.next;
        }
        size++;
    }
    @Override
    public E dequeue() {
        if (size == 0) {
            throw new IllegalArgumentException(""queue is empty!"");
        }
        Node netNode = head;
        head = head.next;
        netNode.next = null;
        if (head == null) {
            tail = null;
        }
        size--;
        return netNode.e;
    }
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
    @Override
    public int getSize() {
        return size;
    }
    @Override
    public E getFront() {
        if (size == 0) {
            throw new IllegalArgumentException(""queue is empty"");
        }
        return head.e;
    }
    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(String.format(""Queue size is %d\n"", size));
        stringBuilder.append(""Front [ "");
        Node netNode = head;
        while (netNode != null) {
            stringBuilder.append(netNode.e).append("" -> "");
            netNode = netNode.next;
        }
        stringBuilder.append("" NULL ] Tail"");
        return stringBuilder.toString();
    }
    public static void main(String[] args) {
        LinkedListQueue<Object> queue = new LinkedListQueue<>();
        for (int i = 0; i < 10; i++) {
            queue.enqueue(i);
            if (i % 3 == 2) {
                queue.dequeue();
            }
            System.out.println(queue);
        }
    }
}",0,0,0,0,0,0,0,0,0
1571,"package LinkedList;
import stack.Stack;
public class LinkedListStack<E> implements Stack<E> {
    private LinkedList<E> list = new LinkedList<E>();
    @Override
    public void push(E e) {
        list.addFirst(e);
    }
    @Override
    public E pop() {
        return list.removeFirst();
    }
    @Override
    public E peek() {
        return list.getFirst();
    }
    @Override
    public int getSize() {
        return list.getSize();
    }
    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }
    @Override
    public String toString() {
        return "" LinkedListStack: TOP "" +
                list;
    }
    public static void main(String[] args) {
        LinkedListStack<Integer> stack = new LinkedListStack<Integer>();
        for (int i = 0; i < 5; i++) {
            stack.push(i);
            System.out.println(stack);
        }
        stack.pop();
        System.out.println(stack);
        stack.peek();
        System.out.println(stack);
    }
}",0,0,0,0,0,0,0,0,0
1572,"from Link import *
LETTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
LETTERS_LEN = len(LETTERS)
if __name__ == '__main__':
  link = Link()
  link.read_file('/home/sakebow/python/linklist/linklist.csv')
  link.delete_node_by_data('3')
  link.output()
  pass",0,0,0,0,0,0,0,0,0
1573,"from node import Node
class LinkList:
    def __init__(self):
        self.first_node = None
        self.last_node = None
    def add_node(self, key, value):
        new_node = Node(key, value)
        new_node.key = key
        new_node.value = value
        self.append_new_node_to_list(new_node)
    def append_new_node_to_list(self, new_node):
        if self.first_node is None:
            self.first_node = new_node
            self.last_node = new_node
        elif self.last_node == self.first_node:
            self.last_node = new_node
            self.first_node.next = new_node
        else:
            self.last_node.next = new_node
            self.last_node = new_node
    def contains_value(self, value):
        current_node = self.first_node
        result = False
        while current_node is not None:
            if current_node.value == value:
                result = True
                break
            current_node = current_node.next
        return result
    def contains_key(self, key):
        current_node = self.first_node
        result = False
        while current_node is not None:
            if current_node.key == key:
                result = True
                break
            else:
                current_node = current_node.next
        return result
    def delete_node_with_key(self, key):
        previous_node = self.last_node
        current_node = self.first_node
        if (current_node.key == key) & (previous_node.key == key):
            self.last_node = None
            self.first_node = None
            return
        else:
            while current_node.next is not None:
                if current_node.key == key:
                    self._remove_node_from_list(current_node, previous_node)
                else:
                    current_node = current_node.next
    @staticmethod
    def _remove_node_from_list(current_node, previous_node):
        previous_node.next = current_node.next
    def clear(self):
        self.__init__()",0,0,0,0,0,1,0,1,0
1574,"__author__ = ""streethacker""
class _BagIterator:
    def __init__(self, theHead):
        self._curNode = theHead
    def __iter__(self):
        return self
    def next(self):
        if self._curNode is None:
            raise StopIteration
        else:
            item = self._curNode.data
            self._curNode = self._curNode.next
            return item
class _BagListNode:
    def __init__(self, data):
        self.data = data
        self.next = None
class Bag:
    def __init__(self):
        self._head = None
        self._size = 0
    def __len__(self):
        return self._size
    def __iter__(self):
        return _BagIterator(self._head)
    def __contains__(self, target):
        curNode = self._head
        while curNode is not None and curNode.data != target:
            curNode = curNode.next
        return curNode is not None
    def add(self, data):
        newNode = _BagListNode(data)
        newNode.next = self._head
        self._head = newNode
        self._size += 1
    def remove(self, data):
        preNode = None
        curNode = self._head
        while curNode is not None and curNode.data != data:
            preNode = curNode
            curNode = curNode.next
        assert curNode is not None, ""The item must be in the bag.""
        self._size -= 1
        if curNode is self._head:
            self._head = curNode.next
        else:
            preNode.next = curNode.next
        return curNode.data
    def printBagElements(self):
        for b in self:
            print b
if __name__ == ""__main__"":
    bag = Bag()
    bag.add(10)
    bag.add(12)
    bag.add(36)
    bag.add(77)
    bag.printBagElements()
    bag.remove(12)
    print
    bag.printBagElements()",0,0,0,0,0,1,0,1,0
1575,"class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
class LinkedList:
    def __init__(self, head = None):
        self.head = head
    def append(self, newElement):
        current = self.head
        if self.head:
            while current.next:
                current = current.next
            current.next = newElement
        else:
            self.head = newElement
    def get_position(self, position):
        current = self.head
        current_pos = 1
        while current_pos <= position:
            if current_pos == position:
                return current
            current = current.next
            current_pos += 1
        return None
    def insert_element(self, element, position):
        if position > 1:
            target_position = self.get_position(position - 1)
            element.next = target_position.next
            target_position.next = element
        else:
            element.next = self.head
            self.head = element
    def delete_element(self, element):
        current = self.head
        previous = None
        while current:
            if current.value == element:
                if not previous:
                    self.head = current.next 
                    return True
                else:
                    previous.next = current.next
            previous = current
            current = current.next
        return False
node1 = Node(""Iron Man"")
node2 = Node(""Capitain America"")
node3 = Node(""Doctor Strange"")
node4 = Node(""Spider man"")
node5 = Node(""Rieder"")
print(""Node1 Value is {}"".format(node1.value))
print(""Node1 next Value is {}"".format(node1.next))
print(""Node2 Value is {}"".format(node2.value))
print(""Node2 next Value is {}"".format(node2.next))
Avengers = LinkedList()
Avengers.append(node1)
print(""Firt element in link list is {}"".format(Avengers.head.value))
Avengers.append(node2)
print(""After Iron Man is {}"".format(Avengers.head.next.value))
print(Avengers.get_position(2).value)
Avengers.append(node3)
Avengers.append(node4)
Avengers.insert_element(node5, 4)
print(Avengers.get_position(4).value)
print(Avengers.get_position(5).value)
Avengers.delete_element(""Rieder"")
print(Avengers.get_position(4).value)",0,0,0,0,0,1,0,1,0
1576,"import node
class List():
    def __init__(self, head=None):
        self._head = head
    def get_head(self):
        return self._head
    def append(self, data):
        new_node = node.Node(data)
        if not self._head:
            self._head = new_node
        else:
            temp = self._head
            while(temp.next):
                temp = temp.next
            temp.next = new_node 
        return self
    def get_position(self, position):
        if position < 1: 
            return None
        current_pos = 1
        current = self._head
        if self._head:
            while current and current_pos < position:
                current = current.next
                current_pos += 1
            return current
        else:
            return None
    def insert(self, new_data, position):
        new_node = node.Node(new_data)
        assert(position >= 1)
        assert(self._head)
        current_pos = 1
        current = self._head
        while current and current_pos < position - 1:
            current = current.next
            current_pos += 1
        if current:
            new_node.next = current.next
            current.next = new_node
        else:
            print('\nERROR: Could not insert node. Position', position, 'is out of bounds.')
    def delete(self, data):
        current = self._head
        previous = None
        while current.data != data and current.next:
            previous = current
            current = current.next
            if current.data == data:
                if previous:
                    previous.next = current.next 
                    current.next = None
                else:
                    self._head = current.next
    def reverse_list_iterative(self):
        prev = None
        curr = self._head
        next = None
        while curr:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        self._head = prev
    def reverse_list_recursive(self, curr, prev=None, next=None):
        if not curr: 
            self._head = prev
        else:
            next = curr.next
            curr.next = prev
            self.reverse_list_recursive(next, curr)
    def print_list(self):
        temp = self._head
        while(temp):
            print(temp)
            temp = temp.next",0,0,0,0,0,1,0,1,0
1577,"class LL:
    pred = None
    post = None
    data = None
    def __init__(self,data,post,pred):
        self.data = data
        self.post = post
    def remove(self,data):
        if self.pred == None:           
            if self.data == data:           
                if self.post == None:           
                    self.data = None
                    return 0
                hold = self.post                
                self.data = self.post.data
                self.post = self.post.post
                del hold
                return 0
            elif self.post == None:         
                return -1
            else:
                return self.post.remove(data)   
        else:
            if self.post == None:       
                if self.data == data:       
                    hold = self
                    temp = self.pred
                    temp.post = None
                    del hold
                    return 0
                else:
                    return -1               
            else:                       
                if self.data == data:       
                    hold = self
                    temp = self.pred
                    temp.post = self.post
                    del hold
                    return 0
                else:
                    return self.post.remove(data)   
    def insert(self,data):
        if data < self.data:
            hold = LL(data,self,None)
            self = hold
        elif self.post == None:
            hold = LL(data,None,self)
            self.post = hold
        else:
            self.post.insert(data)
    def contain(self, s):
            if self.data == None:
                print(s)
            else:
                s = s + "", "" + str(self.data)
                if self.post == None:
                    print(s)
                else:
                    self.post.contain(s)
    def contains(self):
        if self.post == None:
            if self.data == None:
                print(""Empty."")
            else:
                print(self.data)
        else:
            self.post.contain(str(self.data))
def test():
    base = LL(0,None,None)
    print(""contains..."")
    base.contains()
    print()
    print(""inserting 1..."")
    base.insert(1)
    print(""contains:"")
    base.contains()
    print()
    print(""inserting 5..."")
    base.insert(5)
    print(""contains:"")
    base.contains()
    print()
    print(""removing 1..."")
    base.remove(1)
    print(""contains:"")
    base.contains()
    print()
    print(""removing 5..."")
    base.remove(5)
    print(""contains..."")
    base.contains()
    print()
    print(""removing 0..."")
    base.remove(0)
    print(""contains:"")
    base.contains()
    print()",0,0,0,0,0,0,0,1,0
1578,"class LList {
	private LNode head;
	private LNode tail;
	public LList () {
		head = null;
		tail = null;
	}
	public void push (int n) {
		LNode tmp = new LNode(n, null, head);
		if (head == null) {
			tail = tmp;
		}
		else {
			head.setPrev(tmp);		
		}
		head = tmp;
	}
	public LNode pop () {
		LNode t = null;
		if (head != null) {
			t = head;
			head = head.getNext();
		}		
		return t;
	}
	public void enqueue (int n) {
		LNode tmp = new LNode(n, tail, null);
		if (tail == null) {
			head = tmp;
		}
		else {
			tail.setNext(tmp);
		}
		tail = tmp;
	}
	public LNode dequeue () {
		return pop();
	}
	public void sortedInsert(int n) {
		if (head == null) {
			push(n);
		}
		else if (n <= head.getVal()) {
			push(n);
		}
		else if (n >= tail.getVal()) {
			enqueue(n);
		}
		else {
			LNode tmp = head.getNext();
			boolean flag = true;
			while (flag) {
				if (n <= tmp.getVal()) {
					LNode insert = new LNode(n, tmp.getPrev(), tmp);
					tmp.setPrev(insert);
					tmp.getPrev().getPrev().setNext(insert);
					flag = false;
				}
				if (tmp.getNext() == null) {
					flag = false;
				}
				else {
					tmp = tmp.getNext();
				}
			}
		}
	}
	public void reverse () {
		LList newList = new LList();
		LNode tmp = head;
		while (tmp != null) {
			tmp = pop();
			newList.push(tmp.getVal());
			tmp = tmp.getNext();
		}
		head = newList.getHead();
		tail = newList.getTail();
	}
	public void delete (LNode node) {
		if (node.getPrev() == null && node.getNext() == null) {
			head = null;
			tail = null;
		}
		else if (node.getPrev() == null) {
			LNode tmp = head.getNext();
			tmp.setPrev(null);
			head = node.getNext();
		}
		else if (node.getNext() == null) {
			LNode tmp = tail.getPrev();
			tmp.setNext(null);
			tail = node.getPrev();
		}
		else {
			LNode p = node.getPrev();
			LNode n = node.getNext();
			p.setNext(n);
			n.setPrev(p);
		}
	}
	public void delete (int n) {
		LNode tmp = head;
		while (tmp != null && tmp.getVal() != n) {
			tmp = tmp.getNext();
		}
		delete(tmp);
	}
	public void deleteAt(int index) {
		LNode tmp = head;
		for (int i = 0; i < index; i ++) {
			tmp = tmp.getNext();
		}
		delete(tmp);
	}
	public void removeDuplicates () {
		LNode tmp = head;
		while (tmp != null) {
			LNode check = tmp.getNext();
			while (check != null) {
				if (tmp.getVal() == check.getVal()) {
					delete(check);
				}
				check = check.getNext();
			}
			tmp = tmp.getNext();
		}
	}
	public int size() {
		LNode tmp = head;
		int len = 0;
		while (tmp != null) {
			len ++;
			tmp = tmp.getNext();
		}
		return len;
	}
	public LList clone() {
		LList returnList = new LList();
		LNode tmp = head;
		while (tmp != null) {
			returnList.enqueue(tmp.getVal());
			tmp = tmp.getNext();
		}
		return returnList;
	}
	public LNode nodeAtIndex (int index) {
		LNode tmp = head;
		for (int i = 0; i < index; i ++) {
			tmp = tmp.getNext();
		}
		return tmp;
	}
	public void fromArray (int [] vals) {
		for (int i = 0; i < vals.length; i ++) {
			enqueue(vals[i]);
		}
	}
	public LNode getHead() {
		return head;
	}
	public LNode getTail() {
		return tail;
	}
	public String toString () {
		String ans = ""{"";
		LNode tmp = head;
		while (tmp != null) {
			ans += tmp + "", "";
			tmp = tmp.getNext();
		}
		if (ans.contains("","")) {
			ans = ans.substring(0, ans.lastIndexOf("",""));
		}
		return ans + ""}"";
	}
}",0,0,0,0,0,1,0,1,0
1579,"class Node:
    def __init__(self,data):
        self.data= data
        self.next= None
class LinkedList:
    def __init__(self):
        self.first=None
        self.last=None
    def printList(self):
        node=self.first
        print""""
        print  ""              Printing the list...""
        print""              -------------------------""
        llist=[ ]
        while node!=None:
            llist.append(node.data)
            node=node.next
        if llist :
            print ""              Linked List  :"", llist
        else:
            print ""              List is empty !! ""
    def add(self, data):
        new_node =Node(data)
        if self.first==None:     
            self.first=new_node
        if self.last !=None:
            self.last.next=new_node
        self.last= new_node
    def size(self):
        current = self.first
        count=0
        while current !=None:
            count=count+1
            current=current.next
        print ""              Size of List is : "", count
        print """"
    def search(self,item):
        current = self.first
        search_item=item
        found = False
        count =1
        while current != None and not found:
            if int(current.data) == int(search_item):
                found=True
                print ""                    SEARCH NODE FOUND AT POSITION : "",count, "" !! ""
                print """"
            else:
                current=current.next
                count = count+1
        if current==None and found==False:
            print ""                    SEARCH NODE "", search_item, "" NOT FOUND !! ""
            print""""
    def remove(self,search):
        current = self.first
        previous=None
        search_item=search
        found = False
        while not found:
            if current.data == search_item:
                found=True
            else:
                    previous=current
                    current=current.next
        if previous==None:
            self.last=current.next()
        else:
            previous.next=current.next
            print ""              Element deleted""
myList = LinkedList()
menu = {}
menu['1']=""Add Nodes"" 
menu['2']=""Search Node""
menu['3']=""Delete Node""
menu['4']=""Print List""
menu['5']=""Exit""
while True:
    options=menu.keys()
    options.sort()
    print""""
    print ""        MENU""
    print""======================""
    for entry in options: 
      print entry, menu[entry]
    print""""
    selection=raw_input(""Please Select:"")
    print""""
    print """"
    if selection =='1':
        print ""              Adding Nodes"" 
        print""              -----------------------""
        length=input(""              Enter the number of nodes you want for your Linked List  :   "")
        for counter  in range(1,length+1) :
            item=raw_input(""              Enter the Linked List elements : "")
            myList.add(item)
        myList.printList()
        myList.size( )
    elif selection == '2': 
      print ""              Finding Node""
      print ""              -----------------------""
      searchValue=input(""              Enter the Node value to be searched :  "")
      myList.search(searchValue)
    elif selection == '3':
      print ""              Deleting Node"" 
      delete=raw_input(""              Enter the Node value to be deleted:  "")
      myList.remove(delete)
      myList.printList()
      myList.size( )
    elif selection == '4':
        myList.printList()
        myList.size()
    elif selection == '5': 
      break
    else: 
      print ""Unknown Option Selected!"" ",0,0,0,0,0,1,0,1,0
1580,"__author__ = ""streethacker""
class _StackNode(object):
    def __init__(self, item, link):
        self.item = item
        self.next = link
class Stack:
    def __init__(self):
        self._top = None
        self._size = 0
    def isEmpty(self):
        return self._top is None
    def __len__(self):
        return self._size
    def peek(self):
        assert not self.isEmpty(), ""Cannot peek at an empty stack.""
        return self._top.item
    def pop(self):
        assert not self.isEmpty(), ""Cannot pop from an empty stack.""
        node = self._top
        self._top = self._top.next
        self._size -= 1
        return node.item
    def push(self, item):
        self._top = _StackNode(item, self._top)
        self._size += 1
if __name__ == ""__main__"":
    pass",0,0,0,0,0,0,0,0,0
1581,"import copy
class Node:
  def __init__(self, data):
    self.data = data
    self.next = None
  def __str__(self):
    return ""Node[]: {}"".format(self.data)
class LinkedList:
  def __init__(self, data):
    self.head = Node(data)
    self.tail = None
  def getHead(self):
    return self.head
  def setHead(self, head):
    self.head = head
  def insert(self, data):
    node = Node(data)
    head = self.head
    if head.data is None:
      head.data = data
      return
    ptr = head
    while ptr.next != None:
      ptr = ptr.next
    ptr.next = node
  def insert_at_start(self, data):
    node = Node(data)
    node.next = self.head
    self.head = node
  def insert_at_index(self, index, data):
    head = self.head
    if head.data is None:
      head.data = data
      return
    if index == 0:
      self.insert_at_start(data)
      return
    i = 0
    ptr = head
    while i + 1 != index :
      ptr = ptr.next
      if ptr == None:
        raise Exception(""Limit of Linked List Exceeded: Overflow"")
        return
      i+=1
    node = Node(data)
    temp = ptr.next
    ptr.next = node
    node.next = temp
  def display(self):
    ptr = copy.copy(self.head)
    ans = []
    while ptr:
      ans.append(str(ptr.data))
      ptr = ptr.next
    print(""->"".join(ans))
  def reverse(self):
    prev = None
    current = self.head
    while (current is not None):
      n = current.next
      current.next = prev
      prev = current
      current = n
    self.head = prev
Link = LinkedList(1)
for _ in range(2,11):
  Link.insert(_)
Link.display()
Link.reverse()
Link.display()
Link.reverse()
Link.display()",0,0,0,0,0,0,0,1,0
1582,"class Element:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.previous = None
    def Print(self, times=0):
        if type(times) is not int or times < 0:
            raise TypeError(""times must be an int larger or equal to 0."")
        output = []
        node = self
        all = 0 == times
        while node and (all or times > 0):
            output.append(node.value)
            node = node.next
            times -= 1
        print("" -> "".join(output))
    def Next(self):
        return self.next
    def Previous(self):
        return self.previous
    def First(self):
        node = self
        while node.previous:
            node = node.previous
        return node
    def Last(self):
        node = self
        while node.next:
            node = node.next
        return node
    def Nth(self, n):
        if type(n) is not int or n < 0:
            raise ValueError(""n must be an int larger or equal to 0."")
        node = self
        while node and n > 0:
            node = node.next
            n -= 1
        if not node:
            raise ValueError(""n is larger than the size of LinkedList."")
        return node
    def Append(self, item):
        node = self.Last()
        node.next = item if isinstance(item, Element) else Element(item)
        node.next.previous = node
    def Insert(self, item, index=0):
        nth = self.Nth(index)
        previous = nth.previous
        node = item if isinstance(item, Element) else Element(item)
        last = node.Last()
        last.next = nth
        nth.previous = last
        if previous:
            node.previous = previous
            previous.next = node
    def Remove(self):
        if self.next: self.next.previous = self.previous
        if self.previous: self.previous.next = self.next
    def TearDown(self):
        node = self
        if node.previous: node.previous.next = None
        while node:
            temp = node.next
            del node
            node = temp
    def BruteSearch(self, value):
        node = self
        while node:
            if node.value == value:
                return node
            node = node.next
    def GetMiddle(self, last=None):
        slow = fast = self
        while fast and fast.next and (not last or last is not fast):
            fast = fast.next
            if fast and (not last or last is not fast):
                fast = fast.next
                slow = slow.next
        return slow
    def Merge(self, left, right):
        if not left and not right:
            return None
        sorted = node = Element('temp')
        while left and right:
            if left.value < right.value:
                node.next = left
                left.previous = node
                left = left.next
            else:
                node.next = right
                right.previous = node
                right = right.next
            node = node.next
        if not left:
            node.next = right
            right.previous = node
        if not right:
            node.next = left
            left.previous = node
        sorted.next.previous = None
        return sorted.next
    def Sort(self, head=None):
        root = head if head else self.First()
        if not root or not root.next:
            return root
        mid = root.GetMiddle()
        mid.previous.next = None
        mid.previous = None
        left = mid.Sort(head=root)
        right = mid.Sort(head=mid)
        sorted = root.Merge(left, right)
        return sorted
    def BinarySearch(self, value):
        if self.value == value:
            return self
        start = self
        end = None
        while not end or start.next is not end:
            mid = start.GetMiddle(last=end)
            if mid.value == value:
                return mid
            elif mid.value < value:
                start = mid
            else:
                end = mid
        return None
def main():
    root = Element(""Hello"")
    root.Append(Element(""World""))
    root.Append(Element(""This""))
    root.Append(Element(""Is""))
    root.Append(Element(""a""))
    root.Append(Element(""Linked""))
    root.Append(Element(""List""))
    root.Append(Element(""of""))
    root.Append(Element(""Strings""))
    root.Print(0)
    nth = root.Nth(3)
    nth.Print(1)
    nth.Previous().Print(1)
    nth.Next().Print(1)
    nth.First().Print(1)
    nth.Last().Print(1)
    nth.Append(Element("".""))
    nth.Last().Print()
    nth.Insert(Element(""Definitely""))
    root.Print(0)
    secondList = Element(""Second"")
    secondList.Append(Element(""List""))
    nth.Insert(secondList.Last())
    root.Print(0)
    nth.Remove()
    del nth
    root.Print(0)
    found = root.BruteSearch(""of"")
    found.Print(1)
    found = root.BinarySearch(""List"")
    if found:
        found.Print(1)
    root = root.Sort()
    root.Print(0)
    found = root.BinarySearch(""List"")
    found.Print(1)
    found.TearDown()
    root.Print(0)
    root.TearDown()
    del root
if __name__ == ""__main__"":
    main()",0,1,0,0,0,1,1,1,0
1583,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.head = None
    def max_sum_list(self, l2):
        pre1 = cur1 = self.head
        pre2 = cur2 = l2.head
        result = None
        while cur1 or cur2 is not None:
            sum1 = sum2 = 0
            while cur1 and cur2 is not None and cur1.data != cur2.data:
                if cur1.data < cur2.data:
                    sum1 += cur1.data
                    cur1 = cur1.next
                else:
                    sum2 += cur2.data
                    cur2 = cur2.next
            if cur1 is None:
                while cur2 is not None:
                    sum2 += cur2.data
                    cur2 = cur2.next
            elif cur2 is None:
                while cur1 is not None:
                    sum1 += cur1.data
                    cur1 = cur1.next
            if pre1 is self.head and pre2 is l2.head:
                result = pre1 if sum1 > sum2 else pre2
            else:
                if sum1 > sum2:
                    pre2.next = pre1.next
                else:
                    pre1.next = pre2.next
            pre1 = cur1
            pre2 = cur2
            if cur1 is not None:
                cur1 = cur1.next
            if cur2 is not None:
                cur2 = cur2.next
        return result
    def insert_at_beg(self, data):
        node = Node(data)
        node.next = self.head
        self.head = node
    def print_data(self):
        current = self.head
        while current is not None:
            print(current.data, '-> ', end='')
            current = current.next
        print('None')
if __name__ == '__main__':
    linked_list1 = SinglyLinkedList()
    linked_list1.insert_at_beg(130)
    linked_list1.insert_at_beg(120)
    linked_list1.insert_at_beg(100)
    linked_list1.insert_at_beg(90)
    linked_list1.insert_at_beg(32)
    linked_list1.insert_at_beg(12)
    linked_list1.insert_at_beg(3)
    linked_list1.insert_at_beg(0)
    linked_list2 = SinglyLinkedList()
    linked_list2.insert_at_beg(120)
    linked_list2.insert_at_beg(110)
    linked_list2.insert_at_beg(90)
    linked_list2.insert_at_beg(30)
    linked_list2.insert_at_beg(3)
    linked_list2.insert_at_beg(1)
    print('List 1:')
    linked_list1.print_data()
    print('List 2:')
    linked_list2.print_data()
    linked_list1.head = linked_list1.max_sum_list(linked_list2)
    print('Max sum linked list:')
    linked_list1.print_data()",0,0,0,0,0,0,0,0,0
1584,"import math
class Node():
    def __init__(self):
        self.arr = []
        self.next = None
class UnrolledLinkedList():
    def __init__(self, max_node_capacity=16):
        self.max_node_capacity = max_node_capacity
        self.length = 0
        self.head = None
        self.tail = None
    '''Remove the item at the given index.
    If the index is negative, then you should remove starting from the back 
    (i.e. deleting at -2 would delete the second-to-last element)
    If the index is too large, raise an IndexError'''
    def __delitem__(self,index):
        if index < 0:
            absIndex = self.length + index
        else:
            absIndex = index
        if index > self.length - 1: 
            raise IndexError(str(index) + ' out of range.')
        elif absIndex < 0: 
            raise IndexError(str(index) + 'out of range.')
        currentNode = self.head
        currentIndex = 0
        while len(currentNode.arr) - 1 + currentIndex < absIndex:
            currentIndex = currentIndex + len(currentNode.arr)
            currentNode = currentNode.next
        arrIndex = absIndex - currentIndex 
        del currentNode.arr[arrIndex] 
        self.length = self.length - 1
        nextNode = currentNode.next
        while nextNode:
            if len(currentNode.arr) < self.max_node_capacity//2 and nextNode is not None:
                numberToTransfer = self.max_node_capacity//2 - len(currentNode.arr) + 1
                currentNode.arr = currentNode.arr + nextNode.arr[:numberToTransfer]
                nextNode.arr = nextNode.arr[numberToTransfer:]
                if len(nextNode.arr) < self.max_node_capacity//2:
                    currentNode.arr = currentNode.arr + nextNode.arr
                    currentNode.next = nextNode.next
                    del nextNode
            currentNode = currentNode.next
            if(currentNode):
                nextNode = currentNode.next
            else:
                nextNode = None       
    """"""Returns the item in the given index.
    If the index is negative, return with the index starting from the back 
    (i.e. getting at -1 returns the last item)
    If the index is too large, raise an IndexError""""""
    def __getitem__ (self,index):
        if index < 0:
            absIndex = self.length + index
        else:
            absIndex = index
        if index > self.length - 1: 
            raise IndexError(str(index) + ' out of range.')
        elif absIndex < 0: 
            raise IndexError(str(index) + 'out of range.')
        currentNode = self.head
        currentIndex = 0
        while len(currentNode.arr) - 1 + currentIndex < absIndex:
            currentIndex = currentIndex + len(currentNode.arr)
            currentNode = currentNode.next
        arrIndex = absIndex - currentIndex 
        return currentNode.arr[arrIndex] 
    '''Sets the item at key to value
    If the key is too large, raise an IndexError'''
    def __setitem__ (self,key,value):
        index = key
        if index < 0:
            absIndex = self.length + index
        else:
            absIndex = index
        if index > self.length - 1: 
            raise IndexError(str(index) + ' out of range.')
        elif absIndex < 0: 
            raise IndexError(str(index) + 'out of range.')
        currentNode = self.head
        currentIndex = 0
        while len(currentNode.arr) - 1 + currentIndex < absIndex:
            currentIndex = currentIndex + len(currentNode.arr)
            currentNode = currentNode.next
        arrIndex = absIndex - currentIndex 
        currentNode.arr[arrIndex] = value
    '''Use the Python yield statement to make your list iterable. 
    This will allow you to use it in a for-each loop'''
    def __iter__ (self):
        current = self.head
        while current is not None:
            for x in current.arr:
                yield x
            current = current.next
    '''Create a string representation of the list in the form 
    {[x, x, x], [x, x], [x, x, x, x]} where each set of [] indicates
    the list of values within a single node.'''
    def __str__ (self):
        if self.length == 0:
            return '{}'
        result = '{'
        current = self.head
        while current is not None:
            result = result + '['
            for i in range(0, len(current.arr)):
                result = result + str(current.arr[i])
                if i + 1 < len(current.arr):
                    result = result + ', '
            result = result + ']'
            if current.next is not None:
                result = result + ', '
            current = current.next
        result = result + '}'
        return result
    '''returns the total # of data in the list, not the 
    number of nodes'''
    def __len__ (self):
        return self.length
    '''Reverses the list. Does not return a new list - 
    actually mutates the data structure'''
    def __reversed__ (self):
        newL = UnrolledLinkedList(self.max_node_capacity)
        i = self.length - 1
        while i >= 0:
            yield self[i]
            i = i - 1
    '''Returns True if obj is in the data structure, 
    otherwise False'''
    def __contains__ (self, obj):
        for i in self:
            if i == obj:
                return True
        return False
    '''Add the data to the end of the list
    If a node has reached its max capacity, 
    you must create a new node to put the data in'''
    def append(self,data):
        if self.head is None:
            self.head = Node()
            self.head.arr.append(data)
            self.tail = self.head
        elif(len(self.tail.arr) < self.max_node_capacity):
            self.tail.arr.append(data)
        else:
            newNode = Node()
            middle = len(self.tail.arr)//2
            newNode.arr = self.tail.arr[middle*-1:]
            self.tail.arr = self.tail.arr[:middle*-1]
            self.tail.next = newNode
            self.tail = newNode
            self.tail.arr.append(data)
        self.length = self.length + 1",0,0,0,0,0,1,0,1,0
1585,"from DS.LinkedList.DoublyLinkedBase import _DoublyLinkedBase
class PositionalList(_DoublyLinkedBase):
    class Position:
        def __init__(self, container, node):
            self._container = container
            self._node = node
        def element(self):
            return self._node._element
        def __eq__(self, other):
            return type(other) is type(self) and other._node is self._node
        def __ne__(self, other):
            return not(self == other)
    def _validate(self, p):
        if not isinstance(p, self.Position):
            return TypeError('p must be proper Position type')
        if p._conatainer is not self:
            raise ValueError('p does not belong to this container')
        if p._node._next is None:   
            raise ValueError('p is no longer valid')
        return p._node
    def _make_position(self, node):
        if node is self._header or node is self._trailer:
            return None                         
        else:
            return self.Position(self, node)    
    def first(self):
        return self._make_position(self._header._next)
    def last(self):
        return self._make_position(self._trailer._prev)
    def before(self, p):
        node = self._validate(p)
        return self._make_position(node._prev)
    def after(self, p):
        node = self._validate(p)
        return self._make_position(node._next)
    def __iter__(self):
        cursor = self.first()
        while cursor is not None:
            yield cursor._element()
            cursor = self.after(cursor)
    def _insert_between(self, e, predecessor, successor):
        node = super()._insert_between(e,predecessor,successor)
        return self._make_position(node)
    def add_first(self, e):
        return self._insert_between(e, self._header, self._header._next)
    def add_last(self, e):
        return self._insert_between(e, self._trailer._prev, self._trailer)
    def add_before(self, p, e):
        original = self._validate(p)
        return self._insert_between(e,original._prev,original)
    def add_after(self, p, e):
        original = self._validate(p)
        return self._insert_between(e,original, original._next)
    def delete(self, p):
        original = self._validate(p)
        return self._delete_node(original)      
    def replace(self, p, e):
        original = self._validate(p)
        old_value = original._element
        original._element = e
        return old_value",0,0,0,0,0,0,0,0,0
1586,"class Node:
	def __init__(self, data=None):
		self.data = data
  self.next = None
class Queue:
	def __init__(self):
		self.front = self.rear = None
 def enqueue(self, data):
		node = Node(data)
  if self.isEmpty():
			self.front = self.rear = node
  else:
			self.rear.next = node
   self.rear = self.rear.next
 def dequeue(self):
		if self.isEmpty():
			return ""Queue empty""
  else:
			temp = self.front
   self.front = self.front.next
   return temp.data
 def isEmpty(self):
		if self.front == None and self.rear == None:
			return True
  else:
			return False
 def frontQ(self):
		if self.isEmpty():
			return ""Queue empty""
  else:
			return self.front.data
 def print(self):
		while(self.front != None):
			print(self.front.data)
   self.front = self.front.next",0,0,0,0,0,0,0,1,0
1587,"class Node:
    def __init__(self,value=None):
        self.value = value
        self.next = None
class Queue:
    def __init__(self):
        self.first = None
        self.last = None
        self.length = 0
    def peek(self):
        return self.first
    def enqueue(self,value):
        cuurentNode = Node(value=value)
        if(self.length == 0):
            self.last = cuurentNode
            self.first = cuurentNode
        else:
            self.last.next = cuurentNode
            self.last = cuurentNode
        self.length = self.length + 1
    def dequeue(self):
        self.first = self.first .next
        self.length = self.length -1
    def printList(self):
        currentNode = self.first
        while(currentNode != None):
            print(currentNode.value)
            currentNode = currentNode.next
myQueue = Queue()
myQueue.enqueue(10)
myQueue.enqueue(123)
myQueue.enqueue(12312313)
myQueue.enqueue(123123131231)
myQueue.printList()
myQueue.dequeue()
myQueue.printList()",0,0,0,0,0,0,0,1,0
1588,"class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
    def as_string(self):
        out = []
        n = self
        while n:
            out.append(str(n.data))
            n = n.next
        return ''.join(out)
def reverse_linked_list(head):
    prev = None
    curr = head
    while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    return prev
if __name__ == '__main__':
    import doctest
    results = doctest.testmod()
    if results.failed == 0:
        print ""ALL TESTS PASSED!""",0,0,0,0,0,0,0,0,0
1589,,0,0,0,0,0,0,0,0,0
1590,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.head = None
    def reverse(self):
        if self.head is None:
            return None
        current = self.head
        prev = None
        while current is not None:
            next = current.next
            current.next = prev
            prev = current
            current = next
        self.head = prev
    def insert_at_beg(self, data):
        node = Node(data)
        node.next = self.head
        self.head = node
    def print_data(self):
        current = self.head
        while current is not None:
            print(current.data, '-> ', end='')
            current = current.next
        print('None')
if __name__ == '__main__':
    linked_list = SinglyLinkedList()
    linked_list.insert_at_beg(7)
    linked_list.insert_at_beg(6)
    linked_list.insert_at_beg(5)
    linked_list.insert_at_beg(4)
    linked_list.insert_at_beg(3)
    linked_list.insert_at_beg(2)
    linked_list.insert_at_beg(1)
    linked_list.print_data()
    linked_list.reverse()
    linked_list.print_data()",0,0,0,0,0,0,0,0,0
1591,"class Node(object):
    def __init__(self, data):
        self.data = data
        self.next = None
class Linkedlist(object):
    def __init__(self):
        self.head = None
        self.length = 0
    def is_empty(self):
        return self.length == 0
    def append(self, data):
        node = Node(data)
        if self.head is None:
            self.head = node
        else:
            tmp_node = self.head
            while tmp_node.next:
                tmp_node = tmp_node.next
            tmp_node.next = node
        self.length += 1
    def insert(self, data, index):
        if type(index) is int:
            if index > self.length:
                print('index out of range')
            else:
                insert_node = Node(data)
                current_node = self.head
                if index == 0:
                    insert_node.next = current_node
                    self.head = insert_node
                else:
                    while index - 1 > 0:
                        current_node = current_node.next
                        index -= 1
                    insert_node.next = current_node.next
                    current_node.next = insert_node
                self.length += 1
        else:
            print('index not int')
    def reverse(self):
        if not self.head or not self.head.next:
            return self.head
        cur = self.head
        pre = None
        nex = None
        while cur:
            nex = cur.next
            cur.next = pre
            pre = cur
            cur = nex
        self.head = pre
    def delete(self, index):
        if type(index) is int:
            if index < self.length:
                if index == 0:
                    self.head = self.head.next
                else:
                    cur = self.head
                    while index - 1 > 0:
                        cur = cur.next
                        index -= 1
                    cur.next = cur.next.next  
                self.length -= 1
            else:
                print(""index out of range"")
        else:
            print(""index not int"")
    def swap_pair(self, index):
        if type(index) is not int:
            print('index not int')
            return
        if index < self.length - 1:
            if index == 0:
                node1 = self.head
                node2 = self.head.next
                self.head = node2
                node1.next = node2.next
                node2.next = node1
            else:
                cur = self.head
                while index - 1 > 0:
                    cur = cur.next
                    index -= 1
                node1 = cur.next
                node2 = node1.next
                late = node2.next
                cur.next = node2
                node2.next = node1
                node1.next = late
        else:
            print('index out of range')
    def clear(self):
        self.head = None
        self.length = 0
    def show(self):
        if self.length == 0:
            print(""Linkedlist's is None"")
        else:
            tmp = self.head  
            while tmp:
                print(tmp.data, end=' ')
                tmp = tmp.next
            print('\n')
if __name__ == ""__main__"":
    l = Linkedlist()
    l.append(2)
    l.append(3)
    l.append(5)
    l.append(8)
    l.insert(4, 2)
    l.insert(1, 0)
    l.show()
    l.reverse()
    l.show()
    l.delete(4)
    l.show()
    l.swap_pair(0)
    l.show()
    l.clear()
    l.show()",0,0,0,0,0,0,0,1,0
1592,"class EmptyLinkedList(Exception):
	pass
class SingleLinkedList:
	class _Node:
		__slots__ = '_element', '_next'               
  def __init__(self, element=None, next=None):    
			self._element = element                     
   self._next = next                           
 def __init__(self):
		self._head = self._tail = None
  self._size = 0
 def __len__(self):
		return self._size        
 def isEmpty(self):
		return self._size==0  
 def addFirst(self, element):   
		if self._head==None:
			n=self._Node(element,None)
   self._tail=n
  else:
			n=self._Node(element,self._head)
  self._head=n
  self._size+=1
 def addLast(self, element):    
		n=self._Node(element, None)
  if self._tail!=None:
			self._tail._next=n
  else:
			self._head=n
  self._tail=n
  self._size+=1
 def removeFirst(self):  
		if self.isEmpty():
			raise EmptyLinkedList()
  e=self._head._element
  if self._head==self._tail: 
			self._head=self._tail=None
  else:
			self._head=self._head._next
  self._size-=1
  return e
 def removeLast(self):   
		if self.isEmpty():
			raise EmptyLinkedList()
  e=self._tail._element
  if self._head==self._tail:
			self._head=self._tail=None
  else:
			temp=self._head
   while temp._next!=self._tail:
				temp=temp._next
   self._tail=temp
   self._tail._next=None
  self._size-=1
  return e
 def makeEmpty(self):
		self._head = self._tail = None
  self._size = 0
 def getContent(self):
		l=[]
  n=self._head
  while n!= None:
			l.append(n._element)
   n=n._next
  return l",0,0,0,0,0,0,0,1,0
1593,"class EmptyLinkedList(Exception):
	pass
class SingleLinkedList:
	class _Node:
		__slots__ = '_element', '_next'               
  def __init__(self, element=None, next=None):    
			self._element = element                     
   self._next = next                           
 def __init__(self):
		self._head = self._tail = self._Node()
  self._size = 0
 def __len__(self):
		return self._size        
 def isEmpty(self):
		return self._size==0  
 def addFirst(self, element):   
		self._head._element=element
  self._head=self._Node(None,self._head)
  self._size+=1
 def addLast(self, element):    
		self._tail._next=self._Node(element,None)
  self._tail=self._tail._next
  self._size+=1
 def removeFirst(self):  
		if self.isEmpty():
			raise EmptyLinkedList()
  e=self._head._next._element
  self._head=self._head._next
  self._head._element=None
  self._size-=1
  return e
 def removeLast(self):   
		if self.isEmpty():
			raise EmptyLinkedList()
  e=self._tail._element
  n=self._head
  while n._next!=self._tail:
			n=n._next
  self._tail=n
  self._tail._next=None
  self._size-=1
  return e
 def makeEmpty(self):
		self._head = self._tail = self._Node()
  self._size = 0
 def getContent(self):
		l=[]
  n=self._head
  while n._next!= None:
			n=n._next
   l.append(n._element)
  return l",0,0,0,0,0,0,0,1,0
1594,"class LinkedListNode(object):
    def __init__(self,value):
        self.value = value
        self.nextnode = None
a = LinkedListNode(1)
b = LinkedListNode(2)
c = LinkedListNode(3)        
a.nextnode = b
b.nextnode = c
print (a.value)
print (b.value)
print (c.value)
print (a.nextnode.value)",0,0,0,0,0,0,0,0,0
1595,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.tail = None
        self.head = None
        self.count = 0
    def append(self, data):
        node = Node(data)
        if self.head:
            self.head.next = node
            self.head = node
        else:
            self.tail = node
            self.head = node
        self.count += 1
    def iter(self):
        current = self.tail
        while current:
            val = current.data
            current = current.next
            yield val
    def delete(self, data):
        current = self.tail
        prev = self.tail
        while current:
            if current.data == data:
                if current == self.tail:
                    self.tail = current.next
                else:
                    prev.next = current.next
                self.count -= 1
                return
            prev = current
            current = current.next
    def search(self, data):
        for node in self.iter():
            if data == node:
                return True
        return False
    def __getitem__(self, index):
        if index > self.count - 1:
            raise Exception(""Index out of range."")
        current = self.tail
        for n in range(index):
            current = current.next
        return current.data
    def __setitem__(self, index, value):
        if index > self.count - 1:
            raise Exception(""Index out of range."")
        current = self.tail
        for n in range(index):
            current = current.next
        current.data = value",0,0,0,0,0,1,0,1,0
1596,"class Node:
    def __init__(self, data=None, next=None):
        self.data = data
        self.next = next
class LinkedList:
    def __init__(self):
        self.head = None
    def print(self):
        if self.head is None:
            print(""Linked list is empty"")
            return
        itr = self.head
        llstr = ''
        while itr:
            llstr += str(itr.data) + ' --> '
            itr = itr.next
        print(llstr)
    def get_length(self):
        count = 0
        itr = self.head
        while itr:
            count+=1
            itr = itr.next
        return count
    def insert_at_begining(self, data):
        node = Node(data, self.head)
        self.head = node
    def insert_at_end(self, data):
        if self.head is None:
            self.head = Node(data, None)
            return
        itr = self.head
        while itr.next:
            itr = itr.next
        itr.next = Node(data, None)
    def insert_at(self, index, data):
        if index<0 or index>self.get_length():
            raise Exception(""Invalid Index"")
        if index==0:
            self.insert_at_begining(data)
            return
        count = 0
        itr = self.head
        while itr:
            if count == index - 1:
                node = Node(data, itr.next)
                itr.next = node
                break
            itr = itr.next
            count += 1
    def remove_at(self, index):
        if index<0 or index>=self.get_length():
            raise Exception(""Invalid Index"")
        if index==0:
            self.head = self.head.next
            return
        count = 0
        itr = self.head
        while itr:
            if count == index - 1:
                itr.next = itr.next.next
                break
            itr = itr.next
            count+=1
    def insert_values(self, data_list):
        self.head = None
        for data in data_list:
            self.insert_at_end(data)
    def insert_after_value(self, data_after, data_to_insert):
        if self.head is None:
            return
        if self.head.data==data_after:
            self.head.next = Node(data_to_insert,self.head.next)
            return
        itr = self.head
        while itr:
            if itr.data == data_after:
                itr.next = Node(data_to_insert, itr.next)
                break
            itr = itr.next
    def remove_by_value(self, data):
        if self.head is None:
            return
        if self.head.data == data:
            self.head = self.head.next
            return
        itr = self.head
        while itr.next:
            if itr.next.data == data:
                itr.next = itr.next.next
                break
            itr = itr.next
if __name__ == '__main__':
    ll = LinkedList()
    ll.insert_values([""banana"",""mango"",""grapes"",""orange""])
    ll.print()
    ll.insert_after_value(""mango"",""apple"")
    ll.print()
    ll.remove_by_value(""orange"")
    ll.print()
    ll.remove_by_value(""figs"")
    ll.print()
    ll.remove_by_value(""banana"")
    ll.remove_by_value(""mango"")
    ll.remove_by_value(""apple"")
    ll.remove_by_value(""grapes"")
    ll.print()",0,0,0,0,0,0,0,1,0
1597,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.tail = None
        self.head = None
        self.count = 0
    def append(self, data):
        node = Node(data)
        if self.head:
            self.head.next = node
            self.head = node
        else:
            self.tail = node
            self.head = node
        self.count += 1
    def iter(self):
        current = self.tail
        while current:
            val = current.data
            current = current.next
            yield val
    def delete(self, data):
        current = self.tail
        prev = self.tail
        while current:
            if current.data == data:
                if current == self.tail:
                    self.tail = current.next
                else:
                    prev.next = current.next
                self.count -= 1
                return
            prev = current
            current = current.next
    def search(self, data):
        for node in self.iter():
            if data == node:
                return True
        return False
    def __getitem__(self, index):
        if index > self.count - 1:
            raise Exception(""Index out of range."")
        current = self.tail
        for n in range(index):
            current = current.next
        return current.data
    def __setitem__(self, index, value):
        if index > self.count - 1:
            raise Exception(""Index out of range."")
        current = self.tail
        for n in range(index):
            current = current.next
        current.data = value",0,0,0,0,0,1,0,1,0
1598,"class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
    def __str__(self):
        return '{}'.format(self.data)
    def __repr__(self):
        return self.__str__()
class AscLinkedList(object):
    def __init__(self):
        self.head = None
    def add(self, data):
        node = self.head
        r = Node(data)
        if self.isEmpty() or self.head.data > data:
            self.head = r
            self.head.next = node
        else:
            while node:
                if node.data <= data and (node.next is None or node.next.data > data):
                    r.next = node.next
                    node.next = r
                    break
                node = node.next
    def reverse(self):
        node = self.head
        r = None
        while node:
            s = r
            r = node
            node = node.next
            r.next = s
        self.head = r
    def count(self):
        count = 0
        node = self.head
        while node:
            node = node.next
            count += 1
        print(""\nNo of element in the Linked list {}"".format(count))
    def delete(self, data):
        node = self.head
        old = None
        while node.next:
            if node.data == data:
                if node == self.head:
                    self.head = node.next
                else:
                    old.next = node.next
                return
            else:
                old = node
                node = node.next
        print(""\nElement {} not found"".format(data))
    def isEmpty(self):
        return not self.head
    def display(self):
        node = self.head
        print(""\nDisplay Nodes: "")
        while node:
            print(node.data, end="" "")
            node = node.next
if __name__ == '__main__':
    lk = AscLinkedList()
    lk.add(5)
    lk.add(1)
    lk.add(6)
    lk.add(4)
    lk.add(7)
    lk.display()
    lk.count()
    lk.reverse()
    lk.display()",0,0,0,0,0,1,0,1,0
1599,"class Node(object):
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
    def __str__(self):
        return '{}'.format(self.data)
    def __repr__(self):
        return self.__str__()
class LinkedList(object):
    def __init__(self):
        self.head = None
        self.size = 0
    def append(self, data):
        if self.isEmpty():
            node = Node(data)
            self.head = node
        else:
            node = self.head
            while node.next:
                node = node.next
            new_node = Node(data)
            node.next = new_node
    def appendRight(self, data):
        node = Node(data)
        node.next = self.head
        self.head = node
    def appendAfter(self, pos, data):
        tmp = self.head
        for i in range(pos):
            tmp = tmp.next
            if tmp is None:
                print(""There are less than {} elements in list."".format(pos))
                break
        node = Node(data)
        node.next = tmp.next
        tmp.next = node
    def count(self):
        count = 0
        node = self.head
        while node:
            node = node.next
            count += 1
        print(""\nNo of element in the Linked list {}"".format(count))
    def delete(self, data):
        node = self.head
        old = None
        while node.next:
            if node.data == data:
                if node == self.head:
                    self.head = node.next
                else:
                    old.next = node.next
                return
            else:
                old = node
                node = node.next
        print(""\nElement {} not found"".format(data))
    def isEmpty(self):
        return not self.head
    def display(self):
        node = self.head
        print(""\nDisplay Nodes: "")
        while node:
            print(node.data, end="" "")
            node = node.next
if __name__ == '__main__':
    lk = LinkedList()
    lk.append(14)
    lk.append(30)
    lk.append(25)
    lk.append(42)
    lk.append(17)
    lk.display()
    lk.appendRight(999)
    lk.appendRight(888)
    lk.appendRight(777)
    lk.display()
    lk.appendAfter(7, 0)
    lk.appendAfter(2, 1)
    lk.appendAfter(5, 99)
    lk.display()
    lk.count()
    lk.delete(99)
    lk.delete(1)
    lk.delete(10)
    lk.display()
    lk.display()
    lk.count()",0,0,0,0,0,1,0,1,0
1600,,0,0,0,0,0,0,0,0,0
1601,"public class SinglyLinkedList<T> implements LinkedListInterface<T> {
    private LinkedListNode<T> head;
    private LinkedListNode<T> tail;
    private int size;
    @Override
    public void addAtIndex(int index, T data)
            throws IllegalArgumentException, IndexOutOfBoundsException {
        if (index < 0 || index > this.size) {
            throw new IndexOutOfBoundsException(""Index can't be negative""
                    + "" or greater than the size of the Linked List."");
        } else if (data == null) {
            throw new IllegalArgumentException(""Data stored in node cannot""
                    + "" be null"");
        }
        LinkedListNode<T> node = head;
        LinkedListNode<T> temp = new LinkedListNode<T>(data);
        if (index == 0) {
            this.addToFront(data);
        } else if (index == this.size) {
            this.addToBack(data);
        } else {
            while (--index > 0) {
                node = node.getNext();
            }
            temp.setNext(node.getNext());
            node.setNext(temp);
            size++;
        }
    }
    @Override
    public T get(int index) throws IndexOutOfBoundsException {
        if (index < 0 || index >= this.size) {
            throw new IndexOutOfBoundsException(""Index can't be negative ""
                    + ""or greater than/equal to size of linked list"");
        }
        LinkedListNode<T> node = head;
        if (index == 0) {
            return this.head.getData();
        } else if (index == this.size - 1) {
            return this.tail.getData();
        } else {
            while (index > 0) {
                index--;
                node = node.getNext();
            }
            return node.getData();
        }
    }
    @Override
    public T removeAtIndex(int index) throws IndexOutOfBoundsException {
        if (index < 0 || index >= this.size) {
            throw new IndexOutOfBoundsException(""Index can't be negative ""
                    + ""or greater than/equal to size of linked list"");
        }
        LinkedListNode<T> node = head;
        LinkedListNode<T> pre = null;
        T answer;
        if (index == 0) {
            answer = this.removeFromFront();
        } else if (index == this.size - 1) {
            answer = this.removeFromBack();
        } else {
            for (int i = 0; i < index; i++) {
                pre = node;
                node = node.getNext();
            }
            if (pre != null) {
                pre.setNext(node.getNext());
            } else {
                head = head.getNext();
            }
            answer = node.getData();
            size--;
        }
        return answer;
    }
    @Override
    public void addToFront(T data) throws IllegalArgumentException {
        if (data == null) {
            throw new IllegalArgumentException(""Node data cannot be null"");
        }
        this.head = new LinkedListNode<T>(data, this.head);
        if (this.size == 0) {
            tail = head;
        }
        this.size++;
    }
    @Override
    public void addToBack(T data) throws IllegalArgumentException {
        if (data == null) {
            throw new IllegalArgumentException(""Node data cannot be null"");
        }
        LinkedListNode<T> node = new LinkedListNode<T>(data, null);
        if (head == null) {
            this.head = node;
        } else {
            this.tail.setNext(node);
        }
        this.tail = node;
        this.size++;
    }
    @Override
    public T removeFromFront() {
        if (head == null) {
            return null;
        }
        T answer = this.head.getData();
        this.head = this.head.getNext();
        this.size--;
        if (this.size == 0) {
            this.tail = null;
        }
        return answer;
    }
    @Override
    public T removeFromBack() {
        LinkedListNode<T> node = head;
        LinkedListNode<T> pre = null;
        if (head == null) {
            return null;
        }
        while (node.getNext() != null) {
            pre = node;
            node = node.getNext();
        }
        T answer = this.tail.getData();
        if (pre != null) {
            pre.setNext(null);
        } else {
            head = null;
        }
        this.tail = pre;
        size--;
        if (this.size == 0) {
            this.tail = null;
        }
        return answer;
    }
    @Override
    public boolean removeAllOccurrences(T data)
            throws IllegalArgumentException {
        boolean answer = false;
        LinkedListNode<T> node = head;
        if (data == null) {
            throw new IllegalArgumentException(""Data cannot be null"");
        } else {
            int index = 0;
            while (node != null) {
                if (node.getData().equals(data)) {
                    this.removeAtIndex(index);
                    answer = true;
                } else {
                    index++;
                }
                node = node.getNext();
            }
        }
        return answer;
    }
    @Override
    public Object[] toArray() {
        LinkedListNode<T> node = head;
        Object[] arr = new Object[this.size];
        for (int i = 0; i < this.size; i++) {
            arr[i] = node.getData();
            node = node.getNext();
        }
        return arr;
    }
    @Override
    public boolean isEmpty() {
        return (this.size == 0);
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public void clear() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    @Override
    public LinkedListNode<T> getHead() {
        return head;
    }
    @Override
    public LinkedListNode<T> getTail() {
        return tail;
    }
}",0,0,0,0,0,0,0,1,0
1602,"class Node(object):
    def __init__(self, data, next = None):
        self.data = data;
        self.next = next;
    def setData(self, data):
        self.data = data;
    def getData(self):
        return self.data
    def setNext(self, next):
        self.next = next
    def getNext(self):
        return self.next
class LinkedList(object):
    def __init__(self):
        self.head = None
    def printLinkedList(self):
        temp = self.head
        while(temp):
            print(temp.data, end=' ')
            temp = temp.next
    def insertAtStart(self, data):
        if self.head == None:
            newNode = Node(data)
            self.head = newNode
        else:
            newNode = Node(data)
            newNode.next = self.head
            self.head = newNode
    def insertBetween(self, previousNode, data):
        if (previousNode.next is None):
            print('Previous node should have next node!')
        else:
            newNode = Node(data)
            newNode.next = previousNode.next
            previousNode.next = newNode
    def insertAtEnd(self, data):
        newNode = Node(data)
        temp = self.head
        while(temp.next != None):         
            temp = temp.next
        temp.next = newNode
    def delete(self, data):
        temp = self.head
        if (temp.next is not None):
            if(temp.data == data):
                self.head = temp.next
                temp = None
                return
            else:
                while(temp.next != None):
                    if(temp.data == data):
                        break
                    prev = temp          
                    temp = temp.next
                if temp == None:
                    return
                prev.next = temp.next
                return
    def search(self, node, data):
        if node == None:
            return False
        if node.data == data:
            return True
        return self.search(node.getNext(), data)
if __name__ == '__main__':
    List = LinkedList()
    List.head = Node(1)                
    node2 = Node(2)
    List.head.setNext(node2)           
    node3 = Node(3)
    node2.setNext(node3)               
    List.insertAtStart(4)              
    List.insertBetween(node2, 5)       
    List.insertAtEnd(6)
    List.printLinkedList()
    print()
    List.delete(3)
    List.printLinkedList()
    print()
    print(List.search(List.head, 1))",0,0,0,0,0,1,0,1,0
1603,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.head = None
    def size(self):
        current = self.head
        size = 0
        while current is not None:
            size += 1
            current = current.next
        return size
    def insert_at_end(self, data):
        node = Node(data)
        if self.head is None:
            self.head = node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = node
    def insert_at_beg(self, data):
        node = Node(data)
        node.next = self.head
        self.head = node
    def delete_from_end(self):
        current = self.head
        previous = None
        if current is None:
            print(""Linked List Underflow!!"")
        else:
            while current.next is not None:
                previous = current
                current = current.next
            if previous is None:
                self.head = None
            else:
                previous.next = None
    def delete_from_beg(self):
        current = self.head
        if current is None:
            print(""Linked List Underflow!!"")
        else:
            self.head = current.next
    def print_data(self):
        current = self.head
        while current is not None:
            print(current.data, '->', end='')
            current = current.next
        print('End of list')
if __name__ == '__main__':
    linked_list = SinglyLinkedList()
    linked_list.insert_at_beg(3)
    linked_list.insert_at_beg(2)
    linked_list.insert_at_beg(1)
    print('After insertion at the beginning:')
    linked_list.print_data()
    linked_list.insert_at_end(4)
    linked_list.insert_at_end(5)
    print('After insertion at the end:')
    linked_list.print_data()
    print('After deletion at the beginning:')
    linked_list.delete_from_beg()
    linked_list.print_data()
    print('After deletion at the end:')
    linked_list.delete_from_end()
    linked_list.print_data()
    print(""size: "", linked_list.size())",0,0,0,0,0,0,0,1,0
1604,"class Node(object):
    def __init__(self, data, next = None):
        self.data = data;
        self.next = next;
    def setData(self, data):
        self.data = data;
    def getData(self):
        return self.data
    def setNext(self, next):
        self.next = next
    def getNext(self):
        return self.next
class LinkedList(object):
    def __init__(self):
        self.head = None
    def printLinkedList(self):
        temp = self.head
        while(temp):
            print(temp.data, end=' ')
            temp = temp.next
    def insertAtStart(self, data):
        if self.head == None:
            newNode = Node(data)
            self.head = newNode
        else:
            newNode = Node(data)
            newNode.next = self.head
            self.head = newNode
    def insertBetween(self, previousNode, data):
        if (previousNode.next is None):
            print('Previous node should have next node!')
        else:
            newNode = Node(data)
            newNode.next = previousNode.next
            previousNode.next = newNode
    def insertAtEnd(self, data):
        newNode = Node(data)
        temp = self.head
        while(temp.next != None):         
            temp = temp.next
        temp.next = newNode
    def delete(self, data):
        temp = self.head
        if (temp.next is not None):
            if(temp.data == data):
                self.head = temp.next
                temp = None
                return
            else:
                while(temp.next != None):
                    if(temp.data == data):
                        break
                    prev = temp          
                    temp = temp.next
                if temp == None:
                    return
                prev.next = temp.next
                return
    def search(self, node, data):
        if node == None:
            return False
        if node.data == data:
            return True
        return self.search(node.getNext(), data)
if __name__ == '__main__':
    List = LinkedList()
    List.head = Node(1)                
    node2 = Node(2)
    List.head.setNext(node2)           
    node3 = Node(3)
    node2.setNext(node3)               
    List.insertAtStart(4)              
    List.insertBetween(node2, 5)       
    List.insertAtEnd(6)
    List.printLinkedList()
    print()
    List.delete(3)
    List.printLinkedList()
    print()
    print(List.search(List.head, 1))",0,0,0,0,0,1,0,1,0
1605,"class Node(object):
    def __init__(self, data, next = None):
        self.data = data;
        self.next = next;
    def setData(self, data):
        self.data = data;
    def getData(self):
        return self.data
    def setNext(self, next):
        self.next = next
    def getNext(self):
        return self.next
class LinkedList(object):
    def __init__(self):
        self.head = None
    def printLinkedList(self):
        temp = self.head
        while(temp):
            print(temp.data, end=' ')
            temp = temp.next
    def insertAtStart(self, data):
        if self.head == None:
            newNode = Node(data)
            self.head = newNode
        else:
            newNode = Node(data)
            newNode.next = self.head
            self.head = newNode
    def insertBetween(self, previousNode, data):
        if (previousNode.next is None):
            print('Previous node should have next node!')
        else:
            newNode = Node(data)
            newNode.next = previousNode.next
            previousNode.next = newNode
    def insertAtEnd(self, data):
        newNode = Node(data)
        temp = self.head
        while(temp.next != None):         
            temp = temp.next
        temp.next = newNode
    def delete(self, data):
        temp = self.head
        if (temp.next is not None):
            if(temp.data == data):
                self.head = temp.next
                temp = None
                return
            else:
                while(temp.next != None):
                    if(temp.data == data):
                        break
                    prev = temp          
                    temp = temp.next
                if temp == None:
                    return
                prev.next = temp.next
                return
    def search(self, node, data):
        if node == None:
            return False
        if node.data == data:
            return True
        return self.search(node.getNext(), data)
if __name__ == '__main__':
    List = LinkedList()
    List.head = Node(1)                
    node2 = Node(2)
    List.head.setNext(node2)           
    node3 = Node(3)
    node2.setNext(node3)               
    List.insertAtStart(4)              
    List.insertBetween(node2, 5)       
    List.insertAtEnd(6)
    List.printLinkedList()
    print()
    List.delete(3)
    List.printLinkedList()
    print()
    print(List.search(List.head, 1))",0,0,0,0,0,1,0,1,0
1606,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.head = None
    def size(self):
        current = self.head
        size = 0
        while current is not None:
            size += 1
            current = current.next
        return size
    def insert_at_end(self, data):
        node = Node(data)
        if self.head is None:
            self.head = node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = node
    def insert_at_beg(self, data):
        node = Node(data)
        node.next = self.head
        self.head = node
    def delete_from_end(self):
        current = self.head
        previous = None
        if current is None:
            print(""Linked List Underflow!!"")
        else:
            while current.next is not None:
                previous = current
                current = current.next
            if previous is None:
                self.head = None
            else:
                previous.next = None
    def delete_from_beg(self):
        current = self.head
        if current is None:
            print(""Linked List Underflow!!"")
        else:
            self.head = current.next
    def print_data(self):
        current = self.head
        while current is not None:
            print(current.data, '->', end='')
            current = current.next
        print('End of list')
if __name__ == '__main__':
    linked_list = SinglyLinkedList()
    linked_list.insert_at_beg(3)
    linked_list.insert_at_beg(2)
    linked_list.insert_at_beg(1)
    print('After insertion at the beginning:')
    linked_list.print_data()
    linked_list.insert_at_end(4)
    linked_list.insert_at_end(5)
    print('After insertion at the end:')
    linked_list.print_data()
    print('After deletion at the beginning:')
    linked_list.delete_from_beg()
    linked_list.print_data()
    print('After deletion at the end:')
    linked_list.delete_from_end()
    linked_list.print_data()
    print(""size: "", linked_list.size())",0,0,0,0,0,0,0,1,0
1607,"from linked_list.LinkedListExceptions import *
from linked_list.SinglyLinkedListNode import *
__author__ = ""Rahul Tuli""
__email__ = ""rt3991@rit.edu""
__status__ = ""Under-Development""
class LinkedList(object):
    __slots__ = ""head"", ""current"", ""size""
    def __init__(self, values=[]):
        self.head = self.current = None
        self.size = 0
        self.extend(values)
    def __str__(self):
        return ""["" + "", "".join([str(node) for node in self]) + ""]""
    def __len__(self):
        return self.size
    def __iter__(self):
        self.current = self.head
        return self
    def __next__(self):
        if self.current is None:
            raise StopIteration
        next_node = self.current
        self.current = self.current.next
        return next_node
    def __getitem__(self, item):
        assert isinstance(item, int)
        if item < 0:
            item = self.size + item
        if item < 0 or item >= self.size:
            raise IndexError
        for index, node in enumerate(self):
            if index == item:
                return node
    def __setitem__(self, key, value):
        self[key].val = value
    def __eq__(self, other):
        return self.head == other.head
    def __add__(self, other):
        assert isinstance(other, LinkedList), ""Can't add non conforming types""
        if self.head is None:
            self.head = other.head
        else:
            for current in self:
                continue
            current.next = other.head
    def get(self, index):
        return self[index].val
    def set(self, index, value):
        self[index] = value
    def extend(self, values):
        for value in values:
            self.append(value)
    def append(self, value):
        if self.head is None:
            self.head = Node(value)
        else:
            self[-1].next = Node(value)
        self.size += 1
    def pop(self, index=None):
        if index is None:
            index = -1
        if len(self) == 0:
            raise UnderFlow
        return self._remove_at_index(index=index)
    def _remove_at_index(self, index=False):
        if index is not False:
            if index == 0:
                to_remove = self.head
                self.head = self.head.next
            else:
                to_remove = self[index]
                self[index - 1].next = self[index].next
            self.size -= 1
            return to_remove
        raise ElementNotFoundError
    def remove(self, value):
        index = self.index_of(value)
        return self._remove_at_index(index)
    def index_of(self, value):
        for i, node in enumerate(self):
            if node.val == value:
                return i
        return False
    def insert(self, index, value):
        assert isinstance(index, int)
        if index < 0:
            index = self.size + index
        if index > self.size or index < 0:
            raise IndexError
        new_node = Node(value)
        if index == 0:
            new_node.next = self.head
            self.head = new_node
        elif index == self.size:
            print(index)
            self[index - 1].next = new_node
        else:
            prev = self[index - 1]
            new_node.next = prev.next
            prev.next = new_node
        self.size += 1
    def get_list(self):
        return [node.val for node in self]",0,0,0,0,0,1,0,1,0
1608,"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self):
        self.head = None
        self.pos = None
    def insert(self, data):
        newNode = Node(data)
        if self.head == None:
            self.head = newNode
            self.pos = newNode
        else:
            tmp = self.pos.next
            self.pos.next = newNode
            self.pos = newNode
            if tmp != None:
                newNode.next = tmp
    def delete(self):
        if self.pos == self.head:
            self.pos = self.pos.next
            del self.head
            self.head = self.pos
        else:
            tmp = self.head
            while tmp.next != self.pos:
                tmp = tmp.next
            tmp.next = self.pos.next
            del self.pos
            self.pos = tmp
    def reset(self):
        self.pos = self.head
    def advance(self):
        if self.pos != None:
            self.pos = self.pos.next
    def out_of_list(self):
        if self.pos == None:
            return True
        else:
            return False
    def pos_position(self):
        if not (self.out_of_list()):
          return self.pos.data
        else:
          return ""pos is out of list""
    def print_list(self):
        if self.head == None:
            print(""List is empty"")
        else:
            tmp = self.head
            while tmp != None:
                print(tmp.data)
                tmp = tmp.next
run = True
sll = SinglyLinkedList()
while run:
    print( ""\ni  [insert]  insert element"")
    print( ""d  [delete]  delete element"")
    print( ""o  [out]     out_of_list ?"")
    print( ""p  [pos]     current position of pos"")
    print( ""r  [reset]   pos-pointer"")
    print( ""a  [advance] pos-pointer"")
    print( ""pr [print]   print list"")
    print( ""q  [quit]    program"")
    choice = input()
    if choice == ""i"":
        num = input(""Enter Data for insertion: "")
        sll.insert(num)
    elif choice == ""d"":
        sll.delete()
    elif choice == ""o"":
        print(sll.out_of_list())
    elif choice == ""r"":
        sll.reset()
    elif choice == ""a"":
        sll.advance()
    elif choice == ""p"":
        print(sll.pos_position())
    elif choice == ""q"":
        run = False
    elif choice == ""pr"":
        sll.print_list()
    else:
        print(""Invalid Input"")",0,0,0,0,0,0,0,1,0
1609,"class Node:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class SinglyLinkedList:
    def __init__(self):
        self.head = None
    def prepend(self, val):
        new_node = Node(val)
        new_node.next = self.head
        self.head = new_node
    def append(self, val):
        new_node = Node(val)
        if self.head is None:
            self.head = new_node
            return
        last = self.head
        while last.next:
            last = last.next
        last.next = new_node
    def insert_after_node(self, prev_node, val):
        if prev_node is None:
            print(""Previous Node does not exist"")
            return
        new_node = Node(val)
        next_node = prev_node.next
        prev_node.next = new_node
        new_node.next = next_node
    def delete_by_val(self, val):
        curr = self.head
        if curr and curr.val == val:
            self.head = curr.next
            curr = None
            return
        prev = None
        while curr and curr.val != val:
            prev = curr
            curr = curr.next
        if curr is None:
            print(""element not found in the list"")
            return
        prev.next = curr.next
        curr = None
    def delete_by_pos(self, pos):
        curr = self.head
        count = 0
        if curr and pos == count:
            self.head = curr.next
            curr = None
            return
        prev = None
        while curr and count != pos:
            prev = curr
            curr = curr.next
            count += 1
        if curr is None:
            print(""pos greater than length"")
            return
        prev.next = curr.next
        curr = None
    def get_length(self):
        curr = self.head
        length = 0
        while curr :
            curr = curr.next
            length += 1
        return length
    def get_length_recursive(self, node):
        if node is None:
            return 0
        return 1 + self.get_length_recursive(node.next)
    def print_list(self):
        if self.head is None:
            print(""Empty List"")
        curr = self.head
        while curr:
            print(curr.val, end=""->"")
            curr = curr.next
        print(""None"")
if __name__ == ""__main__"":
    llist = SinglyLinkedList()
    llist.append(""A"")
    llist.append(""B"")
    llist.append(""C"")
    llist.print_list() 
    llist.prepend(""Z"")
    llist.prepend(""Y"")
    llist.print_list() 
    llist.insert_after_node(llist.head.next.next, ""D"")
    llist.print_list() 
    llist.delete_by_val(""Y"")
    llist.delete_by_val(""E"")
    llist.delete_by_val(""B"")
    llist.print_list() 
    llist.delete_by_pos(0)
    llist.delete_by_pos(2)
    llist.print_list()",0,0,0,0,0,1,0,1,0
1610,"class Node():
    def __init__(self, data):
        self.data = data
        self.next = None
    def __str__(self):
        return str(self.data)
class SLL():
    def __init__(self):
        self.first = None
    def insertFront(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
        else:
            newNode.next = self.first
            self.first = newNode
    def insertBack(self, data):
        newNode = Node(data)
        if self.first is None:
            self.first = newNode
        else:
            cur = self.first
            while cur.next is not None:
                cur = cur.next
            cur.next = newNode
    def exists(self, data):
        if self.first is None:
            return False
        else:
            cur = self.first
            while (cur is not None) and (cur.data is not data):
                cur = cur.next
            if cur is None:
                return False
            return True
    def delete(self, data):
        if self.exists(data):
            cur = self.first
            prev = cur
            while cur.data is not data:
                prev = cur
                cur = cur.next
            prev.next = cur.next
            return True
        else:
            return False
    def __str__(self):
        if self.first is None:
            return None
        else:
            cur = self.first
            res = """"
            while cur is not None:
                res += str(cur.data) + '\n'
                cur = cur.next
            return res",0,0,0,0,0,1,0,1,0
1611,"public class SinglyLinkedList<T extends Comparable<? super T>> implements
        LinkedListInterface<T> {
    private SLLNode<T> head;
    private SLLNode<T> tail;
    private int size;
    @Override
    public void addToFront(T data) {
        if (data == null) {
            throw new java.lang.IllegalArgumentException(""Input data is null."");
        }
        head = new SLLNode<T>(data, head);
        if (size == 0) {
            tail = head;
        }
        ++size;
    }
    @Override
    public void addAtIndex(T data, int index) {
        if (data == null) {
            throw new java.lang.IllegalArgumentException(""Input data is null."");
        }
        if (index < 0 || index > size) {
            throw new java.lang.IndexOutOfBoundsException(
                    ""Input index is out of bounds."");
        }
        if (index == 0) {
            addToFront(data);
        } else if (index == size) {
            addToBack(data);
        } else {
            SLLNode<T> current = head;
            for (int i = 0; i < index - 1; ++i) {
                current = current.getNext();
            }
            current.setNext(new SLLNode<T>(data, current.getNext()));
            ++size;
        }
    }
    @Override
    public void addToBack(T data) {
        if (data == null) {
            throw new java.lang.IllegalArgumentException(""Input data is null."");
        }
        if (size == 0) {
            addToFront(data);
        } else {
            tail.setNext(new SLLNode<T>(data));
            tail = tail.getNext();
            ++size;
        }
    }
    @Override
    public T removeFromFront() {
        if (size == 0) {
            return null;
        } else {
            T temp = head.getData();
            head = head.getNext();
            if (size == 1) {
                tail = null;
            }
            --size;
            return temp;
        }
    }
    @Override
    public T removeAtIndex(int index) {
        if (index < 0 || index >= size) {
            throw new java.lang.IndexOutOfBoundsException(
                    ""Input index is out of bounds."");
        }
        if (index == 0) {
            return removeFromFront();
        } else if (index == size - 1) {
            return removeFromBack();
        } else {
            SLLNode<T> current = head;
            T temp;
            for (int i = 0; i < index - 1; ++i) {
                current = current.getNext();
            }
            temp = current.getNext().getData();
            current.setNext(current.getNext().getNext());
            --size;
            return temp;
        }
    }
    @Override
    public T removeFromBack() {
        if (size == 0) {
            return null;
        } else if (size == 1) {
            return removeFromFront();
        } else {
            T temp = tail.getData();
            SLLNode<T> current = head;
            for (int i = 1; i < size - 1; ++i) {
                current = current.getNext();
            }
            current.setNext(null);
            tail = current;
            --size;
            return temp;
        }
    }
    @Override
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new java.lang.IndexOutOfBoundsException(
                    ""Input index is out of bounds."");
        }
        if (index == 0) {
            return head.getData();
        } else if (index == size - 1) {
            return tail.getData();
        } else {
            SLLNode<T> current = head;
            for (int i = 0; i < index; ++i) {
                current = current.getNext();
            }
            return current.getData();
        }
    }
    @Override
    public T findLargestElement() {
        if (size == 0) {
            return null;
        }
        T temp = head.getData();
        SLLNode<T> current = head;
        while (current != null) {
            if (temp.compareTo(current.getData()) < 0) {
                temp = current.getData();
            }
            current = current.getNext();
        }
        return temp;
    }
    @Override
    public Object[] toArray() {
        Object[] arrayToReturn = new Object[size];
        SLLNode<T> current = head;
        for (int i = 0; i < size; ++i) {
            arrayToReturn[i] = current.getData();
            current = current.getNext();
        }
        return arrayToReturn;
    }
    @Override
    public int size() {
        return size;
    }
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
    @Override
    public void clear() {
        head = null;
        tail = null;
        size = 0;
    }
    @Override
    public SLLNode<T> getHead() {
        return head;
    }
    @Override
    public SLLNode<T> getTail() {
        return tail;
    }
}",0,0,0,0,0,0,0,1,0
1612,"class _Node:
    __slots__ = '_element', '_next' 
    def __init__(self, element, next):
        self._element = element
        self._next = next",0,0,0,0,0,0,0,0,0
1613,"class Node:
    def __init__(self, data=0, next=None):
        self.data = data
        self.next = next
class LinkedList:
    def __init__(self):
        self.head = None
    def search(self, data):
        curr = self.head
        index = 0
        while curr:
            if curr.data == data:
                return index
            index += 1
            curr = curr.next
        return -1
    def get(self, index: int):
        curr = self.head
        count = 0
        if self.head is None:
            return -1
        if index == 0:
            return self.head.data
        while curr:
            if count == index:
                return curr.data
            count += 1
            curr = curr.next
        return -1
    def insert_at_head(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    def insert_at_tail(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            curr = self.head
            while curr.next:
                curr = curr.next
            curr.next = new_node
    def add_at_index(self, index: int, val: int) -> None:
        index -= 1
        new_node = Node(val)
        if not self.head:
            self.head = new_node
            return
        curr = self.head
        if index < 1:
            new_node.next = self.head
            self.head = new_node
            return
        else:
            count = 0
            prev = self.head
            while curr:
                count += 1
                if count == index:
                    new_node.next = curr.next
                    curr.next = new_node
                    return
                prev = curr
                curr = curr.next
            if count == index:
                curr.next = new_node
                return
            else:
                prev.next = new_node
                return
    def delete_head(self):
        if not self.head:
            return -1
        else:
            value = self.head.data
            temp = self.head.next
            self.head = None
            self.head = temp
            return value
    def delete_tail(self):
        if not self.head:
            return -1
        else:
            curr = self.head
            if not curr.next:
                value = curr.data
                self.head = None
                return value
            while curr.next.next:
                curr = curr.next
            value = curr.next.data
            curr.next = None
            return value
    def delete_at_index(self, index: int):
        index -= 1
        if self.head is None:
            return -1
        curr = self.head
        if index == 0:
            value = curr.data
            self.head = curr.next
            return value
        elif index < 0:
            return -1
        else:
            for i in range(index - 1):
                curr = curr.next
                if curr is None:
                    break
            if curr is None:
                return -1
            if curr.next is None:
                return -1
        value = curr.data
        next = curr.next.next
        curr.next = None
        curr.next = next
        return value
    def printll(self):
        curr = self.head
        while curr:
            print(curr.data, end="" -> "")
            curr = curr.next
        print(""/"")
if __name__ == ""__main__"":
    ll = LinkedList()
    while True:
        print(""\n======================"")
        print(""Linked List Operations"")
        print(""======================"")
        print(""Select the operation"")
        print(""1. Get the Node"")
        print(""2. Search"")
        print(""3. Insert at Head"")
        print(""4. Insert at Tail"")
        print(""5. Insert at Index"")
        print(""6. Delete at head"")
        print(""7. Delete at Tail"")
        print(""8. Delete at Index"")
        print(""9. Display Linked List"")
        print(""10. Exit"")
        choice = int(input(""Choice : ""))
        print(""\n---------------"")
        if choice == 1:
            index = int(input(""Enter the index to get the value of the node : ""))
            node = ll.get(index)
            if node == -1:
                print(""Node Does not exist at index {}"".format(index))
            else:
                print(""node '{}' is present at index : {}"".format(node, index))
        elif choice == 2:
            val = int(input(""Enter the value to be searched : ""))
            index = ll.search(val)
            if index == -1:
                print(""node '{}' is not present"".format(val))
            else:
                print(""node '{}' is present at index : {}"".format(val, index))
        elif choice == 3:
            node = int(input(""Enter the val of node to be inserted : ""))
            ll.insert_at_head(node)
            ll.printll()
        elif choice == 4:
            node = int(input(""Enter the val of node to be inserted : ""))
            ll.insert_at_tail(node)
            ll.printll()
        elif choice == 5:
            index = int(input(""Enter the index at which node will be inserted : ""))
            node = int(input(""Enter the val of node to be inserted : ""))
            ll.add_at_index(index, node)
            ll.printll()
        elif choice == 6:
            value = ll.delete_head()
            if value == -1:
                print(""Linked List does not exist"")
            else:
                print(""node '{}' has been deleted from head"".format(value))
            ll.printll()
        elif choice == 7:
            value = ll.delete_tail()
            if value == -1:
                print(""Linked List does not exist"")
            else:
                print(""node '{}' has been deleted from tail"".format(value))
            ll.printll()
        elif choice == 8:
            index = int(input(""Enter the index to delete the node : ""))
            value = ll.delete_at_index(index)
            if value == -1:
                print(""Node does not exist"")
            else:
                print(""node '{}' has been deleted at index {}"".format(value, index))
            ll.printll()
        elif choice == 9:
            ll.printll()
        elif choice == 10:
            quit()
        else:
            print(""Invalid Choice"")
        print(""---------------"")",0,0,0,0,0,1,0,1,0
1614,"class SNode:
    def __init__(self):
       self.data=None
       self.next=None
    def setData(self, data):
        self.data=data
    def setNext(self, next):
        self.next=next
    def getData(self):
        return self.data
    def getNext(self):
        return self.next
class SLinkedList:
    def __init__(self):
        self.head=self.tail=None
    def insertAtHead(self, data):
        temp = SNode()
        temp.setData(data)
        if self.head==None:
            temp.setNext(None)
            self.head=self.tail=temp
        else:
            temp.setNext(self.head)
            self.head=temp
    def insertAtTail(self, data):
        temp=SNode()
        temp.setData(data)
        if self.tail==None:
            temp.setNext(None)
            self.head=self.tail=temp
        else:
            self.tail.setNext(temp)
            self.tail=temp
    def print(self):
        curr=self.head
        while curr!=None:
            print(curr.getData())
            curr=curr.getNext()
    def deleteFromHead(self):
        if self.head==None:
            return
        if self.head is self.tail:
            self.head=self.tail=None
            return
        self.head=self.head.getNext()
    def deleteFromTail(self):
        if self.tail==None:
            return
        if self.head is self.tail:
            self.head=self.tail=None
            return
        curr=self.head
        while curr.getNext() is not self.tail:
            curr=curr.getNext()
        curr.setNext(None)
        self.tail=curr",0,0,0,0,0,0,0,1,0
1615,"from .compat import cmp, xrange
class sllistnode(object):
    __slots__ = ('__next', 'value', '__list')
    def __init__(self, value=None, next=None, list=None):
        self.__next = next
        self.value = value
        self.__list = list
    @property
    def next(self):
        return self.__next
    @property
    def list(self):
        return self.__list
    def iternext(self, to=None):
        if to is not None:
            if not isinstance(to, sllistnode):
                raise TypeError('to argument must be a sllistnode')
            if to.list is not self.__list:
                raise ValueError('to argument belongs to another list')
        current = self
        while current is not None and current != to:
            yield current
            current = current.__next
    def __call__(self):
        return self.value
    def __str__(self):
        return ""sllistnode(%s)"" % str(self.value)
    def __repr__(self):
        return ""<sllistnode(%s)>"" % repr(self.value)
class sllist(object):
    __slots__ = ('__first', '__last', '__size', )
    def __init__(self, iterable=None):
        self.__first = None
        self.__last = None
        self.__size = 0
        if iterable:
            self.__extend(iterable)
    @property
    def first(self):
        return self.__first
    @property
    def last(self):
        return self.__last
    @property
    def size(self):
        return self.__size
    def nodeat(self, index):
        if not isinstance(index, int):
            raise TypeError('invalid index type')
        if index < 0:
            index = self.__size + index
        if index < 0 or index >= self.__size:
            raise IndexError('index out of range')
        if not self.__first:
            raise IndexError(""index out of range"")
        curr = self.__first
        i = 0
        while(curr != None and i < index):
            curr = curr.next
            i += 1
        return curr
    def __extend(self, iterable):
        for item in iterable:
            self.appendright(item)
    def __delitem__(self, index):
        to_del = self.nodeat(index)
        self.remove(to_del)
    def __getitem__(self, index):
        return self.nodeat(index).value
    def __len__(self):
        return self.__size
    def __setitem__(self, index, value):
        node = self.__getitem__(index)
        if isinstance(value, sllistnode):
            value = value.value
        node.value = value
    def __cmp__(self, other):
        for sval, oval in zip(self, other):
            result = cmp(sval, oval)
            if result != 0:
                return result
        result = len(self) - len(other)
        if result < 0:
            return -1
        elif result > 0:
            return 1
        return 0
    def __eq__(self, other):
        for sval, oval in zip(self, other):
            if sval == oval:
                return True
        return len(self) == len(other)
    def __ne__(self, other):
        for sval, oval in zip(self, other):
            if sval != oval:
                return True
        return len(self) != len(other)
    def __lt__(self, other):
        for sval, oval in zip(self, other):
            if sval < oval:
                return True
        return len(self) < len(other)
    def __le__(self, other):
        for sval, oval in zip(self, other):
            if sval <= oval:
                return True
        return len(self) <= len(other)
    def __gt__(self, other):
        for sval, oval in zip(self, other):
            if sval > oval:
                return True
        return len(self) > len(other)
    def __ge__(self, other):
        for sval, oval in zip(self, other):
            if sval >= oval:
                return True
        return len(self) >= len(other)
    def __str__(self):
        if self.__first is not None:
            return ""sllist([%s])"" % ', '.join((str(x) for x in self))
        else:
            return 'sllist()'
    def __repr__(self):
        if self.__first is not None:
            return ""sllist([%s])"" % ', '.join((repr(x) for x in self))
        else:
            return 'sllist()'
    def __iter__(self):
        current = self.__first
        while current is not None:
            yield current.value
            current = current.next
    def iternodes(self, to=None):
        if self.__first is not None:
            return self.__first.iternext(to=to)
        else:
            return iter([])
    def __get_prev(self, node):
        if not isinstance(node, sllistnode):
            raise TypeError(""Object must be Node instance"")
        if not self.__first:
            raise IndexError(""List is empty"")
        if self.__first == node:
            return None
        curr = self.__first
        prev = None
        while(curr and curr != node):
            prev = curr
            curr = curr.next
        return prev
    def appendleft(self, value):
        if isinstance(value, sllistnode):
            value = value.value
        new_node = sllistnode(value=value, next=self.__first, list=self)
        self.__first = new_node
        if self.__last is None:
            self.__last = new_node
        self.__size += 1
        return new_node
    def insert(self, value, before=None):
        if before is None:
            return self.appendright(value)
        else:
            return self.insertbefore(before, value)
    def insertafter(self, node, value):
        if not isinstance(node, sllistnode):
            raise TypeError(""node must be instance of sllistnode"")
        if not self.__first:
            raise ValueError(""List is empty"")
        if node.list is not self:
            raise ValueError(""Node is not element of this list"")
        if isinstance(value, sllistnode):
            value = value.value
        new_node = sllistnode(value=value, next=None, list=self)
        new_node._sllistnode__next = node.next
        node._sllistnode__next = new_node
        if self.__last is node:
            self.__last = new_node
        self.__size += 1
        return new_node
    def insertbefore(self, node, value):
        if not isinstance(node, sllistnode):
            raise TypeError(""node must be instance of sllistnode"")
        if not self.__first:
            raise ValueError(""List is empty"")
        if node.list is not self:
            raise ValueError(""Node is not element of this list"")
        if isinstance(value, sllistnode):
            value = value.value
        new_node = sllistnode(value=value, next=None, list=self)
        prev = self.__get_prev(node)
        if prev:
            prev._sllistnode__next = new_node
            new_node._sllistnode__next = node
        else:
            new_node._sllistnode__next = node
            self.__first = new_node
        self.__size += 1
        return new_node
    def append(self, value):
        return self.appendright(value)
    def appendright(self, value):
        if isinstance(value, sllistnode):
            value = value.value
        new_node = sllistnode(value=value, next=None, list=self)
        if not self.__first:
            self.__first = new_node
        else:
            self.__last._sllistnode__next = new_node
        self.__last = new_node
        self.__size += 1
        return new_node
    def popleft(self):
        if not self.__first:
            raise ValueError(""List is empty"")
        del_node = self.__first
        self.__first = del_node.next
        if self.__last == del_node:
            self.__last = None
        self.__size -= 1
        del_node._sllistnode__next = None
        del_node._sllistnode__list = None
        return del_node.value
    def pop(self):
        return self.popright()
    def popright(self):
        if not self.__first:
            raise ValueError(""List is empty"")
        del_node = self.__last
        if self.__first == del_node:
            self.__last = None
            self.__first = None
        else:
            prev = self.__get_prev(del_node)
            prev._sllistnode__next = None
            self.__last = prev
        self.__size -= 1
        del_node._sllistnode__list = None
        return del_node.value
    def remove(self, node):
        if not isinstance(node, sllistnode):
            raise TypeError(""node must be a sllistnode"")
        if self.__first is None:
            raise ValueError(""List is empty"")
        if node.list is not self:
            raise ValueError(""Node is not element of this list"")
        prev = self.__get_prev(node)
        if not prev:
            self.popleft()
        else:
            prev._sllistnode__next = node.next
            if self.__last == node:
                self.__last = prev
            self.__size -= 1
        node._sllistnode__next = None
        node._sllistnode__list = None
        return node.value
    def __add__(self, sequence):
        new_list = sllist(self)
        for value in sequence:
            new_list.appendright(value)
        return new_list
    def __iadd__(self, sequence):
        if sequence is not self:
            for value in sequence:
                self.appendright(value)
        else:
            node = sequence.__first
            last_node = self.__last
            while node is not None:
                self.appendright(node.value)
                if node is last_node:
                    break
                node = node.next
        return self
    def __mul__(self, count):
        if not isinstance(count, int):
            raise TypeError('count must be an integer')
        new_list = sllist()
        for i in xrange(count):
            new_list += self
        return new_list
    def __imul__(self, count):
        if not isinstance(count, int):
            raise TypeError('count must be an integer')
        last_node = self.__last
        for i in xrange(count - 1):
            node = self.__first
            while node is not None:
                self.appendright(node.value)
                if node is last_node:
                    break
                node = node.next
        return self
    def __hash__(self):
        h = 0
        for value in self:
            h ^= hash(value)
        return h",0,0,0,0,0,0,0,1,0
1616,"class SLLNode:
    def __init__(self, value=None, next_node=None):
        self.value = value
        self.next_node = next_node
    def __str__(self):
        s = ""Node with value {} and "".format(self.value)
        if not self.next_node:
            s += ""no next node""
        else:
            s += ""next node has value {}."".format(self.next_node.value)
        return s
if __name__ == ""__main__"":
    node = SLLNode(7, None)
    print()
    print(node)
    my_node = SLLNode(8, None)
    print(my_node)
    second_node = SLLNode(27, None)
    first_node = SLLNode(14, second_node)
    print(first_node)",0,0,0,0,0,0,0,0,0
1617,"class Node:
    def __init__(self,value=None):
        self.value = value
        self.next = None
class Stack:
    def __init__(self):
        self.top =  None
        self.bottom = None
        self.length = 0
    def peek(self):
        return self.top
    def push(self,value):
        currentNode = Node(value=value)
        if(self.length == 0):
            self.top = currentNode
            self.bottom = currentNode
        else:
            holdingPointer = self.top
            self.top = currentNode
            self.top.next = holdingPointer
        self.length = self.length + 1
        return self
    def pop(self):
        self.top = self.top.next
        self.length = self.length -1
    def printList(self):
        currentNode = self.top
        while currentNode!= None:
            print(currentNode.value)
            currentNode = currentNode.next
myStack = Stack()
myStack.pushed(10)
myStack.pushed(123)
myStack.pushed(12312313)
myStack.pop()
myStack.pushed(123123131231)
myStack.printList()",0,0,0,0,0,0,0,1,0
1618,"from list import List
class Stack(List):
    pass",0,0,0,0,0,0,0,0,0
1619,"class Node:
	def __init__(self, data):
		self.data = data
  self.next = None
 def getData(self):
		return self.data
 def setData(self, data):
		self.data = data
 def getNext(self):
		return self.next
 def setNext(self, next):
		self.next = next
class Stack:
	def __init__(self):
		self.top = None
 def print(self):
		if self.top is None:
			print(""Stack is empty, nothing to print!!!"")
   return
  current = self.top  
  while current != None:
			print(current.data)
   current = current.next
 def push(self, data):
		node = Node(data)
  node.next = self.top
  self.top = node
 def pop(self):
		if self.top is None:
			return ""Stack empty""
  element = self.top
  self.top = self.top.next
  return element
 def topElement(self):
		if self.top is None:
			return ""Stack empty""
  return self.top.data
 def isEmpty(self):
		if self.top is None:
			return True
  else:
			return False",0,0,0,0,0,0,0,1,0
1620,"def get_by_address(address, global_vars):
    if address == 0:
        return None
    return [x for x in global_vars.values() if id(x) == address][0]
class Node(object):
    def __init__(self, data):
        self.data = data
        self.address_store = None
    def get_address(self):
        return id(self)
    def set_neighbors(self, prev_node=None, next_node=None):
        local_address = self.get_address()
        if prev_node == None:
            prev_address = 0
        else:
            prev_address = prev_node.get_address()
        if next_node == None:
            next_address = 0
        else:
            next_address = next_node.get_address()
        self.address_store = prev_address ^ next_address
    def get_next(self, prev_node, global_vars):
        if self.address_store == None:
            raise Exception('set_neighbors not called yet, no next node!')
        if prev_node == None:
            prev_address = 0
        else:
            prev_address = prev_node.get_address()
        next_address = self.address_store ^ prev_address
        return get_by_address(address=next_address, global_vars=global_vars)
    def get_prev(self, next_node, global_vars):
        if self.address_store == None:
            raise Exception('set_neighbors not called yet, no next node!')
        if next_node == None:
            next_address = 0
        else:
            next_address = next_node.get_address()
        prev_address = self.address_store ^ next_address
        return get_by_address(prev_address, global_vars=global_vars)",0,0,0,0,0,0,0,0,0
1621,"def binary_search(input_array, value):
	low = 0
 high = len(input_array) - 1
 while low < high:
		mid = low + (high - 1)//2
  if input_array[mid] == value:
			return mid
  elif input_array[mid] > value:  
			high = mid - 1
  elif input_array[mid] < value:
			low = mid + 1
 return -1
test_list = [1,3,9,11,15,19,29]
test_val1 = 25
test_val2 = 15
print(binary_search(test_list, test_val1))
print(binary_search(test_list, test_val2))",0,0,0,0,0,0,1,0,0
1622,"def binary_search(input_array, low, high, value):
	if low < high:
		mid = low + (high - 1)//2
  if input_array[mid] == value:
			return mid
  elif input_array[mid] < value:  
			return binary_search(input_array, mid+1, high, value)
  elif input_array[mid] > value:
			return binary_search(input_array, low, mid-1, value)
 return -1
test_list = [1,3,9,11,15,19,29]
test_val1 = 25
test_val2 = 15
print(binary_search(test_list, 0, len(test_list) - 1, test_val1))
print(binary_search(test_list, 0, len(test_list) - 1, test_val2))",0,0,0,0,0,0,1,0,0
1623,"def binary(arr,low,high,x):
    while low < high:
        mid = low + (high-1) // 2
        if(arr[mid] == x):
            return mid
        elif(arr[mid] <x):
            low = mid + 1
        else:
            high = mid - 1
    return -1
print('Enter a list of number')
arr = list(map(int,input().split()))
n=len(arr)
arr.sort()
x =int(input(""Enter the number to find\n""))
result = binary(arr,0,len(arr)-1,x)
if(result == -1):
    print(""Element not found"")
else:
    print(""Element found at "",result+1,"" position"")",0,0,0,0,0,0,1,0,0
1624,"def binary_search(numbers_list, number_to_find):
    left_index = 0
    right_index = len(numbers_list) - 1
    mid_index = 0
    while left_index <= right_index:
        mid_index = (left_index + right_index) // 2
        mid_number = numbers_list[mid_index]
        if mid_number == number_to_find:
            return mid_index
        if mid_number < number_to_find: 
            left_index = mid_index + 1
        else: 
            right_index = mid_index - 1
    return -1
def find_all_occurances(numbers, number_to_find):
    index = binary_search(numbers, number_to_find)
    indices = [index]
    i = index-1
    while i >=0:
        if numbers[i] == number_to_find:
            indices.append(i)
        else:
            break
        i = i - 1
    i = index + 1
    while i<len(numbers):
        if numbers[i] == number_to_find:
            indices.append(i)
        else:
            break
        i = i + 1
    return sorted(indices)
if __name__ == '__main__':
    numbers = [1,4,6,9,11,15,15,15,17,21,34,34,56]
    number_to_find = 15
    indices = find_all_occurances(numbers, number_to_find)
    print(f""Indices of occurances of {number_to_find} are {indices}"")",0,0,0,0,0,0,1,0,0
1625,"def binary_search(input_array, value):
    low = 0
    high = len(input_array)-1
    while (low <= high):
        mid = (low + high)/2
        if input_array[mid]==value:
            return mid
        elif value > input_array[mid]:
            low = mid+1
        elif value < input_array[mid]:
            high = mid - 1
    return -1
test_list = [1,3,9,11,15,19,29]
test_val1 = 25
test_val2 = 15
print binary_search(test_list, test_val1)
print binary_search(test_list, test_val2)",0,0,0,0,0,0,1,0,0
1626,"def binary_search(input_array, value):
    low = 0
    high = len(input_array)-1
    while low <= high:
        mid = int((low+high)/2)
        if value == input_array[mid]:
            return mid
        elif value < input_array[mid]:
            high = mid - 1
        else:
            low = mid + 1
    return -1
test_list = [1,3,9,11,15,17,19,29]
test_val1 = 25
test_val2 = 15
test_val3 = 17
print(binary_search(test_list, test_val1))
print(binary_search(test_list, test_val2))
print(binary_search(test_list, test_val3))",0,0,0,0,0,0,1,0,0
1627,"def binary_search(arr, val):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == val:
            return mid
        elif val > arr[mid]:
            low = mid + 1
        elif val < arr[mid]:
            high = mid - 1
    return -1
if __name__ == '__main__':
    li = [12, 15, 17, 19, 21, 24, 45, 67]
    number = 67
    ind = binary_search(li, number)
    print(ind)",0,0,0,0,0,0,1,0,0
1628,"def binary_search_recursive(arr, value, left, right):
    if left > right:
        return -1
    mid = (left + right) // 2
    mid_val = arr[mid]
    if mid_val == value:
        return mid
    if value > mid_val:
        left = mid + 1
    else:
        right = mid - 1
    return binary_search_recursive(arr, value, left, right)
if __name__ == ""__main__"":
    li = [12, 15, 17, 19, 21, 24, 45, 67]
    number = 88
    ind = binary_search_recursive(li, number, 0, len(li)-1)
    print(ind)",0,0,0,0,0,0,1,0,0
1629,"class binary_search{
	public static void main(String s[]){
		int a[] = {1,5,7,8,13,15,17};
		int x = 8;
		int start = 0,end = 7;
		for(start=0;start<end;start++){
			int mid = (start+end)/2;
			if(a[mid]==x){
				System.out.println(""Found"");
				break;
			}
			if(a[mid]>x){
				end = mid;
			}
			if(a[mid]<x){
				start = mid;
			}
		}
}
}",0,0,0,0,0,0,1,0,0
1630,"import sys
class BinarySearch:
    def binary_search(self, array, key):
        low = 0
        high = len(array) - 1
        while low <= high:
            mid = low + (high - low) // 2
            if array[mid] == key:
                return mid
            elif array[mid] < key:
                low = mid + 1
            else:
                high = mid - 1
        return -1
if __name__ == ""__main__"":
    print(
        """"""
    ==============
    Binary Search
    ==============
    Input Format
    first line contains space separated sorted elements eg., 1 2 3 4 5 6 7 8 9
    Second line contains the key to be searched  eg., 7
    """"""
    )
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    array = data[:-1]
    key = data[-1]
    res = BinarySearch().binary_search(array, key)
    if res == -1:
        print(""Key not found"")
    else:
        print(""Key : '{}' found at index : {}"".format(key, res + 1))",0,0,0,0,0,0,1,0,0
1631,"from util import time_it
@time_it
def linear_search(numbers_list, number_to_find):
    for index, element in enumerate(numbers_list):
        if element == number_to_find:
            return index
    return -1
@time_it
def binary_search(numbers_list, number_to_find):
    left_index = 0
    right_index = len(numbers_list) - 1
    mid_index = 0
    while left_index <= right_index:
        mid_index = (left_index + right_index) // 2
        mid_number = numbers_list[mid_index]
        if mid_number == number_to_find:
            return mid_index
        if mid_number < number_to_find:
            left_index = mid_index + 1
        else:
            right_index = mid_index - 1
    return -1
def binary_search_recursive(numbers_list, number_to_find, left_index, right_index):
    if right_index < left_index:
        return -1
    mid_index = (left_index + right_index) // 2
    if mid_index >= len(numbers_list) or mid_index < 0:
        return -1
    mid_number = numbers_list[mid_index]
    if mid_number == number_to_find:
        return mid_index
    if mid_number < number_to_find:
        left_index = mid_index + 1
    else:
        right_index = mid_index - 1
    return binary_search_recursive(numbers_list, number_to_find, left_index, right_index)
if __name__ == '__main__':
    numbers_list = [12, 15, 17, 19, 21, 24, 45, 67]
    number_to_find = 21
    index = binary_search_recursive(numbers_list, number_to_find, 0, len(numbers_list))
    print(f""Number found at index {index} using binary search"")",0,0,0,0,0,1,1,0,0
1632,"import math
def bs_itr(A, n, key):
    low = 0
    high = n - 1
    while low <= high:
        mid = math.floor((low + high)/2)
        if key == A[mid]:
            return mid
        elif key < A[mid]:
            high = mid - 1
        elif key > A[mid]:
            low = mid + 1
    return ""Not Found""
A = [1, 2, 3, 4, 5, 6, 7]
print(A)
print(""Iterative Binary Search output:"", bs_itr(A, len(A), 10))
print(""Iterative Binary Search output:"", bs_itr(A, len(A), 5))
print(""Iterative Binary Search output:"", bs_itr(A, len(A), 2))
def bs_recur(A, key, low = 0, high = len(A) - 1):
    if low > high:
        return ""Not Found""
    else:
        mid = math.floor((low + high)/2)
        if key == A[mid]:
            return mid
        elif key < A[mid]:
            return bs_recur(A, key, low, mid - 1)
        elif key > A[mid]:
            return bs_recur(A, key, mid + 1, high)
print(""Recursive Binary Search output:"", bs_recur(A, 10))
print(""Recursive Binary Search output:"", bs_recur(A, 5))
print(""Recursive Binary Search output:"", bs_recur(A, 2))",0,0,0,0,0,0,1,0,0
1633,"def binary_search(sort_list, data):
    left = 0
    right = len(sort_list) - 1
    while left < right:
        mid = left + (right - left) // 2
        if sort_list[mid] < data:
            left = mid + 1              
        else: 
            right = mid
    if sort_list[left] == data:
        return left
    return 'not found'
l = list(range(0, 30, 2))
res = binary_search(l, 13)
print(res)",0,0,0,0,0,0,1,0,0
1634,"def binary_search(input_array, value):
    final_array = input_array
    while len(input_array) >= 1:
	    size_of_list = len(input_array)
     if (size_of_list % 2) != 0:
	    	middle_element = input_array[size_of_list/2]
     else:
	    	middle_element = input_array[(size_of_list/2)-1]
     if value == middle_element:
	    	return final_array.index(middle_element)
     elif value < middle_element:
	    	input_array = input_array[:(input_array.index(middle_element))]
     elif value > middle_element:
	       input_array = input_array[(input_array.index(middle_element)+1):]
    return -1
test_list = [1,3,9,11,15,19,29]
test_val1 = 28
test_val2 = 11
print binary_search(test_list, test_val1)
print binary_search(test_list, test_val2)",0,0,0,0,0,0,1,0,0
1635,"def binarySearch(s, x):
    start = 0
    end = len(s) - 1
    while start <= end:
        mid = (start + end) // 2
        if x == s[mid]:
            return mid
        else:
            if x > s[mid]:
                start = mid + 1
            else:
                end = mid - 1
    return -1
def binarySearchRecursive(s, start, end, x):
    if end >= start:
        mid = (start + end) // 2
        if s[mid] == x:
            return mid
        if s[mid] > x:
            return binarySearchRecursive(s, start, mid - 1, x)
        else:
            return binarySearchRecursive(s, mid + 1, end, x)
    else:
        return -1",0,0,0,0,0,0,1,0,0
1636,"def binary_search(input_array, value, high, low):
    if high >= low:
        mid = (high+low)//2
        if value == input_array[mid]:
            return mid
        elif value > input_array[mid]:
            return binary_search(input_array, value, high, mid+1)
        else:
            return binary_search(input_array, value, mid-1, low)
    else:
        return -1
test_list = [1,3,9,11,15,17,19,29]
test_val1 = 25
test_val2 = 15
test_val3 = 17
print(binary_search(test_list, test_val1, len(test_list)-1, 0)) 
print(binary_search(test_list, test_val2, len(test_list)-1, 0)) 
print(binary_search(test_list, test_val3, len(test_list)-1, 0)) ",0,0,0,0,0,0,1,0,0
1637,"package Java.Search;
public class BinarySearch(){
    public int binary_search(int array[], int x){
    	int l = 0, r = array.length - 1;
    	while (l <= r) {
    		int m = (l + r) / 2;
    		if(array[m] < x) l = m + 1;
    		else if (array[m] > x) r = m - 1;
    		else return m;
    	}
    	return -1;
    }
}",0,0,0,0,0,0,1,0,0
1638,"const binarySearch = (sortedArray, seekElement) => {
  let startIndex = 0;
  let endIndex = sortedArray.length - 1;
  while (startIndex <= endIndex) {
    const middleIndex = startIndex + Math.floor((endIndex - startIndex) / 2);
    if (sortedArray[middleIndex] === seekElement) {
      return middleIndex;
    }
    if (sortedArray[middleIndex] < seekElement) {
      startIndex = middleIndex + 1;
    } else {
      endIndex = middleIndex - 1;
    }
  }
  return -1;
};
const sortedArray = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
const firstSeekElement = 8;
const secondSeekElement = 21;
console.log(binarySearch(sortedArray, firstSeekElement));  
console.log(binarySearch(sortedArray, secondSeekElement));  ",0,0,0,0,0,0,1,0,0
1639,"class Node:
    def __init__(self, value, parent=None):
        self.value = value
        self.parent = parent
        self.lchild = None
        self.rchild = None
    def add(self, value):
        if self.value == value:
            return
        if value > self.value:
            if self.rchild is None:
                self.rchild = self.__class__(value, parent=self)
            else:
                self.rchild.add(value)
        else:
            if self.lchild is None:
                self.lchild = self.__class__(value, parent=self)
            else:
                self.lchild.add(value)
    def find(self, value):
        if self.value == value:
            return True
        if value > self.value:
            if self.rchild is None:
                return False
            return self.rchild.find(value)
        else:
            if self.lchild is None:
                return False
            return self.lchild.find(value)
    def order(self):
        if self.lchild:
            self.lchild.order()
        if self.value:
            print(self.value)
        if self.rchild:
            self.rchild.order() ",0,0,0,0,0,0,1,0,0
1640,"def find_closest_number(arr, target):
    low = 0
    high = len(arr) - 1
    min_diff = float(""inf"")
    closest_number = None
    if len(arr) == 0:
        return -1
    if len(arr) == 1:
        return arr[0]
    while low <= high:
        mid = (low + high) // 2
        if mid > 0:
            min_diff_left = abs(arr[mid-1] - target)
        if mid < len(arr) - 1:
            min_diff_right = abs(arr[mid+1] - target)
        if min_diff_left < min_diff:
            min_diff = min_diff_left
            closest_number = arr[mid-1]
        if min_diff_right < min_diff:
            min_diff = min_diff_right
            closest_number = arr[mid + 1]
        if target > arr[mid]:
            low = mid + 1
        elif target < arr[mid]:
            high = mid - 1
        else:  
            return arr[mid]
    return closest_number
if __name__ == ""__main__"":
    A = [1, 2, 5, 7, 9, 11, 14, 15]
    value = 12
    close = find_closest_number(A, value)
    print(close)",0,0,0,0,0,0,1,0,0
1641,"def shiftedBinarySearch(array, target):
    return shiftedBinarySearchHelper(array, target, 0, len(array) - 1)
def shiftedBinarySearchHelper(array, target, left, right):
	if left > right:
		return -1
 middle = (left + right) // 2
 potentialMatch = array[middle]
 leftNum = array[left]
 rightNum = array[right]
 if target == potentialMatch:
		return middle
 elif leftNum <= potentialMatch:
		if target < potentialMatch and target >= leftNum:
			return shiftedBinarySearchHelper(array, target, left, middle - 1)
  else:
			return shiftedBinarySearchHelper(array, target, middle + 1, right)
 else:
		if target > potentialMatch and target <= rightNum:
			return shiftedBinarySearchHelper(array, target, middle + 1, right)
  else:
			return shiftedBinarySearchHelper(array, target, left, middle -1)",0,0,0,0,0,0,1,0,0
1642,"def countOccurrence(A, target):
  count = 0
  for i in xrange(len(A)):
  	if A[i] == target:
  		count += 1
   elif A[i] < target:
  		continue
   else:
  		break
  return count
def countOccurrence1(A, target):
 l, r, m = 0, len(A) - 1, -1
 count = 0
 while l <= r:
		m = l + (r - l) / 2
  print l, r
  if A[m] == target:
			count += 1
   break
  elif target < A[m]:
			r = m - 1
  else:
			l = m + 1
 print '(%d, %d) find %d at %d' % (l, r, target, m)
 if m == -1: return 0
 i, j = m-1, m+1
 while i >= l and A[i] == target:
		print 'check left at %d' % i
  count += 1
  i -= 1
 while j <= r and A[j] == target:
		print 'check right at %d' % j
  count += 1
  j += 1
 return count
def _binarysearch(A, l, r, key):
	while l <= r:
		m = l + (r-l)/2
  if key < A[m]:
			r = m - 1
  elif key > A[m]:
			l = m + 1
  else:
			return m
 return m
def searchrange(A, target):
    def sided_search(A, target, dir):
        l, r = 0, len(A)-1
        idx = -1
        while l <= r:
            m = l + (r-l)/2
            if target < A[m]:
                r = m-1
            elif target > A[m]:
                l = m+1
            else:
                idx = m
                if dir == 'left':
                	print 'left of A[%d]=%d' % (m, A[m])
                 r = m - 1
                else:
                	print 'right of A[%d]=%d' % (m, A[m])
                 l = m + 1
        return idx
    lr = sided_search(A, target, 'left')
    if lr == -1:
    	return []
    rr = sided_search(A, target, 'right')
    return [lr, rr]
def searchclosest(A, target):
 l, r = 0, len(A) -1
 idx = _binarysearch(A, l, r, target)
 if A[idx] == target:
		print 'target found at %d' % idx
  return idx
 if target < A[idx]:
		print 'the closest is located at %d' % (idx-1)
  return idx - 1
 else:
		print 'the closest is located at %d' % idx
  return idx
if __name__ == '__main__':
    A = [3,5,6,6,6,7,7]
    A = [1,3,4,5,6,6]
    A = [3,4,5,6,6,7,7]
    print searchrange(A, 1)
    print 'aaa'",0,0,0,0,0,1,1,0,0
1643,"def linear_search(number_list, number_to_find):
    for index, element in enumerate(number_list):
        if element == number_to_find:
            return index
    return -1
if __name__ == '__main__':
    li = [12, 15, 17, 19, 21, 24, 45, 67]
    number = 12
    ind = linear_search(li, number)
    print(ind)",0,0,0,0,0,1,0,0,0
1644,"def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False
def search1(L, e):
    for i in L:
        if i == e:
            return True
        if i > e:
            return False
    return False
def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False
def search2(L, e):
    for i in L:
        if i == e:
            return True
        elif i > e:
            return False
    return False
def search3(L, e):
    if len(L)==0:
        return False
    elif L[0] == e:
        return True
    elif L[0] > e:
        return False
    else:
        return search3(L[1:], e)
search3([], 4)
print(search3([1, 2, 3,4], 4))
search([], 4)
search([1, 2, 3], 4)",0,0,0,0,0,1,0,0,0
1645,"import sys
class LinearSearch:
    def linear_search(self, array, key):
        for i in range(len(array)):
            if array[i] == key:
                return i
        return -1
if __name__ == ""__main__"":
    print(
        """"""
    Input format 
    first line contains space separated elements eg., 9 6 3 4 5 2 7 1
    Second line contains the key to be searched  eg., 7
    """"""
    )
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    array = data[:-1]
    key = data[-1]
    found = LinearSearch().linear_search(array, key)
    if found == -1:
        print(""Key not found"")
    else:
        print(""Key is found at position : {}"".format(found))",0,0,0,0,0,1,0,0,0
1646,"package Java.Search; 
class LinearSearch{
    private static int search(int[] a,int item)
    {
        for (int i=0;i<a.length;i++ ) {
            if(a[i]==item){
                return i;
            }
        }
        return -1;
    }
    public static void main(String args[])
    {
        int a[] = {22,18,11,6,3,17,45,30};
        int n = a.length;
        int item = 17;
        int pos = search(a,item);
        if(pos != -1){
            System.out.println(""The element ""+item+"" is at postion:- ""+(++pos));
        }else{
            System.out.println(""Element :- ""+item+"" not found"");
        }
    }
}",0,0,0,0,0,1,0,0,0
1647,"function linear_search(arr,k){
    for(i=0;i<arr.length;i++){
        if(k==arr[i])
        {
            return i+1;
        }
    }
    return -1;
}
console.log(linear_search([3,4,5,6,7,2,9,0],6));  ",0,0,0,0,0,1,0,0,0
1648,"def bubble_sort(input_array):
	n = len(input_array)
 for i in range(n):
		for j in range(0, n - i - 1):
			if input_array[j] > input_array[j+1]:
				input_array[j], input_array[j+1] = input_array[j+1], input_array[j]
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print (""Sorted array is:"")
for i in range(len(arr)):
    print (""%d"" %arr[i]), ",0,0,0,0,1,0,0,0,0
1649,"def bubble_sort1(A):
	for i in range (0, len(A) - 1):
		for j in range (0, len(A) - i - 1):
			if A[j] > A[j+1]:
				A[j], A[j+1] = A[j+1], A[j]
def bubble_sort2(A):
	for i in range (0, len(A) - 1):
		done = True
  for j in range (0, len(A) - i - 1):
			if A[j] > A[j+1]:
				A[j], A[j+1] = A[j+1], A[j]
    done = False
  if done:
			return
A = [5,9,1,2,4,8,6,3,7]
print(A)
bubble_sort1(A)
print(A)",0,0,0,0,1,0,0,0,0
1650,"def bubble_sort(elements):
    size = len(elements)
    for i in range(size-1):
        swapped = False
        for j in range(size-1-i):
            if elements[j] > elements[j+1]:
                tmp = elements[j]
                elements[j] = elements[j+1]
                elements[j+1] = tmp
                swapped = True
        if not swapped:
            break
if __name__ == '__main__':
    elements = [5,9,2,1,67,34,88,34]
    elements = [1,2,3,4,2]
    elements = [""mona"", ""dhaval"", ""aamir"", ""tina"", ""chang""]
    bubble_sort(elements)
    print(elements)",0,0,0,0,1,0,0,0,0
1651,"def bubble_sort_ascending(A):
    for i in range(len(A)):
        swap_flag = False;
        for j in range(0, len(A) - 1 - i, 1):
            if (A[j] > A[j + 1]):
                A[j], A[j + 1] = A[j + 1], A[j]
                swap_flag = True;
        if not swap_flag:
            break
def bubble_sort_descending(A):
    i = 0
    while i < len(A):
        j = 1
        has_swap = False
        while j < len(A) - i:
            if A[j - 1] < A[j]:
                has_swap = True
                A[j - 1], A[j] = A[j], A[j - 1]
            j += 1
        i += 1
        if not has_swap:
            break
def sort(A):
    B = A[:]
    bubble_sort_ascending(A)
    bubble_sort_descending(B)
    return (A, B)
assert sort([3, 4, 5, 2, 1]) == ([1, 2, 3, 4, 5], [5, 4, 3, 2, 1])
assert sort([3, 4, 5, 2, 1, 6]) == ([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1])
assert sort([]) == ([], [])
assert sort([1]) == ([1], [1])
assert sort([2, 1]) == ([1, 2], [2, 1])",0,0,0,0,1,0,0,0,0
1652,"import sys
class bubbleSort:
    def bubble_sort(self, data):
        for i in range(len(data) - 1):
            for j in range(0, len(data) - i - 1):
                if data[j] > data[j + 1]:
                    data[j], data[j + 1] = data[j + 1], data[j]
        print(data)
if __name__ == ""__main__"":
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    bubbleSort().bubble_sort(data)",0,0,0,0,1,0,0,0,0
1653,"import random
def bubbleSort(arr):
    for i in range(0, len(arr)):
        for j in range(0, len(arr)-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
if __name__ == ""__main__"":
    A = [random.randint(0, 100) for i in range(20)]
    print(A)
    s = bubbleSort(A)
    print(s)",0,0,0,0,1,0,0,0,0
1654,"n = int(input(""Enter number of elements:""))
print(""Enter elements:"")
array = []
for i in range(n):
    array.append(int(input()))
for i in range(n-1):
    for j in range(n-1-i):
        if array[j] > array[j+1]:
            temp = array[j]
            array[j] = array[j + 1]
            array[j + 1] = temp
print(""Sorted array is:"")
print(array)",0,0,0,0,1,0,0,0,0
1655,"arr = [-1, 10, 15, 3, 52, 19, 5, 19]
n = len(arr)
for times in range(n - 1):
    for i in range(n - times - 1):
        if arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
print(arr)",0,0,0,0,1,0,0,0,0
1656,"def bubble_sort(L):
    swap = False
    step = 0
    while not swap: 
        swap = True
        for j in range(1,len(L)): 
            if L[j-1]>L[j]:
                swap = False
                temp = L[j]
                L[j] = L[j-1]
                L[j-1] = temp
            step += 1
            print(step, swap, j,L)
    return L
bubble_sort([10,9,8,7,6,5,4])",0,0,0,0,1,0,0,0,0
1657,"def bubble_sort(elements, key=None):
    size = len(elements)
    for i in range(size-1):
        swapped = False
        for j in range(size-1-i):
            a = elements[j][key]
            b = elements[j+1][key]
            if a > b:
                tmp = elements[j]
                elements[j] = elements[j+1]
                elements[j+1] = tmp
                swapped = True
        if not swapped:
            break
if __name__ == '__main__':
    elements = [
        { 'name': 'mona',   'transaction_amount': 1000, 'device': 'iphone-10'},
        { 'name': 'dhaval', 'transaction_amount': 400,  'device': 'google pixel'},
        { 'name': 'kathy',  'transaction_amount': 200,  'device': 'vivo'},
        { 'name': 'aamir',  'transaction_amount': 800,  'device': 'iphone-8'},
    ]
    bubble_sort(elements, key='transaction_amount')
    print(elements)",0,0,0,0,1,0,0,0,0
1658,"def bubble_sort(array):
	for i in range(len(array)-1):
		for j in range (len(array)-1-i):
			if array[j] > array[j+1]:
				temp = a[j+1]
    array[j+1] = array[j]
    array[j] = temp
  return array
array = [1,2,4,3,7,6]
array=bubble_sort(array)
print(array)",0,0,0,0,1,0,0,0,0
1659,"import java.util.Arrays;
public class Bubble {
    public static void main(String[] args) {
        int[] myarr = {34, 23, 34, 2, 3, 8, 4, 5};
        BubbleSort(myarr);
        System.out.println(Arrays.toString(myarr));
    }
    public static void BubbleSort(int[] arr){
        for(int i = arr.length - 1; i > 1; i--){
            for(int j = 0; j < i; j++){
                if(arr[j] > arr[j+1]){
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1]= temp;
                }
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
1660,"function bubbleSort(arr){
	for(var i = arr.length; i > 0; i--){
        for(var j = 0; j < i; j++){
            if(arr[j] > arr[j+1]){
                var temp = arr[j]
				arr[j] = arr[j+1]
				arr[j+1] = temp
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
1661,"unordered_list = [5, 2]
i = 0
first_element = unordered_list[0]
second_element = unordered_list[1]
temp = unordered_list[0]
unordered_list[0] = unordered_list[1]
unordered_list[1] = temp
print(unordered_list)
def bubble_sort(unordered_list):
    iteration_number = len(unordered_list)-1
    for i in range(iteration_number,0,-1):
        for j in range(i):
            if unordered_list[j] > unordered_list[j+1]:
                temp = unordered_list[j]
                unordered_list[j] = unordered_list[j+1]
                unordered_list[j+1] = temp
my_list = [4,3,2,1]
bubble_sort(my_list)
print(my_list)
my_list = [1,12,3,4]
bubble_sort(my_list)
print(my_list)",0,0,0,0,1,0,0,0,0
1662,"const swap = (prev, curr) => {
  const temp = prev.val;
  prev.val = curr.val;
  curr.val = temp;
};
const sortList = function(head) {
  if (head == null) return head;
  let prev = null;
  let curr = head;
  let currup = head;
  let swapped;
  while (currup) {
    do {
      swapped = false;
      while (curr) {
        if (prev && prev.val > curr.val) {
          swap(prev, curr);
          swapped = true;
        }
        prev = curr;
        curr = curr.next;
      }
    } while (swapped);
    swapped = true;
    curr = head;
    prev = null;
    currup = currup.next;
  }
  return head;
};",0,0,0,0,1,0,0,0,0
1663,"const bubbleSort = arr => {
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] > arr[i + 1]) {
        const temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        swapped = true;
      }
    }
  } while (swapped);
  return arr;
}
let array = [2,1,8,4,7,5,0]
array = bubbleSort(array)
console.log(array);",0,0,0,0,1,0,0,0,0
1664,"function bubbleSort(array) {
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i < array.length; i++) {
      if (array[i] && array[i + 1] && array[i] > array[i + 1]) {
        const temp = array[i];
        array[i] = array[i + 1];
        array[i + 1] = temp;
        swapped = true;
      }
    }
  } while (swapped);
  return array;
}",0,0,0,0,1,0,0,0,0
1665,"package sort_problem;
public class Bubble<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        boolean isSorted = false;
        for (int i = N - 1; i > 0 && !isSorted; i--) {
            isSorted = true;
            for (int j = 0; j < i; j++) {
                if (less(nums[j + 1], nums[j])) {
                    isSorted = false;
                    swap(nums, j, j + 1);
                }
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
1666,"def bubble_sort(arr):
    l = len(arr)
    for i in range(l):
        for i in range(l - 1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
    return arr",0,0,0,0,1,0,0,0,0
1667,"package Java.Sorting;
import java.io.IOException;
import java.util.*;
public class bubbleSort {
    public static void main(String args[]) throws IOException
    {
        int n;
        Scanner in=new Scanner(System.in);
        System.out.println(""enter size of array"");
        n=in.nextInt();
        int a[]=new int[n];                                  
        System.out.println(""enter array elements"");
        for(int i=0;i<n;i++)                                 
        a[i]=in.nextInt();
        for(int i=0;i<n-1;i++)                               
        {
            for(int j=0;j<n-i-1;j++)
            {
                if(a[j]>a[j+1])                              
                {
                    int t=a[j];
                    a[j]=a[j+1];
                    a[j+1]=t;
                }
            }
        }
        System.out.println(""the sorted array is :"");
        for(int i=0;i<n;i++)                                 
        System.out.print(a[i] + "" "");
    }
}",0,0,0,0,1,0,0,0,0
1668,"def bubbleSort(array):
    isSorted = False
    counter = 0
    while not isSorted:
        isSorted = True
        for i in range(len(array) -1 - counter):
        	if array[i] > array[i+1]:
             swap(i, i+1, array)
             isSorted = False
        counter += 1     
    return array
def swap(i, j , array):
    array[i], array[j] = array[j], array[i]    ",0,0,0,0,1,0,0,0,0
1669,"def bubbleSort(L):
    for j in range(len(L) - 1):
        swap = False
        for i in range(len(L) - j - 1):
            if L[i] > L[i + 1]:
                L[i], L[i + 1] = L[i + 1], L[i]
                swap = True
        if not swap:
            break
    return L",0,0,0,0,1,0,0,0,0
1670,"import random
import timeit
def bubblesort(unsorted_list):
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(unsorted_list) - 1):
            if unsorted_list[i] > unsorted_list[i + 1]:
                unsorted_list[i], unsorted_list[i + 1] = unsorted_list[i + 1], unsorted_list[i]
                swapped = True
    return unsorted_list
def _wrapper(func, *args, **kwargs): 
    def _wrapped(): 
        return func(*args, **kwargs)
    return _wrapped
if __name__ == '__main__': 
    print('Sorting list of 100 rand nums between 0-1000')
    unsorted_list = []
    for i in range(100):
        unsorted_list.append(random.randint(0, 1000))
    sorted_list = bubblesort(unsorted_list)
    bubblesort_list = _wrapper(bubblesort, unsorted_list)
    print('Time to sort 1M times:')
    print(timeit.timeit(bubblesort_list))",0,0,0,0,1,0,0,0,0
1671,"package bubble;
import sort.AbstractBase;
public class BubbleSort extends AbstractBase {
    public Integer[] basicBubbleSort(Integer array[]) {
        int n = array.length;
        int temp;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < (n - i - 1); j++) {
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        return array;
    }
    public Integer[] optimizedBubbleSort(Integer array[]) {
        int n = array.length;
        int temp;
        boolean sorted;     
        for (int i = 0; i < n; i++) {
            sorted = true;
            for (int j = 0; j < (n - i - 1); j++) {
                if (array[j] > array[j + 1]) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    sorted = false;
                }
            }
            if (sorted) break;
        }
        return array;
    }
    @Override
    public <E extends Comparable<E>> E[] genericSort(E[] array) {
        int n = array.length;
        E temp;
        boolean sorted;
        for (int i = 0; i < n; i++) {
            sorted = true;
            for (int j = 0; j < (n - i - 1); j++) {
                if (array[j].compareTo(array[j + 1]) > 0) {
                    temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                    sorted = false;
                }
            }
            if (sorted) break;
        }
        return array;
    }
}",0,0,0,0,1,0,0,0,0
1672,"function bubbleSort(arr){
    for(j=0;j<arr.length-1;j++){
      for(i=0;i<arr.length-1;i++){ 
        if(arr[i]>arr[i+1])
            [arr[i],arr[i+1]] = [arr[i+1],arr[i]]
    }
  }
    return arr;
}
console.log(bubbleSort([5,4,7,3,1,8,2,6]));  ",0,0,0,0,1,0,0,0,0
1673,"def bubble_sort(input_array):
    for i in range(len(input_array)-1):
        for pos in range(len(input_array)-1):
            if input_array[pos] > input_array[pos+1]:
                temp = input_array[pos]
                input_array[pos] = input_array[pos+1]
                input_array[pos+1] = temp
    return input_array
print(bubble_sort([21,4,1,3,9,20,25,6,21,14])) 
print(bubble_sort([3,1,7,0,8])) ",0,0,0,0,1,0,0,0,0
1674,"def bubble_sort(arr):
    for n in range(len(arr)-1,0,-1):
        for k in range(n):
            if arr[k]>arr[k+1]:
                temp = arr[k]
                arr[k] = arr[k+1]
                arr[k+1] = temp
arr = [2,7,1,8,5,9,11,35,25]
bubble_sort(arr)
print (arr)",0,0,0,0,1,0,0,0,0
1675,"print('**** OPTIMIZED BUBBLE SORT *******')
def bubbleSort(arr):
    n = len(arr)
    for i in range(0,n):
        swap = False
        for j in range(0,n-i-1):
            if(arr[j]>arr[j+1]):
                swap=True
                arr[j],arr[j+1] = arr[j+1],arr[j]
        if swap==False:
            break
if __name__=='__main__':
    n = int(input('Enter no. of elements: '))
    string_arr = input('Enter your array here: ').split(' ')
    arr = [int(num) for num in string_arr]
    bubbleSort(arr)
    print('***** SORTED ARRAY ******')
    print(arr)",0,0,0,0,1,0,0,0,0
1676,"def insertsort(A):
    _len = len(A)
    if _len <= 1:
        return A
    for i in xrange(1, _len):
        j = i
        while A[j] < A[j-1] and j > 0:
            A[j], A[j-1] = A[j-1], A[j]
            j -= 1
    return A
def selectsort(A):
    for i in xrange(len(A)):
        minIdx = i
        for j in xrange(i+1, len(A)):
            if A[j] < A[minIdx]:
                minIdx = j
        A[i], A[minIdx] = A[minIdx], A[i]
def mergesort(A):
    def divide(A, l, r):
        print l, r
        if (l >= r):
            return [A[r]]
        m = (l + r) / 2
        L = divide(A, l, m)
        R = divide(A, m+1, r)
        return merge_(L, R)
    def merge_(L, R):
        lenL, lenR = len(L), len(R)
        i, j = 0, 0
        r = []
        while i < lenL and j < lenR:
            if L[i] < R[j]:
                r.append(L[i])
                i += 1
            else:
                r.append(R[j])
                j += 1
        while i < lenL:
            r.append(L[i])
            i += 1
        while j < lenR:
            r.append(R[j])
            j += 1
        return r
    return divide(A, 0, len(A)-1)
if __name__ == '__main__':
    A = [1,3,35,5,4, 6]
    B = [6,6,6,6,6,6,6,6,6,6]
    res = mergesort(B)
    print res",0,1,1,1,0,0,0,0,0
1677,print('****** Binary Insertion Sort **********'),0,0,0,0,0,0,0,0,0
1678,"def insertion_sort(iterable):
    x = iterable[:]
    for i in range(len(x)):
        j = i
        while j > 0:
            if x[j] < x[j-1]:
                x[j], x[j-1] = x[j-1], x[j]
            else:
                break
            j -= 1
    return x
def bubble_sort(iterable):
    x = iterable[:]
    y = len(x) - 1
    while y > 0:
        i = 0
        while i < y:
            if x[i] > x[i+1]:
                x[i], x[i+1] = x[i+1], x[i]
            i += 1
        y -= 1
    return x
def time_track(size):
    import time
    a = [i for i in xrange(size)]
    print ""Best Case""
    start = time.clock()
    insertion_sort(a)
    end = time.clock()
    print ""Insertion: %.2gs"" % (end-start)
    start = time.clock()
    bubble_sort(a)
    end = time.clock()
    print ""Bubble: %.2gs"" % (end-start)
if __name__ == ""__main__"":
    size = 2000
    print ""Size: ""+str(size)
    time_track(size)
    print",0,0,0,1,1,0,0,0,0
1679,"def insertion_sort(unsorted_list):
    for index in range(1, len(unsorted_list)):
        search_index = index
        insert_value = unsorted_list[index]
        while search_index > 0 and unsorted_list[search_index-1] > insert_value:
            unsorted_list[search_index] = unsorted_list[search_index-1]
            search_index -= 1
        unsorted_list[search_index] = insert_value
my_list = [10, 11, 12, 1, 2, 3]
print(my_list)
insertion_sort(my_list)
print(my_list)",0,0,0,1,0,0,0,0,0
1680,"package Java.Sorting;
import java.util.*;
class Insertion_Sort
{
    public static void main(String args[])
    {
        int n, i, min, j;
        Scanner sc = new Scanner(System.in);
        System.out.print(""Enter the size of array:"");
        n = sc.nextInt();
        int arr[] = new int[n];
        System.out.println(""Enter the elements:"");
        for(i = 0; i < n; i++)
        {
            arr[i]= sc.nextInt();
        }
        for(i = 1; i < n; i++)
        {
            min = arr[i];
            for(j = i-1; (j>=0) && (arr[j] > min); j--)
            {
                arr[j+1] = arr[j];
            }
            arr[j+1] = min;
        }
        System.out.println(""Sorted array is:"");
        for(i = 0; i < n; i++)
        {
            System.out.print(arr[i]+"" "");
        }
    }
}",0,0,0,1,0,0,0,0,0
1681,"print('***** INSERTION SORT *********')
def insertionSort(arr):
    for j in range(1,len(arr)):
        key = arr[j]
        index = j-1
        while(index>=0 and arr[index]>key):
            arr[index+1] = arr[index]
            index-=1
        arr[index+1] = key
    return arr
n = int(input('Enter no of elements: '))
string_arr = input('Enter your array here : ').split(' ')
arr = [int(num) for num in string_arr]
arr = insertionSort(arr)
print(""SORTED ARRAY"")
print(arr)
def insertionSort(arr):
    for j in range(1,len(arr)):
        key = arr[j]
        index = j-1
        while(index>=0 and arr[index]>key):
            arr[index+1] = arr[index]
            index-=1
        arr[index+1] = key
    return arr",0,0,0,1,0,0,0,0,0
1682,"def insertion_sort1(A):
	for i in range(1, len(A)):
		for j in range(i-1, -1, -1):
			if A[j] > A[j+1]:
				A[j], A[j+1] = A[j+1], A[j]
   else:
				break
def insertion_sort2(A):
	for i in range(1, len(A)):
		j = i-1
  while A[j] > A[j+1] and j >= 0:
			A[j], A[j+1] = A[j+1], A[j]
   j -= 1
def insertion_sort3(A):
	for i in range(1, len(A)):
		curNum = A[i]
  k = 0
  for j in range(i-1, -2, -1):
			k = j
   if A[j] > curNum:
				A[j+1] = A[j]
   else:
				break
  A[k+1] = curNum
A = [5,9,1,2,4,8,6,3,7]
print(A)
insertion_sort1(A)
print(A)",0,0,0,1,1,0,0,0,0
1683,"def insertion_sort(array):
    for elem in range(len(array)):
        curr = elem
        while curr > 0 and array[curr - 1] > array[curr]:
            array[curr - 1], array[curr] = array[curr], array[curr - 1]
            curr -= 1
    return array
if __name__ == '__main__':
    print insertion_sort.func_doc
    array1 = [3, 2, 1]
    assert insertion_sort(array1) == [1, 2, 3]
    array2 = [1, 2, 3, 5, 4]
    assert insertion_sort(array2) == [1, 2, 3, 4, 5]
    array3 = range(100, 0, -1)
    assert insertion_sort(array3) == range(1, 101)",0,0,0,1,0,0,0,0,0
1684,"def insertion_sort(elements):
    for i in range(1, len(elements)):
        anchor = elements[i]
        j = i - 1
        while j>=0 and anchor < elements[j]:
            elements[j+1] = elements[j]
            j = j - 1
        elements[j+1] = anchor
if __name__ == '__main__':
    elements = [11,9,29,7,2,15,28]
    insertion_sort(elements)
    print(elements)
    tests = [
        [11,9,29,7,2,15,28],
        [3, 7, 9, 11],
        [25, 22, 21, 10],
        [29, 15, 28],
        [],
        [6]
    ]
    for elements in tests:
        insertion_sort(elements)
        print(f'sorted array: {elements}')",0,0,0,1,0,0,0,0,0
1685,"from pyllist import dllist
def ins_sort(array):
    for i in range(1, len(array)):
        for k in range(i, 0, -1):
            if array[k] < array[k - 1]:
                array[k], array[k - 1] = array[k - 1], array[k]
    return array
def ins_sort_llist(data):
    for card in data.first.next.iternext():  
        for left_card in card.iterprev():
            if left_card.prev is not None and left_card.value < left_card.prev.value:
                left_card.value, left_card.prev.value = left_card.prev.value, left_card.value
    return data
def ins_sort_llist2(data):
    for card in data.first.next.iternext():
        for left_card in data.iternodes(to=card):
            if left_card.value > card.value:
                data.remove(card)
                data.insert(card, before=left_card)
                break
    return data
data = [6, 5, 32, 8, 234, 5, 1, 9, 0, 33]
print(ins_sort(data))
data_llist = dllist([6, 5, 32, 8, 234, 5, 1, 9, 0, 33])
print(ins_sort_llist(data_llist))
data_llist = dllist([6, 5, 32, 8, 234, 5, 1, 9, 0, 33])
print(ins_sort_llist2(data_llist))",0,0,0,1,1,0,0,0,0
1686,"from doubly_linked_list import DoublyLinkedList, Node
import string
def insertion_sort(lt, val):
    if lt.len == 0:
        lt.addNodeE(Node(val))
    else:
        current = lt.head
        while True:
            if current.val <= val:
                if current.next != None:
                    current = current.next
                else:
                    lt.addNodeE(Node(val))
                    break
            else:
                node = Node(val)
                temp = current.prev
                current.setPrev(node)
                node.setNext(current)
                if temp != None:
                    node.setPrev(temp)
                    temp.setNext(node)
                else:
                    lt.head = node
                lt.len += 1
                break
    return lt
lt = DoublyLinkedList()
f = open(""insertion_example.txt"", ""r"")
for line in f:
    product = 1
    for char in line:
        if char == '\n':
            break
        elif char != ' ':
            product *= int(char)
    insertion_sort(lt, product)
lt.print()",0,0,0,1,0,0,0,0,0
1687,"def insertion_sort_increasing(A):
    for i in range(1, len(A)):
        key = A[i]
        j = i - 1
        while j >= 0 and A[j] > key:
            A[j + 1] = A[j]
            j -= 1
        A[j + 1] = key  
def insertion_sort_descending(A):
    for i in range(1, len(A)):  
        element = A[i]
        j = i
        while j and A[j - 1] < element:
            A[j] = A[j - 1]
            j -= 1
        A[j] = element
def sort(A):
    B = A[:]
    insertion_sort_increasing(A)
    insertion_sort_descending(B)
    return (A, B)
assert sort([3, 4, 5, 2, 1]) == ([1, 2, 3, 4, 5], [5, 4, 3, 2, 1])
assert sort([3, 4, 5, 2, 1, 6]) == ([1, 2, 3, 4, 5, 6], [6, 5, 4, 3, 2, 1])
assert sort([]) == ([], [])
assert sort([1]) == ([1], [1])
assert sort([2, 1]) == ([1, 2], [2, 1])",0,0,0,1,0,0,0,0,0
1688,"def insertion_sort(lst):
    for i in range(len(lst)):
        j = (i - 1)
        temp = lst[i]
        while j >= 0 and temp < lst[j]:
            lst[j+1] = lst[j]
            j = j-1
        lst[j + 1] = temp
    return lst",0,0,0,1,0,0,0,0,0
1689,"def insertion_sort(the_list):
    for each_number_index in range(1, len(the_list)):
        number_to_be_reinserted = the_list[each_number_index]
        current_index_to_compare_against = each_number_index
        while ((current_index_to_compare_against > 0)
                and (number_to_be_reinserted
                     < the_list[(current_index_to_compare_against - 1)])):
            the_list[current_index_to_compare_against]                = the_list[(current_index_to_compare_against - 1)]
            current_index_to_compare_against -= 1
        the_list[current_index_to_compare_against] = number_to_be_reinserted
    return the_list
if __name__ == '__main__':
    dict_of_lists = {
        'list_zero': [0, 0, 0, 0, 0, 0, 0, 0],
        'list_one': [0, 0, 0, 0, 1, 1, 1, 1],
        'list_two': [0, 1, 0, 1, 0, 1, 0, 1],
        'list_three': [0, 1, 1, 0, 1, 1, 0, 0],
        'list_four': [10, 100, 1000000, 10000, 1, 100000, 0, 1000],
        'list_five': [0001, 0010, 0100, 1000, 1100, 0011, 0101, 0110],
    }
    for each_list in dict_of_lists:
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(dict_of_lists[each_list]))
        sorted_list = insertion_sort(dict_of_lists[each_list])
        print(""Sorted:\n    "" + str(sorted_list))
    print(""\nPerformance is O(n) in the best case O(n^2) in the worst case.""
          ""\n\nHere's performance tests using the timeit module."")
    import timeit
    import random
    giant_quantity_list = []
    for each_pass in range(0, 1000):
        giant_quantity_list.append(random.randint(1000, 9999))
    call_string = 'insertion_sort(giant_quantity_list)'
    setup_string = 'from __main__ import insertion_sort, giant_quantity_list'
    print(""\nTime to sort a list of one thousand""
          ""\nrandom numbers between 10e3 and (10e4) - 1:"")
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    not_so_random_order_of_magnitude = (10 ** 30)
    random_list = []
    giant_quality_list = []
    for each_pass in range(0, 1000):
        topend = (not_so_random_order_of_magnitude * 10) - 1
        random_number = random.randint(not_so_random_order_of_magnitude,
                                       topend)
        giant_quality_list.append(random_number)
    call_string = 'insertion_sort(giant_quality_list)'
    setup_string = 'from __main__ import insertion_sort, giant_quality_list'
    print(""\nTime to sort a list of one thousand""
          ""\nrandom numbers between 10e30 and (10e31) - 1:"")
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    very_predictable_list = []
    very_predictable_list_with_middle_at_start = []
    for each_pass in range(0, 900):
        very_predictable_list.append(each_pass)
        very_predictable_list_with_middle_at_start.append(each_pass)
    very_predictable_list_with_middle_at_start.insert(0, 450)
    print(""\nFor comparison, here's quicksort's worst case with a 900-point list.""
          ""\nBeing sorted, this is also insertion sort's BEST case."")
    call_string = 'insertion_sort(very_predictable_list)'
    setup_string = 'from __main__ import insertion_sort, very_predictable_list'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    print(""\nSame list, midpoint put under where quicksort would put its pivot:"")
    call_string = 'insertion_sort(very_predictable_list_with_middle_at_start)'
    setup_string = 'from __main__ import insertion_sort, very_predictable_list_with_middle_at_start'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    backwards_list = []
    for each_pass in range(899, -1, -1):
        backwards_list.append(each_pass)
    print(""\nHere's insertion sort's WORST case:""
          ""\nThat same 900-point list... sorted in reverse order!"")
    call_string = 'insertion_sort(backwards_list)'
    setup_string = 'from __main__ import insertion_sort, backwards_list'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    raw_input(""\nPress enter to begin testing insertion_sort on strings.\n> "")
    strings_dict = {
        'list_six': ""Not the most useful application for sorting."",
        'list_seven': ""badcfehgjilknmporqtsvuxwzy"",
        'list_eight': ""list_seven is not as random as it may appear"",
        'list_nine': ""the quick brown fox jumps over the lazy dog"",
    }
    def sort_string(input_string):
        sorting_list = []
        for each_character in input_string:
            sorting_list.append(ord(each_character))
        sorting_list = insertion_sort(sorting_list)
        return_list = []
        for each_number in sorting_list:
            return_list.append(chr(each_number))
        return [''.join(return_list)][0]
    for each_list in strings_dict:
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(strings_dict[each_list]))
        sorted_list = sort_string(strings_dict[each_list])
        print(""Sorted:\n    "" + str(sorted_list))
    proceed = raw_input(""\n\nPress enter to very spammily test insertion_sort""
                        ""\non random lists, or press control-c to exit.\n> "")
    print(""\n\n===================\nBegin random tests.\n==================="")
    import random
    for each_pass in range(0, 100):
        random_list = []
        for each_number in range(0, random.randint(3, 40)):
            random_number = random.randint(0, random.randint(1, 1000))
            random_list.append(random_number)
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(random_list))
        sorted_random_list = insertion_sort(random_list)
        print(""Sorted:\n    "" + str(sorted_random_list))
        assert len(random_list) == len(sorted_random_list)
        for each_number in range(0, (len(sorted_random_list) - 1)):
            assert (sorted_random_list[each_number]
                    <= sorted_random_list[(each_number + 1)])
    print",0,0,0,1,0,0,0,0,0
1690,"def insertion_sort(arr):
    size = len(arr)
    for i in range(1,size):
        key = arr[i]
        j = i
        while(j > 0 and arr[j-1] > key):
            arr[j] = arr[j-1]
            j-=1
        arr[j] = key 
def main():
    arr = [int(x) for x in input().split()]
    insertion_sort(arr)
    print(arr)
if __name__ == ""__main__"":
    main()",0,0,0,1,0,0,0,0,0
1691,"import sys
class insertionSort:
    def insertion_sort(self, data):
        for i in range(1, len(data)):
            key = data[i]
            j = i - 1
            while j >= 0 and key < data[j]:
                data[j + 1] = data[j]
                j -= 1
            data[j + 1] = key
        print(data)
if __name__ == ""__main__"":
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    insertionSort().insertion_sort(data)",0,0,0,1,0,0,0,0,0
1692,"def insertion_sort(arr):
    for i in range(1, len(arr)):
        cur_num = arr[i]
        j = i - 1
        while j >= 0 and cur_num < arr[j]:
            arr[j+1] = arr[j]
            j = j - 1
        arr[j+1] = cur_num
    return arr
if __name__ == '__main__':
    A = [20, 15, 2, 3, 25, 30, 14, 26, 5, 10, 18, 1]
    s = insertion_sort(A)
    print(s)",0,0,0,1,0,0,0,0,0
1693,"def insertion_sort(arr):
    comparisons = 0
    moves = 0
    for step in range(1,len(arr)):
        key = arr[step]
        i = step - 1
        while i >= 0 and key < arr[i]:
            arr[i + 1] = arr[i]
            i = i - 1
            comparisons += 1
        if arr[i + 1] != key:
        	arr[i + 1] = key
         print(arr)
         moves += 1
    return (comparisons, moves)
data = [6,2,4,3,5,1,7]
comparisons, moves = insertion_sort(data)
print(f'Sorted Array in Ascending Order: {data}')
print(f'Sorted in {moves} moves and {comparisons} comparisons')",0,0,0,1,0,0,0,0,0
1694,"arr = [-1, 10, 15, 3, 5, 19, 5, 19]
n = len(arr)
for i in range(1, n):
    current = arr[i]
    prev = i - 1
    while prev >= 0 and arr[prev] > current:
        arr[prev + 1] = arr[prev]
        prev = prev - 1
    arr[prev + 1] = current
print(arr)",0,0,0,1,0,0,0,0,0
1695,"def place_to_insert(array, key):
    index = 0
    for i in array:
        if i > key:
            break
        else:
            index += 1
    return index
def insert_to_sorted(array, key):
    index = place_to_insert(array, key)
    return array[0:index]+[key]+array[index:]
if __name__ == ""__main__"":
    array = [2, 1, 5, 7, 2, 0, 5]
    stream = []
    count = 0
    while(True):
        i = int(input())
        count += 1
        stream = insert_to_sorted(stream, i)
        if count % 2 == 1:
            print(f""Median of {stream} : {stream[(count)//2]}"")
        else:
            i1 = count//2
            i2 = (count//2) - 1
            print(f""Median of {stream} : {(stream[i1] + stream[i2])/2}"")",0,0,0,0,0,0,0,0,0
1696,"def insertion_sort(L):
  if len(L) > 1:                    
    marker = L.first()
    while marker != L.last():
      pivot = L.after(marker)       
      value = pivot.element()
      if value > marker.element():  
        marker = pivot              
      else:                         
        walk = marker               
        while walk != L.first() and L.before(walk).element() > value:
          walk = L.before(walk)
        L.delete(pivot)
        L.add_before(walk, value)   ",0,0,0,1,0,0,0,0,0
1697,"import java.util.Arrays;
public class Insert {
    public static void sortInsert(Integer[] arr){
        for(int i = 0; i < arr.length; i++){
            int j = i;
            while(j > 0 && arr[j] < arr[j - 1]){
                int temp = arr[j];
                arr[j] = arr[j-1];
                arr[j-1] = temp;
                j--;
            }
        }
    }
    public static void main(String[] args) {
        Integer[] a = new Integer[]{5, 6, 4, 3};
        System.out.println(Arrays.toString(a));
        sortInsert(a);
        System.out.println(Arrays.toString(a));
    }
}",0,0,0,1,0,0,0,0,0
1698,"print('***** INSERTION SORT *********')
def insertionSort(arr):
    for j in range(1,len(arr)):
        key = arr[j]
        index = j-1
        while(index>=0 and arr[index]>key):
            arr[index+1] = arr[index]
            index-=1
        arr[index+1] = key
    return arr
n = int(input('Enter no of elements: '))
string_arr = input('Enter your array here : ').split(' ')
arr = [int(num) for num in string_arr]
arr = insertionSort(arr)
print(""SORTED ARRAY"")
print(arr)
def insertionSort(arr):
    for j in range(1,len(arr)):
        key = arr[j]
        index = j-1
        while(index>=0 and arr[index]>key):
            arr[index+1] = arr[index]
            index-=1
        arr[index+1] = key
    return arr",0,0,0,1,0,0,0,0,0
1699,"const insertionSort = arr => {
  for (let i = 0; i < arr.length; i++) {
    let temp = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > temp) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = temp;
  }
  return arr;
 }
 let array = [2,1,7,0,9,4,6,5];
 array = insertionSort(array);
 console.log(array);",0,0,0,1,0,0,0,0,0
1700,"const InsertionSort = array => {
  for (let pos = 0; pos < array.length; ++pos)
  Insert(array, pos, array[pos]);
};
const Insert = (array, pos, val) => {
  let i = pos - 1;
  while (i >= 0 && array[i] > val) {
    array[i + 1] = array[i];
    i--;
  }
  array[i + 1] = val;
};
const A = [3, 4, 6, 1, 2, 9, 5];
InsertionSort(A);",0,0,0,1,0,0,0,0,0
1701,"def insertionSort(array):
    for step in range(1, len(array)):
        key = array[step]
        j = step - 1
        while j >= 0 and key < array[j]:
            array[j + 1] = array[j]
            j = j - 1
        array[j + 1] = key
data = list(map(int, input().split("","")))
insertionSort(data)
print('Sorted Array in Ascending Order:')
print(data)",0,0,0,1,0,0,0,0,0
1702,"package sort_problem;
public class Insertion<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0 && less(nums[j], nums[j - 1]); j--) {
                swap(nums, j, j - 1);
            }
        }
    }
}",0,0,0,0,1,0,0,0,0
1703,"from random import randint, shuffle
from timeit import timeit
def insertion_sort(arr):
    l = len(arr)
    for i in range(1, l):
        while i - 1 != -1:
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
            if i != 0:
                i = i - 1
    return arr
def timings():  
    import_sort = 'from insertion import insertion_sort'
    print(""""""
    Timings for best, average and worst case scenarios for the insertion sort.
    --------------------------------------------------------------------------
    """""")
    print(""3 Best Case Scenarios - sorted except for one value"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        rand_lst[6], rand_lst[-1] = rand_lst[-1], rand_lst[6]
        best_time = timeit('insertion_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
    print(""\n3 Average Case Scenarios - Moderately sorted"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        shuffle(rand_lst)
        best_time = timeit('insertion_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
    print(""\n3 Worst Case Scenarios - Completely unsorted"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        rand_lst = rand_lst[::-1]
        best_time = timeit('insertion_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
if __name__ == '__main__':  
    timings()",0,0,0,1,0,0,0,0,0
1704,"package insertion;
import sort.AbstractBase;
public class InsertionSort extends AbstractBase {
    public Integer[] sort(Integer array[]){
        int n=array.length, j;
        int value;
        for(int i=1; i<n; i++){
            j = i;
            value = array[i];
            while(j>0 && array[j-1]>value){
                array[j] = array[j-1];
                j--;
            }
            array[j] = value;
        }
        return array;
    }
    @Override
    public <E extends Comparable<E>> E[] genericSort(E[] array) {
        int n=array.length, j;
        E value;
        for(int i=1; i<n; i++){
            j = i;
            value = array[i];
            while(j>0 && array[j-1].compareTo(value)>0) {
                array[j] = array[j-1];
                j--;
            }
            array[j] = value;
        }
        return array;
    }
}",0,0,0,1,0,0,0,0,0
1705,"def insertionSort(arr):
    for i in range(1, len(arr)):
        j = i
        key = arr[j]
        while j > 0 and key < arr[j - 1]:
            arr[j] = arr[j - 1]
            j -= 1
        arr[j] = key
    return arr",0,0,0,1,0,0,0,0,0
1706,"import random
import timeit
def insertionsort(unsorted_list):
    for i in range(1, len(unsorted_list)):
        current_val = unsorted_list[i]
        while i > 0 and unsorted_list[i - 1] > current_val:
            unsorted_list[i] = unsorted_list[i - 1]
            i = i - 1
        unsorted_list[i] = current_val
    return unsorted_list
def _wrapper(func, *args, **kwargs): 
    def _wrapped(): 
        return func(*args, **kwargs)
    return _wrapped
if __name__ == '__main__': 
    print('Sorting list of 100 rand nums between 0-1000')
    unsorted_list = []
    for i in range(100):
        unsorted_list.append(random.randint(0, 1000))
    sorted_list = insertionsort(unsorted_list)
    insertionsort_list = _wrapper(insertionsort, unsorted_list)
    print('Time to sort 1M times:')
    print(timeit.timeit(insertionsort_list))",0,0,0,1,0,0,0,0,0
1707,"package insertionSort;
public class InsertionSort {
    public static int[] insertionSort(int[] arr){
        for(int i = 1; i < arr.length; i++){
            int j = i - 1;
            int temp = arr[i];
            while( j >= 0 && temp < arr[j]){
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = temp;
        }
        return arr;
    }
}",0,0,0,1,0,0,0,0,0
1708,"def insertion_sort(arr):
    for i in range(1,len(arr)):
        currentvalue = arr[i]
        position = i
        while position>0 and arr[position-1]>currentvalue:
            arr[position]=arr[position-1]
            position = position-1
        arr[position]=currentvalue
arr = [2,7,1,8,5,9,11,35,25]
insertion_sort(arr)
print (arr)",0,0,0,1,0,0,0,0,0
1709,"def insertionSort(a):
	end = len(a) -1 
 for right in range(0,end): 
		left = right
  while left >= 0 and a[left] > a[left+1]:
			a[left],a[left+1] = a[left+1],a[left]
   left -= 1
import random
alist = [5,4,3,2,1,1,3,2,1]
random.shuffle(alist)
print(""input >>>"", alist)
insertionSort(alist)
print(""insertion sort:"",alist)",0,0,0,1,0,0,0,0,0
1710,"def merge_sort(input_list):
   print(""splitting -> "",input_list)
   if len(input_list) > 1:
       mid = len(input_list)//2
       left_half = input_list[:mid]
       right_half = input_list[mid:]
       merge_sort(left_half)
       merge_sort(right_half)
       i=0
       j=0
       k=0
       while i < len(left_half) and j < len(right_half):
           if left_half[i] < right_half[j]:
               input_list[k]=left_half[i]
               i=i+1
           else:
               input_list[k]=right_half[j]
               j=j+1
           k=k+1
       while i < len(left_half):
           input_list[k]=left_half[i]
           i=i+1
           k=k+1
       while j < len(right_half):
           input_list[k]=right_half[j]
           j=j+1
           k=k+1
   print(""Merging "",input_list)
in_list = [54,26,93,17,77,31,44,55,20]
merge_sort(in_list)
print(in_list)",0,1,0,0,0,0,0,0,0
1711,"import sys
def merge_sort(A):
	merge_sort2(A, 0, len(A)-1)
def merge_sort2(A, first, last):
	if first < last:
		middle = (first + last)//2
  merge_sort2(A, first, middle)
  merge_sort2(A, middle+1, last)
  merge(A, first, middle, last)
def merge(A, first, middle, last):
	L = A[first:middle+1]
 R = A[middle+1:last+1]
 L.append(sys.maxsize)
 R.append(sys.maxsize)
 i = j = 0
 for k in range (first, last+1):
		if L[i] <= R[j]:
			A[k] = L[i]
   i += 1
  else:
			A[k] = R[j]
   j += 1
A = [5,9,1,2,4,8,6,3,7]
print(A)
merge_sort(A)
print(A)",0,1,0,0,0,0,0,0,0
1712,"def merge_sort(array):
    if len(array) <= 1:
        return array
    else:
        middle = len(array) / 2
        left = array[:middle]
        right = array[middle:]
        left = merge_sort(left)
        right = merge_sort(right)
        return _merge(left, right)
def _merge(left_array, right_array):
    merged = []
    while len(left_array) > 0 or len(right_array) > 0:
        if len(left_array) > 0 and len(right_array) > 0:
            if left_array[0] <= right_array[0]:
                merged.append(left_array.pop(0))
            else:
                merged.append(right_array.pop(0))
        elif len(left_array) > 0:
            merged.append(left_array.pop(0))
        elif len(right_array) > 0:
            merged.append(right_array.pop(0))
    return merged
if __name__ == '__main__':
    print merge_sort.func_doc
    array1 = [3, 2, 1]
    assert merge_sort(array1) == [1, 2, 3]
    array2 = [1, 2, 3, 5, 4]
    assert merge_sort(array2) == [1, 2, 3, 4, 5]
    array3 = range(100, 0, -1)
    assert merge_sort(array3) == range(1, 101)",0,1,0,0,0,0,0,0,0
1713,"def merge_sort(iterable):
    x = iterable[:]
    size = len(x)>>1
    return _tail_merge(x[:size], x[size:])
def _tail_merge(left, right):
    if len(right) == 0:
        return left
    elif len(left) == 0:
        return right
    else:
        l = len(left) >> 1
        r = len(right) >> 1
        x = _tail_merge(left[:l], left[l:])
        y = _tail_merge(right[:r], right[r:])
        return _join(x, y)
def _join(x, y):
    result = []
    ix = iy = 0
    while True:
        if ix == len(x):
            for i in y[iy:]:
                result.append(i)
            break
        elif iy == len(y):
            for i in x[ix:]:
                result.append(i)
            break
        else:
            if x[ix] < y[iy]:
                result.append(x[ix])
                ix += 1
            else:
                result.append(y[iy])
                iy += 1
    return result
if __name__ == ""__main__"":
    import time
    size = 10
    print ""Size: ""+str(size)
    a = [size-i for i in xrange(size)]
    b = [i for i in xrange(size)]
    start = time.clock()
    merge_sort(a)
    end = time.clock()
    print ""Worst Case %.2gs"" % (end-start)
    start = time.clock()
    merge_sort(b)
    end = time.clock()
    print ""Best Case %.2gs"" % (end-start)",0,1,0,0,0,0,0,0,0
1714,"from linked_list import Node, LinkedList
import string
f = open(""text.txt"", ""r"") 
line = f.read()
table = str.maketrans(string.punctuation, ""                                "")
newline = line.translate(table).lower()
def getWordList(line):                                  
    wordList = LinkedList()
    temp = ''
    for char in line:
        if char != ' ':
            temp = temp + char
        else:
            if temp != '':
                wordList.addNodeE(Node(temp))
                temp = ''
    return wordList
def getNumList(line):                                   
    numList = LinkedList()
    for num in line:
        numList.addNodeE(Node(num))
    return numList
def mergeSort(lt):                                      
    if lt.len < 2:
        return lt
    elif lt.len == 2:
        if lt.head.val < lt.end.val:
            return lt
        else:
            sorted_lt = LinkedList()
            sorted_lt.addNodeH(Node(lt.end.val))
            sorted_lt.addNodeE(Node(lt.head.val))
            return sorted_lt
    else:
        a,b = divideList(lt)
        sorted_a = mergeSort(a)
        sorted_b = mergeSort(b)
        return sortedMerge(sorted_a,sorted_b)
def divideList(lt):                                     
    half_index = int(lt.len/2.0)
    a = LinkedList()
    for i in range(half_index):
        a.addNodeE(Node(lt.head.val))
        lt.delNodeH()
    return a, lt
def sortedMerge(a,b):                                   
    sorted_list = LinkedList()
    while a.len !=0 and b.len !=0:
        if a.head.val < b.head.val:
            sorted_list.addNodeE(Node(a.head.val))
            a.delNodeH()
        else:
            sorted_list.addNodeE(Node(b.head.val))
            b.delNodeH()
    if a.len == 0:
        sorted_list.addNodeE(b.head)
    else:
        sorted_list.addNodeE(a.head)
    return sorted_list
x = getWordList(newline)
x = mergeSort(x)
l = [2,6,2340,734,723,886,4,55]
y = getNumList(l)
y = mergeSort(y)",0,1,0,0,0,0,0,0,0
1715,"def merge(A, low, mid, high):
    first = A[low:mid + 1]  
    second = A[mid + 1:high + 1]
    i = 0
    j = 0
    k = low
    while i < len(first) and j < len(second):
        if first[i] < second[j]:
            A[k] = first[i]
            i += 1
        else:
            A[k] = second[j]
            j += 1
        k += 1
    while i < len(first):
        A[k] = first[i]
        i += 1
        k += 1
    while j < len(second):
        A[k] = second[j]
        j += 1
        k += 1
def merge_sort(A, low, high):
    if low < high:
        mid = low + (high - low) // 2
        merge_sort(A, low, mid)
        merge_sort(A, mid + 1, high)
        merge(A, low, mid, high)
def sort(A):
    merge_sort(A, 0, len(A) - 1)
    return A  
assert sort([3, 4, 5, 2, 1]) == [1, 2, 3, 4, 5]
assert sort([3, 4, 5, 2, 1, 6]) == [1, 2, 3, 4, 5, 6]
assert sort([]) == []
assert sort([1]) == [1]
assert sort([2, 1]) == [1, 2]",0,1,0,0,0,0,0,0,0
1716,"def merge_sort(lst):
    length = len(lst)
    if length > 1:
        middle = length // 2     
        left = lst[:middle]
        right = lst[middle:]
        merge_sort(left)
        merge_sort(right)
        merge(left, right, lst)
    return lst
def merge(left, right, lst):
    i = 0
    j = 0
    k = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            lst[k] = left[i]
            i += 1
        else:
            lst[k] = right[j]
            j += 1
        k += 1
    while i < len(left):
        lst[k] = left[i]
        i += 1
        k += 1
    while j < len(right):
        lst[k] = right[j]
        j += 1
        k += 1",0,1,0,0,0,0,0,0,0
1717,"class Solution:
    def sortArray(self, nums):
        return self.merge_sort(nums)
    def merge(self, list_left, list_right):
        if len(list_left) == 0:
            return list_right
        elif len(list_right) == 0:
            return list_left
        index_left = index_right = 0
        list_merged = []  
        list_len_target = len(list_left) + len(list_right)
        while len(list_merged) < list_len_target:
            if list_left[index_left] <= list_right[index_right]:
                list_merged.append(list_left[index_left])
                index_left += 1
            else:
                list_merged.append(list_right[index_right])
                index_right += 1
            if index_right == len(list_right):
                list_merged += list_left[index_left:]
                break
            elif index_left == len(list_left):
                list_merged += list_right[index_right:]
                break
        return list_merged
    def merge_sort(self, nums):
        if len(nums) <= 1:
            return nums
        else:
            mid = len(nums) // 2
            left = nums[:mid]
            right = nums[mid:]
            return self.merge(self.merge_sort(left), self.merge_sort(right))",0,1,0,0,0,0,0,0,0
1718,"def merge_sort(the_input):
    if len(the_input) <= 1:
        return the_input
    halfway_mark = len(the_input) // 2
    left_half = the_input[:halfway_mark]
    right_half = the_input[halfway_mark:]
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    return merge_while_sorting(left_half, right_half)
def merge_while_sorting(left_half, right_half):
    merged_list = []
    while len(left_half) > 0 or len(right_half) > 0:
        if len(left_half) > 0 and len(right_half) > 0:
            if left_half[0] <= right_half[0]:
                merged_list.append(left_half[0])
                left_half = left_half[1:]
            elif right_half[0] < left_half[0]:
                merged_list.append(right_half[0])
                right_half = right_half[1:]
        elif len(left_half) > 0:
            merged_list.append(left_half[0])
            left_half = left_half[1:]
        elif len(right_half) > 0:
            merged_list.append(right_half[0])
            right_half = right_half[1:]
    return merged_list
if __name__ == '__main__':
    import random
    for each_pass in range(0, 100):
        random_list = []
        for each_number in range(0, random.randint(3, 40)):
            random_number = random.randint(0, random.randint(1, 1000))
            random_list.append(random_number)
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(random_list))
        sorted_random_list = merge_sort(random_list)
        print(""Sorted:\n    "" + str(sorted_random_list))
        assert len(random_list) == len(sorted_random_list)
        for each_number in range(0, (len(sorted_random_list) - 1)):
            assert (sorted_random_list[each_number]
                    <= sorted_random_list[(each_number + 1)])
    print(""\n\n===================\nBegin numeric tests.\n==================="")
    dict_of_lists = {
        'list_zero': [0, 0, 0, 0, 0, 0, 0, 0],
        'list_one': [0, 0, 0, 0, 1, 1, 1, 1],
        'list_two': [0, 1, 0, 1, 0, 1, 0, 1],
        'list_three': [0, 1, 1, 0, 1, 1, 0, 0],
        'list_four': [10, 100, 1000000, 10000, 1, 100000, 0, 1000],
        'list_five': [0001, 0010, 0100, 1000, 1100, 0011, 0101, 0110],
    }
    for each_list in dict_of_lists:
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(dict_of_lists[each_list]))
        sorted_list = merge_sort(dict_of_lists[each_list])
        print(""Sorted:\n    "" + str(sorted_list))
    print(""\nPerformance is O(nlogn) in the best, worst, and typical cases.""
          ""\nIt's very predictable that way.""
          ""\n\nHere's performance tests using the timeit module."")
    import timeit
    import random
    giant_quantity_list = []
    for each_pass in range(0, 10000):
        giant_quantity_list.append(random.randint(1000, 9999))
    call_string = 'merge_sort(giant_quantity_list)'
    setup_string = 'from __main__ import merge_sort, giant_quantity_list'
    print(""\nTime to sort a list of ten thousand""
          ""\nrandom numbers between 10e3 and (10e4) - 1:"")
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    not_so_random_order_of_magnitude = (10 ** 30)
    random_list = []
    giant_quality_list = []
    for each_pass in range(0, 10000):
        topend = (not_so_random_order_of_magnitude * 10) - 1
        random_number = random.randint(not_so_random_order_of_magnitude,
                                       topend)
        giant_quality_list.append(random_number)
    call_string = 'merge_sort(giant_quality_list)'
    setup_string = 'from __main__ import merge_sort, giant_quality_list'
    print(""\nTime to sort a list of ten thousand""
          ""\nrandom numbers between 10e30 and (10e31) - 1:"")
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    very_predictable_list = []
    very_predictable_list_with_middle_at_start = []
    for each_pass in range(0, 900):
        very_predictable_list.append(each_pass)
        very_predictable_list_with_middle_at_start.append(each_pass)
    very_predictable_list_with_middle_at_start.insert(0, 450)
    print(""\nBecause merge_sort is very predictable, it has no worst case.""
          ""\nHere's Quicksort's worst case with a 900-point list:"")
    call_string = 'merge_sort(very_predictable_list)'
    setup_string = 'from __main__ import merge_sort, very_predictable_list'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    print(""\nSame list, midpoint put under what""
          ""\nwould be Quicksort's pivot spot:"")
    call_string = 'merge_sort(very_predictable_list_with_middle_at_start)'
    setup_string = 'from __main__ import merge_sort, very_predictable_list_with_middle_at_start'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    raw_input(""\n    Press enter to begin testing sorting on strings."")
    strings_dict = {
        'list_six': ""Not the most useful application for sorting."",
        'list_seven': ""badcfehgjilknmporqtsvuxwzy"",
        'list_eight': ""list_seven is not as random as it may appear"",
        'list_nine': ""the quick brown fox jumps over the lazy dog"",
    }
    def sort_string(input_string):
        sorting_list = []
        for each_character in input_string:
            sorting_list.append(ord(each_character))
        sorting_list = merge_sort(sorting_list)
        return_list = []
        for each_number in sorting_list:
            return_list.append(chr(each_number))
        return [''.join(return_list)][0]
    for each_list in strings_dict:
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(strings_dict[each_list]))
        sorted_list = sort_string(strings_dict[each_list])
        print(""Sorted:\n    "" + str(sorted_list))
    print",0,1,0,0,0,0,0,0,0
1719,"def merge(arr, left, middle, right):
    count_left  = middle - left + 1 
    count_right = right - middle    
    left_subarray  = []
    right_subarray = []
    for i in range(0, count_left):
        left_subarray.append(arr[left + i])
    for j in range(0, count_right):
        right_subarray.append(arr[middle + 1 + j])
    i = 0    
    j = 0    
    k = left 
    while i < count_left and j < count_right:
        if left_subarray[i] <= right_subarray[j]:
            arr[k] = left_subarray[i]
            i += 1
        else:
            arr[k] = right_subarray[j]
            j += 1
        k += 1
    while i < count_left:
        arr[k] = left_subarray[i]
        i += 1
        k += 1
    while j < count_right:
        arr[k] = right_subarray[j]
        j += 1
        k += 1
def merge_sort(arr, left, right):
    if left < right:
        middle = (left + right) // 2
        merge_sort(arr, left, middle)
        merge_sort(arr, middle + 1, right)
        merge(arr, left, middle, right)
def main():
    arr = [int(x) for x in input().split()]
    merge_sort(arr, 0, len(arr) - 1)
    print(arr)
if __name__ == ""__main__"":
    main()",0,1,0,0,0,0,0,0,0
1720,"import sys
class MergeSort:
    def merge_sort(self, data):
        if len(data) > 1:
            mid = len(data) // 2
            left = data[:mid]
            right = data[mid:]
            self.merge_sort(left)
            self.merge_sort(right)
            i = 0
            j = 0
            k = 0
            while i < len(left) and j < len(right):
                if left[i] < right[j]:
                    data[k] = left[i]
                    i += 1
                else:
                    data[k] = right[j]
                    j += 1
                k += 1
            while i < len(left):
                data[k] = left[i]
                i += 1
                k += 1
            while j < len(right):
                data[k] = right[j]
                j += 1
                k += 1
if __name__ == ""__main__"":
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    MergeSort().merge_sort(data)
    print(data)",0,1,0,0,0,0,0,0,0
1721,"import random
def merge_two_sorted_list(a, b):
    len_a = len(a)
    len_b = len(b)
    sorted_list = []
    i = j = 0
    while i < len_a and j < len_b:
        if a[i] <= b[j]:
            sorted_list.append(a[i])
            i += 1
        else:
            sorted_list.append(b[j])
            j += 1
    while i < len_a:
        sorted_list.append(a[i])
        i += 1
    while j < len_b:
        sorted_list.append(b[j])
        j += 1
    return sorted_list
def mergeSort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left, right = arr[:mid], arr[mid:]
    left = mergeSort(left)
    right = mergeSort(right)
    return merge_two_sorted_list(left, right)
if __name__ == ""__main__"":
    A = [random.randint(0, 100) for i in range(20)]
    print(A)
    sort = mergeSort(A)
    print(sort)",0,1,0,0,0,0,0,0,0
1722,"from random import randint, shuffle
from timeit import timeit
def merge_sort(nums):
    half = int(len(nums) // 2)
    if len(nums) == 1:
        return nums
    if len(nums) == 2:
        if nums[0] > nums[1]:
            nums[0], nums[1] = nums[1], nums[0]
        return nums
    left = merge_sort(nums[:half])
    right = merge_sort(nums[half:])
    output = []
    left_ct = 0
    right_ct = 0
    while left_ct < len(left) and right_ct < len(right):
        if left[left_ct] < right[right_ct]:
            output.append(left[left_ct])
            left_ct += 1
        else:
            output.append(right[right_ct])
            right_ct += 1
    if left_ct == len(left):
        output += right[right_ct:]
    elif right_ct == len(right):
        output += left[left_ct:]
    return output
def timings():  
    import_sort = 'from merge_sort import merge_sort'
    print(""""""
    Timings for best, average and worst case scenarios for the merge sort.
    --------------------------------------------------------------------------
    """""")
    print(""3 Best Case Scenarios - sorted except for one value"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        rand_lst[6], rand_lst[-1] = rand_lst[-1], rand_lst[6]
        best_time = timeit('merge_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
    print(""\n3 Average Case Scenarios - Moderately sorted"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        shuffle(rand_lst)
        best_time = timeit('merge_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
    print(""\n3 Worst Case Scenarios - Completely unsorted"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        rand_lst = rand_lst[::-1]
        best_time = timeit('merge_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
if __name__ == '__main__':  
    timings()",0,1,0,0,0,0,0,0,0
1723,"def merge_sort(elements, key, descending=False):
    size = len(elements)
    if size == 1:
        return elements
    left_list = merge_sort(elements[0:size//2], key, descending)
    right_list = merge_sort(elements[size//2:], key, descending)
    sorted_list = merge(left_list, right_list, key, descending)
    return sorted_list
def merge(left_list, right_list, key, descending=False):
    merged = []
    if descending:
        while len(left_list) > 0 and len(right_list) > 0:
            if left_list[0][key] >= right_list[0][key]:
                merged.append(left_list.pop(0))
            else:
                merged.append(right_list.pop(0))
    else:
        while len(left_list) > 0 and len(right_list) > 0:
            if left_list[0][key] <= right_list[0][key]:
                merged.append(left_list.pop(0))
            else:
                merged.append(right_list.pop(0))
    merged.extend(left_list)
    merged.extend(right_list)
    return merged
if __name__ == '__main__':
    elements = [
        { 'name': 'vedanth',   'age': 17, 'time_hours': 1},
        { 'name': 'rajab', 'age': 12,  'time_hours': 3},
        { 'name': 'vignesh',  'age': 21,  'time_hours': 2.5},
        { 'name': 'chinmay',  'age': 24,  'time_hours': 1.5},
    ]
    sorted_list = merge_sort(elements, key='time_hours', descending=True)
    print(sorted_list)",0,1,0,0,0,0,0,0,0
1724,"def merge_sort(arr):
    if len(arr) <= 1:
        return
    mid = len(arr)//2
    left = arr[:mid]
    right = arr[mid:]
    merge_sort(left)
    merge_sort(right)
    merge_two_sorted_lists(left, right, arr)
def merge_two_sorted_lists(a,b,arr):
    len_a = len(a)
    len_b = len(b)
    i = j = k = 0
    while i < len_a and j < len_b:
        if a[i] <= b[j]:
            arr[k] = a[i]
            i+=1
        else:
            arr[k] = b[j]
            j+=1
        k+=1
    while i < len_a:
        arr[k] = a[i]
        i+=1
        k+=1
    while j < len_b:
        arr[k] = b[j]
        j+=1
        k+=1
if __name__ == '__main__':
    test_cases = [
        [10, 3, 15, 7, 8, 23, 98, 29],
        [],
        [3],
        [9,8,7,2],
        [1,2,3,4,5]
    ]
    for arr in test_cases:
        merge_sort(arr)
        print(arr)",0,1,0,0,0,0,0,0,0
1725,"def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr)//2
    left = arr[:mid]
    right = arr[mid:]
    left = merge_sort(left)
    right = merge_sort(right)
    return merge_two_sorted_lists(left, right)
def merge_two_sorted_lists(a,b):
    sorted_list = []
    len_a = len(a)
    len_b = len(b)
    i = j = 0
    while i < len_a and j < len_b:
        if a[i] <= b[j]:
            sorted_list.append(a[i])
            i+=1
        else:
            sorted_list.append(b[j])
            j+=1
    while i < len_a:
        sorted_list.append(a[i])
        i+=1
    while j < len_b:
        sorted_list.append(b[j])
        j+=1
    return sorted_list
if __name__ == '__main__':
    arr = [10,3,15,7,8,23,98,29]
    print(merge_sort(arr))",0,1,0,0,0,0,0,0,0
1726,"print('******** MERGE SORT *********')
def mergeSort(arr):
    if len(arr)>1:
        mid = len(arr)//2
        Left = arr[:mid]
        Right = arr[mid:]
        mergeSort(Left)
        mergeSort(Right)
        i=j=k=0
        while i<len(Left) and j<len(Right):
            if Left[i]<Right[i]:
                arr[k] = Left[i]
                i+=1
            else:
                arr[k] = Right[j]
                j+=1
            k+=1
        while i<len(Left):
            arr[k] = Left[i]
            i+=1
            k+=1
        while j<len(Right):
            arr[k] = Right[j]
            j+=1
            k+=1
if __name__=='__main__':
    n = int(input('Enter the no. of elements: '))
    string_arr = input('Enter your array here : ').split(' ')
    arr = [int(num) for num in string_arr]
    mergeSort(arr)
    print('**** SORTED ARRAY ****')
    print(arr)",0,1,0,0,0,0,0,0,0
1727,"const merge_sort = list => {
  if (list.length == 1) return list;
  const middle_index = Math.trunc(list.length / 2);
  const left = list.slice(0, middle_index);
  const right = list.slice(middle_index + 1);
  const left_sorted = merge_sort(left);
  const right_sorted = merge_sort(right);
  return combine_sorted_list(left_sorted, right_sorted);
};
const combine_sorted_list = (list_one, list_two) => {
  let list_one_index = 0;
  let list_two_index = 0;
  const merged_list = [];
  while (list_one_index < list_one.length && list_two_index < list_two.length) {
    if (list_one[list_one_index] <= list_two[list_two_index]) {
      merged_list.push(list_one[list_one_index]);
      list_one_index++;
    } else {
      merged_list.push(list_two[list_two_index]);
      list_two_index++;
    }
  }
  while (list_one_index < list_one.length) {
    if (list_one[list_one_index] <= list_two[list_two_index]) {
      merged_list.push(list_one[list_one_index]);
      list_one_index++;
    }
  }
  while (list_two_index < list_two.length) {
    if (list_two[list_two_index] <= list_one[list_one_index]) {
      merged_list.push(list_two[list_two_index]);
      list_two_index++;
    }
  }
  return merged_list;
};",0,1,0,0,0,0,0,0,0
1728,,0,0,0,0,0,0,0,0,0
1729," const mergeSort = arr => {
  if (arr.length <= 1) return arr;
  let middle = Math.floor(arr.length / 2);
  let left = arr.slice(0, middle);
  let right = arr.slice(middle);
  return merge(
    mergeSort(left),  
    mergeSort(right));
};
const merge = (left, right) => {
  let result = [], leftIndex = 0, rightIndex = 0;
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex])
      result.push(left[leftIndex++]);
    else
      result.push(right[rightIndex++]);
  }
  return result
    .concat(left.slice(leftIndex))
    .concat(right.slice(rightIndex));
}
const merge1 = (left, right) => {
  let merged_list, index1 = 0, index2 = 0;
  while (index1 < left.length && index2 < right.length) {
    if (left[index1] <= right[index2]) 
      merged_list.push(left[index1++]);
    else 
      merged_list.push(right[index2++]);
  }
  while (index1 < left.length) merged_list.push(left[index1++]);
  while (index2 < right.length) merged_list.push(right[index2++]);
  return merged_list;
};
const mergeSort1 = arr => {
  if (arr.length <= 1) return arr;
  let mid = Math.floor(arr.length / 2);
  let left_sorted = MergeSort1(arr.slice(0, mid));
  let right_sorted = MergeSort1(arr.slice(mid));
  return merge1(left_sorted, right_sorted);
};
 let array = [2,1,7,0,9,4,6,5];
 array = mergeSort1(array);
 console.log(array);",0,1,0,0,0,0,0,0,0
1730,"const merge = (left, right) => {
  let index1 = 0, index2 = 0;
  const merged_list = [];
  while (index1 < left.length && index2 < right.length) {
    if (left[index1] <= right[index2]) 
      merged_list.push(left[index1++]);
    else 
      merged_list.push(right[index2++]);
  }
  while (index1 < left.length) merged_list.push(left[index1++]);
  while (index2 < right.length) merged_list.push(right[index2++]);
  return merged_list;
};
const MergeSort = arr => {
  if (arr.length <= 1) return arr;
  let mid = Math.floor(arr.length / 2);
  let left_sorted = MergeSort(arr.slice(0, mid));
  let right_sorted = MergeSort(arr.slice(mid));
  return merge(left_sorted, right_sorted);
};
const sortArray = function(nums) {
  return MergeSort(nums);
};",0,1,0,0,0,0,0,0,0
1731,"import heapq
def merge(lists):
    merged_list = []
    heap = [(lst[0], i, 0) for i, lst in enumerate(lists) if lst]
    heapq.heapify(heap)
    while heap:
        val, list_ind, element_ind = heapq.heappop(heap)
        merged_list.append(val)
        if element_ind + 1 < len(lists[list_ind]):
            next_tuple = (lists[list_ind][element_ind + 1],
                          list_ind,
                          element_ind + 1)
            heapq.heappush(heap, next_tuple)
    return merged_list
if __name__ == ""__main__"":
    print(merge([[1], [1, 3, 5], [1, 10, 20, 30, 40]]))",0,0,0,0,0,0,0,0,0
1732,"const mergeTwoLists = (l1, l2) => {
  if (l1 == null && l2 == null) return null;
  const preHead = new ListNode(-1);
  let prev = preHead;
  while (l1 !== null && l2 !== null) {
    if (l1.val <= l2.val) {
      prev.next = l1;
      l1 = l1.next;
    } else {
      prev.next = l2;
      l2 = l2.next;
    }
    prev = prev.next;
  }
  prev.next = l1 == null ? l2 : l1;
  return preHead.next;
};",0,0,0,0,0,0,0,0,0
1733,"const mergeTwoLists = (l1, l2) => {
  if (l1 == null && l2 == null) return null;
  else if (l1 == null) return l2;
  else if (l2 == null) return l1;
  else if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l2.next, l1);
    return l2;
  }
};",0,0,0,0,0,0,0,0,0
1734,"var merge = function(nums1, nums2) {
  let list1 = nums1.slice();
  nums1.length = [];
  let list_one_index = 0;
  let list_two_index = 0;
  while (list_one_index < list1.length && list_two_index < nums2.length) {
    if (list1[list_one_index] <= nums2[list_two_index]) {
      nums1.push(list1[list_one_index]);
      list_one_index++;
    } else {
      nums1.push(nums2[list_two_index]);
      list_two_index++;
    }
  }
  while (list_one_index < list1.length) {
    nums1.push(list1[list_one_index]);
    list_one_index++;
  }
  while (list_two_index < nums2.length) {
    nums1.push(nums2[list_two_index]);
    list_two_index++;
  }
  return nums1;
};",0,0,0,0,0,0,0,0,0
1735,"import array, tempfile, heapq, random
def gen_file(num):
    ar = array.array('i')
    f = open('large_int_file', 'w')
    for i in xrange(num):
        ar.append(random.randint(1, num))
        if len(ar) >= 100: 
            ar.tofile(f)
            del ar[:]
    f.close()
def read_in_chunks(f, size):
    while True:
        data = f.read(size)
        if not data:
            break
        yield data
def tempfile_gen(t):
    t.seek(0)
    ints = array.array('i')
    for data in read_in_chunks(t, 400):
        ints.fromstring(data)
    for each in ints:
        yield each
def merge_sortedfiles(iters):
    output = open('output.txt', 'w')
    ar = array.array('i')
    for x in heapq.merge(*iters):
        ar.append(x)
        if len(ar) >= 50: 
            ws = ','.join(map(str, ar))
            output.write(ws)
            output.write('\n')
            del ar[:] 
    if ar:
        ws = ','.join(map(str, ar))
        output.write(ws)
def sort_large_int_file():
    f = open('large_int_file', 'r')
    ar = array.array('i')
    iters = []
    for data in read_in_chunks(f, 800):
        ar.fromstring(data)
        t = tempfile.TemporaryFile()
        sorted_ar = array.array('i', sorted(ar))
        sorted_ar.tofile(t)
        iters.append( tempfile_gen(t) )
        del ar[:]  
    merge_sortedfiles(iters)
    f.close()
if __name__ == ""__main__"":
    sort_large_int_file()",0,0,0,0,0,0,0,0,0
1736,"package sort_problem;
public class MergeSort<T extends Comparable<T>> extends Sort<T> {
    protected T[] aux;
    protected void merge(T[] nums, int l, int m, int h) {
        int i = l, j = m + 1;
        for (int k = l; k <= h; k++) {
            aux[k] = nums[k];
        }
        for (int k = l; k <= h; k++) {
            if (i > m) {
                nums[k] = aux[j++];
            } else if (j > h) {
                nums[k] = aux[i++];
            } else if (aux[i].compareTo(aux[j]) <= 0) {
                nums[k] = aux[i++];  
            } else {
                nums[k] = aux[j++];
            }
        }
    }
    @Override
    public void sort(T[] nums) {
        aux = (T[]) new Comparable[nums.length];
        sort(nums, 0, nums.length - 1);
    }
    private void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int mid = l + (h - l) / 2;
        sort(nums, l, mid);
        sort(nums, mid + 1, h);
        merge(nums, l, mid, h);
    }
    public static void main(String[] args) {
        Integer[] nums = new Integer[]{3, 5, 1, 2, 4};
        new MergeSort<Integer>().sort(nums);
    }
}",0,1,0,0,0,0,0,0,0
1737,"__author__ = ""Caleb Madrigal""
__date__ = ""2015-02-13""
def merge(left, right):
    if len(left) < 1:
        return right
    elif len(right) < 1:
        return left
    else:
        first_left, *rest_left = left
        first_right, *rest_right = right
        if first_left <= first_right:
            return [first_left] + merge(rest_left, right)
        else:
            return [first_right] + merge(left, rest_right)
def mergesort(lst):
    list_len = len(lst)
    if list_len < 2:
        return lst
    if list_len == 2:
        if lst[0] <= lst[1]:
            return lst
        else:
            return [lst[1], lst[0]]
    else: 
        split_point = list_len // 2
        left = lst[0:split_point]
        right = lst[split_point:]
        left_sorted = mergesort(left)
        right_sorted = mergesort(right)
        return merge(left_sorted, right_sorted)
if __name__ == ""__main__"":
    import unittest
    testsuite = unittest.TestLoader().discover('test', pattern=""*mergesort*"")
    unittest.TextTestRunner(verbosity=1).run(testsuite)",0,1,0,0,0,0,0,0,0
1738,"package merge;
import java.util.Arrays;
import sort.AbstractBase;
public class MergeSort extends AbstractBase  {
    public Integer[] sort(Integer array[]){
        int n=array.length, i, j;
        int mid = n/2;
        Integer left[] = new Integer[mid];
        Integer right[] = new Integer[n-mid];
        for(i=0; i<mid; i++){
            left[i] = array[i];
        }
        for(j=mid; j<n; j++){
            right[j-mid] = array[j];
        }
        if(n<2){
            return array;
        } else{
            sort(left);
            sort(right);
            array = merge(left, right, array);
            left=right=null;
            return array;
        }
    }
    private Integer[] merge(Integer left[], Integer right[], Integer array[]){
        int iL=0, iR=0, iA=0;
        int nL = left.length, nR = right.length;
        while(iL<nL && iR<nR){
            if(left[iL]<=right[iR]){
                array[iA] = left[iL];
                iL++;
            } else {
                array[iA] = right[iR];
                iR++;
            }
            iA++;
        }
        while(iL<nL){
            array[iA] = left[iL];
            iL++;
            iA++;
        }
        while(iR<nR){
            array[iA] = right[iR];
            iR++;
            iA++;
        }
        return array;
    }
    @Override
    public <E extends Comparable<E>> E[] genericSort(E[] array) {
        int n=array.length;
        int mid = n/2;
        E[] left = Arrays.copyOfRange(array, 0, mid);
        E[] right = Arrays.copyOfRange(array, mid, n);
        if(n<2){
            return array;
        } else{
            genericSort(left);
            genericSort(right);
            array = merge(left, right, array);
            left=right=null;
            return array;
        }
    }
    public <E extends Comparable<E>> E[] merge(E left[], E right[], E array[]) {
        int nL = left.length, nR = right.length;
        int iL = 0,iR = 0, iA=0;
        while(iL<nL && iR<nR){
            if( (left[iL].compareTo(right[iR])) <=0){
                array[iA] = left[iL];
                iL++;
            } else{
                array[iA] = right[iR];
                iR++;
            }
            iA++;
        }
        while(iL<nL){
            array[iA] = left[iL];
            iL++;
            iA++;
        }
        while(iR<nR){
            array[iA] = right[iR];
            iR++;
            iA++;
        }
        return array;
    }
}",0,1,0,0,0,0,0,0,0
1739,"def merge_sort(input_array):
    if len(input_array) < 2:
        return input_array
    return merge(merge_sort(input_array[:len(input_array)//2]), merge_sort(input_array[len(input_array)//2:]))
def merge(lefthalf, righthalf):
    output_array = []
    l = 0
    r = 0
    while l < len(lefthalf) and r < len(righthalf):
        if lefthalf[l] < righthalf[r]:
            output_array.append(lefthalf[l])
            l += 1
        else:
            output_array.append(righthalf[r])
            r += 1
    output_array += lefthalf[l:]
    output_array += righthalf[r:]
    return output_array
arr1 = [8,3,1,7,0,10,2]
arr2 = [21,4,1,3,9,20,25,22,17,2,8]
arr1 = merge_sort(arr1)
arr2 = merge_sort(arr2)
print(arr1) 
print(arr2) ",0,1,0,0,0,0,0,0,0
1740,"package Java.Sorting; 
import java.util.Scanner;
public class MergeSort {
    void merge(int arr[], int l, int m, int r)   
    { 
    int i, j, k; 
    int n1 = m - l + 1; 
    int n2 =  r - m;    
    int L[] = new int[n1];  
    int R[] = new int[n2];   
    for (i = 0; i < n1; i++) 
        L[i] = arr[l + i]; 
    for (j = 0; j < n2; j++) 
        R[j] = arr[m + 1+ j];   
    i = 0; 
    j = 0; 
    k = l; 
    while (i < n1 && j < n2)   
    { 
        if (L[i] <= R[j]) 
        { 
            arr[k] = L[i]; 
            i++; 
        } 
        else
        { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 
      while (i < n1) 
    { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 
      while (j < n2) 
    { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
}
    void mergeSort(int arr[], int l, int r) {  
        if (l < r) {
            int m = l + (r - l) / 2;
            mergeSort(arr, l, m);  
            mergeSort(arr, m + 1, r);  
            merge(arr, l, m, r);  
        }
    }
     static void display(int arr[]) {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        System.out.println(""Enter the length of the array : "");
        int n=scanner.nextInt();
        int arr[] =new int[n];
        System.out.println(""Enter the Elements of the array :\n"");
        for(int i=0; i<arr.length; i++ ) {
            arr[i] = scanner.nextInt();
        }
        MergeSort mergeSort=new MergeSort();
        mergeSort.mergeSort(arr, 0, arr.length-1);
        for(int i=0; i<arr.length; i++ ) {
            System.out.print(arr[i]+"" "");
        }
    }
}",0,1,0,0,0,0,0,0,0
1741,"class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None
class SinglyLinkedList:
    def __init__(self, head=None):
        self.head = head
    def insert_at_beg(self, data):
        node = Node(data)
        node.next = self.head
        self.head = node
    def print_data(self):
        current = self.head
        while current is not None:
            print(current.data, '-> ', end='')
            current = current.next
        print('None')
def split(head):
    slow = head
    if slow is None or slow.next is None:
        return head, None
    fast = slow.next
    while fast is not None:
        fast = fast.next
        if fast is not None:
            fast = fast.next
            slow = slow.next
    fast = slow.next
    slow.next = None
    return head, fast
def merge(a, b):
    dummy = Node()
    dummy.next = None
    temp = SinglyLinkedList(dummy)
    tail = temp.head
    while True:
        if a is None:
            tail.next = b
            break
        elif b is None:
            tail.next = a
            break
        elif a.data <= b.data:
            tail.next = a
            a = a.next
        else:
            tail.next = b
            b = b.next
        tail = tail.next
    return temp.head.next
def merge_sort(head):
    if head is None or head.next is None:
        return head
    a, b = split(head)
    a = merge_sort(a)
    b = merge_sort(b)
    head = merge(a, b)
    return head
if __name__ == '__main__':
    linked_list = SinglyLinkedList()
    linked_list.insert_at_beg(9)
    linked_list.insert_at_beg(3)
    linked_list.insert_at_beg(2)
    linked_list.insert_at_beg(1)
    linked_list.insert_at_beg(5)
    linked_list.insert_at_beg(4)
    linked_list.insert_at_beg(8)
    linked_list.insert_at_beg(7)
    linked_list.insert_at_beg(6)
    print('before sorting')
    linked_list.print_data()
    linked_list.head = merge_sort(linked_list.head)
    print('after sorting')
    linked_list.print_data()",0,1,0,0,0,0,0,0,0
1742,"def merge(arr, l, mid, r):
    n1 = mid - l + 1
    n2 = r - mid
    Left = [0] * (n1)
    Right = [0] * (n2)
    for i in range(0, n1):
        Left[i] = arr[l + i]
    for j in range(0, n2):
        Right[j] = arr[mid + 1 + j]
    i = 0     
    j = 0     
    k = l     
    while i < n1 and j < n2:
        if Left[i] <= Right[j]:
            arr[k] = Left[i]
            i += 1
        else:
            arr[k] = Right[j]
            j += 1
        k += 1
    while i < n1:
        arr[k] = Left[i]
        i += 1
        k += 1
    while j < n2:
        arr[k] = Right[j]
        j += 1
        k += 1
def mergeSort(arr, l, r):
    if l < r:
        mid = (l+(r-1))//2
        mergeSort(arr, l, mid)
        mergeSort(arr, mid+1, r)
        merge(arr, l, mid, r)
arr = [12, 11, 13, 5, 6, 7]
n = len(arr)
print(""Input array:"")
for i in range(n):
    print(""%d"" % arr[i]),
mergeSort(arr, 0, n-1)
print(""\n\nSorted array:"")
for i in range(n):
    print(""%d"" % arr[i]),",0,1,0,0,0,0,0,0,0
1743,"def mergeSort(arr): 
    if len(arr) <= 1:
        return arr
    mid = len(arr)//2
    L = mergeSort(arr[:mid])
    R = mergeSort(arr[mid:])
    return merge(L, R)
def merge(L, R): 
    arr = []
    i, j = 0, 0
    while i < len(L) and j < len(R):
        if L[i] <= R[j]:
            arr.append(L[i])
            i += 1
        else:
            arr.append(R[j])
            j += 1
    arr += L[i:]
    arr += R[j:]
    return arr
print(merge([1,2,3], [0,4,6,8]))
print(merge([1, 2, 4],[0, 1, 3]))
print(mergeSort([2,0,1,4,3]))",0,1,0,0,0,0,0,0,0
1744,"def merge(l, r):
    i = 0
    j = 0
    res = []
    while i < len(l) and j < len(r):
        if l[i] <= r[j]:
            res.append(l[i])
            i += 1
        elif l[i] > r[j]:
            res.append(r[j])
            j += 1
    while i < len(l):
        res.append(l[i])
        i += 1
    while j < len(r):
        res.append(r[j])
        j += 1
    return res
def mergeSort(arr):
    L = len(arr)
    if L <= 1:
        return arr
    mid = int(L / 2)
    l = mergeSort(arr[:mid])
    r = mergeSort(arr[mid:])
    return merge(l, r)",0,1,0,0,0,0,0,0,0
1745,"import random
import timeit
def mergesort(unsorted_list):
    if len(unsorted_list) > 1:
        mid = len(unsorted_list) // 2
        left_half = unsorted_list[:mid]
        right_half = unsorted_list[mid:]
        mergesort(left_half)
        mergesort(right_half)
        i = 0
        j = 0
        k = 0
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                unsorted_list[k] = left_half[i]
                i = i + 1
            else:
                unsorted_list[k] = right_half[j]
                j = j + 1
            k = k + 1
        while i < len(left_half):
            unsorted_list[k] = left_half[i]
            i = i + 1
            k = k + 1
        while j < len(right_half):
            unsorted_list[k] = right_half[j]
            j = j + 1
            k = k + 1
        return unsorted_list
def _wrapper(func, *args, **kwargs): 
    def _wrapped(): 
        return func(*args, **kwargs)
    return _wrapped
if __name__ == '__main__': 
    print('Sorting list of 10 rand nums between 0-1000')
    unsorted_list = []
    for i in range(10):
        unsorted_list.append(random.randint(0, 1000))
    sorted_list = mergesort(unsorted_list)
    mergesort_list = _wrapper(mergesort, unsorted_list)
    print('Time to sort 1M times:')
    print(timeit.timeit(mergesort_list))",0,1,0,0,0,0,0,0,0
1746,"def mergesort(lst):
    if len(lst) <= 1:
        return lst
    else:
        mid = int(len(lst) / 2)
        left = mergesort(lst[:mid])
        right = mergesort(lst[mid:])
        return merge(left, right)
def merge(left, right):
    if not left:
        return right
    if not right:
        return left
    if left[0] < right[0]:
        return [left[0]] + merge(left[1:], right)
    else:
        return [right[0]] + merge(left, right[1:])
print(mergesort([10, 3, 4, 5, 8, 3, 29, 32, 7]))",0,1,0,0,0,0,0,0,0
1747,"package mergeSort;
public class MergeSort {
        public static void main(String[] args){
            int[] arr= {45,12,9,20};
            for(int a: arr){
                System.out.println(a);
            }
            System.out.println(""=================="");
            int[] res= mergeSort(arr);
            for(int a: res){
                System.out.println(a);
            }
        }
        public static int[] mergeSort(int[] arr){
            return  sortArr(arr,0,arr.length-1);
        }
        private static int[] sortArr(int[] arr,int left,int right){
            if(left>=right)return  arr;
            int mid=(left+right)/2;
            sortArr(arr,left,mid);
            sortArr(arr,mid+1,right);
            return  merge(arr,left,mid,right);
        }
        private static int[] merge(int[] arr, int left, int mid, int right){
            int[] tmp = new int[arr.length];
            int r1 = mid + 1;
            int tIndex = left;
            int cIndex=left;
            while(left <=mid && r1 <= right) {
                if (arr[left] <= arr[r1])
                    tmp[tIndex++] = arr[left++];
                else
                    tmp[tIndex++] = arr[r1++];
            }
            while (left <=mid) {
                tmp[tIndex++] = arr[left++];
            }
            while ( r1 <= right ) {
                tmp[tIndex++] = arr[r1++];
            }
            while(cIndex<=right){
                arr[cIndex]=tmp[cIndex];
                cIndex++;
            }
            return arr;
        }
}",0,1,0,0,0,0,0,0,0
1748,"const unsortedArr = [
  31,
  27,
  28,
  42,
  13,
  8,
  11,
  30,
  17,
  41,
  15,
  43,
  1,
  36,
  9,
  16,
  20,
  35,
  48,
  37,
  7,
  26,
  34,
  21,
  22,
  6,
  29,
  32,
  49,
  10,
  12,
  19,
  24,
  38,
  5,
  14,
  44,
  40,
  3,
  50,
  46,
  25,
  18,
  33,
  47,
  4,
  45,
  39,
  23,
  2,
];
const merge = (arr1, arr2) => {
  let sorted = [];
  while (arr1.length && arr2.length) {
    if (arr1[0] < arr2[0]) sorted.push(arr1.shift());
    else sorted.push(arr2.shift());
  }
  return sorted.concat(arr1.slice().concat(arr2.slice()));
};
const mergeSort = (arr) => {
  if (arr.length <= 1) return arr;
  let mid = Math.floor(arr.length / 2),
    left = mergeSort(arr.slice(0, mid)),
    right = mergeSort(arr.slice(mid));
  return merge(left, right);
};
console.log(mergeSort(unsortedArr));",0,1,0,0,0,0,0,0,0
1749,"def merge_sort(items):
  if len(items) <= 1:
    return items
  middle_index = len(items) // 2
  left_split = items[:middle_index]
  right_split = items[middle_index:]
  left_sorted = merge_sort(left_split)
  right_sorted = merge_sort(right_split)
  return merge(left_sorted, right_sorted)
def merge(left, right):
  result = []
  while (left and right):
    if left[0] < right[0]:
      result.append(left[0])
      left.pop(0)
    else:
      result.append(right[0])
      right.pop(0)
  if left:
    result += left
  if right:
    result += right
  return result",0,1,0,0,0,0,0,0,0
1750,"def merge_sort(arr):
    if len(arr)>1:
        mid = len(arr)//2
        lefthalf = arr[:mid]
        righthalf = arr[mid:]
        merge_sort(lefthalf)
        merge_sort(righthalf)
        i=0
        j=0
        k=0
        while i < len(lefthalf) and j < len(righthalf):
            if lefthalf[i] < righthalf[j]:
                arr[k]=lefthalf[i]
                i=i+1
            else:
                arr[k]=righthalf[j]
                j=j+1
            k=k+1
        while i < len(lefthalf):
            arr[k]=lefthalf[i]
            i=i+1
            k=k+1
        while j < len(righthalf):
            arr[k]=righthalf[j]
            j=j+1
            k=k+1
arr = [11,2,5,4,7,6,8,1,23]
merge_sort(arr)
print (arr)",0,1,0,0,0,0,0,0,0
1751,"import random
def mergeSort(alist):
    if len(alist)>1:
        mid = len(alist)//2
        lefthalf = alist[:mid]
        righthalf = alist[mid:]
        lefthalflength = len(lefthalf)
        righthalflength = len(righthalf)
        mergeSort(lefthalf)
        mergeSort(righthalf)
        i=0
        j=0
        k=0
        while i < lefthalflength and j < righthalflength:
            if lefthalf[i] <= righthalf[j]:   
                alist[k]=lefthalf[i]
                i=i+1
            else:
                alist[k]=righthalf[j]
                j=j+1
            k=k+1
        while i < lefthalflength:
            alist[k]=lefthalf[i]
            i=i+1
            k=k+1
        while j < righthalflength:
            alist[k]=righthalf[j]
            j=j+1
            k=k+1
alist = [54,26,93,17,77,31,44,55,20]
random.shuffle(alist)
print(""input >>>"", alist)
mergeSort(alist)
print(""merge sort >>>"", alist)
assert alist == [17, 20, 26, 31, 44, 54, 55, 77, 93], ""Merge Sort error!""",0,1,0,0,0,0,0,0,0
1752,"def merge1(l, r):
	result = []
 while l and r:
		if l[-1] > r[-1]:
			result.append(l.pop())
  else:
			result.append(r.pop())
 result+=(l+r)[::-1]
 result.reverse()
 return result
def merge2(a1,a2,l1,l2):
	i = 0
 j = 0
 result = []
 while (l1 > i and l2 > j):
		if (a1[i] == a2[j]):
			result.append(a1[i])
   result.append(a2[j])
   i +=1
   j +=1
  elif (a1[i] > a2[j]):
			result.append(a2[j])
   j += 1
  else:
			result.append(a1[i])
   i += 1
 if (l1 <= i):
		result.extend(a2[j:]) 
 if (l2 <= j):
		result.extend(a1[i:])
 return result 
a1 = [1,2,6,70,90]
a2 = [1,3,5,9]
print(""Input ==>"",a1,a2) 
result = []
result = merge2(a1,a2,len(a1),len(a2))
print(""Merged sorted output ===>"", result)",0,0,0,0,0,0,0,0,0
1753,"def quick_sort(input_list):
   quick_sort_helper(input_list, 0, len(input_list) - 1)
def quick_sort_helper(input_list,first,last):
   if first < last:
       split_point = partition(input_list, first, last)
       quick_sort_helper(input_list, first, split_point - 1)
       quick_sort_helper(input_list, split_point + 1, last)
def partition(alist,first,last):
   pivotvalue = alist[first]
   leftmark = first + 1
   rightmark = last
   done = False
   while not done:
       while leftmark <= rightmark and alist[leftmark] <= pivotvalue:
           leftmark = leftmark + 1
       while alist[rightmark] >= pivotvalue and rightmark >= leftmark:
           rightmark = rightmark -1
       if rightmark < leftmark:
           done = True
       else:
           temp = alist[leftmark]
           alist[leftmark] = alist[rightmark]
           alist[rightmark] = temp
   temp = alist[first]
   alist[first] = alist[rightmark]
   alist[rightmark] = temp
   return rightmark
alist = [54,26,93,17,77,31,44,55,20,1,100,200,21]
quick_sort(alist)
print(alist)",1,0,0,0,0,0,0,0,0
1754,"def quick_sort(A):
	quick_sort2(A, 0, len(A)-1)
def quick_sort2(A, low, hi):
	if hi-low < threshold and low < hi:
		quick_selection(A, low, hi)
 elif low < hi:
		p = partition(A, low, hi)
  quick_sort2(A, low, p - 1)
  quick_sort2(A, p + 1, hi)
def get_pivot(A, low, hi):
	mid = (hi + low) // 2
 s = sorted([A[low], A[mid], A[hi]])
 if s[1] == A[low]:
		return low
 elif s[1] == A[mid]:
		return mid
 return hi
def partition(A, low, hi):
	pivotIndex = get_pivot(A, low, hi)
 pivotValue = A[pivotIndex]
 A[pivotIndex], A[low] = A[low], A[pivotIndex]
 border = low
 for i in range(low, hi+1):
		if A[i] < pivotValue:
			border += 1
   A[i], A[border] = A[border], A[i]
 A[low], A[border] = A[border], A[low]
 return (border)
def quick_selection(x, first, last):
	for i in range (first, last):
		minIndex = i
  for j in range (i+1, last+1):
			if x[j] < x[minIndex]:
				minIndex = j
  if minIndex != i:
			x[i], x[minIndex] = x[minIndex], x[i]
A = [5,9,1,2,4,8,6,3,7]
print(A)
quick_sort(A)
print(A)",1,0,1,0,0,0,0,0,0
1755,"def quick_sort(array, start=0, end=-1):
    if end == -1:
        end = len(array) - 1
    if start < end:
        array, pivot = _partition(array, start, end)
        array = quick_sort(array, start, pivot - 1)
        array = quick_sort(array, pivot + 1, end)
    return array
def _partition(array, start, end):
    pivot_index = end
    pivot_value = array[pivot_index]
    store_index = start
    for i in range(start, end + 1):
        if array[i] < pivot_value:
            array[i], array[store_index] = array[store_index], array[i]
            store_index += 1
    array[store_index], array[end] = array[end], array[store_index]
    return array, store_index
if __name__ == '__main__':
    print quick_sort.func_doc
    array1 = [3, 2, 1]
    assert quick_sort(array1) == [1, 2, 3]
    array2 = [1, 2, 3, 5, 4]
    assert quick_sort(array2) == [1, 2, 3, 4, 5]
    array3 = range(100, 0, -1)
    assert quick_sort(array3) == range(1, 101)
    array4 = [4, 5, 7, 4, 3, 2]
    assert quick_sort(array4) == [2, 3, 4, 4, 5, 7]
    print ""tests pass""",1,0,0,0,0,0,0,0,0
1756,"def swap(a, b, arr):
    if a!=b:
        tmp = arr[a]
        arr[a] = arr[b]
        arr[b] = tmp
def quick_sort(elements, start, end):
    if start < end:
        pi = partition(elements, start, end)
        quick_sort(elements, start, pi-1)
        quick_sort(elements, pi+1, end)
def partition(elements, start, end):
    pivot_index = start
    pivot = elements[pivot_index]
    while start < end:
        while start < len(elements) and elements[start] <= pivot:
            start+=1
        while elements[end] > pivot:
            end-=1
        if start < end:
            swap(start, end, elements)
    swap(pivot_index, end, elements)
    return end
if __name__ == '__main__':
    elements = [11,9,29,7,2,15,28]
    quick_sort(elements, 0, len(elements)-1)
    print(elements)
    tests = [
        [11,9,29,7,2,15,28],
        [3, 7, 9, 11],
        [25, 22, 21, 10],
        [29, 15, 28],
        [],
        [6]
    ]
    for elements in tests:
        quick_sort(elements, 0, len(elements)-1)
        print(f'sorted array: {elements}')",1,0,0,0,0,0,0,0,0
1757,"def quick_sort(iterable):
    x = [i for i in iterable]
    m = _median(x[0], x[len(x)>>1], x[-1])
    _pivoting(x, m, 0, len(x)-1)
    return x
def _pivoting(x, med, low, hi):
    m = _swap(x, med, low, hi)
    if m < hi:
        mid = _median(x[m+1], x[(m+hi+1)>>1], x[hi])
        _pivoting(x, mid, m+1, hi)
    if m > low:
        mid = _median(x[low], x[(m+low-1)>>1], x[m-1])
        _pivoting(x, mid, low, m-1)
def _swap(x, med, low, hi):
    while low < hi:
        while x[low] < med:
            low += 1
        while x[hi] > med:
            hi -= 1
        if low > hi:
            break
        x[low], x[hi] = x[hi], x[low]
        if x[low] == x[hi] == med:
            low -= 1
        elif x[low] == med:
            low -= 1
        elif x[hi] == med:
            hi += 1
        low += 1
        hi -= 1
    return low
def _median(a, b, c):
    print a, b, c
    if a <= b <= c or a >= b >= c:
        return b
    elif b <= a <= c or b >= a >= c:
        return a
    else:
        return c
if __name__==""__main__"":
    import random
    x = [random.randint(10,100) for i in xrange(20)]
    a = [11-i for i in xrange(10)]
    print ""Original "", x
    x = quick_sort(x)
    print ""Sorted "", x",1,0,0,0,0,0,0,0,0
1758,"def quick_sort(lst, left, right):
    if left < right:
        position = partition(lst, left, right)
        quick_sort(lst, left, position - 1)
        quick_sort(lst, position + 1, right)
    return lst
def partition(lst, left, right):
    pivot = lst[right]
    low = left - 1
    for i in range(left, right):
        if lst[i] <= pivot:
            low += 1
            lst[low], lst[i] = lst[i], lst[low]
    lst[low+1], lst[right] = lst[right], lst[low+1]
    return (low + 1)",1,0,0,0,0,0,0,0,0
1759,"class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        if len(nums) == 1:
            return nums
        return self.quickSort(nums, 0, len(nums)-1)
    def partition(self, nums, start, end):
        pivot = nums[start]
        low = start + 1
        high = end
        while True:
            while low <= high and nums[high] >= pivot:
                high = high - 1
            while low <= high and nums[low] <= pivot:
                low = low + 1
            if low <= high:
                nums[low], nums[high] = nums[high], nums[low]
            else:
                break
        nums[start], nums[high] = nums[high], nums[start]
        return high
    def quickSort(self, nums, start, end):
        if start >= end:
            return
        pi = self.partition(nums, start, end)
        self.quickSort(nums, start, pi-1)
        self.quickSort(nums, pi+1, end)
        return nums",1,0,0,0,0,0,0,0,0
1760,"import sys
class QuickSort:
    def partition(self, data, low, high):
        pivot = data[high]
        i = low  
        j = low  
        while j < high:
            if data[j] < pivot:
                data[j], data[i] = data[i], data[j]
                i += 1
            j += 1
        data[i], data[high] = data[high], data[i]
        print(""pivot"", pivot, end="" -> "")
        print(data)
        return i
    def quick_sort(self, data, low, high):
        if low < high:
            pivot = self.partition(data, low, high)
            self.quick_sort(data, low, pivot - 1)
            self.quick_sort(data, pivot + 1, high)
if __name__ == ""__main__"":
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    low = 0
    high = len(data) - 1
    print(""Input array is : "", data)
    QuickSort().quick_sort(data, low, high)
    print(""Sorted Array is : "", data)",1,0,0,0,0,0,0,0,0
1761,"def swap(a, b, arr):
    if a!=b:
        tmp = arr[a]
        arr[a] = arr[b]
        arr[b] = tmp
def quick_sort(elements, start, end):
    if len(elements)== 1:
        return
    if start < end:
        pi = partition(elements, start, end)
        quick_sort(elements, start, pi-1)
        quick_sort(elements, pi+1, end)
def partition(elements, start, end):
    pivot = elements[end]
    p_index = start
    for i in range(start, end):
        if elements[i] <= pivot:
            swap(i, p_index, elements)
            p_index += 1
    swap(p_index, end, elements)
    return p_index
if __name__ == '__main__':
    tests = [
        [11,9,29,7,2,15,28],
        [3, 7, 9, 11],
        [25, 22, 21, 10],
        [29, 15, 28],
        [],
        [6]
    ]
    for elements in tests:
        quick_sort(elements, 0, len(elements)-1)
        print(f'sorted array: {elements}')",1,0,0,0,0,0,0,0,0
1762,"def swap(arr,a,b):
    temp = arr[a]
    arr[a]=arr[b]
    arr[b]=temp
def partition(arr,start,end):
    pivot = arr[end]
    pindex = start
    for i in range(start,end):
        if arr[i] <= pivot:
            swap(arr,i,pindex)
            pindex = pindex + 1
    swap(arr,end,pindex)
    return pindex
def quicksort(arr,start,end):
    if (start < end):
        pindex = partition(arr,start,end)
        quicksort(arr,pindex+1,end)
        quicksort(arr,start,pindex-1)
arr = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
quicksort(arr,0,9)
print(arr)",1,0,0,0,0,0,0,0,0
1763,"package Java.Sorting;
class quick_sort{
int partition(int a[],int l, int h)
{
    int pivot = a[h];
    int i= (l-1);  
    for(int j=l ; j<h ;j++)
      {
    	 if(a[j] < pivot)
          {
             i++;
             int temp = a[i];
	     a[i] = a[j];
             a[j] = temp;
           }
       }
int temp = a[i+1];
a[i+1] = a[h];
a[h] = temp;
return i+1;
}
void q_sort(int a[],int l,int h)
{
   if(l < h)
     {
            int p = partition(a,l,h);
            q_sort(a,l,p-1);
 	    q_sort(a,p+1,h);
      }
}
static void print_array(int a[])
{
   int n = a.length;
   for(int i=0;i<n;i++)
   {
        System.out.print(a[i]+"" "");
        System.out.print(""\t"");
    }
}
public static void main(String args[])
{
    int a[] = {3,5,2,1,4};
    int n = a.length;
    quick_sort q = new quick_sort();
    q.sort(a,0,n-1);
    System.out.println(""Sorted Array "");
    print_array(a);
}
}",1,0,0,0,0,0,0,0,0
1764,"def partition(unsorted_array, first_index, last_index):
    pivot = unsorted_array[first_index]
    pivot_index = first_index
    index_of_last_element = last_index
    less_than_pivot_index = index_of_last_element
    greater_than_pivot_index = first_index + 1
    while True:
        while unsorted_array[greater_than_pivot_index] < pivot and greater_than_pivot_index < last_index:
            greater_than_pivot_index += 1
        while unsorted_array[less_than_pivot_index] > pivot and less_than_pivot_index >= first_index:
            less_than_pivot_index -= 1
        if greater_than_pivot_index < less_than_pivot_index:
            temp = unsorted_array[greater_than_pivot_index]
            unsorted_array[greater_than_pivot_index] = unsorted_array[less_than_pivot_index]
            unsorted_array[less_than_pivot_index] = temp
        else:
            break
    unsorted_array[pivot_index] = unsorted_array[less_than_pivot_index]
    unsorted_array[less_than_pivot_index] = pivot
    return less_than_pivot_index
def quick_sort(unsorted_array, first, last):
    if last - first <= 0:
        return
    else:
        partition_point = partition(unsorted_array, first, last)
        quick_sort(unsorted_array, first, partition_point-1)
        quick_sort(unsorted_array, partition_point+1, last)
my_array = [43, 3, 77, 89, 4, 20]
print(my_array)
quick_sort(my_array, 0, 5)
print(my_array)",1,0,0,0,0,0,0,0,0
1765,"const partitionHoare = (array, left, right) => {
  const pivot = Math.floor(Math.random() * (right - left + 1) + left)
  while (left <= right) {
    while (array[left] < array[pivot])
       left++;
    while (array[right] > array[pivot])
      right--;
    if (left <= right) {
      [array[left], array[right]] = [array[right], array[left]];
      left++;
      right--;
    }
  }
  return left;
}
const quickSort = (array, left = 0, right = array.length - 1) => {
  const pivot = partitionHoare(array, left, right);
  if (left < pivot - 1) quickSort(array, left, pivot - 1);
  if (right > pivot) quickSort(array, pivot, right);
  return array;
}
let array = [2,1,7,0,9,4,6,5];
array = quickSort(array);
console.log(array);",1,0,0,0,0,0,0,0,0
1766,"(function main() {
    const partition = (input, lo, hi) => {
      const pivot = input[hi];
      let i = lo;
      for (let j = lo; j < hi; j++) {
        if (input[j] < pivot) {
          let tmp = input[i];
          input[i] = input[j];
          input[j] = tmp;
          i++;
        }
      }
      let tmp = input[hi];
      input[hi] = input[i];
      input[i] = tmp;
      return i;
    }
    const qSort = (input, lo, hi) => {
      if (input.length <= 1) return input;
      if (lo < hi) {
        const p = partition(input, lo, hi);
        qSort(input, lo, p - 1);
        qSort(input, p + 1, hi);
      }
    }
    const quickSort = (input) => {
      const n = input.length;
      qSort(input, 0, n - 1);
    }
    const arr1 = [3,6,7,8,1,9,2,4,5,0];
    const quickSort_2 = (arr) => {
      if (arr.length <= 1) return arr;
      let left = [],
            right = [],
            pivot = arr[0];
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot)
          left.push(arr[i]);
        else
          right.push(arr[i]);
      }
      const sortedLeft = quickSort_2(left),
            sortedRight = quickSort_2(right);
      const sorted = [].concat(sortedLeft, pivot, sortedRight);
      console.log(sorted)
      return sorted;
    }
    const qs = arr => {
      if (arr.length <= 1) return arr;
      let r = [].concat(
        qs(arr.slice(1).filter(d => d < arr[0])),
        arr[0],
        qs(arr.slice(1).filter(d => d > arr[0]))
      );
      console.log(...r);
      return r;
    }
    const input3 = [3,6,7,8,1,9,2,4,5,0];
    qs(input3);
  }());",1,0,0,0,0,0,0,0,0
1767,"from random import randint, shuffle
from timeit import timeit
def quick_sort(arr):
    if len(arr) == 1:
        return arr
    if len(arr) > 1:
        pivot = arr[0]
        left = 1
        right = len(arr) - 1
        while left <= right:
            if arr[left] > pivot and arr[right] < pivot:
                arr[left], arr[right] = arr[right], arr[left]
                left += 1
                right -= 1
            elif arr[left] <= pivot and arr[right] < pivot:
                left += 1
            elif arr[left] > pivot and arr[right] >= pivot:
                right -= 1
            elif arr[left] <= pivot and arr[right] >= pivot:
                left += 1
                right -= 1
        arr[0], arr[right] = arr[right], arr[0]
        divider = right + 1
        first = quick_sort(arr[:right])
        second = quick_sort(arr[divider:])
        return first + [arr[right]] + second
    else:
        return arr
def timings():  
    import_sort = 'from quick import quick_sort'
    print(""""""
    Timings for best, average and worst case scenarios for the merge sort.
    --------------------------------------------------------------------------
    """""")
    print(""3 Best Case Scenarios - sorted except for one value"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        rand_lst[6], rand_lst[-1] = rand_lst[-1], rand_lst[6]
        best_time = timeit('quick_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
    print(""\n3 Average Case Scenarios - Moderately sorted"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        shuffle(rand_lst)
        best_time = timeit('quick_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
    print(""\n3 Worst Case Scenarios - Completely unsorted"")
    for i in range(3):
        lst_len = randint(9, 50)
        rand_lst = [i for i in range(lst_len)]
        rand_lst = rand_lst[::-1]
        best_time = timeit('quick_sort({})'.format(rand_lst), import_sort)
        print('List {}: length={}; time = {}'.format(i + 1, lst_len, best_time))
if __name__ == '__main__':  
    timings()",1,0,0,0,0,0,0,0,0
1768,"package sort_problem;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
public class QuickSort<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        shuffle(nums);
        sort(nums, 0, nums.length - 1);
    }
    private void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int j = partition(nums, l, h);
        sort(nums, l, j - 1);
        sort(nums, j + 1, h);
    }
    private void shuffle(T[] nums) {
        List<Comparable> list = Arrays.asList(nums);
        Collections.shuffle(list);
        list.toArray(nums);
    }
    private int partition(T[] nums, int l, int h) {
        int i = l, j = h + 1;
        T v = nums[l];
        while (true) {
            while (less(nums[++i], v) && i != h) ;
            while (less(v, nums[--j]) && j != l) ;
            if (i >= j)
                break;
            swap(nums, i, j);
        }
        swap(nums, l, j);
        return j;
    }
}",1,0,0,0,0,0,0,0,0
1769,"__author__ = ""Caleb Madrigal""
__date__ = ""2015-02-14""
def quicksort(lst):
    if len(lst) < 2:
        return lst
    else:
        pivot = lst[-1]
        low = []
        high = []
        for i in lst[:-1]:
            if i <= pivot:
                low.append(i)
            else:
                high.append(i)
        return quicksort(low) + [pivot] + quicksort(high)
if __name__ == ""__main__"":
    import unittest
    testsuite = unittest.TestLoader().discover('test', pattern=""*quicksort*"")
    unittest.TextTestRunner(verbosity=1).run(testsuite)",1,0,0,0,0,0,0,0,0
1770,"package quick;
import sort.AbstractBase;
public class QuickSort extends AbstractBase {
    public Integer[] sort(Integer array[], int start, int end){
        if(start<end){
            int pIndex = partition(array, start, end);
            sort(array, start, pIndex-1);
            sort(array, pIndex+1, end);
        }
        return array;
    }
    public int partition(Integer array[], int start, int end){
        int pIndex=start;
        int pivot = array[end], temp;
        for(int i=start; i<end; i++){
            if(array[i]<=pivot){
                temp = array[pIndex];
                array[pIndex] = array[i];
                array[i] = temp;
                pIndex++;
            }
        }
        temp = array[pIndex];
        array[pIndex] = array[end];
        array[end] = temp;
        return pIndex;
    }
    public <E extends Comparable<E>> E[] genericSort(E[] array, int start, int end) {
        if(start<end) {
            int pIndex = partition(array, start, end);
            genericSort(array, start, pIndex-1);
            genericSort(array, pIndex+1, end);
        }
        return array;
    }
    public <E extends Comparable<E>> int partition(E[] array, int start, int end) {
        int pIndex = start;
        E pivot = array[end], temp;
        for(int i=start; i<end; i++){
            if(array[i].compareTo(pivot)<=0){
                temp = array[i];
                array[i] = array[pIndex];
                array[pIndex] = temp;
                pIndex++;
            }
        }
        temp = array[pIndex];
        array[pIndex] = array[end];
        array[end] = temp;
        return pIndex;
    }
}",1,0,0,0,0,0,0,0,0
1771,"def quicksort(a):
    _quicksort(a, 0, len(a)-1)
def _quicksort(a, l, r):
    if l >= r:
        return
    i = partition(a,l,r)
    _quicksort(a,l,i-1)
    _quicksort(a,i,r)
def partition(a,l,r):
    p = a[(l+r)//2]
    while l <= r:
        while a[l] < p:
            l += 1
        while a[r] > p:
            r -= 1
        if l <= r:
            a[l],a[r] = a[r],a[l]
            l += 1
            r -= 1
    return l
test1 = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
test2 = [8,3,1,7,0,10,2]
test3 = [10, 7, 8, 9, 1, 5]
test4 = [1,2,3]
quicksort(test1)
quicksort(test2)
quicksort(test3)
quicksort(test4)
print(test1) 
print(test2) 
print(test3) 
print(test4) ",1,0,0,0,0,0,0,0,0
1772,"def quicksort(the_list):
    if the_list == []:
        return the_list
    pivot_value = the_list[0]
    values_lesser_than_the_pivot = []
    values_greater_than_the_pivot = []
    for each_element in the_list[1:]:
        if each_element < pivot_value:
            values_lesser_than_the_pivot.append(each_element)
        else:
            values_greater_than_the_pivot.append(each_element)
    sorted_values_lesser_than_the_pivot        = quicksort(values_lesser_than_the_pivot)
    sorted_values_greater_than_the_pivot        = quicksort(values_greater_than_the_pivot)
    sorted_list = []
    if sorted_values_lesser_than_the_pivot is not None:
        sorted_list += sorted_values_lesser_than_the_pivot
    sorted_list += [pivot_value]
    if sorted_values_greater_than_the_pivot is not None:
        sorted_list += sorted_values_greater_than_the_pivot
    return sorted_list
if __name__ == '__main__':
    import random
    for each_pass in range(0, 100):
        random_list = []
        for each_number in range(0, random.randint(3, 40)):
            random_number = random.randint(0, random.randint(1, 1000))
            random_list.append(random_number)
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(random_list))
        sorted_random_list = quicksort(random_list)
        print(""Sorted:\n    "" + str(sorted_random_list))
        assert len(random_list) == len(sorted_random_list)
        for each_number in range(0, (len(sorted_random_list) - 1)):
            assert (sorted_random_list[each_number]
                    <= sorted_random_list[(each_number + 1)])
    print(""\n\n===================\nBegin numeric tests.\n==================="")
    dict_of_lists = {
        'list_zero': [0, 0, 0, 0, 0, 0, 0, 0],
        'list_one': [0, 0, 0, 0, 1, 1, 1, 1],
        'list_two': [0, 1, 0, 1, 0, 1, 0, 1],
        'list_three': [0, 1, 1, 0, 1, 1, 0, 0],
        'list_four': [10, 100, 1000000, 10000, 1, 100000, 0, 1000],
        'list_five': [0001, 0010, 0100, 1000, 1100, 0011, 0101, 0110],
    }
    for each_list in dict_of_lists:
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(dict_of_lists[each_list]))
        sorted_list = quicksort(dict_of_lists[each_list])
        print(""Sorted:\n    "" + str(sorted_list))
    print(""\nPerformance is O(nlogn) in the best and average cases,""
          ""\nand O(n^2) in the worst case.""
          ""\n\nHere's performance tests using the timeit module."")
    import timeit
    import random
    giant_quantity_list = []
    for each_pass in range(0, 100000):
        giant_quantity_list.append(random.randint(1000, 9999))
    call_string = 'quicksort(giant_quantity_list)'
    setup_string = 'from __main__ import quicksort, giant_quantity_list'
    print(""\nTime to sort a list of one hundred thousand""
          ""\nrandom numbers between 10e3 and (10e4) - 1:"")
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    not_so_random_order_of_magnitude = (10 ** 30)
    random_list = []
    giant_quality_list = []
    for each_pass in range(0, 100000):
        topend = (not_so_random_order_of_magnitude * 10) - 1
        random_number = random.randint(not_so_random_order_of_magnitude,
                                       topend)
        giant_quality_list.append(random_number)
    call_string = 'quicksort(giant_quality_list)'
    setup_string = 'from __main__ import quicksort, giant_quality_list'
    print(""\nTime to sort a list of one hundred thousand""
          ""\nrandom numbers between 10e30 and (10e31) - 1:"")
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    very_predictable_list = []
    very_predictable_list_with_middle_at_start = []
    for each_pass in range(0, 900):
        very_predictable_list.append(each_pass)
        very_predictable_list_with_middle_at_start.append(each_pass)
    very_predictable_list_with_middle_at_start.insert(0, 450)
    print(""\nWorst case is not dramatically demonstrable because:""
          ""\n'RuntimeError: maximum recursion depth exceeded in cmp'""
          ""\nSo, here's the worst case with a 900-point list:"")
    call_string = 'quicksort(very_predictable_list)'
    setup_string = 'from __main__ import quicksort, very_predictable_list'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    print(""\nSame list, midpoint put under pivot spot:"")
    call_string = 'quicksort(very_predictable_list_with_middle_at_start)'
    setup_string = 'from __main__ import quicksort, very_predictable_list_with_middle_at_start'
    time_taken = timeit.Timer(call_string, setup_string)
    print time_taken.timeit(number=1)
    raw_input(""\n    Press enter to demonstrate sorting strings."")
    strings_dict = {
        'list_six': ""Not the most useful application for sorting."",
        'list_seven': ""badcfehgjilknmporqtsvuxwzy"",
        'list_eight': ""list_seven is not as random as it may appear"",
        'list_nine': ""the quick brown fox jumps over the lazy dog"",
    }
    def sort_string(input_string):
        sorting_list = []
        for each_character in input_string:
            sorting_list.append(ord(each_character))
        sorting_list = quicksort(sorting_list)
        return_list = []
        for each_number in sorting_list:
            return_list.append(chr(each_number))
        return [''.join(return_list)][0]
    for each_list in strings_dict:
        print(""\n* * * * *\n\nUnsorted:\n    "" + str(strings_dict[each_list]))
        sorted_list = sort_string(strings_dict[each_list])
        print(""Sorted:\n    "" + str(sorted_list))
    print",1,0,0,0,0,0,0,0,0
1773,"def quickSort(array):
    quickSortHelper(array, 0, len(array) - 1)
	return array
def quickSortHelper(array, startIdx, endIdx):
	if startIdx >= endIdx:
		return
 pivotIdx = startIdx
 leftIdx = startIdx + 1
 rightIdx = endIdx
 while rightIdx >= leftIdx:
		if array[leftIdx] > array[pivotIdx] and array[rightIdx] < array[pivotIdx]:
			swap(leftIdx, rightIdx, array)
  if array[leftIdx] <= array[pivotIdx]:
			leftIdx += 1
  if array[rightIdx] >= array[pivotIdx]:
			rightIdx -= 1
 swap(pivotIdx, rightIdx, array)
 leftSubarrayIsSmaller = rightIdx - 1 - startIdx < endIdx - (rightIdx + 1)
 if leftSubarrayIsSmaller:
		quickSortHelper(array, startIdx, rightIdx - 1)
  quickSortHelper(array, rightIdx + 1, endIdx)
 else:
		quickSortHelper(array, rightIdx +1, endIdx)
  quickSortHelper(array, startIdx, rightIdx - 1)
def swap(i, j, array):
	array[i], array[j] = array[j], array[i] ",1,0,0,0,0,0,0,0,0
1774,"def quicksort(array, low, high):
    if low >= high:
        return array
    pivot_position = low
    current = low
    pivot = array[high]
    while current < high :
        if array[current] < pivot:
            temp = array[current]
            array[current] = array[pivot_position]
            array[pivot_position] = temp
            pivot_position += 1
            current += 1
        else:
            current += 1
    array[high]  = array[pivot_position]
    array[pivot_position] = pivot
    quicksort(array, low, pivot_position - 1)
    quicksort(array, pivot_position + 1, high)
    return array
test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]
print quicksort(test, 0 , len(test)-1)",1,0,0,0,0,0,0,0,0
1775,"def partition(arr, low, high):
    i = (low-1)         
    pivot = arr[high]     
    for j in range(low, high):
        if arr[j] <= pivot:
            i = i+1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return (i+1)
def quickSort(a, low, high):
	if len(a) == 1:
		return a
 if low < high:
		pi = partition(a, low, high)  
  quickSort(a, low, pi-1)
  quickSort(a, pi+1, high)
n=int(input('enter the length of array '))
print('enter the elements of the array ')
a=[]
for i in range(n):
    a.append(int(input()))
print('unsorted array is')
print(a)
quickSort(a, 0,len(a)-1)
print(""Sorted array is:"")
print(a)",1,0,0,0,0,0,0,0,0
1776,"def quickSort(L):
    less = []
    more = []
    if len(L) < 2:
        return L
    pivot = L[0]
    for i in range(1, len(L)):
        if L[i] < pivot:
            less.append(L[i])
        else:
            more.append(L[i])
    return quickSort(less) + [pivot] + quickSort(more)
def partition(array, start, end):
    pivot = array[start]
    low = start + 1
    high = end
    while True:
        while low <= high and array[high] >= pivot:
            high -= 1
        while low <= high and array[low] <= pivot:
            low += 1
        if low <= high:
            array[low], array[high] = array[high], array[low]
        else:
            break
    array[start], array[high] = array[high], array[start]
    return high
def quick_sort(array, start, end):
    if start >= end:
        return
    p = partition(array, start, end)
    quick_sort(array, start, p - 1)
    quick_sort(array, p + 1, end)",1,0,0,0,0,0,0,0,0
1777,"import random
import timeit
def quicksort(unsorted_list):
    if len(unsorted_list) == 0:
        return []
    if len(unsorted_list) == 1:
        return unsorted_list
    pivot = unsorted_list[0]
    left = []
    right = []
    equal = []
    for item in unsorted_list:
        if item == pivot:
            equal.append(item)
        if item < pivot:
            left.append(item)
        if item > pivot:
            right.append(item)
    return quicksort(left) + equal + quicksort(right)
def _wrapper(func, *args, **kwargs): 
    def _wrapped(): 
        return func(*args, **kwargs)
    return _wrapped
if __name__ == '__main__':
    unsorted_list = []
    for i in range(10):
        unsorted_list.append(random.randint(0, 1000))
    quicksort_list = _wrapper(quicksort, unsorted_list)
    print('Time to sort 1M times:')
    print(timeit.timeit(quicksort_list))",1,0,0,0,0,0,0,0,0
1778,"package quickSort;
public class Quicksort {
    public static int[] sort(int arr[], int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            sort(arr, low, pi-1);
            sort(arr, pi+1, high);
        }
        return arr;
    }
    public static int partition(int arr[], int low, int high) {
        int pivot = arr[high];
        int i = (low-1);
        for (int j=low; j<high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i+1];
        arr[i+1] = arr[high];
        arr[high] = temp;
        return i + 1;
    }
    public static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i]+"" "");
        System.out.println();
    }
    public static void main(String args[])
    {
        int arr[] = {10, 7, 8, 9, 1, 5};
        int n = arr.length;
        sort(arr, 0, n-1);
        System.out.println(""sorted array"");
        printArray(arr);
    }
}",1,0,0,0,0,0,0,0,0
1779,"var items = [5,3,7,6,2,9];
function swap(items, leftIndex, rightIndex){
    var temp = items[leftIndex];
    items[leftIndex] = items[rightIndex];
    items[rightIndex] = temp;
}
function partition(items, left, right) {
    var pivot   = items[Math.floor((right + left) / 2)],  
        i  = left,
        j  = right; 
    while (i <= j) {
        while (items[i] < pivot) {
            i++;
        }
        while (items[j] > pivot) {
            j--;
        }
        if (i <= j) {
            swap(items, i, j);  
            i++;
            j--;
        }
    }
    return i;
}
function quickSort(items, left, right) {
    var index;
    if (items.length > 1) {
        index = partition(items, left, right);
        if (left < index - 1) {
            quickSort(items, left, index - 1);
        }
        if (index < right) { 
            quickSort(items, index, right);
        }
    }
    return items;
}
var sortedArray = quickSort(items, 0, items.length - 1);
console.log(sortedArray); ",1,0,0,0,0,0,0,0,0
1780,"class QuickSort:
    def __init__(self):
        self.name = ""Quick Sort""
    @staticmethod
    def quickSort(arr, start, end):
        pivot = arr[end]
        i = start-1
        for x in range(start, end):
            if arr[x] > pivot:
                continue
            else:
                i += 1
                arr[i],arr[x] = arr[x],arr[i]
        for y in range(end, i + 1, -1):
            arr[y] = arr[y-1]
        arr[i + 1] = pivot
        return arr.index(pivot)
    @staticmethod
    def partition(array, start, end):
        if start < end:                       
            pos = QuickSort.quickSort(array, start, end)
            QuickSort.partition(array, start, pos - 1)
            QuickSort.partition(array, pos + 1, end)
test = QuickSort()
array = [7, 2, 1, 8, 6, 3, 5, 4]
test.partition(array, 0, 7)
print(array)",1,0,0,0,0,0,0,0,0
1781,"def quick_sort(arr):
    quick_sort_help(arr,0,len(arr)-1)
def quick_sort_help(arr,first,last):
    if first<last:
        splitpoint = partition(arr,first,last)
        quick_sort_help(arr,first,splitpoint-1)
        quick_sort_help(arr,splitpoint+1,last)
def partition(arr,first,last):
    pivotvalue = arr[first]
    leftmark = first+1
    rightmark = last
    done = False
    while not done:
        while leftmark <= rightmark and arr[leftmark] <= pivotvalue:
            leftmark = leftmark + 1
        while arr[rightmark] >= pivotvalue and rightmark >= leftmark:
            rightmark = rightmark -1
        if rightmark < leftmark:
            done = True
        else:
            temp = arr[leftmark]
            arr[leftmark] = arr[rightmark]
            arr[rightmark] = temp
    temp = arr[first]
    arr[first] = arr[rightmark]
    arr[rightmark] = temp
    return rightmark
arr = [2,7,1,8,5,9,11,35,25]
quick_sort(arr)
print (arr)",1,0,0,0,0,0,0,0,0
1782,"def qs(L):
    if len(L) < 2:
        return L
    pivot = L[0]
    return qs([x for x in L[1:] if x < pivot]) + [pivot] + qs(
        [x for x in L[1:] if x >= pivot])",1,0,0,0,0,0,0,0,0
1783,"def quick_select(A, k):
    pivot = random.choice(A)
    A1 = [] 
    A2 = [] 
    for i in A:
        if i < pivot:
            A1.append(i)
        elif i > pivot:
            A2.append(i)
        else:
            pass  
    if k <= len(A1):
        return quick_select(A1, k)
    elif k > len(A) - len(A2):
        return quick_select(A2, k - (len(A) - len(A2)))
    else:
        return pivot
input = [14, 4, 0, 9, 11, 19, 13]
import random
random.shuffle(input)
print(input)
k = 3
a = quick_select(input,k)
print(""3rd Smallest value="",a)",1,0,0,0,0,0,0,0,0
1784,"def quicksort(a,start,end):
	if start < end:
		pivotIndex = partition(a,start,end)
  quicksort(a,start,pivotIndex-1)
  quicksort(a,pivotIndex+1,end)
def partition(a,start,end):
	pivotValue = a[start]  
 left = start + 1
 right = end
 end = False
 while not end:
		 while left <=right and a[left] < pivotValue:
		 		left +=1
   while right >=left and a[right] >= pivotValue:
		 		right -=1
   if left < right:
		 	a[left],a[right] = a[right],a[left]
   else:
		 	end = True
 a[start],a[right] = a[right],a[start]
 return right 
import random
a= [1,4,3,4,4,4,4,5]
random.shuffle(a)
print(""input >>>"", a)
quicksort(a,0,len(a)-1)
print(""sorted input>>>"",a)",1,0,0,0,0,0,0,0,0
1785,"package sort_problem;
public class ThreeWayQuickSort<T extends Comparable<T>> extends QuickSort<T> {
    protected void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i <= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp < 0) {
                swap(nums, lt++, i++);
            } else if (cmp > 0) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}",1,0,0,0,0,0,0,0,0
1786,"arr = [20, 90, 1045, -875, 90, -402, 224, 332, 777]",0,0,0,0,0,0,0,0,0
1787,"package sort_problem;
public class QuickSelection<T extends Comparable<T>> extends Sort<T>{
    public T select(T[] nums, int k) {
        int l = 0, h = nums.length - 1;
        while (h > l) {
            int j = partition(nums, l, h);
            if (j == k) {
                return nums[k];
            } else if (j > k) {
                h = j - 1;
            } else {
                l = j + 1;
            }
        }
        return nums[k];
    }
    private int partition(T[] nums, int l, int h) {
        int i = l, j = h + 1;
        T v = nums[l];
        while (true) {
            while (less(nums[++i], v) && i != h) ;
            while (less(v, nums[--j]) && j != l) ;
            if (i >= j)
                break;
            swap(nums, i, j);
        }
        swap(nums, l, j);
        return j;
    }
    @Override
    public void sort(T[] nums) {
    }
}",0,0,0,0,0,0,0,0,0
1788,"import random
def partition(ar, l, r):
    idx = random.randrange(l,r)
    pivot = ar[idx]
    ar[l], ar[idx] = ar[idx], ar[l]
    m = l
    for i in range(l+1, r):
        if ar[i] < pivot:
            m += 1
            ar[m], ar[i] = ar[i], ar[m]
    ar[l], ar[m] = ar[m], ar[l]
    print 'partition %d to %d, pivot %d at %d' % (l,r,pivot,m)
    print ar
    return m
def quickselect(ar, k):
    def recurse(ar, l, r, k):
        if l+1 >= r: return l
        m = partition(ar, l, r)
        if m == k-1:
            return m
        elif m < k:
            return recurse(ar, m+1, r, k)
        else:
            return recurse(ar, l, m, k)
    idx = recurse(ar, 0, len(ar), k)
    return ar[idx]
if __name__ == '__main__':
    arrK = quickselect([9,8,8,7,7,5], 1)",1,0,1,0,0,0,0,0,0
1789,"def selection_sort(arr):
    size = len(arr)
    for i in range(size-1):
        min_index = i
        for j in range(min_index+1,size):
            if arr[j] < arr[min_index]:
                min_index = j
        if i != min_index:
            arr[i], arr[min_index] = arr[min_index], arr[i]
if __name__ == '__main__':
    tests = [
        [89, 78, 61, 53, 23, 21, 17, 12, 9, 7, 6, 2, 1],
        [],
        [1,5,8,9],
        [234,3,1,56,34,12,9,12,1300],
        [78, 12, 15, 8, 61, 53, 23, 27],
        [5]
    ]
    for elements in tests:
        selection_sort(elements)
        print(elements)",0,0,1,0,0,0,0,0,0
1790,"def selection_sort(a):
    for i in range(len(a)-1):
        smallest = i
        for j in range(i+1, len(a)):
            if a[j] < a[smallest]:
                smallest = j
        a[i], a[smallest] = a[smallest], a[i]
    print(a)
    return a
a = [1, 6, 4, 7, 9]
selection_sort(a)",0,0,1,0,0,0,0,0,0
1791,"import sys
class selectionSort:
    def selection_sort(self, data):
        for i in range(len(data)):
            min_index = i
            for j in range(i + 1, len(data)):
                if data[min_index] > data[j]:
                    min_index = j
            data[i], data[min_index] = data[min_index], data[i]
        print(data)
if __name__ == ""__main__"":
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    selectionSort().selection_sort(data)",0,0,1,0,0,0,0,0,0
1792,"def selectionSort(arr):
    for i in range(len(arr)-1):
        minIndex =0
        for j in range(i+1, len(arr)):
            if arr[j] < arr[minIndex]:
                minIndex = j
        if minIndex != i:
            arr[i], arr[minIndex] = arr[minIndex], arr[i]
if __name__ == ""__main__"":
    A = [20, 15, 2, 3, 25, 30, 14, 26, 5, 10, 18, 1]
    s = selectionSort(A)
    print(s)",0,0,1,0,0,0,0,0,0
1793,"arr = [-1, 10, 15, 3, 5, 19, 5, 19]
n = len(arr)
for position in range(n - 1):
    current = arr[position]
    min_position = position
    for j in range(position, n):
        if arr[j] < arr[min_position]:
            min_position = j
    arr[position], arr[min_position] = arr[min_position], arr[position]
print(arr)",0,0,1,0,0,0,0,0,0
1794,"def selection_sort(L):
    if len(L)==0:
        return []
    temp = L[0]
    sub = L[1:]
    step = 0
    while sub:
        for i,val in enumerate(sub): 
            if val < temp:
                sub[i] = temp
                temp = val
        L[step] = temp
        temp = sub[0]
        sub = sub[1:]
        print('step',step,temp, sub)
        step+=1
    L[-1]=temp
    return L
print('result:', selection_sort([9,8,7,6,1,3,5,7,12,0,0,0]))
print('result:', selection_sort([]))
def selSort(L):
    store = 0
    while store!= len(L):
        for i in range(store, len(L)):
            if L[i]<L[store]:
                L[store],L[i] = L[i], L[store]
        store+=1
    return L
print('result selSort:', selSort([9,8,7,6,1,3,5,7,12,0,0,0]))",0,0,1,0,0,0,0,0,0
1795,"def multilevel_selection_sort(elements, sort_by_list):
    for sort_by in sort_by_list[-1::-1]:
        for x in range(len(elements)):
            min_index = x
            for y in range(x, len(elements)):
                if elements[y][sort_by] < elements[min_index][sort_by]:
                    min_index = y
            if x != min_index:
                elements[x], elements[min_index] = elements[min_index], elements[x]
if __name__ == '__main__':
    elements = [
        {'First Name': 'Raj', 'Last Name': 'Nayyar'},
        {'First Name': 'Suraj', 'Last Name': 'Sharma'},
        {'First Name': 'Karan', 'Last Name': 'Kumar'},
        {'First Name': 'Jade', 'Last Name': 'Canary'},
        {'First Name': 'Raj', 'Last Name': 'Thakur'},
        {'First Name': 'Raj', 'Last Name': 'Sharma'},
        {'First Name': 'Kiran', 'Last Name': 'Kamla'},
        {'First Name': 'Armaan', 'Last Name': 'Kumar'},
        {'First Name': 'Jaya', 'Last Name': 'Sharma'},
        {'First Name': 'Ingrid', 'Last Name': 'Galore'},
        {'First Name': 'Jaya', 'Last Name': 'Seth'},
        {'First Name': 'Armaan', 'Last Name': 'Dadra'},
        {'First Name': 'Ingrid', 'Last Name': 'Maverick'},
        {'First Name': 'Aahana', 'Last Name': 'Arora'}
    ]
    print(f'Given unsorted array:', *elements, sep='\n')
    multilevel_selection_sort(
        elements, ['First Name', 'Last Name'])
    print(f'Array after Multi-Level Sorting:', *elements, sep='\n')",0,0,1,0,0,0,0,0,0
1796,"def selection_sort(A):
	for i in range (0, len(A) - 1):
		minIndex = i
  for j in range (i+1, len(A)):
			if A[j] < A[minIndex]:
				minIndex = j
  if minIndex != i:
			A[i], A[minIndex] = A[minIndex], A[i]
A = [5,9,1,2,4,8,6,3,7]
print(A)
selection_sort(A)
print(A)",0,0,1,0,0,0,0,0,0
1797,"def selection_sort(unsorted_list):
    size_of_list = len(unsorted_list)
    for i in range(size_of_list):
        for j in range(i+1, size_of_list):
            if unsorted_list[j] < unsorted_list[i]:
                temp = unsorted_list[i]
                unsorted_list[i] = unsorted_list[j]
                unsorted_list[j] = temp
a_list = [3, 2, 35, 4, 32, 94, 5, 7]
selection_sort(a_list)
print(a_list)",0,0,1,0,0,0,0,0,0
1798,"const selectionSort = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    let min = i;
    for (let j = i + 1; j < arr.length; j++)
      if (arr[j] < arr[min]) min = j;
    if (i !== min)
      [arr[i], arr[min]] = [arr[min], arr[i]];
  }
  return arr;
 }
 let array = [2,1,7,0,9,4,6,5];
 array = selectionSort(array);
 console.log(array);",0,0,1,0,0,0,0,0,0
1799,,0,0,0,0,0,0,0,0,0
1800,"package sort_problem;
public class Selection<T extends Comparable<T>> extends Sort<T> {
    @Override
    public void sort(T[] nums) {
        int N = nums.length;
        for (int i = 0; i < N - 1; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(nums[j], nums[min])) {
                    min = j;
                }
            }
            swap(nums, i, min);
        }
    }
}",0,0,1,0,0,0,0,0,0
1801,"package Java.Sorting;  
import java.util.Scanner;
public class SelectionSort {
  public static void main (String[] args){
    Scanner in  = new Scanner(System.in);
    System.out.print(""array length: "");
    int a[] = new int[Integer.parseInt(in.nextLine())];
    for (int i = 0; i < a.length; i++){
      a[i] = in.nextInt();
    }
    System.out.println(""Before:"");
    for (int i = 0; i < a.length; i++){
      System.out.print(a[i] + "" "");
    }
    sort(a);
    System.out.println(""\nAfter:"");
    for (int i = 0; i < a.length; i++){
      System.out.print(a[i]+ "" "");
    }
    in.close();
  }
  private static void sort(int a[]) {
    int i, j, min;
    for (i = 0; i < a.length; i++){
      min = i;
      for (j = i+1; j < a.length; j++){
        if (a[j] <= a[min]){
          min = j;
        }
      }
      int tmp = a[min];
      a[min] = a[i];
      a[i] = tmp;
    }
  }
}",0,0,1,0,0,0,0,0,0
1802,"def selection_sort(arr):
    for i in range(len(arr)):
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
n = int(input(""Enter number of elements: ""))
print(""Enter elements:"")
nums = []
for i in range(n):
    nums.append(int(input()))
selection_sort(nums)
print(""Sorted Array:"")
print(nums)",0,0,1,0,0,0,0,0,0
1803,"def selectionSort(arr):
    for i in range(len(arr)-1):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]: 
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
arr = [2,0,1,4,3]
selectionSort(arr)
print(arr)
arr = [8, 3, 1, 7, 0, 10,7,3, 2]
selectionSort(arr)     
print(arr)
arr = [1,0]
selectionSort(arr)     
print(arr)
arr = [1]
selectionSort(arr)     
print(arr)",0,0,1,0,0,0,0,0,0
1804,"package selection;
import sort.AbstractBase;
public class SelectionSort extends AbstractBase {
    public Integer[] sort(Integer array[]){
        int n = array.length, temp, imin;
        for(int i=0; i<(n-1); i++){
            imin = i;
            for(int j=i+1; j<n; j++){
                if(array[j]<array[imin]){
                    imin = j;
                }
            }
            temp = array[i];
            array[i] = array[imin];
            array[imin] = temp;
        }
        return array;
    }
    @Override
    public <E extends Comparable<E>> E[] genericSort(E array[]){
        int n = array.length, imin;
        E temp;
        for(int i=0; i<(n-1); i++){
            imin=i;
            for(int j=i+1; j<n; j++){
                if(array[j].compareTo(array[imin])<0) {
                    imin = j;
                }
            }
            temp = array[i];
            array[i] = array[imin];
            array[imin] = temp;
        }
        return array;
    }
}",0,0,1,0,0,0,0,0,0
1805,"function selection_sort(nums) { 
    let n = nums.length;
    for(let i = 0; i < n; i++) {
        let min_index = i;
        for(let j = i+1; j < n; j++){
            if(nums[min_index] > nums[j]) {
                min_index = j; 
            }
         }
         [nums[i], nums[min_index]] = [nums[min_index], nums[i]];
    }
}",0,0,1,0,0,0,0,0,0
1806,"def selectionSort(array):
	leftpointer = 0
 array_len = len(array) - 1
 while leftpointer < array_len:
        minpointer = leftpointer
        for index in range(leftpointer+1, array_len+1):
        	if array[index] < array[minpointer]: 
  				minpointer = index
  swapElements(array, leftpointer, minpointer)
  leftpointer += 1
 return array
def swapElements(array, i, j):
	array[i], array[j] = array[j], array[i]",0,0,1,0,0,0,0,0,0
1807,"def selection_sort(arr):
    for fillslot in range(len(arr)-1,0,-1):
        positionOfMax=0
        for location in range(1,fillslot+1):
            if arr[location]>arr[positionOfMax]:
                positionOfMax = location
        temp = arr[fillslot]
        arr[fillslot] = arr[positionOfMax]
        arr[positionOfMax] = temp
arr = [2,7,1,8,5,9,11,35,25]
selection_sort(arr)
print (arr)",0,0,1,0,0,0,0,0,0
1808,"def bubble_sort(arr):
    list_length = len(arr)
    for i in range(list_length-1):
        flag = False
        for j in range(list_length-1-i):
            if arr[j] > arr[j+1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                flag = True
        if flag is False:
            break
    return arr
def insertion_sort(arr):
    list_length = len(arr)
    for i in range(1, list_length):
        tmp = arr[i]
        j = i - 1
        while j >= 0 and tmp < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = tmp
    return arr
def shell_sort(arr):
    list_length = len(arr)
    gap = list_length // 2
    while gap > 0:
        for i in range(gap, list_length, gap):
            tmp = arr[i]
            j = i - gap
            while j >= 0 and tmp < arr[j]:
                arr[j + gap] = arr[j]
                j -= gap
            arr[j + gap] = tmp
        gap //= 2
    return arr
def selection_sort(arr):
    list_length = len(arr)
    for i in range(list_length-1):
        min_idx = i
        for j in range(i+1, list_length):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
def heap_sort(arr):
    def adjust_down(arr, parent_idx, length):
        tmp = arr[parent_idx]
        while parent_idx*2 + 1 <= length:
            child_idx = parent_idx * 2 + 1
            if child_idx != length and arr[child_idx] < arr[child_idx+1]:
                child_idx += 1
            if tmp < arr[child_idx]:
                arr[parent_idx] = arr[child_idx]
            else:
                break
            parent_idx = child_idx
        arr[parent_idx] = tmp
    def creat_max_heap(arr, length):
        for parent_idx in range(length//2, -1, -1):
            adjust_down(arr, parent_idx, length)
    length = len(arr) - 1
    creat_max_heap(arr, length)
    for i in range(length, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        adjust_down(arr, 0, i - 1)
    return arr
def merge_sort(arr):
    def merge(left, right):
        i, j = 0, 0  
        merged = []  
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i += 1
            else:
                merged.append(right[j])
                j += 1
        if len(left[i:]) > 0:
            merged.extend(left[i:])
        if len(right[j:]) > 0:
            merged.extend(right[j:])
        return merged
    if len(arr) <= 1:
        return arr
    middle = len(arr) // 2
    left = merge_sort(arr[0:middle])
    right = merge_sort(arr[middle:])
    return merge(left, right)
def quick_sort(arr):
    def q_sort(array, low, high):
        if low >= high:
            return
        pivot = array[high]
        i, j = low, high
        while i < j:
            while i < j and array[i] <= pivot:
                i += 1
            while i < j and array[j] >= pivot:
                j -= 1
            array[i], array[j] = array[j], array[i]
        array[i], array[high] = array[high], array[i]
        q_sort(array, low, i - 1)
        q_sort(array, i + 1, high)
    q_sort(arr, 0, len(arr) - 1)
    return arr
def radix_sort(arr):
    digit = 1  
    max_digit = 1  
    max_item = max(arr)
    while max_item >= 10 ** max_digit:
        max_digit += 1
    while digit <= max_digit:
        bucket = {}  
        for i in range(10):
            bucket.setdefault(i, [])  
        for i in arr:
            radix = int(i / (10**(digit-1)) % 10)  
            bucket[radix].append(i)  
        tmp_list = []
        for i in range(10):
            if len(bucket[i]) > 0:
                for j in bucket[i]:
                    tmp_list.append(j)
        arr = tmp_list
        digit += 1
    return arr
test_list = [1, 12, 5, 5, 3, 7, 10, 143, 9, 6, 11, 4, 155, 13, 2, 8]
result = quick_sort(test_list)
for item in result:
    print(item, end=' ')",1,1,1,1,1,0,0,0,0
1809,"import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
public class Sorting {
    public static <T> void insertionSort(T[] arr, Comparator<T> comparator) {
        if (arr == null) {
            throw new IllegalArgumentException(""Input array can not be null."");
        }
        if (comparator == null) {
            throw new IllegalArgumentException(""Input comparator can not ""
                    + ""be null."");
        }
        int compIndex;
        T tempSwap;
        for (int i = 1; i < arr.length; i++) {
            compIndex = i;
            while (compIndex > 0
                    && comparator.compare(arr[compIndex - 1],
                    arr[compIndex]) > 0) {
                tempSwap = arr[compIndex - 1];
                arr[compIndex - 1] = arr[compIndex];
                arr[compIndex] = tempSwap;
                --compIndex;
            }
        }
    }
    public static <T> T kthSelect(int k, T[] arr, Comparator<T> comparator,
                                     Random rand) {
        if (arr == null) {
            throw new IllegalArgumentException(""Input array can not be null."");
        }
        if (comparator == null) {
            throw new IllegalArgumentException(""Comparator can not be null."");
        }
        if (rand == null) {
            throw new IllegalArgumentException(""Random can not be null."");
        }
        if (k < 1 || k > arr.length) {
            throw new IllegalArgumentException(""K is out of the array range."");
        }
        return kthSelectHelper(k, arr, comparator, rand, 0,
                arr.length - 1);
    }
    private static <T> T kthSelectHelper(int k,
                                         T[] arr, Comparator<T> comparator,
                                         Random rand, int leftBound,
                                         int rightBound) {
        if (leftBound == rightBound) {
            return arr[leftBound];
        }
        int pivot = rand.nextInt(rightBound + 1 - leftBound) + leftBound;
        T tempSwap;
        tempSwap = arr[leftBound];
        arr[leftBound] = arr[pivot];
        arr[pivot] = tempSwap;
        int i = leftBound + 1;
        int j = rightBound;
        while (j > i) {
            while (i < rightBound && j > i && comparator.compare(arr[i],
                    arr[leftBound]) < 0) {
                ++i;
            }
            while (j >= leftBound && j > i && comparator.compare(arr[j],
                    arr[leftBound]) > 0) {
                --j;
            }
            if (j > i) {
                tempSwap = arr[i];
                arr[i] = arr[j];
                arr[j] = tempSwap;
            }
        }
        if (rightBound - leftBound == 1) {
            if (comparator.compare(arr[j], arr[leftBound]) < 0) {
                tempSwap = arr[leftBound];
                arr[leftBound] = arr[rightBound];
                arr[rightBound] = tempSwap;
                --j;
            }
        } else if (i == rightBound) {
            tempSwap = arr[leftBound];
            arr[leftBound] = arr[rightBound];
            arr[rightBound] = tempSwap;
        } else {
            tempSwap = arr[leftBound];
            arr[leftBound] = arr[--j];
            arr[j] = tempSwap;
        }
        if (j == k - 1) {
            return arr[j];
        } else if (j < k - 1) {
            return kthSelectHelper(k, arr, comparator, rand, j + 1, rightBound);
        } else {
            return kthSelectHelper(k, arr, comparator, rand, leftBound, j - 1);
        }
    }
    @SuppressWarnings(""unchecked"")
    public static <T> void mergeSort(T[] arr, Comparator<T> comparator) {
        if (arr == null) {
            throw new IllegalArgumentException(""Input array can not be null."");
        }
        if (comparator == null) {
            throw new IllegalArgumentException(""Input comparator can not ""
                    + ""be null."");
        }
        if (arr.length <= 1) {
            return;
        }
        if (arr.length > 1) {
            if (arr.length == 2) {
                T tempSwap;
                if (comparator.compare(arr[0], arr[1]) > 0) {
                    tempSwap = arr[0];
                    arr[0] = arr[1];
                    arr[1] = tempSwap;
                }
            } else {
                int rightSize = arr.length / 2;
                if (arr.length % 2 == 1) {
                    ++rightSize;
                }
                T[] arrLeft = (T[]) new Object[arr.length / 2];
                T[] arrRight = (T[]) new Object[rightSize];
                for (int i = 0; i < arr.length / 2; i++) {
                    arrLeft[i] = arr[i];
                }
                for (int i = 0; i < rightSize; i++) {
                    arrRight[i] = arr[i + (arr.length / 2)];
                }
                mergeSort(arrLeft, comparator);
                mergeSort(arrRight, comparator);
                int index = 0;
                int lIndex = 0;
                int rIndex = 0;
                while (index < arr.length) {
                    if (lIndex >= arrLeft.length) {
                        arr[index++] = arrRight[rIndex++];
                    } else if (rIndex >= arrRight.length) {
                        arr[index++] = arrLeft[lIndex++];
                    } else if (comparator.compare(arrLeft[lIndex],
                           arrRight[rIndex]) > 0) {
                        arr[index++] = arrRight[rIndex++];
                    } else {
                        arr[index++] = arrLeft[lIndex++];
                    }
                }
            }
        } else {
            return;
        }
    }
    public static int[] lsdRadixSort(int[] arr) {
        if (arr == null) {
            throw new IllegalArgumentException(""Input array can not be null"");
        }
        if (arr.length <= 1) {
            return arr;
        }
        int longestValue = Math.abs(arr[0]);
        for (int i = 1; i < arr.length; ++i) {
            if (arr[i] == Integer.MIN_VALUE) {
                longestValue = Integer.MAX_VALUE;
                i = arr.length;
            } else if (Math.abs(arr[i]) > longestValue) {
                longestValue = Math.abs(arr[i]);
            }
        }
        int numDigits = 1;
        int divisor = 10;
        while (longestValue / divisor != 0) {
            divisor *= 10;
            ++numDigits;
        }
        ArrayList<Queue<Integer>> listTemp = new ArrayList<>(9);
        int index;
        for (int i = 0; i < numDigits; ++i) {
            for (int j = 0; j < 19; ++j) {
                listTemp.add(new LinkedList<>());
            }
            for (int j = 0; j < arr.length; ++j) {
                index = (Math.abs(arr[j]) / pow(10, i)) % 10;
                if (arr[j] == Integer.MIN_VALUE) {
                    listTemp.get(0).add(arr[j]);
                } else if (arr[j] < 0) {
                    listTemp.get(9 - index).add(arr[j]);
                } else {
                    listTemp.get(9 + index).add(arr[j]);
                }
            }
            int count = 0;
            for (int j = 0; j < listTemp.size(); ++j) {
                if (listTemp.get(j) != null) {
                    while (!listTemp.get(j).isEmpty()) {
                        arr[count++] = listTemp.get(j).remove();
                    }
                }
            }
            listTemp.clear();
        }
        return arr;
    }
    private static int pow(int base, int exp) {
        if (exp < 0) {
            throw new IllegalArgumentException(""Exponent cannot be negative."");
        } else if (base == 0 && exp == 0) {
            throw new IllegalArgumentException(
                    ""Both base and exponent cannot be 0."");
        } else if (exp == 0) {
            return 1;
        } else if (exp == 1) {
            return base;
        }
        int halfPow = pow(base, exp / 2);
        if (exp % 2 == 0) {
            return halfPow * halfPow;
        } else {
            return halfPow * halfPow * base;
        }
    }
}",0,1,0,1,0,0,0,0,0
1810,"def bubbleSort(a):
    for i in range(len(a)-1):
        for j in range(len(a)-i-1):
            if a[j]>a[j+1]:
                a[j],a[j+1]=a[j+1],a[j]
    return a
def selectionSort(a):
    for i in range(0,len(a)-1):
        min=i
        for j in range(i+1,len(a)):
            if a[j]<a[min]:
                min =j
        if min !=i:
            a[i],a[min]=a[min],a[i]
    return a
def insertionSort(a):
    for i in range(1,len(a)):
        for j in range(i-1,-1,-1):
            if(a[j]>a[j+1]):
                a[j],a[j+1]=a[j+1],a[j]
            else:
                break
    return a
def insertionSort_shifting(a):
    for i in range(1,len(a)):
        temp=a[i]
        for j in range(i-1,-1,-1):
            if a[j]>temp:
                a[j+1]=a[j]
                j=j-1 
            else:
                break
        a[j+1]=temp       
    return a
def mergesort(listValue):
    if len(listValue)>1:
        mid=len(listValue)//2
        left=listValue[:mid]
        right=listValue[mid:]
        mergesort(left)
        mergesort(right)
        i=j=k=0
        while i<len(left) and j<len(right):
            if left[i]<right[j]:
                listValue[k]=left[i]
                i=i+1
            else:
                listValue[k]=right[j]
                j=j+1
            k=k+1
        while (i<len(left)):
            listValue[k]=left[i]
            i=i+1
            k=k+1
        while(j<len(right)):
            listValue[k]=right[j]
            j=j+1
            k=k+1
    return listValue
def partition(l):
    length=len(l)
    pivot=l[length-1]
    left=[]
    right=[]
    for i in range(length-1):
        el=l[i]
        if(el<=pivot):
            left+=[el]
        else:
            right+=[el]
    return (left,pivot,right)
def quick_sort(a):
    if (len(a)<=1):
        return a
    else:
        left,pivot,right=partition(a)
        left_sort=quick_sort(left)
        right_sort=quick_sort(right)
        return left_sort+[pivot]+right_sort
print quick_sort([23,1,-3,450,23,-1,220])",1,1,1,1,1,0,0,0,0
1811,"print('**** COUNTING SORT *******')
def countSort(arr):
    sorted = [0 for i in range(0,256)]
    count = [0 for i in range(0,256)]
    result = ["""" for _ in arr]
    for i in arr:
        count[ord(i)] += 1
    for i in range(256):
        count[i] += count[i-1]
    for i in range(len(arr)):
       sorted[count[ord(arr[i])]-1] = arr[i]
       count[ord(arr[i])] -= 1
    for i in range(len(arr)):
        result[i] = sorted[i]
    return result
arr = ""InformationTechnology""
ans = countSort(arr)
print('***** SORTED ARRAY ******')
print(ans)",0,0,0,0,0,0,0,0,0
1812,"print('***** HEAP SORT ******')
def heapify(arr,n,i):
    largest = i
    left = 2*i+1
    right = 2*i+2
    if(left<n and arr[left]>arr[largest]):
        largest = left
    if (right<n and arr[right]>arr[largest]):
        largest = right
    if(largest!=i):
        arr[i],arr[largest] = arr[largest],arr[i]
        heapify(arr,n,largest)
def heapSort(arr):
    n = len(arr)
    for i in range(n//2,-1,-1):
        heapify(arr,n,i)
    for i in range(n-1,0,-1):
        arr[0],arr[i] = arr[i],arr[0]
        heapify(arr,i,0)
if __name__=='__main__':
    n = int(input('Enter the no. of elements: '))
    string_arr = input('Enter your array here : ').split(' ')
    arr = [int(num) for num in string_arr]
    heapSort(arr)
    print('***** SORTED ARRAY ******')
    print(arr)",0,0,0,0,0,0,0,0,0
